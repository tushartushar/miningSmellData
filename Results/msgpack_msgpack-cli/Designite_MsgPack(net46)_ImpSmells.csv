Implementation smell,Namespace,Class,File,Method,Description
Long Method,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The method has 347 lines of code.
Long Method,MsgPack,MessagePackCode,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackCode.cs,ToString,The method has 105 lines of code.
Long Method,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,Equals,The method has 104 lines of code.
Long Method,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ToString,The method has 155 lines of code.
Long Method,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ToStringBinary,The method has 110 lines of code.
Long Method,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,PackToMessage,The method has 127 lines of code.
Long Method,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,PackToMessageAsync,The method has 127 lines of code.
Long Method,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,FromObject,The method has 101 lines of code.
Long Method,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ToObject,The method has 108 lines of code.
Long Method,MsgPack,MessagePackObjectDictionary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObjectDictionary.cs,TryValidateObjectArgument,The method has 103 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadByteSlow,The method has 115 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadByteSlowAsync,The method has 115 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSByteSlow,The method has 115 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSByteSlowAsync,The method has 115 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt16Slow,The method has 115 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt16SlowAsync,The method has 115 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt16Slow,The method has 115 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt16SlowAsync,The method has 115 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt32Slow,The method has 115 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt32SlowAsync,The method has 115 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt32Slow,The method has 115 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt32SlowAsync,The method has 115 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt64Slow,The method has 115 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt64SlowAsync,The method has 115 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt64Slow,The method has 115 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt64SlowAsync,The method has 115 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSingleSlow,The method has 115 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSingleSlowAsync,The method has 115 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadDoubleSlow,The method has 115 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadDoubleSlowAsync,The method has 115 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinary,The method has 157 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinaryAsync,The method has 159 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadString,The method has 157 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringAsync,The method has 159 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method has 875 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The method has 905 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLength,The method has 144 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLengthAsync,The method has 141 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLength,The method has 144 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLengthAsync,The method has 141 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObject,The method has 148 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The method has 155 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObjectAsync,The method has 150 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The method has 154 lines of code.
Long Method,MsgPack,ReadValueResults,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The method has 199 lines of code.
Long Method,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,HandleParseResult,The method has 166 lines of code.
Long Method,MsgPack,TimestampStringConverter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The method has 146 lines of code.
Long Method,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitCollectionUnpackFromStatements,The method has 159 lines of code.
Long Method,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,MakeDefaultParameterValueLiteral,The method has 106 lines of code.
Long Method,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitSetMemberValueStatement,The method has 173 lines of code.
Long Method,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitUnpackItemValueStatement,The method has 114 lines of code.
Long Method,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitConstructPolymorphismSchema,The method has 328 lines of code.
Long Method,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildObjectPackToCore,The method has 230 lines of code.
Long Method,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitObjectUnpackFromCore,The method has 142 lines of code.
Long Method,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitObjectUnpackingContextInitialization,The method has 115 lines of code.
Long Method,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTuplePackToCore,The method has 125 lines of code.
Long Method,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTupleUnpackFromCore,The method has 185 lines of code.
Long Method,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,CreateCore,The method has 118 lines of code.
Long Method,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,The method has 172 lines of code.
Long Method,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,DetermineCollectionInterfaces,The method has 107 lines of code.
Long Method,MsgPack.Serialization,SerializationContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationContext.cs,GetSerializer,The method has 156 lines of code.
Long Method,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,Prepare,The method has 114 lines of code.
Long Method,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The method has 156 lines of code.
Long Method,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,EndMethodOverrideCore,The method has 173 lines of code.
Long Method,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,EmitGetActionsExpression,The method has 120 lines of code.
Long Method,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,Finish,The method has 398 lines of code.
Long Method,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,TryCreateAbstractCollectionSerializer,The method has 127 lines of code.
Long Method,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,UnpackFromCore,The method has 132 lines of code.
Long Method,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,UnpackFromAsyncCore,The method has 107 lines of code.
Long Method,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The method has 112 lines of code.
Long Method,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The method has 112 lines of code.
Long Method,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,EmitForEachLoop,The method has 102 lines of code.
Long Method,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,EmitGetActionsExpression,The method has 115 lines of code.
Long Method,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,CreateContextfulObjectConstructor,The method has 191 lines of code.
Long Method,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,CreateCollectionSerializer,The method has 117 lines of code.
Long Method,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,GetMetadata,The method has 151 lines of code.
Long Method,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,TraceMethod,The method has 109 lines of code.
Complex Method,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackCore,Cyclomatic complexity of the method is 8
Complex Method,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackCore,Cyclomatic complexity of the method is 10
Complex Method,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,Cyclomatic complexity of the method is 8
Complex Method,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,Cyclomatic complexity of the method is 10
Complex Method,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadBinary,Cyclomatic complexity of the method is 11
Complex Method,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadString,Cyclomatic complexity of the method is 11
Complex Method,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectCore,Cyclomatic complexity of the method is 8
Complex Method,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,Cyclomatic complexity of the method is 54
Complex Method,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadArrayLength,Cyclomatic complexity of the method is 9
Complex Method,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMapLength,Cyclomatic complexity of the method is 9
Complex Method,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMessagePackExtendedTypeObject,Cyclomatic complexity of the method is 10
Complex Method,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,Cyclomatic complexity of the method is 11
Complex Method,MsgPack,MessagePackCode,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackCode.cs,ToString,Cyclomatic complexity of the method is 22
Complex Method,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,AsByte,Cyclomatic complexity of the method is 9
Complex Method,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,AsSByte,Cyclomatic complexity of the method is 9
Complex Method,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,AsInt16,Cyclomatic complexity of the method is 9
Complex Method,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,AsInt32,Cyclomatic complexity of the method is 9
Complex Method,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,AsInt64,Cyclomatic complexity of the method is 8
Complex Method,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,AsUInt64,Cyclomatic complexity of the method is 8
Complex Method,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,Equals,Cyclomatic complexity of the method is 16
Complex Method,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,EqualsWhenValueType,Cyclomatic complexity of the method is 16
Complex Method,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ToString,Cyclomatic complexity of the method is 20
Complex Method,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ToStringBinary,Cyclomatic complexity of the method is 16
Complex Method,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,IsTypeOf,Cyclomatic complexity of the method is 16
Complex Method,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,PackToMessage,Cyclomatic complexity of the method is 22
Complex Method,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,PackToMessageAsync,Cyclomatic complexity of the method is 22
Complex Method,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,FromObject,Cyclomatic complexity of the method is 22
Complex Method,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ToObject,Cyclomatic complexity of the method is 19
Complex Method,MsgPack,MessagePackObjectDictionary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObjectDictionary.cs,TryValidateObjectArgument,Cyclomatic complexity of the method is 20
Complex Method,MsgPack,MessagePackObjectDictionary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObjectDictionary.cs,AddCore,Cyclomatic complexity of the method is 9
Complex Method,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackCore,Cyclomatic complexity of the method is 8
Complex Method,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackCore,Cyclomatic complexity of the method is 10
Complex Method,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,Cyclomatic complexity of the method is 8
Complex Method,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,Cyclomatic complexity of the method is 10
Complex Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinary,Cyclomatic complexity of the method is 17
Complex Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinaryAsync,Cyclomatic complexity of the method is 17
Complex Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadString,Cyclomatic complexity of the method is 17
Complex Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringAsync,Cyclomatic complexity of the method is 17
Complex Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectCore,Cyclomatic complexity of the method is 8
Complex Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,Cyclomatic complexity of the method is 102
Complex Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectCoreAsync,Cyclomatic complexity of the method is 8
Complex Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,Cyclomatic complexity of the method is 102
Complex Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLength,Cyclomatic complexity of the method is 15
Complex Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLengthAsync,Cyclomatic complexity of the method is 15
Complex Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLength,Cyclomatic complexity of the method is 15
Complex Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLengthAsync,Cyclomatic complexity of the method is 15
Complex Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObject,Cyclomatic complexity of the method is 16
Complex Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,Cyclomatic complexity of the method is 17
Complex Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObjectAsync,Cyclomatic complexity of the method is 16
Complex Method,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,Cyclomatic complexity of the method is 17
Complex Method,MsgPack,ReadValueResults,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,Cyclomatic complexity of the method is 32
Complex Method,MsgPack,StringEscape,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\StringEscape.cs,ForDisplay,Cyclomatic complexity of the method is 11
Complex Method,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,HandleParseResult,Cyclomatic complexity of the method is 26
Complex Method,MsgPack,TimestampStringConverter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,Cyclomatic complexity of the method is 20
Complex Method,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildCollectionSerializer,Cyclomatic complexity of the method is 11
Complex Method,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,DetermineSerializationStrategy,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,MakeDefaultParameterValueLiteral,Cyclomatic complexity of the method is 19
Complex Method,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitConstructPolymorphismSchema,Cyclomatic complexity of the method is 21
Complex Method,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,DetermineBaseClass,Cyclomatic complexity of the method is 11
Complex Method,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildObjectPackToCore,Cyclomatic complexity of the method is 11
Complex Method,MsgPack.Serialization.AbstractSerializers,TypeDefinition,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\TypeDefinition.cs,ResolveRuntimeType,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,DefaultConcreteTypeRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultConcreteTypeRepository.cs,Register,Cyclomatic complexity of the method is 10
Complex Method,MsgPack.Serialization,IdentifierUtility,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\IdentifierUtility.cs,EscapeTypeName,Cyclomatic complexity of the method is 13
Complex Method,MsgPack.Serialization,PackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PackHelpers.cs,PackToMap,Cyclomatic complexity of the method is 10
Complex Method,MsgPack.Serialization,PackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PackHelpers.cs,PackToMapAsyncCore,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,ToDebugString,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,CreateCore,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,Cyclomatic complexity of the method is 18
Complex Method,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,DetermineCollectionInterfaces,Cyclomatic complexity of the method is 22
Complex Method,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,Prepare,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,FindDeserializationConstructor,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,CheckTargetEligibility,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,SerializerGenerationLogic<TConfig>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerGenerator.cs,ExtractElementTypes,Cyclomatic complexity of the method is 10
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackArrayTo,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionTo,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionTo,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionTo,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionTo,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMapTo,Cyclomatic complexity of the method is 11
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMapTo,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValue,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValue,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValueAsync,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValueAsync,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValue,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValue,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValueAsync,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValueAsync,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValue,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValue,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValueAsync,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValueAsync,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,EndMethodOverrideCore,Cyclomatic complexity of the method is 14
Complex Method,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,EmitGetActionsExpression,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,Finish,Cyclomatic complexity of the method is 28
Complex Method,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,TryCreateImmutableCollectionSerializer,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,DetermineImmutableCollectionType,Cyclomatic complexity of the method is 14
Complex Method,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,TryCreateAbstractCollectionSerializer,Cyclomatic complexity of the method is 10
Complex Method,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,IsSupported,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,UnpackFromCore,Cyclomatic complexity of the method is 11
Complex Method,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,UnpackFromAsyncCore,Cyclomatic complexity of the method is 11
Complex Method,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,Cyclomatic complexity of the method is 19
Complex Method,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,Cyclomatic complexity of the method is 19
Complex Method,MsgPack.Serialization.DefaultSerializers,System_Collections_DictionaryEntryMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_DictionaryEntryMessagePackSerializer.cs,UnpackFromCore,Cyclomatic complexity of the method is 10
Complex Method,MsgPack.Serialization.DefaultSerializers,System_Collections_DictionaryEntryMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_DictionaryEntryMessagePackSerializer.cs,UnpackFromAsyncCore,Cyclomatic complexity of the method is 10
Complex Method,MsgPack.Serialization.DefaultSerializers,System_ObjectMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_ObjectMessagePackSerializer.cs,UnpackFromCore,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization.DefaultSerializers,System_ObjectMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_ObjectMessagePackSerializer.cs,UnpackFromAsyncCore,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromCore,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromAsyncCore,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,MakeIntegerLiteral,Cyclomatic complexity of the method is 12
Complex Method,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,MakeEnumLiteral,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,EmitGetActionsExpression,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization.EmittingSerializers,InvocationILConsruct,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\InvocationILConsruct.cs,Invoke,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,CreateContextfulObjectConstructor,Cyclomatic complexity of the method is 22
Complex Method,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,DecodeRuntimeTypeInfo,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,DecodeRuntimeTypeInfoAsync,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,PackToCore,Cyclomatic complexity of the method is 10
Complex Method,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,PackToAsyncCore,Cyclomatic complexity of the method is 10
Complex Method,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackFromCore,Cyclomatic complexity of the method is 11
Complex Method,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackMemberValue,Cyclomatic complexity of the method is 11
Complex Method,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackAndAddCollectionItem,Cyclomatic complexity of the method is 10
Complex Method,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackFromAsyncCore,Cyclomatic complexity of the method is 12
Complex Method,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackMemberValueAsync,Cyclomatic complexity of the method is 11
Complex Method,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackAndAddCollectionItemAsync,Cyclomatic complexity of the method is 10
Complex Method,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,CreateCollectionSerializer,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,GetMetadata,Cyclomatic complexity of the method is 17
Complex Method,MsgPack.Serialization.Reflection,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\ReflectionExtensions.cs,ToILString,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitAnyLdc_I4,Cyclomatic complexity of the method is 11
Complex Method,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitAnyLdelem,Cyclomatic complexity of the method is 12
Complex Method,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitAnyStelem,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitLiteralInteger,Cyclomatic complexity of the method is 13
Complex Method,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,TraceSignature,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,TraceMethod,Cyclomatic complexity of the method is 14
Complex Method,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,WriteCallingConventions,Cyclomatic complexity of the method is 11
Long Parameter List,MsgPack,CollectionOperation,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\CollectionOperation.cs,CopyTo,The method has 6 parameters. Parameters: source' sourceCount' index' array' arrayIndex' count
Long Parameter List,MsgPack,CollectionOperation,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\CollectionOperation.cs,CopyTo,The method has 7 parameters. Parameters: source' sourceCount' index' array' arrayIndex' count' converter
Long Parameter List,MsgPack,CollectionOperation,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\CollectionOperation.cs,ValidateCopyToArguments,The method has 5 parameters. Parameters: sourceCount' index' array' arrayIndex' count
Long Parameter List,MsgPack,EncodingExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\EncodingExtensions.cs,EncodeString,The method has 7 parameters. Parameters: source' pChar' charsLength' pBuffer' bufferCount' charsUsed' bytesUsed
Long Parameter List,MsgPack,EncodingExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\EncodingExtensions.cs,DecodeString,The method has 6 parameters. Parameters: source' bytes' bytesOffset' bytesLength' buffer' result
Long Parameter List,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadItems,The method has 5 parameters. Parameters: count' isMap' source' offset' result
Long Parameter List,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,EncodeString,The method has 7 parameters. Parameters: encoder' value' startOffset' count' buffer' charsUsed' bytesUsed
Long Parameter List,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadItems,The method has 5 parameters. Parameters: count' isMap' buffer' offset' result
Long Parameter List,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadItemsAsync,The method has 5 parameters. Parameters: count' isMap' buffer' offset' cancellationToken
Long Parameter List,MsgPack,PackerUnpackerExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\PackerUnpackerExtensions.cs,PackDictionaryAsyncCore,The method has 5 parameters. Parameters: source' dictionary' keySerializer' valueSerializer' cancellationToken
Long Parameter List,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,TryParseExact,The method has 5 parameters. Parameters: input' format' formatProvider' styles' result
Long Parameter List,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,TryParseExact,The method has 5 parameters. Parameters: input' formats' formatProvider' styles' result
Long Parameter List,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,TryParseExactCore,The method has 5 parameters. Parameters: input' format' formatProvider' styles' result
Long Parameter List,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,TryParseExactCore,The method has 5 parameters. Parameters: input' formats' formatProvider' styles' result
Long Parameter List,MsgPack,Value,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.cs,Value,The method has 7 parameters. Parameters: year' month' day' hour' minute' second' nanoseconds
Long Parameter List,MsgPack,TimestampStringConverter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The method has 5 parameters. Parameters: input' format' formatProvider' styles' result
Long Parameter List,MsgPack,TimestampStringConverter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,ParseDigitRange,The method has 6 parameters. Parameters: input' minLength' position' min' max' result
Long Parameter List,MsgPack,TimestampStringConverter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,ParseDay,The method has 5 parameters. Parameters: input' position' month' isLeapYear' day
Long Parameter List,MsgPack.Serialization.AbstractSerializers,MethodDefinition,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\MethodDefinition.cs,MethodDefinition,The method has 6 parameters. Parameters: name' genericArguments' declaringType' isStatic' returnType' parameterTypes
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,DetermineSerializationStrategy,The method has 5 parameters. Parameters: context' concreteType' targetInfo' isUnpackFromRequired' isAddItemRequired
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildCollectionUnpackFromCore,The method has 5 parameters. Parameters: context' concreteType' schema' canDeserialize' isAsync
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,MakeDefaultParameterValueLiteral,The method has 5 parameters. Parameters: context' targetVariable' literalType' literal' hasDefault
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,ExtractPrivateMethod,The method has 6 parameters. Parameters: context' name' isStatic' returnType' bodyFactory' parameters
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,DefinePrivateMethod,The method has 6 parameters. Parameters: context' name' isStatic' returnType' bodyFactory' parameters
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitStoreCollectionItemsEmitSetCollectionMemberIfNullAndSettable,The method has 8 parameters. Parameters: context' instance' collection' existent' collectionType' asField' asProperty' storeCollectionItems
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitSetProperty,The method has 5 parameters. Parameters: context' instance' property' value' withReflection
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitSetIndexedProperty,The method has 6 parameters. Parameters: context' instance' declaringType' proeprtyName' key' value
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitSetField,The method has 5 parameters. Parameters: context' instance' field' value' withReflection
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitSetField,The method has 5 parameters. Parameters: context' instance' nestedType' fieldName' value
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitPackItemStatements,The method has 9 parameters. Parameters: context' packer' itemType' nilImplication' memberName' item' memberInfo' itemsSchema' isAsync
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitSerializeItemExpressionCore,The method has 7 parameters. Parameters: context' packer' itemType' item' memberInfo' itemsSchema' isAsync
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitUnpackItemValueStatement,The method has 12 parameters. Parameters: context' memberType' memberName' nilImplication' memberInfo' itemsSchema' unpacker' unpackingContext' indexOfItem' countOfItem' setterDelegate' isAsync
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitAppendCollectionItem,The method has 5 parameters. Parameters: context' member' traits' collection' unpackedItem
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitAppendDictionaryItem,The method has 8 parameters. Parameters: context' traits' dictionary' keyType' key' valueType' value' withBoxing
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitPackActionCollectionCore,The method has 6 parameters. Parameters: context' targetInfo' actionType' actionCollection' method' isAsync
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitObjectUnpackFromCore,The method has 5 parameters. Parameters: context' targetInfo' unpackingContext' method' isAsync
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitObjectUnpackingContextInitialization,The method has 5 parameters. Parameters: context' contextFields' constructorArguments' mappableConstructorArguments' argumentInitializers
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitUnpackActionCollectionInitializationCore,The method has 6 parameters. Parameters: context' targetInfo' actionType' actionCollection' method' isAsync
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,InitializeConstructorArgumentInitializationStatements,The method has 5 parameters. Parameters: context' target' constructorParameters' constructorArguments' mappableConstructorArguments
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,GetKnownActions,The method has 5 parameters. Parameters: context' targetInfo' method' nameFactory' isAsync
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTuplePackTo,The method has 5 parameters. Parameters: context' itemTypes' itemSchemaList' isValueTuple' isAsync
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTuplePackToCore,The method has 5 parameters. Parameters: context' itemTypes' itemSchemaList' isValueTuple' isAsync
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTuplePackToCore,The method has 6 parameters. Parameters: context' itemTypes' itemSchemaList' memberFactory' chainConstructFactory' isAsync
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitPackTupleItemStatements,The method has 8 parameters. Parameters: context' itemType' currentPacker' tuple' memberInvocationChain' itemsSchema' chainConstructFactory' isAsync
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTupleUnpackFrom,The method has 5 parameters. Parameters: context' itemTypes' itemSchemaList' isValueTuple' isAsync
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTupleUnpackFromCore,The method has 5 parameters. Parameters: context' itemTypes' itemSchemaList' isValueTuple' isAsync
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTupleUnpackFromCore,The method has 5 parameters. Parameters: context' itemTypes' itemSchemaList' memberFactory' isAsync
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilderOnPackingParameter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.cs,SerializerBuilderOnPackingParameter,The method has 5 parameters. Parameters: builder' context' item' itemType' memberName
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerBuilderOnUnpacedParameter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.cs,SerializerBuilderOnUnpacedParameter,The method has 5 parameters. Parameters: builder' context' itemType' memberName' store
Long Parameter List,MsgPack.Serialization.AbstractSerializers,SerializerGenerationContext<TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerGenerationContext.cs,DefineUnpackingContextCore,The method has 6 parameters. Parameters: fields' type' constructor' parameterInUnpackValueMethods' parameterInSetValueMethods' parameterInCreateObjectFromContext
Long Parameter List,MsgPack.Serialization.AbstractSerializers,TypeDefinition,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\TypeDefinition.cs,TypeDefinition,The method has 5 parameters. Parameters: runtimeType' name' elementType' flags' genericArguments
Long Parameter List,MsgPack.Serialization,CollectionTraits,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CollectionTraits.cs,CollectionTraits,The method has 5 parameters. Parameters: type' elementType' getEnumeratorMethod' addMethod' countPropertyGetter
Long Parameter List,MsgPack.Serialization,DefaultSerializerNameResolver,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializerNameResolver.cs,ResolveTypeName,The method has 5 parameters. Parameters: useSequence' targetType' namespace' serializerTypeName' serializerTypeNamespace
Long Parameter List,MsgPack.Serialization,PackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PackHelpers.cs,PackToMapAsyncCore,The method has 6 parameters. Parameters: serializationContext' packer' target' operations' nullCheckers' cancellationToken
Long Parameter List,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,PolymorphismSchema,The method has 5 parameters. Parameters: targetType' polymorphismType' typeVerifier' childrenType' childItemSchemaList
Long Parameter List,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,PolymorphismSchema,The method has 6 parameters. Parameters: targetType' polymorphismType' codeTypeMapping' typeVerifier' childrenType' childItemSchemaList
Long Parameter List,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,PolymorphismSchema,The method has 6 parameters. Parameters: targetType' polymorphismType' codeTypeMapping' typeVerifier' childrenType' childItemSchemaList
Long Parameter List,MsgPack.Serialization,TypeTableEntry,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,SetKnownType,The method has 5 parameters. Parameters: target' memberName' tupleItemNumber' typeCode' bindingType
Long Parameter List,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,TryCreateCollectionTraitsForIEnumerableT,The method has 5 parameters. Parameters: source' genericTypes' options' getMethod' result
Long Parameter List,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,DetermineCollectionInterfaces,The method has 6 parameters. Parameters: type' genericTypes' idictionary' ilist' icollection' ienumerable
Long Parameter List,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,DetermineCanDeserialize,The method has 5 parameters. Parameters: kind' context' targetType' correspondingMemberNames' allowDefault
Long Parameter List,MsgPack.Serialization,SerializerCodeGenerationResult,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerCodeGenerationResult.cs,SerializerCodeGenerationResult,The method has 5 parameters. Parameters: targetType' filePath' serializerTypeFullName' serializerTypeNamespace' serializerTypeName
Long Parameter List,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,GetNullableCompanion,The method has 5 parameters. Parameters: targetType' context' serializer' nullableType' nullableSerializerProvider
Long Parameter List,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,Register,The method has 5 parameters. Parameters: targetType' serializerProvider' nullableType' nullableSerializerProvider' options
Long Parameter List,MsgPack.Serialization,TypeKeyRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\TypeKeyRepository.cs,Register,The method has 5 parameters. Parameters: type' entry' nullableType' nullableValue' options
Long Parameter List,MsgPack.Serialization,TypeKeyRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\TypeKeyRepository.cs,RegisterCore,The method has 5 parameters. Parameters: key' value' nullableType' nullableValue' options
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,Trace,The method has 5 parameters. Parameters: context' label' unpacker' index' itemNames
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,Trace,The method has 5 parameters. Parameters: context' label' unpacker' index' key
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValue,The method has 9 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' directRead' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValueCore,The method has 9 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' directRead' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValueAsync,The method has 10 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' directRead' setter' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValueAsyncCore,The method has 10 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' directRead' setter' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValue,The method has 10 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' nilImplication' directRead' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValueCore,The method has 10 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' nilImplication' directRead' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValueAsync,The method has 11 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' nilImplication' directRead' setter' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValueAsyncCore,The method has 11 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' nilImplication' directRead' setter' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValue,The method has 10 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' nilImplication' directRead' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValueCore,The method has 10 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' nilImplication' directRead' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValueAsync,The method has 11 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' nilImplication' directRead' setter' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValueAsyncCore,The method has 11 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' nilImplication' directRead' setter' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMessagePackObjectValueFromArray,The method has 7 parameters. Parameters: unpacker' context' itemsCount' unpacked' memberName' nilImplication' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMessagePackObjectValueFromArrayAsync,The method has 8 parameters. Parameters: unpacker' context' itemsCount' unpacked' memberName' nilImplication' setter' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMessagePackObjectValueFromMap,The method has 7 parameters. Parameters: unpacker' context' itemsCount' unpacked' memberName' nilImplication' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMessagePackObjectValueFromMapAsync,The method has 8 parameters. Parameters: unpacker' context' itemsCount' unpacked' memberName' nilImplication' setter' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMessagePackObjectValueCore,The method has 7 parameters. Parameters: unpacker' unpackingContext' itemsCount' unpacked' memberName' nilImplication' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMessagePackObjectValueAsyncCore,The method has 8 parameters. Parameters: unpacker' unpackingContext' itemsCount' unpacked' memberName' nilImplication' setter' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackFromArray,The method has 5 parameters. Parameters: unpacker' context' factory' itemNames' operations
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackFromArrayCore,The method has 5 parameters. Parameters: unpacker' unpackingContext' factory' itemNames' operations
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackFromArrayAsync,The method has 6 parameters. Parameters: unpacker' context' factory' itemNames' operations' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackFromArrayAsyncCore,The method has 6 parameters. Parameters: unpacker' unpackingContext' factory' itemNames' operations' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackFromMapAsync,The method has 5 parameters. Parameters: unpacker' context' factory' operations' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackFromMapAsyncCore,The method has 5 parameters. Parameters: unpacker' unpackingContext' factory' operations' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollection,The method has 5 parameters. Parameters: unpacker' itemsCount' collection' bulkOperation' eachOperation
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionCore,The method has 5 parameters. Parameters: unpacker' itemsCount' collection' bulkOperation' eachOperation
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionAsync,The method has 6 parameters. Parameters: unpacker' itemsCount' collection' bulkOperation' eachOperation' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionAsyncCore,The method has 6 parameters. Parameters: unpacker' itemsCount' collection' bulkOperation' eachOperation' cancellationToken
Long Parameter List,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,DefineUnpackingContextCore,The method has 6 parameters. Parameters: fields' type' constructor' parameterInUnpackValueMethods' parameterInSetValueMethods' parameterInCreateObjectFromContext
Long Parameter List,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,EmitSetIndexedProperty,The method has 6 parameters. Parameters: context' instance' declaringType' proeprtyName' key' value
Long Parameter List,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,EmitSetField,The method has 5 parameters. Parameters: context' instance' nestedType' fieldName' value
Long Parameter List,MsgPack.Serialization.DefaultSerializers,AbstractCollectionSerializerHelper,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractCollectionSerializerHelper.cs,GetConcreteSerializer,The method has 7 parameters. Parameters: context' schema' abstractType' targetType' exampleType' factory' serializer
Long Parameter List,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,TryCreateAbstractCollectionSerializer,The method has 5 parameters. Parameters: context' abstractType' concreteType' schema' traits
Long Parameter List,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,ForEach,The method has 5 parameters. Parameters: array' totalLength' lowerBounds' lengths' action
Long Parameter List,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,ForEachAsync,The method has 5 parameters. Parameters: array' totalLength' lowerBounds' lengths' action
Long Parameter List,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderEmittingContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderEmittingContext.cs,DefineUnpackingContextCore,The method has 6 parameters. Parameters: fields' type' constructor' parameterInUnpackValueMethods' parameterInSetValueMethods' parameterInCreateObjectFromContext
Long Parameter List,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,EmitSetIndexedProperty,The method has 6 parameters. Parameters: context' instance' declaringType' proeprtyName' key' value
Long Parameter List,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,EmitSetField,The method has 5 parameters. Parameters: context' instance' nestedType' fieldName' value
Long Parameter List,MsgPack.Serialization.EmittingSerializers,BinaryOperatorILConstruct,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\BinaryOperatorILConstruct.cs,BinaryOperatorILConstruct,The method has 6 parameters. Parameters: operator' resultType' left' right' operation' branchOperation
Long Parameter List,MsgPack.Serialization.EmittingSerializers,ILConstruct,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\ILConstruct.cs,BinaryOperator,The method has 6 parameters. Parameters: operator' resultType' left' right' operation' branchOperation
Long Parameter List,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,DefineMethod,The method has 5 parameters. Parameters: methodName' isOverride' isStatic' returnType' parameterTypes
Long Parameter List,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,RegisterSerializer,The method has 5 parameters. Parameters: targetType' enumMemberSerializationMethod' dateTimeConversionMethod' polymorphismSchema' schemaRegenerationCodeProvider
Long Parameter List,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,CreateObjectInstance,The method has 5 parameters. Parameters: context' builder' targetInfo' schema' capabilities
Long Parameter List,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,CreateContextfulObjectConstructor,The method has 15 parameters. Parameters: context' baseType' capabilities' il' packActionListInitializerProvider' packActionTableInitializerProvider' nullCheckerTableInitializerProvider' unpackActionListInitializerProvider' unpackActionTableInitializerProvider' packAsyncActionListInitializerProvider' packAsyncActionTableInitializerProvider' unpackAsyncActionListInitializerProvider' unpackAsyncActionTableInitializerProvider' memberNamesInitializerProvider' unpackToInitializerProvider
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionCollectionMessagePackSerializer<TCollection;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionCollectionMessagePackSerializer`2.cs,ReflectionCollectionMessagePackSerializer,The method has 5 parameters. Parameters: ownerContext' targetType' collectionTraits' itemsSchema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionDictionaryMessagePackSerializer<TDictionary;TKey;TValue>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionDictionaryMessagePackSerializer`3.cs,ReflectionDictionaryMessagePackSerializer,The method has 5 parameters. Parameters: ownerContext' targetType' collectionTraits' itemsSchema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionEnumerableMessagePackSerializer<TCollection;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionEnumerableMessagePackSerializer`2.cs,ReflectionEnumerableMessagePackSerializer,The method has 5 parameters. Parameters: ownerContext' targetType' collectionTraits' itemsSchema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionNonGenericCollectionMessagePackSerializer<TCollection>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionNonGeenricCollectionMessagePackSerializer`1.cs,ReflectionNonGenericCollectionMessagePackSerializer,The method has 5 parameters. Parameters: ownerContext' targetType' collectionTraits' itemsSchema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionNonGenericEnumerableMessagePackSerializer<TCollection>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionNonGeenricEnumerableMessagePackSerializer`1.cs,ReflectionNonGenericEnumerableMessagePackSerializer,The method has 5 parameters. Parameters: ownerContext' targetType' collectionTraits' itemsSchema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionNonGenericDictionaryMessagePackSerializer<TDictionary>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionNonGenericDictionaryMessagePackSerializer`1.cs,ReflectionNonGenericDictionaryMessagePackSerializer,The method has 5 parameters. Parameters: ownerContext' targetType' collectionTraits' itemsSchema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionNonGenericListMessagePackSerializer<TList>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionNonGenericListMessagePackSerializer`1.cs,ReflectionNonGenericListMessagePackSerializer,The method has 5 parameters. Parameters: ownerContext' targetType' collectionTraits' itemsSchema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackMemberValue,The method has 6 parameters. Parameters: objectGraph' unpacker' itemsCount' unpacked' index' unpackerOffset
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackMemberValueAsync,The method has 7 parameters. Parameters: objectGraph' unpacker' itemsCount' unpacked' index' unpackerOffset' cancellationToken
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,GetMetadata,The method has 8 parameters. Parameters: targetType' members' context' getters' setters' memberInfos' contracts' serializers
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,IVariantReflectionSerializerFactory,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The method has 5 parameters. Parameters: context' targetType' collectionTraits' schema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,NonGenericEnumerableSerializerFactory<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The method has 5 parameters. Parameters: context' targetType' collectionTraits' schema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,NonGenericCollectionSerializerFactory<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The method has 5 parameters. Parameters: context' targetType' collectionTraits' schema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,NonGenericListSerializerFactory<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The method has 5 parameters. Parameters: context' targetType' collectionTraits' schema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,NonGenericDictionarySerializerFactory<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The method has 5 parameters. Parameters: context' targetType' collectionTraits' schema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,EnumerableSerializerFactory<TCollection;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The method has 5 parameters. Parameters: context' targetType' collectionTraits' schema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,CollectionSerializerFactory<TCollection;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The method has 5 parameters. Parameters: context' targetType' collectionTraits' schema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,DictionarySerializerFactory<TDictionary;TKey;TValue>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The method has 5 parameters. Parameters: context' targetType' collectionTraits' schema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionTupleMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionTupleMessagePackSerializer`1.cs,GetGetters,The method has 5 parameters. Parameters: itemTypes' tupleTypes' metadataFactory' accessorFactory' chainedGetterFactory
Long Parameter List,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,TraceSignature,The method has 5 parameters. Parameters: managedCallingConventions' unmanagedCallingConvention' returnType' requiredParameterTypes' optionalParameterTypes
Long Identifier,MsgPack,PackerUnpackerStreamOptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\PackerUnpackerStreamOptions.cs,,The length of the parameter _knownMemoryOrBufferingStreams is 30.
Long Identifier,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitUnpackItemValueStatement,The length of the parameter unpackHelperParameterTypeDefinition is 35.
Long Identifier,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildObjectPackToCore,The length of the parameter packHelperParameterTypeDefinition is 33.
Long Identifier,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTuplePackToCore,The length of the parameter packHelperParameterTypeDefinition is 33.
Long Identifier,MsgPack.Serialization.AbstractSerializers,SerializerGenerationContext<TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerGenerationContext.cs,DefineUnpackingContextCore,The length of the parameter parameterInCreateObjectFromContext is 34.
Long Identifier,MsgPack.Serialization.AbstractSerializers,SerializerGenerationContext<TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerGenerationContext.cs,DefineUnpackingContextWithResultObjectCore,The length of the parameter parameterInCreateObjectFromContext is 34.
Long Identifier,MsgPack.Serialization.AbstractSerializers,TypeDefinition,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\TypeDefinition.cs,,The length of the parameter EnumMemberSerializationMethodType is 33.
Long Identifier,MsgPack.Serialization.AbstractSerializers,TypeDefinition,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\TypeDefinition.cs,,The length of the parameter DateTimeMemberConversionMethodType is 34.
Long Identifier,MsgPack.Serialization,DateTimeMessagePackSerializerHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DateTimeMessagePackSerializerHelpers.cs,DetermineDateTimeConversionMethod,The length of the parameter dateTimeMemberConversionMethod is 30.
Long Identifier,MsgPack.Serialization,DependentAssemblyManager,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DependentAssemblyManager.cs,,The length of the parameter _compiledCodeDomSerializerAssemblies is 36.
Long Identifier,MsgPack.Serialization,MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,,The length of the parameter _packerCompatibilityOptionsForCompatibility is 43.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForPolymorphicObjectTypeEmbeddingMethod is 39.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForPolymorphicObjectCodeTypeMappingMethod is 41.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForContextSpecifiedCollectionMethod is 35.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForPolymorphicCollectionTypeEmbeddingMethod is 43.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForPolymorphicCollectionCodeTypeMappingMethod is 45.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForContextSpecifiedDictionaryMethod is 35.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForPolymorphicDictionaryTypeEmbeddingMethod is 43.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForPolymorphicDictionaryCodeTypeMappingMethod is 45.
Long Identifier,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,The length of the parameter allowNonCollectionEnumerableTypes is 33.
Long Identifier,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,,The length of the parameter ExceptionConstructorWithInnerParameterTypes is 43.
Long Identifier,MsgPack.Serialization,SerializationCompatibilityOptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationCompatibilityOptions.cs,,The length of the parameter _ignorePackabilityForCollection is 31.
Long Identifier,MsgPack.Serialization,SerializationCompatibilityOptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationCompatibilityOptions.cs,,The length of the parameter _allowNonCollectionEnumerableTypes is 34.
Long Identifier,MsgPack.Serialization,SerializationContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationContext.cs,,The length of the parameter _dictionarySerializationOptions is 31.
Long Identifier,MsgPack.Serialization,SerializationContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationContext.cs,,The length of the parameter _defaultDateTimeConversionMethod is 32.
Long Identifier,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,,The length of the parameter ThrowValueTypeCannotBeNull3Method is 33.
Long Identifier,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,,The length of the parameter ThrowTupleCardinarityIsNotMatchMethod is 37.
Long Identifier,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,,The length of the parameter NewUnpackFromIsNotSupportedMethod is 33.
Long Identifier,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,,The length of the parameter NewCreateInstanceIsNotSupportedMethod is 37.
Long Identifier,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,,The length of the parameter MessagePackMemberAttributeTypeName is 34.
Long Identifier,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,,The length of the parameter MessagePackIgnoreAttributeTypeName is 34.
Long Identifier,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,,The length of the parameter MessagePackDeserializationConstructorAttributeTypeName is 54.
Long Identifier,MsgPack.Serialization,SerializerDebugging,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerDebugging.cs,,The length of the parameter _useLegacyNullMapEntryHandling is 30.
Long Identifier,MsgPack.Serialization,SerializingMember,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializingMember.cs,GetEnumMemberSerializationMethod,The length of the parameter messagePackEnumMemberAttributes is 31.
Long Identifier,MsgPack.Serialization,SerializingMember,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializingMember.cs,GetDateTimeMemberConversionMethod,The length of the parameter messagePackDateTimeMemberAttribute is 34.
Long Identifier,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,DefineUnpackingContextCore,The length of the parameter parameterInCreateObjectFromContext is 34.
Long Identifier,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,DefineUnpackingContextWithResultObjectCore,The length of the parameter parameterInCreateObjectFromContext is 34.
Long Identifier,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,DefineUnpackValueMethodArguments,The length of the parameter parameterInCreateObjectFromContext is 34.
Long Identifier,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,,The length of the parameter ConditionalExpressionHelperMethodName is 37.
Long Identifier,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,,The length of the parameter ConditionalExpressionHelperConditionParameterName is 49.
Long Identifier,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,,The length of the parameter ConditionalExpressionHelperWhenTrueParameterName is 48.
Long Identifier,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,,The length of the parameter ConditionalExpressionHelperWhenFalseParameterName is 49.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractCollectionMessagePackSerializer<TCollection;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractCollectionMessagePackSerializer`2.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractDictionaryMessagePackSerializer<TDictionary;TKey;TValue>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractDictionaryMessagePackSerializer`3.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractEnumerableMessagePackSerializer<TCollection;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractEnumerableMessagePackSerializer`2.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractNonGenericCollectionMessagePackSerializer<TCollection>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractNonGenericCollectionMessagePackSerializer`1.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractNonGenericDictionaryMessagePackSerializer<TDictionary>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractNonGenericDictionaryMessagePackSerializer`1.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractNonGenericEnumerableMessagePackSerializer<TCollection>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractNonGenericEnumerableMessagePackSerializer`1.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractNonGenericListMessagePackSerializer<TCollection>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractNonGenericListMessagePackSerializer`1.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractReadOnlyCollectionMessagePackSerializer<TCollection;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractReadOnlyCollectionMessagePackSerializer`2.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractReadOnlyDictionaryMessagePackSerializer<TDictionary;TKey;TValue>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractReadOnlyDictionaryMessagePackSerializer`3.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,IsSupported,The length of the parameter preferReflectionBasedSerializer is 31.
Long Identifier,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderEmittingContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderEmittingContext.cs,DefineUnpackingContextCore,The length of the parameter parameterInCreateObjectFromContext is 34.
Long Identifier,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderEmittingContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderEmittingContext.cs,DefineUnpackingContextWithResultObjectCore,The length of the parameter parameterInCreateObjectFromContext is 34.
Long Identifier,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderEmittingContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderEmittingContext.cs,DefineUnpackValueMethodArguments,The length of the parameter parameterInCreateObjectFromContext is 34.
Long Identifier,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,BuildSerializerCodeCore,The length of the parameter asAssemblyBuilderCodeGenerationContext is 38.
Long Identifier,MsgPack.Serialization.EmittingSerializers,SerializationMethodGeneratorManager,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializationMethodGeneratorManager.cs,,The length of the parameter _debuggableAttributeCtorArguments is 33.
Long Identifier,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,RegisterSerializer,The length of the parameter schemaRegenerationCodeProvider is 30.
Long Identifier,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,CreateObjectConstructor,The length of the parameter unpackActionTableInitialization is 31.
Long Identifier,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,CreateContextfulObjectConstructor,The length of the parameter packActionListInitializerProvider is 33.
Long Identifier,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,CreateContextfulObjectConstructor,The length of the parameter packActionTableInitializerProvider is 34.
Long Identifier,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,CreateContextfulObjectConstructor,The length of the parameter nullCheckerTableInitializerProvider is 35.
Long Identifier,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,CreateContextfulObjectConstructor,The length of the parameter unpackActionListInitializerProvider is 35.
Long Identifier,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,CreateContextfulObjectConstructor,The length of the parameter unpackActionTableInitializerProvider is 36.
Long Identifier,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,CreateContextfulObjectConstructor,The length of the parameter packAsyncActionListInitializerProvider is 38.
Long Identifier,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,CreateContextfulObjectConstructor,The length of the parameter packAsyncActionTableInitializerProvider is 39.
Long Identifier,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,CreateContextfulObjectConstructor,The length of the parameter unpackAsyncActionListInitializerProvider is 40.
Long Identifier,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,CreateContextfulObjectConstructor,The length of the parameter unpackAsyncActionTableInitializerProvider is 41.
Long Identifier,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,CreateContextfulObjectConstructor,The length of the parameter memberNamesInitializerProvider is 30.
Long Identifier,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,,The length of the parameter ContextConstructorParameterTypes is 32.
Long Identifier,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,,The length of the parameter ContextAndEnumSerializationMethodConstructorParameterTypes is 58.
Long Identifier,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,,The length of the parameter _defaultEnumSerializationMethod is 31.
Long Identifier,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,,The length of the parameter ConstructorParameterTypesWithoutCapabilities is 44.
Long Identifier,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,,The length of the parameter ConstructorParameterTypesWithCapabilities is 41.
Long Identifier,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,,The length of the parameter CollectionConstructorParameterTypes is 35.
Long Identifier,MsgPack.Serialization.Metadata,_DateTimeMessagePackSerializerHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Metadata\_DateTimeMessagePackSerializerHelpers.cs,,The length of the parameter DetermineDateTimeConversionMethodMethod is 39.
Long Identifier,MsgPack.Serialization.Metadata,_EnumMessagePackSerializerHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Metadata\_EnumMessagePackSerializerHelpers.cs,,The length of the parameter DetermineEnumSerializationMethodMethod is 38.
Long Identifier,MsgPack.Serialization.Metadata,_SerializationContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Metadata\_SerializationContext.cs,,The length of the parameter GetSerializer1_Parameter_Method is 31.
Long Identifier,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,,The length of the parameter _ArgumentException_ctor_String_String_Exception is 47.
Long Identifier,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,,The length of the parameter _standardExceptionConstructorParamterTypesWithInnerException is 60.
Long Statement,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The length of the statement  "					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32" is 141.
Long Statement,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The length of the statement  "					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];" is 133.
Long Statement,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt16,The length of the statement  "			Contract.Assert( buffer.Length >= offset + sizeof( ushort )' buffer.Length + ">=" + offset + " + " + sizeof( ushort ) );" is 120.
Long Statement,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt32,The length of the statement  "				return ( uint )( ( buffer[ offset ] << 24 ) | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ] );" is 126.
Long Statement,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The length of the statement  "					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32" is 152.
Long Statement,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The length of the statement  "					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );" is 135.
Long Statement,MsgPack,Binary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToBits,The length of the statement  "			// Float32Bits usage is effectively pointer dereference operation rather than shifting operators' so we must consider endianness here." is 134.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteByteAsync( value ? ( byte )MessagePackCode.TrueValue : ( byte )MessagePackCode.FalseValue' cancellationToken ).ConfigureAwait( false );" is 151.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt8' unchecked( ( Byte )value )' cancellationToken ).ConfigureAwait( false );" is 138.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )value )' cancellationToken ).ConfigureAwait( false );" is 136.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )value )' cancellationToken ).ConfigureAwait( false );" is 136.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false );" is 147.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )value )' cancellationToken ).ConfigureAwait( false );" is 139.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false );" is 147.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )value )' cancellationToken ).ConfigureAwait( false );" is 139.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false );" is 149.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt16' unchecked( ( UInt16 )value )' cancellationToken ).ConfigureAwait( false );" is 141.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false );" is 147.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 152.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt32' unchecked( ( UInt32 )value )' cancellationToken ).ConfigureAwait( false );" is 139.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false );" is 147.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 152.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt32' unchecked( ( UInt32 )value )' cancellationToken ).ConfigureAwait( false );" is 139.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false );" is 149.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 154.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt32' unchecked( ( UInt32 )value )' cancellationToken ).ConfigureAwait( false );" is 141.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false );" is 147.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 152.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt32' unchecked( ( UInt32 )( value & 0xFFFFFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 156.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt64' unchecked( ( UInt64 )value )' cancellationToken ).ConfigureAwait( false );" is 139.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false );" is 147.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 152.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt32' unchecked( ( UInt32 )( value & 0xFFFFFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 156.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt64' unchecked( ( UInt64 )value )' cancellationToken ).ConfigureAwait( false );" is 139.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false );" is 149.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 154.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt32' unchecked( ( UInt32 )( value & 0xFFFFFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 158.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt64' unchecked( ( UInt64 )value )' cancellationToken ).ConfigureAwait( false );" is 141.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Real32' unchecked( ( Single )value )' cancellationToken ).ConfigureAwait( false );" is 134.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Real64' unchecked( ( Double )value )' cancellationToken ).ConfigureAwait( false );" is 134.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackArrayHeaderAsyncCore,The length of the statement  "				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedArray | length ) )' cancellationToken ).ConfigureAwait( false );" is 140.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackArrayHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Array16' unchecked( ( ushort )( length & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 149.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackArrayHeaderAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Array32' unchecked( ( uint )length )' cancellationToken ).ConfigureAwait( false );" is 134.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackMapHeaderAsyncCore,The length of the statement  "				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedMap | length ) )' cancellationToken ).ConfigureAwait( false );" is 138.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackMapHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Map16' unchecked( ( ushort )( length & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 147.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackMapHeaderAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Map32' unchecked( ( uint )length )' cancellationToken ).ConfigureAwait( false );" is 132.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackStringHeaderAsyncCore,The length of the statement  "				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedRaw | length ) )' cancellationToken ).ConfigureAwait( false );" is 138.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackStringHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Str8' unchecked( ( byte )( length & 0xFF ) )' cancellationToken ).ConfigureAwait( false );" is 142.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackStringHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Str16' unchecked( ( ushort )( length & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 147.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackStringHeaderAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Str32' unchecked( ( uint )length )' cancellationToken ).ConfigureAwait( false );" is 132.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackBinaryHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Bin8' unchecked( ( byte )( length & 0xFF ) )' cancellationToken ).ConfigureAwait( false );" is 142.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackBinaryHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Bin16' unchecked( ( ushort )( length & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 147.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackBinaryHeaderAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Bin32' unchecked( ( uint )length )' cancellationToken ).ConfigureAwait( false );" is 132.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackRawAsyncCore,The length of the statement  "			await this.WriteBytesAsync( value' ( this.CompatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) == 0' cancellationToken ).ConfigureAwait( false );" is 160.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackRawAsyncCore,The length of the statement  "				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedRaw | value.Length ) )' cancellationToken ).ConfigureAwait( false );" is 144.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackRawAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Str8' unchecked( ( byte )( value.Length ) )' cancellationToken ).ConfigureAwait( false );" is 141.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackRawAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Str16' unchecked( ( ushort )( value.Length ) )' cancellationToken ).ConfigureAwait( false );" is 144.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackRawAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Str32' unchecked( ( uint )value.Length )' cancellationToken ).ConfigureAwait( false );" is 138.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackBinaryAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Bin8' unchecked( ( byte )( value.Length ) )' cancellationToken ).ConfigureAwait( false );" is 141.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackBinaryAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Bin16' unchecked( ( ushort )( value.Length ) )' cancellationToken ).ConfigureAwait( false );" is 144.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackBinaryAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Bin32' unchecked( ( uint )value.Length )' cancellationToken ).ConfigureAwait( false );" is 138.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueAsyncCore,The length of the statement  "							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext8' ( byte )body.Length' cancellationToken ).ConfigureAwait( false );" is 123.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueAsyncCore,The length of the statement  "							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext16' ( ushort )body.Length' cancellationToken ).ConfigureAwait( false );" is 126.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueAsyncCore,The length of the statement  "							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext32' ( uint )body.Length' cancellationToken ).ConfigureAwait( false );" is 124.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadByteAsync,The length of the statement  "			return Task.FromResult( this.ReadByte( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Byte>() );" is 121.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableByteAsync,The length of the statement  "			return Task.FromResult( this.ReadNullableByte( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Byte?>() );" is 130.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadSByteAsync,The length of the statement  "			return Task.FromResult( this.ReadSByte( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<SByte>() );" is 123.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableSByteAsync,The length of the statement  "			return Task.FromResult( this.ReadNullableSByte( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<SByte?>() );" is 132.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadInt16Async,The length of the statement  "			return Task.FromResult( this.ReadInt16( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Int16>() );" is 123.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableInt16Async,The length of the statement  "			return Task.FromResult( this.ReadNullableInt16( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Int16?>() );" is 132.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadUInt16Async,The length of the statement  "			return Task.FromResult( this.ReadUInt16( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<UInt16>() );" is 125.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableUInt16Async,The length of the statement  "			return Task.FromResult( this.ReadNullableUInt16( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<UInt16?>() );" is 134.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadInt32Async,The length of the statement  "			return Task.FromResult( this.ReadInt32( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Int32>() );" is 123.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableInt32Async,The length of the statement  "			return Task.FromResult( this.ReadNullableInt32( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Int32?>() );" is 132.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadUInt32Async,The length of the statement  "			return Task.FromResult( this.ReadUInt32( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<UInt32>() );" is 125.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableUInt32Async,The length of the statement  "			return Task.FromResult( this.ReadNullableUInt32( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<UInt32?>() );" is 134.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadInt64Async,The length of the statement  "			return Task.FromResult( this.ReadInt64( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Int64>() );" is 123.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableInt64Async,The length of the statement  "			return Task.FromResult( this.ReadNullableInt64( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Int64?>() );" is 132.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadUInt64Async,The length of the statement  "			return Task.FromResult( this.ReadUInt64( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<UInt64>() );" is 125.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableUInt64Async,The length of the statement  "			return Task.FromResult( this.ReadNullableUInt64( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<UInt64?>() );" is 134.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadSingleAsync,The length of the statement  "			return Task.FromResult( this.ReadSingle( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Single>() );" is 125.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableSingleAsync,The length of the statement  "			return Task.FromResult( this.ReadNullableSingle( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Single?>() );" is 134.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadDoubleAsync,The length of the statement  "			return Task.FromResult( this.ReadDouble( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Double>() );" is 125.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableDoubleAsync,The length of the statement  "			return Task.FromResult( this.ReadNullableDouble( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Double?>() );" is 134.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadBooleanAsync,The length of the statement  "			return Task.FromResult( this.ReadBoolean( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Boolean>() );" is 127.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableBooleanAsync,The length of the statement  "			return Task.FromResult( this.ReadNullableBoolean( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Boolean?>() );" is 136.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadBinaryAsync,The length of the statement  "			return Task.FromResult( this.ReadBinary( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Byte[]>() );" is 125.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadStringAsync,The length of the statement  "			return Task.FromResult( this.ReadString( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<String>() );" is 125.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectCore,The length of the statement  "				if ( ( header & ReadValueResult.RawTypeMask ) == ReadValueResult.RawTypeMask && ( header & ReadValueResult.LengthOfLengthMask ) == 0 )" is 134.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectAsync,The length of the statement  "			return Task.FromResult( this.ReadObject( isDeep' out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<MessagePackObject>() );" is 144.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadArrayLengthAsync,The length of the statement  "			return Task.FromResult( this.ReadArrayLength( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Int64>() );" is 129.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMapLengthAsync,The length of the statement  "			return Task.FromResult( this.ReadMapLength( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Int64>() );" is 127.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMessagePackExtendedTypeObjectAsync,The length of the statement  "			return Task.FromResult( this.ReadMessagePackExtendedTypeObject( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<MessagePackExtendedTypeObject>() );" is 171.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The length of the statement  "			return Task.FromResult( this.ReadNullableMessagePackExtendedTypeObject( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<MessagePackExtendedTypeObject?>() );" is 180.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large array (0x{0:X} elements) which has more than Int32.MaxValue elements' at position {1:#'0}"" is 133.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large array (0x{0:X} elements) which has more than Int32.MaxValue elements' at offset {1:#'0}";" is 132.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large map (0x{0:X} entries) which has more than Int32.MaxValue entries' at position {1:#'0}"" is 129.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large map (0x{0:X} entries) which has more than Int32.MaxValue entries' at offset {1:#'0}";" is 128.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large ext type (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at position {1:#'0}"" is 130.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large ext type (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at offset {1:#'0}";" is 129.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large binary or string (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at position {1:#'0}"" is 138.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large binary or string (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at offset {1:#'0}";" is 137.
Long Statement,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,Equals,The length of the statement  "			Contract.Assert( false' String.Format( "Unknown handle type this:'{0}'(value: '{1}')' other:'{2}'(value: '{3}')"' this._handleOrTypeCode.GetType()' this._handleOrTypeCode' other._handleOrTypeCode.GetType()' other._handleOrTypeCode ) );" is 235.
Long Statement,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,GetHashCode,The length of the statement  "				Contract.Assert( false' String.Format( "(this._handleOrTypeCode is string) but {0}"' this._handleOrTypeCode.GetType() ) );" is 122.
Long Statement,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ToString,The length of the statement  "			Contract.Assert( false' String.Format( "(this._handleOrTypeCode is string) but {0}"' this._handleOrTypeCode.GetType() ) );" is 122.
Long Statement,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,IsTypeOf,The length of the statement  "					return typeCode.IsInteger && ( this._value < 0x80000000 || ( 0xFFFFFFFF80000000 <= this._value && typeCode.IsSigned ) );" is 120.
Long Statement,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,PackToMessage,The length of the statement  "					if ( asString.GetUnderlyingType() == typeof( string ) || ( packer.CompatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) != 0 )" is 140.
Long Statement,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,PackToMessageAsync,The length of the statement  "					if ( asString.GetUnderlyingType() == typeof( string ) || ( packer.CompatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) != 0 )" is 140.
Long Statement,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,PackToMessageAsync,The length of the statement  "					await packer.PackExtendedTypeValueAsync( unchecked( ( byte )this._value )' asExtendedTypeObjectBody' cancellationToken ).ConfigureAwait( false );" is 145.
Long Statement,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,AsString,The length of the statement  "				throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "Not '{0}' string."' encoding.WebName )' ex );" is 126.
Long Statement,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,VerifyUnderlyingType,The length of the statement  "					throw new ArgumentException( String.Format( CultureInfo.CurrentCulture' "Do not convert nil MessagePackObject to {0}."' typeof( T ) )' parameterName );" is 151.
Long Statement,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,VerifyUnderlyingType,The length of the statement  "					throw new ArgumentException( String.Format( CultureInfo.CurrentCulture' "Do not convert {0} MessagePackObject to {1}."' instance.UnderlyingType' typeof( T ) )' parameterName );" is 176.
Long Statement,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,VerifyUnderlyingRawType,The length of the statement  "				throw new ArgumentException( String.Format( CultureInfo.CurrentCulture' "Do not convert {0} MessagePackObject to {1}."' instance.UnderlyingType' typeof( T ) )' parameterName );" is 176.
Long Statement,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ThrowCannotBeNilAs,The length of the statement  "			throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "Do not convert nil MessagePackObject to {0}."' typeof( T ) ) );" is 144.
Long Statement,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ThrowInvalidTypeAs,The length of the statement  "				throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "Do not convert {0} (binary:0x{2:x}) MessagePackObject to {1}."' instance.UnderlyingType' typeof( T )' instance._value ) );" is 203.
Long Statement,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ThrowInvalidTypeAs,The length of the statement  "				throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "Do not convert {0} MessagePackObject to {1}."' instance.UnderlyingType' typeof( T ) ) );" is 169.
Long Statement,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,FromObject,The length of the statement  "			throw new MessageTypeException( String.Format( CultureInfo.CurrentCulture' "Type '{0}' is not supported."' boxedValue.GetType() ) );" is 132.
Long Statement,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,DebugDump,The length of the statement  "				return String.Format( CultureInfo.InvariantCulture' "{0}([{1}])"' this._handleOrTypeCode' this._handleOrTypeCode.GetType() );" is 125.
Long Statement,MsgPack,MessagePackObjectDictionary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObjectDictionary.cs,ThrowDuplicatedKeyException,The length of the statement  "			throw new ArgumentException( String.Format( CultureInfo.CurrentCulture' "Key '{0}'({1} type) already exists in this dictionary."' key' key.UnderlyingType )' parameterName );" is 173.
Long Statement,MsgPack,MessagePackObjectDictionary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObjectDictionary.cs,ValidateObjectArgument,The length of the statement  "				throw new ArgumentException( String.Format( CultureInfo.CurrentCulture' "Cannot convert '{1}' to {0}."' typeof( MessagePackObject ).Name' obj.GetType() )' parameterName );" is 171.
Long Statement,MsgPack,MessagePackObjectDictionary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObjectDictionary.cs,AddCore,The length of the statement  "				this._dictionary = new Dictionary<MessagePackObject' MessagePackObject>( DictionaryInitialCapacity' MessagePackObjectEqualityComparer.Instance );" is 145.
Long Statement,MsgPack,MessagePackObjectDictionary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObjectDictionary.cs,CopyTo,The length of the statement  "				CollectionOperation.CopyTo( this' this.Count' 0' asDictionaryEntries' index' array.Length' kv => new DictionaryEntry( kv.Key' kv.Value ) );" is 139.
Long Statement,MsgPack,Enumerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObjectDictionary.Enumerator.cs,GetCurrentStrict,The length of the statement  "					throw new InvalidOperationException( "The enumerator is positioned before the first element of the collection or after the last element." );" is 140.
Long Statement,MsgPack,Enumerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObjectDictionary.Enumerator.cs,MoveNext,The length of the statement  "				this._current = new KeyValuePair<MessagePackObject' MessagePackObject>( this._underlying._keys[ this._position ]' this._underlying._values[ this._position ] );" is 159.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteByteAsync( value ? ( byte )MessagePackCode.TrueValue : ( byte )MessagePackCode.FalseValue' cancellationToken ).ConfigureAwait( false );" is 151.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt8' unchecked( ( Byte )value )' cancellationToken ).ConfigureAwait( false );" is 138.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )value )' cancellationToken ).ConfigureAwait( false );" is 136.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )value )' cancellationToken ).ConfigureAwait( false );" is 136.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false );" is 147.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )value )' cancellationToken ).ConfigureAwait( false );" is 139.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false );" is 147.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )value )' cancellationToken ).ConfigureAwait( false );" is 139.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false );" is 149.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt16' unchecked( ( UInt16 )value )' cancellationToken ).ConfigureAwait( false );" is 141.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false );" is 147.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 152.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt32' unchecked( ( UInt32 )value )' cancellationToken ).ConfigureAwait( false );" is 139.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false );" is 147.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 152.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt32' unchecked( ( UInt32 )value )' cancellationToken ).ConfigureAwait( false );" is 139.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false );" is 149.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 154.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt32' unchecked( ( UInt32 )value )' cancellationToken ).ConfigureAwait( false );" is 141.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false );" is 147.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 152.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt32' unchecked( ( UInt32 )( value & 0xFFFFFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 156.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt64' unchecked( ( UInt64 )value )' cancellationToken ).ConfigureAwait( false );" is 139.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false );" is 147.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 152.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt32' unchecked( ( UInt32 )( value & 0xFFFFFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 156.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt64' unchecked( ( UInt64 )value )' cancellationToken ).ConfigureAwait( false );" is 139.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false );" is 149.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 154.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt32' unchecked( ( UInt32 )( value & 0xFFFFFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 158.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt64' unchecked( ( UInt64 )value )' cancellationToken ).ConfigureAwait( false );" is 141.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Real32' unchecked( ( Single )value )' cancellationToken ).ConfigureAwait( false );" is 134.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Real64' unchecked( ( Double )value )' cancellationToken ).ConfigureAwait( false );" is 134.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackArrayHeaderAsyncCore,The length of the statement  "				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedArray | length ) )' cancellationToken ).ConfigureAwait( false );" is 140.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackArrayHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Array16' unchecked( ( ushort )( length & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 149.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackArrayHeaderAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Array32' unchecked( ( uint )length )' cancellationToken ).ConfigureAwait( false );" is 134.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackMapHeaderAsyncCore,The length of the statement  "				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedMap | length ) )' cancellationToken ).ConfigureAwait( false );" is 138.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackMapHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Map16' unchecked( ( ushort )( length & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 147.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackMapHeaderAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Map32' unchecked( ( uint )length )' cancellationToken ).ConfigureAwait( false );" is 132.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackStringHeaderAsyncCore,The length of the statement  "				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedRaw | length ) )' cancellationToken ).ConfigureAwait( false );" is 138.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackStringHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Str8' unchecked( ( byte )( length & 0xFF ) )' cancellationToken ).ConfigureAwait( false );" is 142.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackStringHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Str16' unchecked( ( ushort )( length & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 147.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackStringHeaderAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Str32' unchecked( ( uint )length )' cancellationToken ).ConfigureAwait( false );" is 132.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackBinaryHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Bin8' unchecked( ( byte )( length & 0xFF ) )' cancellationToken ).ConfigureAwait( false );" is 142.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackBinaryHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Bin16' unchecked( ( ushort )( length & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false );" is 147.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackBinaryHeaderAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Bin32' unchecked( ( uint )length )' cancellationToken ).ConfigureAwait( false );" is 132.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackRawAsyncCore,The length of the statement  "			await this.WriteBytesAsync( value' ( this.CompatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) == 0' cancellationToken ).ConfigureAwait( false );" is 160.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackRawAsyncCore,The length of the statement  "				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedRaw | value.Length ) )' cancellationToken ).ConfigureAwait( false );" is 144.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackRawAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Str8' unchecked( ( byte )( value.Length ) )' cancellationToken ).ConfigureAwait( false );" is 141.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackRawAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Str16' unchecked( ( ushort )( value.Length ) )' cancellationToken ).ConfigureAwait( false );" is 144.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackRawAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Str32' unchecked( ( uint )value.Length )' cancellationToken ).ConfigureAwait( false );" is 138.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackBinaryAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Bin8' unchecked( ( byte )( value.Length ) )' cancellationToken ).ConfigureAwait( false );" is 141.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackBinaryAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Bin16' unchecked( ( ushort )( value.Length ) )' cancellationToken ).ConfigureAwait( false );" is 144.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackBinaryAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Bin32' unchecked( ( uint )value.Length )' cancellationToken ).ConfigureAwait( false );" is 138.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueAsyncCore,The length of the statement  "							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext8' ( byte )body.Length' cancellationToken ).ConfigureAwait( false );" is 123.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueAsyncCore,The length of the statement  "							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext16' ( ushort )body.Length' cancellationToken ).ConfigureAwait( false );" is 126.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueAsyncCore,The length of the statement  "							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext32' ( uint )body.Length' cancellationToken ).ConfigureAwait( false );" is 124.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteStringHeaderAsync,The length of the statement  "				await this.WriteByteAsync( ( byte )( bytesLength | MessagePackCode.MinimumFixedRaw )' cancellationToken ).ConfigureAwait( false );" is 130.
Long Statement,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteStringHeaderAsync,The length of the statement  "			await this.WriteBytesAsync( MessagePackCode.Str32' unchecked(( uint )bytesLength)' cancellationToken ).ConfigureAwait( false );" is 127.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinaryCoreAsync,The length of the statement  "				var readLength = await this._source.ReadAsync( result' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadByteAsync,The length of the statement  "				var slowAsyncResult = await this.ReadByteSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 120.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadByteSlowAsync,The length of the statement  "					var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableByteAsync,The length of the statement  "				var slowAsyncResult = await this.ReadNullableByteSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 128.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableByteSlowAsync,The length of the statement  "			var asyncReadResult = await this.ReadByteSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 120.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSByteAsync,The length of the statement  "				var slowAsyncResult = await this.ReadSByteSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 121.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSByteSlowAsync,The length of the statement  "					var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableSByteAsync,The length of the statement  "				var slowAsyncResult = await this.ReadNullableSByteSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 129.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableSByteSlowAsync,The length of the statement  "			var asyncReadResult = await this.ReadSByteSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 121.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt16Async,The length of the statement  "				var slowAsyncResult = await this.ReadInt16SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 121.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt16SlowAsync,The length of the statement  "					var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableInt16Async,The length of the statement  "				var slowAsyncResult = await this.ReadNullableInt16SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 129.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableInt16SlowAsync,The length of the statement  "			var asyncReadResult = await this.ReadInt16SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 121.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt16Async,The length of the statement  "				var slowAsyncResult = await this.ReadUInt16SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt16SlowAsync,The length of the statement  "					var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableUInt16Async,The length of the statement  "				var slowAsyncResult = await this.ReadNullableUInt16SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 130.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableUInt16SlowAsync,The length of the statement  "			var asyncReadResult = await this.ReadUInt16SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt32Async,The length of the statement  "				var slowAsyncResult = await this.ReadInt32SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 121.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt32SlowAsync,The length of the statement  "					var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableInt32Async,The length of the statement  "				var slowAsyncResult = await this.ReadNullableInt32SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 129.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableInt32SlowAsync,The length of the statement  "			var asyncReadResult = await this.ReadInt32SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 121.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt32Async,The length of the statement  "				var slowAsyncResult = await this.ReadUInt32SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt32SlowAsync,The length of the statement  "					var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableUInt32Async,The length of the statement  "				var slowAsyncResult = await this.ReadNullableUInt32SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 130.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableUInt32SlowAsync,The length of the statement  "			var asyncReadResult = await this.ReadUInt32SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt64Async,The length of the statement  "				var slowAsyncResult = await this.ReadInt64SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 121.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt64SlowAsync,The length of the statement  "					var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableInt64Async,The length of the statement  "				var slowAsyncResult = await this.ReadNullableInt64SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 129.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableInt64SlowAsync,The length of the statement  "			var asyncReadResult = await this.ReadInt64SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 121.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt64Async,The length of the statement  "				var slowAsyncResult = await this.ReadUInt64SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt64SlowAsync,The length of the statement  "					var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableUInt64Async,The length of the statement  "				var slowAsyncResult = await this.ReadNullableUInt64SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 130.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableUInt64SlowAsync,The length of the statement  "			var asyncReadResult = await this.ReadUInt64SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSingleAsync,The length of the statement  "				var slowAsyncResult = await this.ReadSingleSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSingleSlowAsync,The length of the statement  "					var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableSingleAsync,The length of the statement  "				var slowAsyncResult = await this.ReadNullableSingleSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 130.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableSingleSlowAsync,The length of the statement  "			var asyncReadResult = await this.ReadSingleSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadDoubleAsync,The length of the statement  "				var slowAsyncResult = await this.ReadDoubleSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadDoubleSlowAsync,The length of the statement  "					var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableDoubleAsync,The length of the statement  "				var slowAsyncResult = await this.ReadNullableDoubleSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 130.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableDoubleSlowAsync,The length of the statement  "			var asyncReadResult = await this.ReadDoubleSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinaryAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinaryAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinaryAsync,The length of the statement  "			var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );" is 134.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringAsync,The length of the statement  "			var asyncReadResult = await this.ReadStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );" is 134.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectCore,The length of the statement  "				if ( ( header & ReadValueResult.RawTypeMask ) == ReadValueResult.RawTypeMask && ( header & ReadValueResult.LengthOfLengthMask ) == 0 )" is 134.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectAsync,The length of the statement  "			var asyncReadResult = await this.ReadObjectCoreAsync( isDeep' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectCoreAsync,The length of the statement  "				if ( ( header & ReadValueResult.RawTypeMask ) == ReadValueResult.RawTypeMask && ( header & ReadValueResult.LengthOfLengthMask ) == 0 )" is 134.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectCoreAsync,The length of the statement  "					var asyncReadReasult = await this.ReadObjectSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 123.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectCoreAsync,The length of the statement  "				var asyncReadReasult = await this.ReadItemsAsync( result.AsInt32()' collectionType == CollectionType.Map' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 166.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );" is 137.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );" is 137.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );" is 137.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );" is 134.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );" is 134.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );" is 134.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 165.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 165.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 165.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 165.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadItemsAsync,The length of the statement  "					var itemAsyncReadResult = await this.ReadObjectCoreAsync( true' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 124.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadItemsAsync,The length of the statement  "					var keyAsyncReadResult = await this.ReadObjectCoreAsync( true' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 123.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadItemsAsync,The length of the statement  "					var valueAsyncReadResult = await this.ReadObjectCoreAsync( true' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 125.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLengthAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLengthAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLengthAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLengthAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObjectAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObjectAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObjectAsync,The length of the statement  "			var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 165.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );" is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The length of the statement  "			var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );" is 165.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large array (0x{0:X} elements) which has more than Int32.MaxValue elements' at position {1:#'0}"" is 133.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large array (0x{0:X} elements) which has more than Int32.MaxValue elements' at offset {1:#'0}";" is 132.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large map (0x{0:X} entries) which has more than Int32.MaxValue entries' at position {1:#'0}"" is 129.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large map (0x{0:X} entries) which has more than Int32.MaxValue entries' at offset {1:#'0}";" is 128.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large ext type (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at position {1:#'0}"" is 130.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large ext type (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at offset {1:#'0}";" is 129.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large binary or string (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at position {1:#'0}"" is 138.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large binary or string (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at offset {1:#'0}";" is 137.
Long Statement,MsgPack,MessagePackString,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,GetString,The length of the statement  "				throw new InvalidOperationException( "This bytes is not UTF-8 string."' this._decodingError == IsBinary ? default( Exception ) : this._decodingError );" is 151.
Long Statement,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackAsyncCore,The length of the statement  "			await this.WriteByteAsync( value ? ( byte )MessagePackCode.TrueValue : ( byte )MessagePackCode.FalseValue' cancellationToken ).ConfigureAwait( false );" is 151.
Long Statement,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,ThrowCannotBeNegativeException,The length of the statement  "			throw new ArgumentOutOfRangeException( parameterName' String.Format( CultureInfo.CurrentCulture' "'{0}' is negative."' parameterName ) );" is 137.
Long Statement,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,Create,The length of the statement  "			return new MessagePackStreamPacker( stream' ownsStream ? PackerUnpackerStreamOptions.SingletonOwnsStream : PackerUnpackerStreamOptions.None' compatibilityOptions );" is 164.
Long Statement,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,Create,The length of the statement  "			return new MessagePackByteArrayPacker( buffer' 0' allowsBufferExpansion ? SingleArrayBufferAllocator.Default : FixedArrayBufferAllocator.Instance' compatibilityOptions );" is 170.
Long Statement,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,Create,The length of the statement  "			return new MessagePackByteArrayPacker( buffer' startOffset' allowsBufferExpansion ? SingleArrayBufferAllocator.Default : FixedArrayBufferAllocator.Instance' compatibilityOptions );" is 180.
Long Statement,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,Create,The length of the statement  "			return new MessagePackByteArrayPacker( buffer' startOffset' new SingleArrayBufferAllocator( allocator )' compatibilityOptions );" is 128.
Long Statement,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The length of the statement  "			// Float32Bits usage is effectively pointer dereference operation rather than shifting operators' so we must consider endianness here." is 134.
Long Statement,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackAsyncCore,The length of the statement  "			// Float32Bits usage is effectively pointer dereference operation rather than shifting operators' so we must consider endianness here." is 134.
Long Statement,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackArrayHeaderAsyncCore,The length of the statement  "				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedArray | count ) )' cancellationToken ).ConfigureAwait( false );" is 139.
Long Statement,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackMapHeaderAsyncCore,The length of the statement  "				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedMap | count ) )' cancellationToken ).ConfigureAwait( false );" is 137.
Long Statement,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackStringHeaderAsyncCore,The length of the statement  "				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedRaw | length ) )' cancellationToken ).ConfigureAwait( false );" is 138.
Long Statement,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PrivatePackRawBodyAsyncCore,The length of the statement  "				return await this.PrivatePackRawBodyAsyncCore( asCollection' asCollection.IsReadOnly' cancellationToken ).ConfigureAwait( false );" is 130.
Long Statement,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackArrayHeaderAsync,The length of the statement  "			return array == null ? this.PackNullAsync( cancellationToken ) : this.PackArrayHeaderAsync( array.Count' cancellationToken );" is 125.
Long Statement,MsgPack,PackerUnpackerExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\PackerUnpackerExtensions.cs,PackAsyncCore,The length of the statement  "				await Task.Run( () => asPackable.PackToMessage( source' new PackingOptions() )' cancellationToken ).ConfigureAwait( false );" is 124.
Long Statement,MsgPack,PackerUnpackerExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\PackerUnpackerExtensions.cs,PackCollectionAsyncCore,The length of the statement  "				await Task.Run( () => asPackable.PackToMessage( source' new PackingOptions() )' cancellationToken ).ConfigureAwait( false );" is 124.
Long Statement,MsgPack,PackerUnpackerExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\PackerUnpackerExtensions.cs,PackDictionaryAsyncCore,The length of the statement  "			return PackDictionaryAsyncCore( source' dictionary' context.GetSerializer<TKey>()' context.GetSerializer<TValue>()' cancellationToken );" is 136.
Long Statement,MsgPack,PackerUnpackerExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\PackerUnpackerExtensions.cs,PackDictionaryAsyncCore,The length of the statement  "				await Task.Run( () => asPackable.PackToMessage( source' new PackingOptions() )' cancellationToken ).ConfigureAwait( false );" is 124.
Long Statement,MsgPack,ReadValueResults,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The length of the statement  "								Contract.Assert( ( int )( source & ReadValueResult.ValueOrLengthMask ) == 16' ( int )( source & ReadValueResult.ValueOrLengthMask ) + " == 16" );" is 145.
Long Statement,MsgPack,ReadValueResults,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The length of the statement  "					Contract.Assert( ( source & ReadValueResult.TypeCodeMask ) == ReadValueResult.Real64Type' ( source & ReadValueResult.TypeCodeMask ) + " == ReadValueResult.Real64Type" );" is 169.
Long Statement,MsgPack,ReflectionAbstractions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\ReflectionAbstractions.cs,GetRuntimeConstructor,The length of the statement  "			return source.GetTypeInfo().DeclaredConstructors.SingleOrDefault( c => c.GetParameters().Select( p => p.ParameterType ).SequenceEqual( parameters ) );" is 150.
Long Statement,MsgPack,ReflectionAbstractions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\ReflectionAbstractions.cs,GetRuntimeConstructor,The length of the statement  "			return source.GetConstructor( BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance' null' parameters' null );" is 125.
Long Statement,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadAsyncCore,The length of the statement  "			if ( this._itemsCount.Count == 0 || !( await this._root.ReadInternalAsync( cancellationToken ).ConfigureAwait( false ) ) )" is 122.
Long Statement,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ToTicks,The length of the statement  "				throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "This value is too small for '{0}'."' destination ) );" is 134.
Long Statement,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ToTicks,The length of the statement  "				throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "This value is too large for '{0}'."' destination ) );" is 134.
Long Statement,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,FromDateTime,The length of the statement  "			FromDateTimeTicks( ( value.Kind == DateTimeKind.Local ? value.ToUniversalTime() : value ).Ticks' out unixEpocSeconds' out nanoSeconds );" is 136.
Long Statement,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Decode,The length of the statement  "					return new Timestamp( BigEndianBinary.ToInt64( value.Body' sizeof( int ) )' unchecked( ( int )BigEndianBinary.ToUInt32( value.Body' 0 ) ) );" is 140.
Long Statement,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,FromComponents,The length of the statement  "				var days = YearsToDaysOfNewYear( value.Year ) + ToDaysOffsetFromNewYear( value.Month' value.Day' isLeapYear ) - Timestamp.UnixEpochInSeconds / Timestamp.SecondsPerDay;" is 167.
Long Statement,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ParseExact,The length of the statement  "			HandleParseResult( TryParseExactCore( input' format' formatProvider' styles' out result )' "Cannot parse specified input with specified format." );" is 147.
Long Statement,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ParseExact,The length of the statement  "			HandleParseResult( TryParseExactCore( input' formats' formatProvider' styles' out result )' "Cannot parse specified input with any specified formats." );" is 153.
Long Statement,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,HandleParseResult,The length of the statement  "					Contract.Assert( kind == TimestampParseResult.KindNoMatchedFormats' kind + " == TimestampParseResult.KindNoMatchedFormats" );" is 125.
Long Statement,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The length of the statement  "			Contract.Assert( this.unixEpochSeconds >= -UnixEpochInSeconds' this.unixEpochSeconds + " > " + ( -UnixEpochInSeconds ) );" is 121.
Long Statement,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The length of the statement  "			// https://github.com/dotnet/coreclr/blob/0825741447c14a6a70c60b7c429e16f95214e74e/src/mscorlib/shared/System/DateTime.cs#L863" is 126.
Long Statement,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The length of the statement  "			year = unchecked( ( long )( numberOf400Years * 400 + numberOf100Years * 100 + numberOf4years * 4 + numberOf1Year + 1 ) );" is 121.
Long Statement,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The length of the statement  "			Contract.Assert( this.unixEpochSeconds < -UnixEpochInSeconds' this.unixEpochSeconds + " > " + ( -UnixEpochInSeconds ) );" is 120.
Long Statement,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The length of the statement  "			// https://github.com/dotnet/coreclr/blob/0825741447c14a6a70c60b7c429e16f95214e74e/src/mscorlib/shared/System/DateTime.cs#L863" is 126.
Long Statement,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,TryParseExactCore,The length of the statement  "				if ( TimestampStringConverter.TryParseExact( input' format' formatProvider' styles' out result ) == TimestampParseResult.Success )" is 130.
Long Statement,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ValidateParseStyles,The length of the statement  "			if ( styles != DateTimeStyles.None && ( styles & ~( DateTimeStyles.AllowLeadingWhite | DateTimeStyles.AllowTrailingWhite ) ) != 0 )" is 131.
Long Statement,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ValidateParseStyles,The length of the statement  "				throw new ArgumentException( "Timestamp currently only support DateTimeStyles.None' DateTimeStyles.AllowLeadingWhite' and DateTimeStyles.AllowTrailingWhite."' "styles" );" is 170.
Long Statement,MsgPack,TimestampStringConverter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The length of the statement  "			if ( !ParseWhitespace( input' ref position' ( styles & DateTimeStyles.AllowLeadingWhite ) != 0' /* isTrailing */false ) )" is 121.
Long Statement,MsgPack,TimestampStringConverter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The length of the statement  "			if ( !ParseWhitespace( input' ref position' ( styles & DateTimeStyles.AllowTrailingWhite ) != 0' /* isTrailing */true ) )" is 121.
Long Statement,MsgPack,Unpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Unpacker.cs,ThrowInvalidModeException,The length of the statement  "			throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "Reader is in '{0}' mode."' this._mode ) );" is 123.
Long Statement,MsgPack,Unpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Unpacker.cs,ReadNullableMessagePackExtendedTypeObject,The length of the statement  "			result = this.LastReadData.IsNil ? default( MessagePackExtendedTypeObject? ) : this.LastReadData.AsMessagePackExtendedTypeObject();" is 131.
Long Statement,MsgPack,Unpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Unpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The length of the statement  "			return AsyncReadResult.Success( this.LastReadData.IsNil ? default( MessagePackExtendedTypeObject? ) : this.LastReadData.AsMessagePackExtendedTypeObject() );" is 156.
Long Statement,MsgPack,Unpacking,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Unpacking.cs,NewTypeMismatchException,The length of the statement  "			return new MessageTypeException( String.Format( CultureInfo.CurrentCulture' "Message type is not compatible to {0}."' requestedType )' innerException );" is 152.
Long Statement,MsgPack,Unpacking,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Unpacking.cs,NewInvalidEncodingException,The length of the statement  "			return new MessageTypeException( String.Format( CultureInfo.CurrentCulture' "The stream cannot be decoded as {0} string."' encoding.WebName )' innerException );" is 160.
Long Statement,MsgPack,Validation,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Validation.cs,ValidateNamespace,The length of the statement  "			if ( matches.Count == 1 && matches[ 0 ].Success && matches[ 0 ].Index == 0 && matches[ 0 ].Length == @namespace.Length )" is 120.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilderHelper,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilderHelper.cs,GetResolvedDelegateType,The length of the statement  "					: typeDefinition.MakeGenericType( parameterTypes.Select( t => t.ResolveRuntimeType() ).Concat( new[] { returnType.ResolveRuntimeType() } ).ToArray() );" is 151.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildCollectionSerializer,The length of the statement  "			this.DetermineSerializationStrategy( context' concreteType' out targetInfo' out isUnpackFromRequired' out isAddItemRequired );" is 126.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildCollectionSerializer,The length of the statement  "				this.BuildIUnpackableUnpackFrom( context' this.GetUnpackableCollectionInstantiation( context )' targetInfo.CanDeserialize );" is 124.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildCollectionSerializer,The length of the statement  "					this.BuildIAsyncUnpackableUnpackFrom( context' this.GetUnpackableCollectionInstantiation( context )' targetInfo.CanDeserialize );" is 129.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildCollectionSerializer,The length of the statement  "						: ( concreteType ?? this.TargetType ).GetCollectionTraits( CollectionTraitOptions.Full' context.SerializationContext.CompatibilityOptions.AllowNonCollectionEnumerableTypes ) // For concrete collection." is 201.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitCollectionUnpackFromStatements,The length of the statement  "				var traitsOfTheCollection = instanceType.GetCollectionTraits( CollectionTraitOptions.Full' context.SerializationContext.CompatibilityOptions.AllowNonCollectionEnumerableTypes);" is 176.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitCollectionUnpackFromStatements,The length of the statement  "						isAsync ? TypeDefinition.GenericReferenceType( typeof( Func<''''> )' TypeDefinition.UnpackerType' this.TargetType' TypeDefinition.Int32Type' TypeDefinition.CancellationTokenType' TypeDefinition.TaskType ) :" is 206.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitCollectionUnpackFromStatements,The length of the statement  "						TypeDefinition.GenericReferenceType( typeof( Action<''> )' TypeDefinition.UnpackerType' this.TargetType' TypeDefinition.Int32Type )" is 131.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitCollectionUnpackFromStatements,The length of the statement  "						isAsync ? TypeDefinition.GenericReferenceType( typeof( Func<'''''> )' TypeDefinition.UnpackerType' this.TargetType' TypeDefinition.Int32Type' TypeDefinition.Int32Type' TypeDefinition.CancellationTokenType' TypeDefinition.TaskType ) :" is 233.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitCollectionUnpackFromStatements,The length of the statement  "						TypeDefinition.GenericReferenceType( typeof( Action<'''> )' TypeDefinition.UnpackerType' this.TargetType' TypeDefinition.Int32Type' TypeDefinition.Int32Type )" is 158.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitCollectionUnpackFromStatements,The length of the statement  "			foreach ( var construct in this.CreatePackUnpackHelperArgumentInitialization( context' unpackHelperParameters' unpackHelperArguments ) )" is 136.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitUnpackToInitialization,The length of the statement  "						this.BaseClass.GetRuntimeMethods().Single( m => m.Name == MethodName.UnpackToCore && m.GetParameterTypes().SequenceEqual( parameterTypes ) )" is 140.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitUnpackToInitialization,The length of the statement  "							this.BaseClass.GetRuntimeMethods().Single( m => m.Name == MethodName.UnpackToAsyncCore && m.GetParameterTypes().SequenceEqual( asyncParameterTypes ) )" is 150.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,ExtractPrivateMethod,The length of the statement  "			return this.EmitGetPrivateMethodDelegateExpression( context' DefinePrivateMethod( context' name' isStatic' returnType' bodyFactory' parameters ) );" is 147.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitGetPrivateMethodDelegateExpression,The length of the statement  "					context.GetCachedPrivateMethodDelegate( method' SerializerBuilderHelper.GetDelegateTypeDefinition( method.ReturnType' method.ParameterTypes ) )" is 143.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitSetMemberValueStatement,The length of the statement  "				traits = asField.FieldType.GetCollectionTraits( CollectionTraitOptions.Full' context.SerializationContext.CompatibilityOptions.AllowNonCollectionEnumerableTypes );" is 163.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitSetMemberValueStatement,The length of the statement  "				traits = asProperty.PropertyType.GetCollectionTraits( CollectionTraitOptions.Full' context.SerializationContext.CompatibilityOptions.AllowNonCollectionEnumerableTypes );" is 169.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitStoreCollectionItemsEmitSetCollectionMemberIfNullAndSettable,The length of the statement  "			if ( storeCollectionItems != null && ( asField != null && asField.IsInitOnly ) || ( asProperty != null && asProperty.GetSetMethod( true ) == null ) )" is 149.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitSetFieldOnValueType,The length of the statement  "					this.EmitStoreVariableStatement( context' instance' this.EmitUnboxAnyExpression( context' instance.ContextType' boxed ) )" is 121.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitUnpackItemValueStatement,The length of the statement  "				? TypeDefinition.GenericValueType( unpackHelperParameterTypeDefinition' unpackingContext.ContextType' Nullable.GetUnderlyingType( memberType ) )" is 144.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitUnpackItemValueStatement,The length of the statement  "					unpackHelperArguments.Add( "NilImplication"' this.MakeEnumLiteral( context' TypeDefinition.NilImplicationType' nilImplication ) );" is 130.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitUnpackItemValueStatement,The length of the statement  "						? typeof( Func<''''> ).MakeGenericType( typeof( Unpacker )' typeof( Type )' typeof( String )' typeof( CancellationToken )' typeof( Task<> ).MakeGenericType( memberType ) ) :" is 173.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitUnpackItemValueStatement,The length of the statement  "								? this.EmitRetrunStatement( context' this.EmitInvokeMethodExpression( context' null' helperMethod' this.EmitMakeRef( context' unpackHelperParameters ) ) )" is 154.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,CreatePackUnpackHelperArgumentInitialization,The length of the statement  "				Contract.Assert( parameterType.ElementType.TryGetRuntimeType() != null' parameterType + ".ElementType.ElementType(" + parameterType.ElementType.ElementType + " does not have runtime type" );" is 190.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,CreatePackUnpackHelperArgumentInitialization,The length of the statement  "				Contract.Assert( parameterType.ElementType.TryGetRuntimeType().GetIsGenericTypeDefinition()' parameterType + ".ElementType.ElementType(" + parameterType.ElementType.ElementType + " is not generic type definition" );" is 215.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,CreatePackUnpackHelperArgumentInitialization,The length of the statement  "				yield return this.EmitSetField( context' helperArguments' new FieldDefinition( parameterType' field.Name' field.FieldType )' argument.Value );" is 142.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,DetermineCollectionConstructorArguments,The length of the statement  "					return new[] { this.GetConstructorArgument( context' parameters[ 0 ] )' this.GetConstructorArgument( context' parameters[ 1 ] ) };" is 130.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitConstructPolymorphismSchema,The length of the statement  "						foreach ( var statement in this.EmitConstructLeafPolymorphismSchema( context' itemSchema' schema.ChildSchemaList[ i ]' variableName ) )" is 135.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitConstructPolymorphismSchema,The length of the statement  "						yield return this.EmitSetArrayElementStatement( context' tupleItemsSchema' this.MakeInt32Literal( context' i )' itemSchema );" is 125.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitConstructLeafPolymorphismSchema,The length of the statement  "				foreach ( var instruction in this.EmitConstructTypeCodeMappingForPolymorphismSchema( context' currentSchema' typeMap ) )" is 120.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildPackUnderlyingValueTo,The length of the statement  "							this.EmitEnumToUnderlyingCastExpression( context' underlyingType' this.ReferArgument( context' this.TargetType' "enumValue"' 2 ) )'" is 131.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildPackUnderlyingValueTo,The length of the statement  "						this.EmitEnumToUnderlyingCastExpression( context' underlyingType' this.ReferArgument( context' this.TargetType' "enumValue"' 2 ) )" is 130.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildNullableUnpackFrom,The length of the statement  "						.Single( m => m.IsPublic && m.Name == "UnpackFromAsync" && m.ReturnType == asyncMethodReturnType && m.GetParameterTypes().SequenceEqual( SerializerBuilderHelper.UnpackFromAsyncParameterTypes ) ) :" is 196.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildObjectSerializer,The length of the statement  "				this.BuildIUnpackableUnpackFrom( context' this.GetUnpackableObjectInstantiation( context )' targetInfo.CanDeserialize );" is 120.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildObjectSerializer,The length of the statement  "					this.BuildIAsyncUnpackableUnpackFrom( context' this.GetUnpackableObjectInstantiation( context )' targetInfo.CanDeserialize );" is 125.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildObjectPackToCore,The length of the statement  "								? this.EmitRetrunStatement( context' this.EmitInvokeMethodExpression( context' context.Packer' methodForNull' argumentsForNull ) )" is 130.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildObjectPackToCore,The length of the statement  "						this.EmitGetPropertyExpression( context' this.EmitThisReferenceExpression( context )' Metadata._MessagePackSerializer.OwnerContext )" is 132.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildObjectPackToCore,The length of the statement  "				foreach ( var construct in this.CreatePackUnpackHelperArgumentInitialization( context' packHelperParameters' packHelperArguments ) )" is 132.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,GetPackOperationType,The length of the statement  "					? typeof( Func<'''> ).MakeGenericType( typeof( Packer )' this.TargetType' typeof( CancellationToken )' typeof( Task ) ) :" is 121.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitPackActionCollectionCore,The length of the statement  "				targetInfo.Members.Where( m => m.Member != null ).All( m => context.IsDeclaredMethod( GetPackValueMethodName( m' isAsync ) ) )'" is 127.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitPackActionCollectionCore,The length of the statement  "							this.MakeStringLiteral( context' context.SerializationContext.DictionarySerializationOptions.SafeKeyTransformer( knownActions[ i ].Key ) )'" is 139.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitPackNullCheckerTableInitialization,The length of the statement  "			var listType = typeof( Dictionary<'> ).MakeGenericType( typeof( string )' typeof( Func<'> ).MakeGenericType( this.TargetType' typeof( bool ) ) );" is 145.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitPackNullCheckerTableInitializationCore,The length of the statement  "						this.MakeStringLiteral( context' context.SerializationContext.DictionarySerializationOptions.SafeKeyTransformer( knownActions[ i ].Key ) )'" is 139.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildIUnpackableUnpackFromCore,The length of the statement  "				yield return this.EmitInvokeVoidMethod( context' result' new MethodDefinition( unpackFrom' @interface )' context.Unpacker );" is 124.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitObjectUnpackFromCore,The length of the statement  "					|| ( targetInfo.IsConstructorDeserialization && !unpackingContext.MappableConstructorArguments.Contains( targetInfo.Members[ i ].Contract.Name ) ) )" is 148.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitObjectUnpackFromCore,The length of the statement  "								this.EmitSetMemberValueStatement( context' context.UnpackingContextInSetValueMethods' targetInfo.Members[ count ].Member' unpackedItem );" is 137.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitObjectUnpackingContextInitialization,The length of the statement  "					constructorParameters.Select( ( p' i ) => new KeyValuePair<string' TypeDefinition>( targetInfo.GetCorrespondingMemberName( i ) ?? ( "__OrphanParameter" + i.ToString( CultureInfo.InvariantCulture ) )' p.ParameterType ) ).ToArray();" is 230.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitObjectUnpackingContextInitialization,The length of the statement  "			var unpackingContext = UnpackingContextInfo.Create( unpackingContextType' unpackingContextConstructor' mappableConstructorArguments );" is 134.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitUnpackOperationTableInitialization,The length of the statement  "			var dictionaryType = TypeDefinition.GenericReferenceType( typeof( Dictionary<'> )' TypeDefinition.StringType' actionType );" is 123.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitUnpackActionCollectionInitializationCore,The length of the statement  "							this.MakeStringLiteral( context' context.SerializationContext.DictionarySerializationOptions.SafeKeyTransformer( knownActions[ i ].Key ) )'" is 139.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitInvokeDeserializationConstructorStatementsCore,The length of the statement  "								this.EmitGetFieldExpression( context' unpackingContext' new FieldDefinition( unpackingContext.ContextType' f.Key' f.Value ) )" is 125.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,GetKnownActions,The length of the statement  "			var filter = method == SerializationMethod.Array ? _ => true : new Func<SerializingMember' bool>( m => m.MemberName != null );" is 126.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTuplePackToCore,The length of the statement  "					? BuildTuplePackToCore( context' itemTypes' itemSchemaList' ( t' n ) => t.GetField( n )' ( c' s' m ) => this.EmitGetFieldExpression( c' s' m )' isAsync )" is 153.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTuplePackToCore,The length of the statement  "					: BuildTuplePackToCore( context' itemTypes' itemSchemaList' ( t' n ) => t.GetProperty( n )' ( c' s' m )=> this.EmitGetPropertyExpression( c' s' m )' isAsync );" is 159.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTuplePackToCore,The length of the statement  "			foreach ( var construct in this.CreatePackUnpackHelperArgumentInitialization( context' packHelperParameters' packHelperArguments ) )" is 132.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTupleUnpackFromCore,The length of the statement  "					Contract.Assert( tupleTypeList[ nest ].GetFullName() == "System.ValueTuple"' tupleTypeList[ nest ].GetFullName() + " == System.ValueTuple");" is 140.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerFieldKey,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerFieldKey.cs,GetHashCode,The length of the statement  "			return this.TypeHandle.GetHashCode() ^ this.EnumSerializationMethod.GetHashCode() ^ this.DateTimeConversionMethod.GetHashCode() ^ this._schema.GetHashCode();" is 157.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerGenerationContext<TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerGenerationContext.cs,GetCachedDelegateCore,The length of the statement  "				delegateInfo = new CachedDelegateInfo( isThis' method' this.DeclarePrivateField( key.Replace( '.'' '_' ) + "Delegate"' delegateType ) );" is 136.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerGenerationContext<TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerGenerationContext.cs,DefineUnpackingContext,The length of the statement  "			this.DefineUnpackingContextCore( fields' out type' out constructor' out parameterInUnpackValueMethods' out parameterInSetValueMethods' out parameterInCreateObjectFromContext );" is 176.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerGenerationContext<TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerGenerationContext.cs,DefineUnpackingContextWithResultObject,The length of the statement  "			this.DefineUnpackingContextWithResultObjectCore( out type' out parameterInUnpackValueMethods' out parameterInSetValueMethods' out parameterInCreateObjectFromContext );" is 167.
Long Statement,MsgPack.Serialization.AbstractSerializers,SerializerSpecification,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerSpecification.cs,GetHashCode,The length of the statement  "			return this.TargetType.GetHashCode() ^ this.SerializerTypeName.GetHashCode() ^ this.SerializerTypeNamespace.GetHashCode();" is 122.
Long Statement,MsgPack.Serialization.AbstractSerializers,TypeDefinition,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\TypeDefinition.cs,ResolveRuntimeType,The length of the statement  "			var resolvingType = this._runtimeType ?? this.ElementType.TryGetRuntimeType() ?? this.ElementType.ResolveRuntimeType( false );" is 126.
Long Statement,MsgPack.Serialization.AbstractSerializers,TypeDefinition,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\TypeDefinition.cs,Object,The length of the statement  "			return new TypeDefinition( type' type.FullName' type.IsArray ? Object( type.GetElementType() ) : null' Flags.HasRuntimeType );" is 126.
Long Statement,MsgPack.Serialization.AbstractSerializers,TypeDefinition,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\TypeDefinition.cs,Array,The length of the statement  "				? new TypeDefinition( elementType.ResolveRuntimeType().MakeArrayType()' elementType.ResolveRuntimeType().FullName + "[]"' elementType' Flags.HasRuntimeType )" is 157.
Long Statement,MsgPack.Serialization.AbstractSerializers,TypeDefinition,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\TypeDefinition.cs,ManagedReference,The length of the statement  "				? new TypeDefinition( elementType.ResolveRuntimeType().MakeByRefType()' elementType.ResolveRuntimeType().FullName' elementType' Flags.HasRuntimeType )" is 150.
Long Statement,MsgPack.Serialization,BindingOptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\BindingOptions.cs,GetAllIgnoringMembers,The length of the statement  "				return this._typeIgnoringMembersMap.ToDictionary( item => item.Key' item => ( IEnumerable<string> )item.Value.ToArray() );" is 122.
Long Statement,MsgPack.Serialization,DefaultConcreteTypeRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultConcreteTypeRepository.cs,GetConcreteType,The length of the statement  "			if ( typeOrDefinition == null || !typeOrDefinition.GetIsGenericTypeDefinition() || !abstractCollectionType.GetIsGenericType() )" is 127.
Long Statement,MsgPack.Serialization,DefaultConcreteTypeRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultConcreteTypeRepository.cs,Register,The length of the statement  "					String.Format( CultureInfo.CurrentCulture' "The defaultCollectionType cannot be abstract class nor interface. The type '{0}' is abstract type."' defaultCollectionType )'" is 169.
Long Statement,MsgPack.Serialization,DefaultConcreteTypeRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultConcreteTypeRepository.cs,Register,The length of the statement  "			this._defaultCollectionTypes.Register( abstractCollectionType' defaultCollectionType' null' null' SerializerRegistrationOptions.AllowOverride );" is 144.
Long Statement,MsgPack.Serialization,IndividualFileCodeGenerationSink,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\IndividualFileCodeGenerationSink.cs,AssignTextWriterCore,The length of the statement  "			codeInformation.SetFileWriter( Path.Combine( codeInformation.Directory' codeInformation.TypeFullName + codeInformation.FileExtension ) );" is 137.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,Create,The length of the statement  "			// Old Create behavior was effectively Get() because the Builder internally register genreated serializer and returned existent one if it had been already registered. " is 166.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateInternal,The length of the statement  "				typeof( T ).GetCollectionTraits( CollectionTraitOptions.None' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes );" is 127.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateInternal,The length of the statement  "				typeof( T ).GetCollectionTraits( CollectionTraitOptions.Full' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes );" is 127.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateInternal,The length of the statement  "						GenericSerializer.TryCreateAbstractCollectionSerializer( context' typeof( T )' concreteType' schema ) as MessagePackSerializer<T>" is 129.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateInternal,The length of the statement  "			return ( MessagePackSerializer<T> ) builder.BuildSerializerInstance( context' concreteType' schema == null ? null : schema.FilterSelf() );" is 138.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateReflectionInternal,The length of the statement  "				typeof( T ).GetCollectionTraits( CollectionTraitOptions.WithAddMethod' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes );" is 136.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateReflectionInternal,The length of the statement  "				typeof( T ).GetCollectionTraits( CollectionTraitOptions.WithAddMethod | CollectionTraitOptions.WithCountPropertyGetter' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes );" is 185.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateReflectionInternal,The length of the statement  "						ReflectionSerializerHelper.CreateCollectionSerializer<T>( context' concreteType' traits' ( schema ?? PolymorphismSchema.Default ) );" is 132.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateReflectionInternal,The length of the statement  "							ReflectionSerializerHelper.CreateCollectionSerializer<T>( context' concreteType' traits' ( schema ?? PolymorphismSchema.Default ) )" is 131.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,InferCapatibity,The length of the statement  "			var traits = typeof( T ).GetCollectionTraits( CollectionTraitOptions.WithAddMethod' allowNonCollectionEnumerableTypes: false );" is 127.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,PackAsync,The length of the statement  "			var packer = Packer.Create( stream' this.PackerCompatibilityOptions' PackerUnpackerStreamOptions.SingletonForAsyncPacking );" is 124.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,UnpackAsync,The length of the statement  "			var unpacker = Unpacker.Create( stream' PackerUnpackerStreamOptions.SingletonForAsyncUnpacking' DefaultUnpackerOptions );" is 121.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,PackSingleObjectAsBytes,The length of the statement  "			var packer = Packer.Create( BufferManager.NewByteBuffer( BufferSize )' /* allowExpansion */true' this.PackerCompatibilityOptions );" is 131.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,PackSingleObjectAsBytesAsync,The length of the statement  "			var packer = Packer.Create( BufferManager.NewByteBuffer( BufferSize )'  /* allowExpansion */true' this.PackerCompatibilityOptions );" is 132.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,InternalPackTo,The length of the statement  "					ThrowArgumentException( String.Format( CultureInfo.CurrentCulture' "'{0}' is not compatible for '{1}'."' objectTree.GetType()' typeof( T ) )' "objectTree" );" is 157.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,InternalUnpackTo,The length of the statement  "				ThrowArgumentException( String.Format( CultureInfo.CurrentCulture' "'{0}' is not compatible for '{1}'."' collection.GetType()' typeof( T ) )' "collection" );" is 157.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,InternalPackSingleObject,The length of the statement  "				ThrowArgumentException( String.Format( CultureInfo.CurrentCulture' "'{0}' is not compatible for '{1}'."' objectTree == null ? "(null)" : objectTree.GetType().FullName' typeof( T ) )' "objectTree" );" is 198.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,InternalPackToAsync,The length of the statement  "					ThrowArgumentException( String.Format( CultureInfo.CurrentCulture' "'{0}' is not compatible for '{1}'."' objectTree.GetType()' typeof( T ) )' "objectTree" );" is 157.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,InternalUnpackToAsync,The length of the statement  "				ThrowArgumentException( String.Format( CultureInfo.CurrentCulture' "'{0}' is not compatible for '{1}'."' collection.GetType()' typeof( T ) )' "collection" );" is 157.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,InternalPackSingleObjectAsync,The length of the statement  "				ThrowArgumentException( String.Format( CultureInfo.CurrentCulture' "'{0}' is not compatible for '{1}'."' objectTree == null ? "(null)" : objectTree.GetType().FullName' typeof( T ) )' "objectTree" );" is 198.
Long Statement,MsgPack.Serialization,PackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PackHelpers.cs,PackToMap,The length of the statement  "				&& parameter.SerializationContext != null && parameter.SerializationContext.DictionarySerializationOptions.OmitNullEntry )" is 122.
Long Statement,MsgPack.Serialization,PackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PackHelpers.cs,PackToMapAsync,The length of the statement  "			return PackToMapAsyncCore( parameter.SerializationContext' parameter.Packer' parameter.Target' parameter.Operations' parameter.NullCheckers' parameter.CancellationToken );" is 171.
Long Statement,MsgPack.Serialization,PolymorphicTypeVerificationContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphicTypeVerificationContext.cs,Equals,The length of the statement  "			return this._loadingTypeFullName == other._loadingTypeFullName && this._loadingAssemblyFullName == other._loadingAssemblyFullName;" is 130.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,ForPolymorphicObject,The length of the statement  "			return new PolymorphismSchema( targetType' PolymorphismType.RuntimeType' DefaultTypeVerfiier' PolymorphismSchemaChildrenType.None );" is 132.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,ForPolymorphicObject,The length of the statement  "			return new PolymorphismSchema( targetType' PolymorphismType.RuntimeType' typeVerifier' PolymorphismSchemaChildrenType.None );" is 125.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,VerifyArity,The length of the statement  "				throw new ArgumentException( "An arity of itemSchemaList does not match for an arity of the tuple."' "itemSchemaList" );" is 120.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,FilterSelf,The length of the statement  "			return new PolymorphismSchema( this.TargetType' PolymorphismType.None' this._codeTypeMapping' this.TypeVerifier' this.ChildrenType' this._children );" is 149.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,CreateCore,The length of the statement  "			var traits = member.GetMemberValueType().GetCollectionTraits( CollectionTraitOptions.None' allowNonCollectionEnumerableTypes: false );" is 134.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,CreateCore,The length of the statement  "						SerializerDebugging.TracePolimorphicSchemaEvent( "Returns default because '{0}' does not have own nor items schema: {1}"' member' defaultSchema );" is 146.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,CreateCore,The length of the statement  "						SerializerDebugging.TracePolimorphicSchemaEvent( "Returns default because '{0}' does not have own' keys' nor items schema: {1}"' member' defaultSchema );" is 153.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,CreateCore,The length of the statement  "							SerializerDebugging.TracePolimorphicSchemaEvent( "Returns default because '{0}' does not have any tuple items schema: {1}"' member' defaultSchema );" is 148.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,CreateCore,The length of the statement  "							SerializerDebugging.TracePolimorphicSchemaEvent( "Returns default because '{0}' does not have own schema: {1}"' member' defaultSchema );" is 136.
Long Statement,MsgPack.Serialization,TypeTableEntry,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,Interpret,The length of the statement  "					Contract.Assert( attribute.Target == PolymorphismTarget.TupleItem' attribute.Target + " == PolymorphismTarget.TupleItem" );" is 123.
Long Statement,MsgPack.Serialization,TypeTableEntry,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,Interpret,The length of the statement  "				this.SetRuntimeType( attribute.Target' memberName' tupleItemNumber' GetVerifier( attribute as IPolymorphicRuntimeTypeAttribute ) );" is 131.
Long Statement,MsgPack.Serialization,TypeTableEntry,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,GetVerifier,The length of the statement  "				var method = attribute.VerifierType.GetRuntimeMethods().SingleOrDefault( m => IsVerificationMethod( m' attribute.VerifierMethodName ) );" is 136.
Long Statement,MsgPack.Serialization,TypeTableEntry,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,GetVerifier,The length of the statement  "					throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "A public static or instance method named '{0}' with single parameter typed PolymorphicTypeVerificationContext in type '{1}'."' attribute.VerifierMethodName' attribute.VerifierMethodName ) );" is 268.
Long Statement,MsgPack.Serialization,TypeTableEntry,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,GetVerifier,The length of the statement  "					return method.CreateDelegate( typeof( Func<PolymorphicTypeVerificationContext' bool> ) ) as Func<PolymorphicTypeVerificationContext' bool>;" is 139.
Long Statement,MsgPack.Serialization,TypeTableEntry,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,GetVerifier,The length of the statement  "					return method.CreateDelegate( typeof( Func<PolymorphicTypeVerificationContext' bool> )' Activator.CreateInstance( attribute.VerifierType ) ) as Func<PolymorphicTypeVerificationContext' bool>;" is 191.
Long Statement,MsgPack.Serialization,TypeTableEntry,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,IsVerificationMethod,The length of the statement  "				return parameters.Length == 1 && parameters[ 0 ].ParameterType.IsAssignableFrom( typeof( PolymorphicTypeVerificationContext ) );" is 128.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,The length of the statement  "			 * If the object has single public method TEnumerator GetEnumerator() ( where TEnumerator implements IEnumerator<TItem>)'" is 120.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,The length of the statement  "			 * Else' if the object has single public method IEnumerator GetEnumerator()' then the object is considered as the collection of Object." is 134.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,The length of the statement  "			 * First' if the object implements IDictionary<MessagePackObject'MessagePackObject>' then it is considered as MPO dictionary." is 124.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,The length of the statement  "			 * Third' if the object implement SINGLE IDictionary<TKey'TValue> and multiple IEnumerable<T>' then it is considered as dictionary of TKey and TValue." is 149.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,The length of the statement  "			 * Fourth' the object is considered as UNSERIALIZABLE member. This behavior similer to DataContract serialization behavor" is 120.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,TryCreateGenericCollectionTraits,The length of the statement  "						( source == typeof( IDictionary<MessagePackObject' MessagePackObject> ) || source.Implements( typeof( IDictionary<MessagePackObject' MessagePackObject> ) ) )" is 157.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,TryCreateGenericCollectionTraits,The length of the statement  "						GetGetEnumeratorMethodFromEnumerableType( source' typeof( IEnumerable<KeyValuePair<MessagePackObject' MessagePackObject>> )' options )'" is 135.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,TryCreateGenericCollectionTraits,The length of the statement  "									: ( source == typeof( IReadOnlyList<MessagePackObject> ) || source.Implements( typeof( IReadOnlyList<MessagePackObject> ) ) )" is 125.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,TryCreateGenericCollectionTraits,The length of the statement  "												: ( source == typeof( IReadOnlyCollection<MessagePackObject> ) || source.Implements( typeof( IReadOnlyCollection<MessagePackObject> ) ) )" is 137.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetGetEnumeratorMethodFromElementType,The length of the statement  "			return FindInterfaceMethod( targetType' typeof( IEnumerable<> ).MakeGenericType( elementType )' "GetEnumerator"' ReflectionAbstractions.EmptyTypes );" is 149.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,FindInterfaceMethod,The length of the statement  "				return targetType.FindInterfaces( ( type' _ ) => type == interfaceType' null ).Single().GetMethod( name' parameterTypes );" is 122.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,FindInterfaceMethod,The length of the statement  "			int index = Array.FindIndex( map.InterfaceMethods' method => method.Name == name && method.GetParameters().Select( p => p.ParameterType ).SequenceEqual( parameterTypes ) );" is 172.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,FindInterfaceMethod,The length of the statement  "			int index = map.InterfaceMethods.FindIndex( method => method.Name == name && method.GetParameters().Select( p => p.ParameterType ).SequenceEqual( parameterTypes ) );" is 165.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,FindInterfaceMethod,The length of the statement  "				Contract.Assert( false' interfaceType + "::" + name + "(" + String.Join<Type>( "' "' parameterTypes ) + ") is not found in " + targetType );" is 140.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,FindInterfaceMethod,The length of the statement  "				Contract.Assert( false' interfaceType + "::" + name + "(" + String.Join( "' "' parameterTypes.Select( t => t.ToString() ).ToArray() ) + ") is not found in " + targetType );" is 172.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,FilterCollectionType,The length of the statement  "			return type.GetAssembly().Equals( typeof( Array ).GetAssembly() ) && ( type.Namespace == "System.Collections" || type.Namespace == "System.Collections.Generic" );" is 162.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,FilterCollectionType,The length of the statement  "			return typeInfo.Assembly.Equals( typeof( Array ).GetTypeInfo().Assembly ) && ( type.Namespace == "System.Collections" || type.Namespace == "System.Collections.Generic" );" is 170.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,CreateConstructorDelegate,The length of the statement  "			return ( TDelegate )CreateDelegate( typeof( TDelegate )' constructor.DeclaringType' constructor' constructor.GetParameterTypes() );" is 131.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetMemberValueType,The length of the statement  "			Contract.Assert( typeof( MemberInfo ).IsAssignableFrom( typeof( Type ) )' "Type is assginable to MemberInfo on this platform' so should not step in this line." );" is 162.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetMemberValueType,The length of the statement  "			Contract.Assert( typeof( Type ).IsAssignableFrom( typeof( TypeInfo ) )' "TypeInfo is assginable to Type on this platform' so should not step in this line." );" is 158.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetMemberValueType,The length of the statement  "				throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "'{0}'({1}) is not field nor property."' source' source.GetType() ) );" is 150.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,HoistUpInnerException,The length of the statement  "			var ctor = targetInvocationException.InnerException.GetType().GetConstructor( ExceptionConstructorWithInnerParameterTypes );" is 124.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,HoistUpInnerException,The length of the statement  "				return ctor.Invoke( new object[] { targetInvocationException.InnerException.Message' targetInvocationException } ) as Exception;" is 128.
Long Statement,MsgPack.Serialization,ReflectionHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionHelpers.cs,GetMethod,The length of the statement  "						.Where( m => !m.IsGenericMethod && !m.IsStatic && m.GetParameters().Select( p => p.ParameterType ).SequenceEqual( parameterTypes ) )" is 132.
Long Statement,MsgPack.Serialization,SerializationContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationContext.cs,GetSerializer,The length of the statement  "						Contract.Assert( typeof( T ).GetIsEnum()' typeof( T ) + " is not enum but generated serializer is ICustomizableEnumSerializer" );" is 129.
Long Statement,MsgPack.Serialization,SerializationContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationContext.cs,GetSerializer,The length of the statement  "						Contract.Assert( !typeof( T ).GetIsEnum()' typeof( T ) + " is enum but generated serializer is not ICustomizableEnumSerializer : " + ( serializer == null ? "null" : serializer.GetType().FullName ) );" is 199.
Long Statement,MsgPack.Serialization,SerializationContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationContext.cs,GetSerializer,The length of the statement  "					// If T is null and schema is not provided or default schema is provided' then exception will be thrown here from the new provider." is 131.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewValueTypeCannotBeNull,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Member '{0}' of type '{1}' cannot be null because it is value type('{2}')."' name' declaringType' memberType ) );" is 192.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewValueTypeCannotBeNull,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Cannot be null '{0}' type value."' type ) );" is 123.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewTypeCannotDeserialize,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Cannot deserialize '{0}' type."' type ) );" is 121.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewTypeCannotDeserialize,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Cannot deserialize member '{1}' of type '{0}'."' type' memberName )' inner );" is 156.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewMissingItem,The length of the statement  "			return new InvalidMessagePackStreamException( String.Format( CultureInfo.CurrentCulture' "Items at index '{0}' is missing."' index ) );" is 135.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewTargetDoesNotHavePublicDefaultConstructor,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Type '{0}' does not have default (parameterless) public constructor."' type ) );" is 159.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewTargetDoesNotHavePublicDefaultConstructorNorInitialCapacity,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Type '{0}' does not have both of default (parameterless) public constructor and  public constructor with an Int32 parameter."' type ) );" is 215.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewMissingAddMethod,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Type '{0}' does not have appropriate Add method."' type ) );" is 139.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewNotSupportedBecauseCannotInstanciateAbstractType,The length of the statement  "			return new NotSupportedException( String.Format( CultureInfo.CurrentCulture' "This operation is not supported because '{0}' cannot be instanciated."' type ) );" is 159.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewTupleCardinarityIsNotMatch,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "The length of array ({0}) does not match to tuple cardinality ({1})."' actualArrayLength' expectedTupleCardinality ) );" is 198.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewNullIsProhibited,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "The member '{0}' cannot be nil."' memberName ) );" is 128.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewReadOnlyMemberItemsMustNotBeNull,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "The member '{0}' cannot be nil because it is read only member."' memberName ) );" is 159.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewStreamDoesNotContainCollectionForMember,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Cannot deserialize member '{0}' because the underlying stream does not contain collection."' memberName ) );" is 187.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewUnexpectedArrayLength,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "The MessagePack stream is invalid. Expected array length is {0}' but actual is {1}."' expectedLength' actualLength ) );" is 198.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewFailedToDeserializeMember,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Cannot deserialize member '{0}' of type '{1}'."' memberName' targetType )' inner );" is 162.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewUnpackFromIsNotSupported,The length of the statement  "			return new NotSupportedException( String.Format( CultureInfo.CurrentCulture' "This operation is not supported for '{0}' because the serializer does not support UnpackFrom method."' targetType ) );" is 196.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewCreateInstanceIsNotSupported,The length of the statement  "			return new NotSupportedException( String.Format( CultureInfo.CurrentCulture' "This operation is not supported for '{0}' because the serializer does not support CreateInstance method."' targetType ) );" is 200.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewUnpackToIsNotSupported,The length of the statement  "			return new NotSupportedException( String.Format( CultureInfo.CurrentCulture' "This operation is not supported for '{0}' because it does not have accesible Add(T) method."' type )' inner );" is 188.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewUnknownTypeEmbedding,The length of the statement  "			return new SerializationException( "Cannot deserialize with type-embedding based serializer. Root object must be 3 element array." );" is 133.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewIncompatibleCollectionSerializer,The length of the statement  "						"Cannot serialize type '{0}' because registered or generated serializer '{1}' does not implement '{2}'' which is implemented by '{3}'' for example."'" is 149.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,ThrowArgumentNullException,The length of the statement  "			throw new ArgumentNullException( parameterName' String.Format( CultureInfo.CurrentCulture' "Field '{0}' of parameter '{1}' cannot be null."' fieldName' parameterName ) );" is 170.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,ThrowArgumentCannotBeNegativeException,The length of the statement  "			throw new ArgumentOutOfRangeException( parameterName' String.Format( CultureInfo.CurrentCulture' "Field '{0}' of parameter '{1}' cannot be negative number."' fieldName' parameterName ) );" is 187.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,ThrowInvalidArrayItemsCount,The length of the statement  "							"Cannot deserialize type '{0}' because stream is not {1} elements array. Current type is {2} and its element count is {3}."'" is 124.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,GetCapabilitiesForObject,The length of the statement  "			return this.CanDeserialize ? ( SerializerCapabilities.PackTo | SerializerCapabilities.UnpackFrom ) : SerializerCapabilities.PackTo;" is 131.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,VerifyCanSerializeTargetType,The length of the statement  "			if ( context.SerializerOptions.DisablePrivilegedAccess && !targetType.GetIsPublic() && !targetType.GetIsNestedPublic() && !ThisAssembly.Equals( targetType.GetAssembly() ) )" is 172.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,VerifyCanSerializeTargetType,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "Cannot serialize type '{0}' because it is not public to the serializer."' targetType ) );" is 167.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,Prepare,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "Cannot serialize type '{0}' because it does not have any serializable fields nor properties."' targetType ) );" is 188.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,Prepare,The length of the statement  "						// For backward compatibility' no exceptions are thrown here even if mulitiple deserialization constructor attributes in the type" is 129.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,Prepare,The length of the statement  "				if ( constructor != null && constructor.GetParameters().Any() || context.CompatibilityOptions.AllowAsymmetricSerializer )" is 121.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,Prepare,The length of the statement  "						canDeserialize ?? DetermineCanDeserialize( constructorKind' context' targetType' correspondingMemberNames' allowDefault: true )" is 127.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,DetermineCanDeserialize,The length of the statement  "					Trace( "SerializationTarget::DetermineCanDeserialize({0}' {1}) -> {2}: HasAnyCorrespondingMembers"' targetType' kind' result );" is 127.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,DetermineCanDeserialize,The length of the statement  "					Contract.Assert( kind == ConstructorKind.None || kind == ConstructorKind.Ambiguous' "kind == ConstructorKind.None || kind == ConstructorKind.Ambiguous : " + kind );" is 164.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,GetAnnotatedMembersWithDuplicationDetection,The length of the statement  "					member => member.GetCustomAttributesData().Any( a => a.GetAttributeType().FullName == MessagePackIgnoreAttributeTypeName )" is 122.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,GetAnnotatedMembersWithDuplicationDetection,The length of the statement  "						var attribute = member.GetCustomAttributesData().Single( a => a.GetAttributeType().FullName == MessagePackMemberAttributeTypeName );" is 132.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,GetAnnotatedMembersWithDuplicationDetection,The length of the statement  "									( NilImplication )( ( int? )GetAttributeProperty( MessagePackMemberAttributeTypeName' attribute' "NilImplication" ) ).GetValueOrDefault()'" is 138.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,GetAnnotatedMembersWithDuplicationDetection,The length of the statement  "						var attribute = member.GetCustomAttributes( typeof( MessagePackMemberAttribute )' true ).Single() as MessagePackMemberAttribute;" is 128.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,FindDeserializationConstructor,The length of the statement  "			Trace( "SerializationTarget::FindDeserializationConstructor.MostRich({0}) -> {1}"' targetType' String.Join( ";"' mostRichConstructors.Select( x => x.ToString() ).ToArray() ) );" is 176.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,FindDeserializationConstructor,The length of the statement  "								"Cannot serialize type '{0}' because it does not have any serializable fields nor properties' and serializer generator failed to determine constructor to deserialize among({1})."'" is 179.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,NewTypeCannotBeSerializedException,The length of the statement  "						"Cannot serialize type '{0}' because it does not have any serializable fields nor properties' and it does not have any public constructors with parameters."'" is 157.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,CheckTargetEligibility,The length of the statement  "			var traits = returnType.GetCollectionTraits( CollectionTraitOptions.WithAddMethod' allowNonCollectionEnumerableTypes: false );" is 126.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,ComplementMembers,The length of the statement  "					"Cannot specify order value 0 on DataMemberAttribute when SerializationContext.CompatibilityOptions.OneBoundDataMemberOrder is set to true."" is 140.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,VerifyKeyUniqueness,The length of the statement  "						duplicated.Add( member.Contract.Name' new List<MemberInfo> { existents[ member.Contract.Name ].Member' member.Member } );" is 121.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,VerifyKeyUniqueness,The length of the statement  "									String.Join( "'"' kv.Value.Select( m => String.Format( CultureInfo.InvariantCulture' "{0}.{1}({2})"' m.DeclaringType' m.Name' ( m is FieldInfo ) ? "Field" : "Property" ) ).ToArray() )" is 183.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,CreateForTuple,The length of the statement  "			return new SerializationTarget( itemTypes.Select( ( _' i ) => new SerializingMember( GetTupleItemNameFromIndex( i ) ) ).ToArray()' null' null' true );" is 150.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,BuiltInSerializerExists,The length of the statement  "			return GenericSerializer.IsSupported( type' traits' configuration.PreferReflectionBasedSerializer ) || SerializerRepository.InternalDefault.ContainsFor( type );" is 160.
Long Statement,MsgPack.Serialization,MemberConstructorParameterEqualityComparer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,GetHashCode,The length of the statement  "				return ( obj.Key == null ? 0 : StringComparer.OrdinalIgnoreCase.GetHashCode( obj.Key ) ) ^ ( obj.Value == null ? 0 : obj.Value.GetHashCode() );" is 143.
Long Statement,MsgPack.Serialization,SerializerDebugging,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerDebugging.cs,TracePolimorphicSchemaEvent,The length of the statement  "			Tracer.Emit.TraceEvent( Tracer.EventType.PolimorphicSchema' Tracer.EventId.PolimorphicSchema' format' memberInfo' schema == null ? "(null)" : schema.DebugString );" is 163.
Long Statement,MsgPack.Serialization,SerializerGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerGenerator.cs,GenerateSerializerSourceCodes,The length of the statement  "			return new SerializerCodesGenerationLogic().Generate( targetTypes' configuration ?? new SerializerCodeGenerationConfiguration() );" is 130.
Long Statement,MsgPack.Serialization,SerializerGenerationLogic<TConfig>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerGenerator.cs,Generate,The length of the statement  "						.Where( t => !SerializationTarget.BuiltInSerializerExists( configuration' t' t.GetCollectionTraits( CollectionTraitOptions.None' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes ) ) );" is 198.
Long Statement,MsgPack.Serialization,SerializerGenerationLogic<TConfig>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerGenerator.cs,ExtractElementTypes,The length of the statement  "				var traits = type.GetCollectionTraits( CollectionTraitOptions.None' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes );" is 133.
Long Statement,MsgPack.Serialization,SerializerGenerationLogic<TConfig>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerGenerator.cs,ExtractElementTypes,The length of the statement  "								.Members.Where( m => m.Member != null ).SelectMany( m => ExtractElementTypes( context' configuration' m.Member.GetMemberValueType() ) )" is 135.
Long Statement,MsgPack.Serialization,SerializerGenerationLogic<TConfig>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerGenerator.cs,ExtractElementTypes,The length of the statement  "					elementTypes.AddRange( type.GetGenericArguments().SelectMany( g => ExtractElementTypes( context' configuration' g ) ) );" is 120.
Long Statement,MsgPack.Serialization,SerializerGenerationLogic<TConfig>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerGenerator.cs,ExtractElementTypes,The length of the statement  "					if ( !SerializationTarget.BuiltInSerializerExists( configuration' elementType' elementType.GetCollectionTraits( CollectionTraitOptions.None' allowNonCollectionEnumerableTypes: false ) ) )" is 187.
Long Statement,MsgPack.Serialization,SerializerAssemblyGenerationLogic,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerGenerator.cs,CreateGeneratorFactory,The length of the statement  "				return type => new AssemblyBuilderSerializerBuilder( type' type.GetCollectionTraits( CollectionTraitOptions.Full' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes ) );" is 181.
Long Statement,MsgPack.Serialization,SerializerCodesGenerationLogic,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerGenerator.cs,CreateGeneratorFactory,The length of the statement  "				return type => new CodeDomSerializerBuilder( type' type.GetCollectionTraits( CollectionTraitOptions.Full' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes ) );" is 173.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,Register,The length of the statement  "				GetNullableCompanion( typeof( T )' serializer.OwnerContext' serializer' out nullableType' out nullableSerializerProvider );" is 123.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,Register,The length of the statement  "			return this.Register( typeof( T )' new PolymorphicSerializerProvider<T>( serializer )' nullableType' nullableSerializerProvider' options );" is 139.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,Register,The length of the statement  "			return this.Register( typeof( T )' new PolymorphicSerializerProvider<T>(  serializer.OwnerContext' serializer )' nullableType' nullableSerializerProvider' options );" is 165.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( MessagePackObject ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.MsgPack_MessagePackObjectMessagePackSerializer( ownerContext ) );" is 166.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( MessagePackObjectDictionary ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.MsgPack_MessagePackObjectDictionaryMessagePackSerializer( ownerContext ) );" is 186.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( MessagePackExtendedTypeObject ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.MsgPack_MessagePackExtendedTypeObjectMessagePackSerializer( ownerContext ) );" is 190.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( List<MessagePackObject> ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_ListOfMessagePackObjectMessagePackSerializer( ownerContext ) );" is 197.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( Object ).TypeHandle' new MsgPack.Serialization.Polymorphic.PolymorphicSerializerProvider<object>( new MsgPack.Serialization.DefaultSerializers.System_ObjectMessagePackSerializer( ownerContext ) ) );" is 222.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( Object ).TypeHandle' new MsgPack.Serialization.Polymorphic.PolymorphicSerializerProvider<object>( ownerContext' new MsgPack.Serialization.DefaultSerializers.System_ObjectMessagePackSerializer( ownerContext ) ) );" is 236.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( String ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_StringMessagePackSerializer( ownerContext ) );" is 143.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( StringBuilder ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Text_StringBuilderMessagePackSerializer( ownerContext ) );" is 162.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( Char[] ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_CharArrayMessagePackSerializer( ownerContext ) );" is 146.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( Byte[] ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_ByteArrayMessagePackSerializer( ownerContext ) );" is 146.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( DateTime ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.DateTimeMessagePackSerializerProvider( ownerContext' false ) );" is 155.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( DateTimeOffset ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.DateTimeOffsetMessagePackSerializerProvider( ownerContext' false ) );" is 167.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( Timestamp ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.TimestampMessagePackSerializerProvider( ownerContext' false ) );" is 157.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Runtime.InteropServices.ComTypes.FILETIME ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.FileTimeMessagePackSerializerProvider( ownerContext' false ) );" is 195.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( DateTime? ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.DateTimeMessagePackSerializerProvider( ownerContext' true ) );" is 155.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( DateTimeOffset? ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.DateTimeOffsetMessagePackSerializerProvider( ownerContext' true ) );" is 167.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( Timestamp? ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.TimestampMessagePackSerializerProvider( ownerContext' true ) );" is 157.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Runtime.InteropServices.ComTypes.FILETIME? ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.FileTimeMessagePackSerializerProvider( ownerContext' true ) );" is 195.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( DBNull ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_DBNullMessagePackSerializer( ownerContext ) );" is 143.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Boolean ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_BooleanMessagePackSerializer( ownerContext ) );" is 152.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Byte ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_ByteMessagePackSerializer( ownerContext ) );" is 146.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Char ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_CharMessagePackSerializer( ownerContext ) );" is 146.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Decimal ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_DecimalMessagePackSerializer( ownerContext ) );" is 152.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Double ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_DoubleMessagePackSerializer( ownerContext ) );" is 150.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Guid ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_GuidMessagePackSerializer( ownerContext ) );" is 146.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Int16 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Int16MessagePackSerializer( ownerContext ) );" is 148.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Int32 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Int32MessagePackSerializer( ownerContext ) );" is 148.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Int64 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Int64MessagePackSerializer( ownerContext ) );" is 148.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.SByte ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_SByteMessagePackSerializer( ownerContext ) );" is 148.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Single ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_SingleMessagePackSerializer( ownerContext ) );" is 150.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.TimeSpan ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_TimeSpanMessagePackSerializer( ownerContext ) );" is 154.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.UInt16 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_UInt16MessagePackSerializer( ownerContext ) );" is 150.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.UInt32 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_UInt32MessagePackSerializer( ownerContext ) );" is 150.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.UInt64 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_UInt64MessagePackSerializer( ownerContext ) );" is 150.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Security.Cryptography.HashAlgorithmName ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Security_Cryptography_HashAlgorithmNameMessagePackSerializer( ownerContext ) );" is 216.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.Specialized.BitVector32 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Collections_Specialized_BitVector32MessagePackSerializer( ownerContext ) );" is 208.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.BigInteger ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_BigIntegerMessagePackSerializer( ownerContext ) );" is 176.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Matrix3x2 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_Matrix3x2MessagePackSerializer( ownerContext ) );" is 174.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Matrix4x4 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_Matrix4x4MessagePackSerializer( ownerContext ) );" is 174.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Plane ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_PlaneMessagePackSerializer( ownerContext ) );" is 166.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Quaternion ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_QuaternionMessagePackSerializer( ownerContext ) );" is 176.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Vector2 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_Vector2MessagePackSerializer( ownerContext ) );" is 170.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Vector3 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_Vector3MessagePackSerializer( ownerContext ) );" is 170.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Vector4 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_Vector4MessagePackSerializer( ownerContext ) );" is 170.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Globalization.CultureInfo ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Globalization_CultureInfoMessagePackSerializer( ownerContext ) );" is 188.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.DictionaryEntry ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Collections_DictionaryEntryMessagePackSerializer( ownerContext ) );" is 192.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.Stack ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Collections_StackMessagePackSerializer( ownerContext ) );" is 172.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.Queue ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Collections_QueueMessagePackSerializer( ownerContext ) );" is 172.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.Generic.KeyValuePair<'> ).TypeHandle' typeof( System_Collections_Generic_KeyValuePair_2MessagePackSerializer<' > ) );" is 160.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.Generic.Stack<> ).TypeHandle' typeof( System_Collections_Generic_Stack_1MessagePackSerializer<> ) );" is 143.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.Generic.Queue<> ).TypeHandle' typeof( System_Collections_Generic_Queue_1MessagePackSerializer<> ) );" is 143.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Complex ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_ComplexMessagePackSerializer( ownerContext ) );" is 170.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Uri ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_UriMessagePackSerializer( ownerContext ) );" is 144.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Version ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_VersionMessagePackSerializer( ownerContext ) );" is 152.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.Specialized.NameValueCollection ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Collections_Specialized_NameValueCollectionMessagePackSerializer( ownerContext ) );" is 224.
Long Statement,MsgPack.Serialization,SerializingMember,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializingMember.cs,ToString,The length of the statement  "			return String.Format( CultureInfo.InvariantCulture' "{{\"Name\": \"{0}\"' \"Id\": {1}' \"Member\": \"{2}\"' \"NilImplication\": \"{3}\" }}"' this.MemberName' this.Contract.Id' this.MemberName' this.Contract.NilImplication );" is 224.
Long Statement,MsgPack.Serialization,TypeKeyRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\TypeKeyRepository.cs,GetEntries,The length of the statement  "				return this._table.Select( kv => new KeyValuePair<Type' object>( Type.GetTypeFromHandle( kv.Key )' kv.Value ) ).ToArray();" is 122.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The length of the statement  "						if ( currentScore < withCapacityAndComparer && parameters[ 0 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 1 ].ParameterType ) )" is 151.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The length of the statement  "						else if ( currentScore < withComparerAndCapacity && parameters[ 1 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 0 ].ParameterType ) )" is 156.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,GetEqualityComparer,The length of the statement  "			// AotHelper is internal because it should not be API -- it is subject to change when the Unity's Mono is updated or IL2CPP becomes stable." is 139.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValue,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "directRead"' "directRead cannot be null if serializer argument is null." );" is 124.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValue,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "parameter"' "DirectRead cannot be null if Serializer field is null." );" is 120.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValueAsync,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "directRead"' "directRead cannot be null if serializer argument is null." );" is 124.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValueAsync,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "parameter"' "DirectRead cannot be null if Serializer field is null." );" is 120.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValue,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "directRead"' "directRead cannot be null if serializer argument is null." );" is 124.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValue,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "parameter"' "DirectRead cannot be null if Serializer field is null." );" is 120.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValueAsync,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "directRead"' "directRead cannot be null if serializer argument is null." );" is 124.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValueAsync,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "parameter"' "DirectRead cannot be null if Serializer field is null." );" is 120.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValue,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "directRead"' "directRead cannot be null if serializer argument is null." );" is 124.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValue,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "parameter"' "DirectRead cannot be null if Serializer field is null." );" is 120.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValueAsync,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "directRead"' "directRead cannot be null if serializer argument is null." );" is 124.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValueAsync,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "parameter"' "DirectRead cannot be null if Serializer field is null." );" is 120.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackFromMapAsyncCore,The length of the statement  "				var key = await UnpackStringValueAsync( unpacker' typeof( TResult )' "MemberName"' cancellationToken ).ConfigureAwait( false );" is 127.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionCore,The length of the statement  "					SerializationExceptions.ThrowArgumentException( "eachOperation"' "eachOperation cannot not be null when bulkOperation is null." );" is 130.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionAsyncCore,The length of the statement  "					SerializationExceptions.ThrowArgumentException( "eachOperation"' "eachOperation cannot not be null when bulkOperation is null." );" is 130.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,RegisterCachedFieldInfo,The length of the statement  "						"_field" + field.DeclaringType.Name.Replace( '`'' '_' ) + "_" + field.Name + this._cachedTargetFields.Count.ToString( CultureInfo.InvariantCulture )" is 148.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,RegisterCachedMethodBase,The length of the statement  "						"_methodBase" + method.DeclaringType.Name.Replace( '`'' '_' ) + "_" + method.Name + this._cachedPropertyAccessors.Count.ToString( CultureInfo.InvariantCulture )" is 160.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,ResetCore,The length of the statement  "					new CodeAttributeArgument( new CodePrimitiveExpression( "MsgPack.Serialization.CodeDomSerializers.CodeDomSerializerBuilder" ) )'" is 128.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,ResetCore,The length of the statement  "			var traits = targetType.GetCollectionTraits( CollectionTraitOptions.Full' this.SerializationContext.CompatibilityOptions.AllowNonCollectionEnumerableTypes );" is 157.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,BeginMethodOverride,The length of the statement  "			this._methodContextStack.Push( new MethodContext( name' false' TypeDefinition.ObjectType' SerializerBuilderHelper.EmptyParameters ) );" is 134.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,EndMethodOverrideCore,The length of the statement  "					codeMethod.Attributes = ( this.IsInternalToMsgPackLibrary ? MemberAttributes.FamilyOrAssembly : MemberAttributes.Family ) | MemberAttributes.Override;" is 150.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,EndMethodOverrideCore,The length of the statement  "					codeMethod.Attributes = ( this.IsInternalToMsgPackLibrary ? MemberAttributes.FamilyOrAssembly : MemberAttributes.Family ) | MemberAttributes.Override;" is 150.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,EndMethodOverrideCore,The length of the statement  "					codeMethod.Attributes = ( this.IsInternalToMsgPackLibrary ? MemberAttributes.FamilyOrAssembly : MemberAttributes.Family ) | MemberAttributes.Override;" is 150.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,EndMethodOverrideCore,The length of the statement  "					codeMethod.Attributes = ( this.IsInternalToMsgPackLibrary ? MemberAttributes.FamilyOrAssembly : MemberAttributes.Family ) | MemberAttributes.Override;" is 150.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,EndMethodOverrideCore,The length of the statement  "					codeMethod.Parameters.Add( new CodeParameterDeclarationExpression( typeof( MessagePackObject )' "messagePackObject" ) );" is 120.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,EndMethodOverrideCore,The length of the statement  "					codeMethod.Attributes = ( this.IsInternalToMsgPackLibrary ? MemberAttributes.FamilyOrAssembly : MemberAttributes.Family ) | MemberAttributes.Override;" is 150.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,EndMethodOverrideCore,The length of the statement  "					codeMethod.Attributes = ( this.IsInternalToMsgPackLibrary ? MemberAttributes.FamilyOrAssembly : MemberAttributes.Family ) | MemberAttributes.Override;" is 150.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,EndMethodOverrideCore,The length of the statement  "					codeMethod.Attributes = ( this.IsInternalToMsgPackLibrary ? MemberAttributes.FamilyOrAssembly : MemberAttributes.Family ) | MemberAttributes.Override;" is 150.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,EndMethodOverrideCore,The length of the statement  "					codeMethod.Attributes = ( this.IsInternalToMsgPackLibrary ? MemberAttributes.FamilyOrAssembly : MemberAttributes.Family ) | MemberAttributes.Override;" is 150.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,EndMethodOverrideCore,The length of the statement  "					codeMethod.Attributes = ( this.IsInternalToMsgPackLibrary ? MemberAttributes.FamilyOrAssembly : MemberAttributes.Family ) | MemberAttributes.Override;" is 150.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,EndPrivateMethodCore,The length of the statement  "			var codeMethod = new CodeMemberMethod { Name = context.Name' Attributes = MemberAttributes.Private | ( context.IsStatic ? MemberAttributes.Static : 0 ) };" is 154.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,BeginConstructor,The length of the statement  "			this._methodContextStack.Push( new MethodContext( ".ctor"' false' TypeDefinition.ObjectType' SerializerBuilderHelper.EmptyParameters ) );" is 137.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,DefineUnpackingContextCore,The length of the statement  "			DefineUnpackValueMethodArguments( type' out parameterInUnpackValueMethods' out parameterInSetValueMethods' out parameterInCreateObjectFromContext );" is 148.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomContext.cs,DefineUnpackingContextWithResultObjectCore,The length of the statement  "			DefineUnpackValueMethodArguments( type' out parameterInUnpackValueMethods' out parameterInSetValueMethods' out parameterInCreateObjectFromContext );" is 148.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,EmitThisReferenceExpression,The length of the statement  "			return CodeDomConstruct.Expression( typeof( MessagePackSerializer<> ).MakeGenericType( this.TargetType )' new CodeThisReferenceExpression() );" is 142.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,EmitBoxExpression,The length of the statement  "			return CodeDomConstruct.Expression( TypeDefinition.ObjectType' new CodeCastExpression( typeof( object )' value.AsExpression() ) );" is 130.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,EmitCreateNewObjectExpression,The length of the statement  "			Contract.Assert( arguments.All( c => c.IsExpression )' String.Join( "'"' arguments.Select( c => c.ToString() ).ToArray() ) );" is 125.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,EmitMakeRef,The length of the statement  "			return CodeDomConstruct.Expression( target.ContextType' new CodeDirectionExpression( FieldDirection.Ref' target.AsExpression() ) );" is 131.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,EmitInvokeVoidMethod,The length of the statement  "			Contract.Assert( arguments.All( c => c.IsExpression )' String.Join( "'"' arguments.Select( c => c.ToString() ).ToArray() ) );" is 125.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,EmitInvokeMethodExpression,The length of the statement  "			Contract.Assert( arguments.All( c => c.IsExpression )' String.Join( "'"' arguments.Select( c => c.ToString() ).ToArray() ) );" is 125.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,EmitInvokeDelegateExpression,The length of the statement  "			Contract.Assert( arguments.All( c => c.IsExpression )' String.Join( "'"' arguments.Select( c => c.ToString() ).ToArray() ) );" is 125.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,EmitGetActionsExpression,The length of the statement  "						isAsync ? typeof( IList<> ).MakeGenericType( typeof( Func<'''> ).MakeGenericType( typeof( Packer )' this.TargetType' typeof( CancellationToken )' typeof( Task ) ) ) :" is 166.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,EmitGetActionsExpression,The length of the statement  "						isAsync ? typeof( IDictionary<'> ).MakeGenericType( typeof( string )' typeof( Func<'''> ).MakeGenericType( typeof( Packer )' this.TargetType' typeof( CancellationToken )' typeof( Task ) ) ) :" is 191.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,EmitGetActionsExpression,The length of the statement  "						typeof( IDictionary<'> ).MakeGenericType( typeof( string )' typeof( Action<'> ).MakeGenericType( typeof( Packer )' this.TargetType ) );" is 135.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,EmitGetActionsExpression,The length of the statement  "					type = typeof( IDictionary<'> ).MakeGenericType( typeof( string )' typeof( Func<'> ).MakeGenericType( this.TargetType' typeof( bool ) ) );" is 138.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,EmitGetActionsExpression,The length of the statement  "						isAsync ? typeof( Func<''''> ).MakeGenericType( typeof( Unpacker )' this.TargetType' typeof( int )' typeof( CancellationToken )' typeof( Task ) ) :" is 147.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,EmitEnumToUnderlyingCastExpression,The length of the statement  "			return CodeDomConstruct.Expression( underlyingType' new CodeCastExpression( underlyingType' enumValue.AsExpression() ) );" is 121.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,EmitNewPrivateMethodDelegateExpression,The length of the statement  "						method.IsStatic ? new CodeTypeReferenceExpression( context.DeclaringType.Name ) as CodeExpression : new CodeThisReferenceExpression()'" is 134.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,CreateSerializerConstructor,The length of the statement  "			return targetType.GetConstructors().Single().CreateConstructorDelegate<Func<SerializationContext' MessagePackSerializer>>();" is 124.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,CreateEnumSerializerConstructor,The length of the statement  "			return targetType.GetConstructors().Single( c => c.GetParameters().Length == 1 ).CreateConstructorDelegate<Func<SerializationContext' MessagePackSerializer>>();" is 160.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,Finish,The length of the statement  "				ctor2.Parameters.Add( new CodeParameterDeclarationExpression( typeof( EnumSerializationMethod )' "enumSerializationMethod" ) );" is 127.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,Finish,The length of the statement  "						capabilitiesExpression = BuildCapabilitiesExpression( capabilitiesExpression' capabilities.Value' SerializerCapabilities.UnpackFrom );" is 134.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,Finish,The length of the statement  "						capabilitiesExpression = BuildCapabilitiesExpression( capabilitiesExpression' capabilities.Value' SerializerCapabilities.UnpackTo );" is 132.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,Finish,The length of the statement  "				conditional.Parameters.Add( new CodeParameterDeclarationExpression( typeof( bool )' CodeDomContext.ConditionalExpressionHelperConditionParameterName ) );" is 153.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,Finish,The length of the statement  "				conditional.Parameters.Add( new CodeParameterDeclarationExpression( tRef' CodeDomContext.ConditionalExpressionHelperWhenTrueParameterName ) );" is 142.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,Finish,The length of the statement  "				conditional.Parameters.Add( new CodeParameterDeclarationExpression( tRef' CodeDomContext.ConditionalExpressionHelperWhenFalseParameterName ) );" is 143.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,Finish,The length of the statement  "						new CodeStatement[] { new CodeMethodReturnStatement( new CodeArgumentReferenceExpression( CodeDomContext.ConditionalExpressionHelperWhenTrueParameterName ) ) }'" is 160.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,Finish,The length of the statement  "						new CodeStatement[] { new CodeMethodReturnStatement( new CodeArgumentReferenceExpression( CodeDomContext.ConditionalExpressionHelperWhenFalseParameterName ) ) }" is 160.
Long Statement,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,BuildCapabilitiesExpression,The length of the statement  "					new CodeFieldReferenceExpression( new CodeTypeReferenceExpression( typeof( SerializerCapabilities ) )' value.ToString() );" is 122.
Long Statement,MsgPack.Serialization.DefaultSerializers,ArraySegmentMessageSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\ArraySegmentMessageSerializer.cs,PackCharArraySegmentTo,The length of the statement  "			packer.PackRawBody( MessagePackConvert.EncodeString( new string( objectTree.Array.Skip( objectTree.Offset ).Take( objectTree.Count ).ToArray() ) ) );" is 149.
Long Statement,MsgPack.Serialization.DefaultSerializers,ArraySegmentMessageSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\ArraySegmentMessageSerializer.cs,PackByteArraySegmentToAsync,The length of the statement  "			await packer.PackRawBodyAsync( objectTree.Array.Skip( objectTree.Offset ).Take( objectTree.Count )' cancellationToken ).ConfigureAwait( false );" is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,ArraySegmentMessageSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\ArraySegmentMessageSerializer.cs,PackCharArraySegmentToAsync,The length of the statement  "			await packer.PackRawBodyAsync( MessagePackConvert.EncodeString( new string( objectTree.Array.Skip( objectTree.Offset ).Take( objectTree.Count ).ToArray() ) )' cancellationToken ).ConfigureAwait( false );" is 203.
Long Statement,MsgPack.Serialization.DefaultSerializers,ArraySegmentMessageSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\ArraySegmentMessageSerializer.cs,PackGenericArraySegmentToAsync,The length of the statement  "				await itemSerializer.PackToAsyncCore( packer' objectTree.Array[ i + objectTree.Offset ]' cancellationToken ).ConfigureAwait( false );" is 133.
Long Statement,MsgPack.Serialization.DefaultSerializers,ArraySerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\ArraySerializer.cs,Create,The length of the statement  "			// Check the T is SZArray -- Type.GetArrayRank() returns 1 for single dimension' non-zero based arrays' so use (SZArrayType).IsAssinableFrom() instead." is 151.
Long Statement,MsgPack.Serialization.DefaultSerializers,DateTimeOffsetMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DateTimeOffsetMessagePackSerializer.cs,PackToAsyncCore,The length of the statement  "				await packer.PackAsync( Timestamp.FromDateTimeOffset( objectTree ).Encode()' cancellationToken ).ConfigureAwait( false );" is 121.
Long Statement,MsgPack.Serialization.DefaultSerializers,DateTimeOffsetMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DateTimeOffsetMessagePackSerializer.cs,PackToAsyncCore,The length of the statement  "					await packer.PackAsync( ( short )( objectTree.Offset.Hours * 60 + objectTree.Offset.Minutes )' cancellationToken ).ConfigureAwait( false );" is 139.
Long Statement,MsgPack.Serialization.DefaultSerializers,DateTimeOffsetMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DateTimeOffsetMessagePackSerializer.cs,PackToAsyncCore,The length of the statement  "				await packer.PackAsync( MessagePackConvert.FromDateTimeOffset( objectTree )' cancellationToken ).ConfigureAwait( false );" is 121.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_BooleanMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Boolean )' ex.Message ) );" is 163.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_ByteMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Byte )' ex.Message ) );" is 160.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_CharMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex );" is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_CharMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex );" is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_DecimalMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex );" is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_DecimalMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex );" is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_DecimalMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,PackToAsyncCore,The length of the statement  "			await packer.PackStringAsync( value.ToString( "G"' CultureInfo.InvariantCulture )' cancellationToken ).ConfigureAwait( false );" is 127.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_DoubleMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Double )' ex.Message ) );" is 162.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_GuidMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex );" is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_GuidMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex );" is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Int16MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Int16 )' ex.Message ) );" is 161.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Int32MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Int32 )' ex.Message ) );" is 161.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Int64MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Int64 )' ex.Message ) );" is 161.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_SByteMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.SByte )' ex.Message ) );" is 161.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_SingleMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Single )' ex.Message ) );" is 162.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_TimeSpanMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Int64 )' ex.Message ) );" is 161.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_UInt16MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.UInt16 )' ex.Message ) );" is 162.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_UInt32MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.UInt32 )' ex.Message ) );" is 162.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_UInt64MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.UInt64 )' ex.Message ) );" is 162.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_Specialized_BitVector32MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Int32 )' ex.Message ) );" is 161.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Numerics_BigIntegerMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex );" is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Numerics_BigIntegerMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex );" is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,FSharpMapSerializer<T;TKey;TValue>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\FSharpMapSerializer`3.cs,FindFactory,The length of the statement  "			return result.CreateDelegate( typeof( Func<IEnumerable<Tuple<TKey' TValue>>' T> ) ) as Func<IEnumerable<Tuple<TKey' TValue>>' T>;" is 129.
Long Statement,MsgPack.Serialization.DefaultSerializers,FSharpMapSerializer<T;TKey;TValue>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\FSharpMapSerializer`3.cs,FindFactory,The length of the statement  "			return Delegate.CreateDelegate( typeof( Func<IEnumerable<Tuple<TKey' TValue>>' T> )' result ) as Func<IEnumerable<Tuple<TKey' TValue>>' T>;" is 139.
Long Statement,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,Create,The length of the statement  "					return CreateListSerializer( context' targetType' targetType.GetCollectionTraits( CollectionTraitOptions.WithAddMethod' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes )' schema );" is 195.
Long Statement,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,Create,The length of the statement  "					return CreateDictionarySerializer( context' targetType' targetType.GetCollectionTraits( CollectionTraitOptions.WithAddMethod' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes )' genericTypeArguments[ 0 ]' genericTypeArguments[ 1 ]' schema );" is 255.
Long Statement,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,TryCreateImmutableCollectionSerializer,The length of the statement  "							typeof( ImmutableDictionarySerializerFactory<''> ).MakeGenericType( targetType' targetType.GetGenericArguments()[ 0 ]' targetType.GetGenericArguments()[ 1 ] )" is 158.
Long Statement,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,TryCreateImmutableCollectionSerializer,The length of the statement  "							typeof( FSharpMapSerializerFactory<''> ).MakeGenericType( targetType' targetType.GetGenericArguments()[ 0 ]' targetType.GetGenericArguments()[ 1 ] )" is 148.
Long Statement,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,TryCreateAbstractCollectionSerializer,The length of the statement  "					abstractType.GetCollectionTraits( CollectionTraitOptions.None' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes )" is 127.
Long Statement,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,TryCreateAbstractCollectionSerializer,The length of the statement  "					return new AbstractDictionaryMessagePackSerializer( context' abstractType' concreteType' genericArgumentOfKeyValuePair[ 0 ]' genericArgumentOfKeyValuePair[ 1 ]' traits' schema );" is 178.
Long Statement,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,TryCreateAbstractCollectionSerializer,The length of the statement  "					return new AbstractDictionaryMessagePackSerializer( context' abstractType' concreteType' genericArgumentOfKeyValuePair[ 0 ]' genericArgumentOfKeyValuePair[ 1 ]' traits' schema );" is 178.
Long Statement,MsgPack.Serialization.DefaultSerializers,DictionaryInstanceFactory<TKey;TValue>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,Create,The length of the statement  "				return new System_Collections_Generic_Dictionary_2MessagePackSerializer<TKey' TValue>( context' itemSchema.KeySchema' itemSchema.ItemSchema );" is 142.
Long Statement,MsgPack.Serialization.DefaultSerializers,ImmutableDictionarySerializer<T;TKey;TValue>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\ImmutableDictionarySerializer`3.cs,FindFactory,The length of the statement  "			return result.CreateDelegate( typeof( Func<KeyValuePair<TKey' TValue>[]' T> ) ) as Func<KeyValuePair<TKey' TValue>[]' T>;" is 121.
Long Statement,MsgPack.Serialization.DefaultSerializers,ImmutableDictionarySerializer<T;TKey;TValue>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\ImmutableDictionarySerializer`3.cs,FindFactory,The length of the statement  "			return Delegate.CreateDelegate( typeof( Func<KeyValuePair<TKey' TValue>[]' T> )' result ) as Func<KeyValuePair<TKey' TValue>[]' T>;" is 131.
Long Statement,MsgPack.Serialization.DefaultSerializers,InternalDateTimeExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\InternalDateTimeExtensions.cs,ToDateTime,The length of the statement  "			// DateTime.FromFileTimeUtc in Mono 2.10.x does not return Utc DateTime (Mono issue #2936)' so do convert manually to ensure returned DateTime is UTC." is 150.
Long Statement,MsgPack.Serialization.DefaultSerializers,MessagePackObjectExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MessagePackObjectExtensions.cs,DeserializeAsInt64,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex );" is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,MessagePackObjectExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MessagePackObjectExtensions.cs,DeserializeAsString,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex );" is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,MessagePackObjectExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MessagePackObjectExtensions.cs,DeserializeAsMessagePackExtendedTypeObject,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex );" is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,MsgPack_MessagePackExtendedTypeObjectMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MsgPack_MessagePackExtendedTypeObjectMessagePackSerializer.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex );" is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,PackArrayCore,The length of the statement  "				packer.PackExtendedTypeValue( this.OwnerContext.ExtTypeCodeMapping[ KnownExtTypeName.MultidimensionalArray ]' buffer.ToArray() );" is 129.
Long Statement,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,UnpackFromCore,The length of the statement  "						SerializationExceptions.ThrowSerializationException( "Multidimensional metadata array must be encoded as 2 element array." );" is 125.
Long Statement,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,PackArrayAsyncCore,The length of the statement  "				await packer.PackExtendedTypeValueAsync( this.OwnerContext.ExtTypeCodeMapping[ KnownExtTypeName.MultidimensionalArray ]' buffer.ToArray()' cancellationToken ).ConfigureAwait( false );" is 183.
Long Statement,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,PackArrayAsyncCore,The length of the statement  "				async indices => await this._itemSerializer.PackToAsync( packer' ( TItem )array.GetValue( indices )' cancellationToken ).ConfigureAwait( false )" is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,UnpackFromAsyncCore,The length of the statement  "						SerializationExceptions.ThrowSerializationException( "Multidimensional metadata array must be encoded as 2 element array." );" is 125.
Long Statement,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,UnpackFromAsyncCore,The length of the statement  "					lengthsAndLowerBounds = await this.ReadArrayMetadataAsync( metadataUnpacker' cancellationToken ).ConfigureAwait( false );" is 121.
Long Statement,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,ReadArrayMetadataAsync,The length of the statement  "				lengths = await this._int32ArraySerializer.UnpackFromAsync( lengthsUnpacker' cancellationToken ).ConfigureAwait( false );" is 121.
Long Statement,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,ReadArrayMetadataAsync,The length of the statement  "				lowerBounds = await this._int32ArraySerializer.UnpackFromAsync( lowerBoundsUnpacker' cancellationToken ).ConfigureAwait( false );" is 129.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The length of the statement  "			return new Matrix4x4( m11.Value' m12.Value' m13.Value' m14.Value' m21.Value' m22.Value' m23.Value' m24.Value' m31.Value' m32.Value' m33.Value' m34.Value' m41.Value' m42.Value' m43.Value' m44.Value );" is 199.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_DictionaryEntryMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_DictionaryEntryMessagePackSerializer.cs,PackToAsyncCore,The length of the statement  "			await EnsureMessagePackObject( objectTree.Key ).PackToMessageAsync( packer' null' cancellationToken ).ConfigureAwait( false );" is 126.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_DictionaryEntryMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_DictionaryEntryMessagePackSerializer.cs,PackToAsyncCore,The length of the statement  "			await EnsureMessagePackObject( objectTree.Value ).PackToMessageAsync( packer' null' cancellationToken ).ConfigureAwait( false );" is 128.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_Generic_Dictionary_2MessagePackSerializer<TKey;TValue>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_Generic_Dictionary_2MessagePackSerializer`2.cs,PackToAsyncCore,The length of the statement  "			return PackerUnpackerExtensions.PackDictionaryAsyncCore( packer' objectTree' this._keySerializer' this._valueSerializer' cancellationToken );" is 141.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_Generic_Dictionary_2MessagePackSerializer<TKey;TValue>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_Generic_Dictionary_2MessagePackSerializer`2.cs,UnpackToAsyncCore,The length of the statement  "						collection.Add( key' await this._valueSerializer.UnpackFromAsync( subTreeUnpacker' cancellationToken ).ConfigureAwait( false ) );" is 129.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_Generic_Dictionary_2MessagePackSerializer<TKey;TValue>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_Generic_Dictionary_2MessagePackSerializer`2.cs,UnpackToAsyncCore,The length of the statement  "					collection.Add( key' await this._valueSerializer.UnpackFromAsync( unpacker' cancellationToken ).ConfigureAwait( false ) );" is 122.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_Generic_KeyValuePair_2MessagePackSerializer<TKey;TValue>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_Generic_KeyValuePair_2MessagePackSerializer`2.cs,UnpackFromAsyncCore,The length of the statement  "			var key = unpacker.LastReadData.IsNil ? default( TKey ) : await this._keySerializer.UnpackFromAsync( unpacker' cancellationToken ).ConfigureAwait( false );" is 155.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_Generic_KeyValuePair_2MessagePackSerializer<TKey;TValue>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_Generic_KeyValuePair_2MessagePackSerializer`2.cs,UnpackFromAsyncCore,The length of the statement  "			var value = unpacker.LastReadData.IsNil ? default( TValue ) : await this._valueSerializer.UnpackFromAsync( unpacker' cancellationToken ).ConfigureAwait( false );" is 161.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_Generic_List_1MessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_Generic_List_1MessagePackSerializer`1.cs,UnpackToAsyncCore,The length of the statement  "						collection.Add( await this._itemSerializer.UnpackFromAsync( subTreeUnpacker' cancellationToken ).ConfigureAwait( false ) );" is 123.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_Generic_Stack_1MessagePackSerializer<TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_Generic_Stack_1MessagePackSerializer`1.cs,UnpackFromAsyncCore,The length of the statement  "			return new Stack<TItem>( await this.UnpackItemsInReverseOrderAsync( unpacker' UnpackHelpers.GetItemsCount( unpacker )' cancellationToken ).ConfigureAwait( false ) );" is 165.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_Generic_Stack_1MessagePackSerializer<TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_Generic_Stack_1MessagePackSerializer`1.cs,UnpackToAsyncCore,The length of the statement  "			foreach ( var item in await this.UnpackItemsInReverseOrderAsync( unpacker' UnpackHelpers.GetItemsCount( unpacker )' cancellationToken ).ConfigureAwait( false ) )" is 161.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_StackMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_StackMessagePackSerializer.cs,UnpackFromAsyncCore,The length of the statement  "			return new Stack( await UnpackItemsInReverseOrderAsync( unpacker' UnpackHelpers.GetItemsCount( unpacker )' cancellationToken ).ConfigureAwait( false ) );" is 153.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_StackMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_StackMessagePackSerializer.cs,UnpackToAsyncCore,The length of the statement  "			foreach ( var item in await UnpackItemsInReverseOrderAsync( unpacker' UnpackHelpers.GetItemsCount( unpacker )' cancellationToken ).ConfigureAwait( false ) )" is 156.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_ObjectMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_ObjectMessagePackSerializer.cs,PackToCore,The length of the statement  "				// Prevents stack overflow -- System.Object cannot be serialized anyway because it does not have any properties/fields to serialize." is 132.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_ObjectMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_ObjectMessagePackSerializer.cs,PackToAsyncCore,The length of the statement  "				// Prevents stack overflow -- System.Object cannot be serialized anyway because it does not have any properties/fields to serialize." is 132.
Long Statement,MsgPack.Serialization.DefaultSerializers,TimestampFileTimeMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\TimestampFileTimeMessagePackSerializer.cs,UnpackFromCore,The length of the statement  "			return Timestamp.Decode( unpacker.LastReadData.DeserializeAsMessagePackExtendedTypeObject() ).ToDateTime().ToWin32FileTimeUtc();" is 128.
Long Statement,MsgPack.Serialization.DefaultSerializers,TimestampMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\TimestampMessagePackSerializer.cs,PackToAsyncCore,The length of the statement  "				await packer.PackAsync( MessagePackConvert.FromDateTimeOffset( objectTree.ToDateTimeOffset() )' cancellationToken ).ConfigureAwait( false );" is 140.
Long Statement,MsgPack.Serialization.EmittingSerializers,AndConditionILConstruct,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AndConditionILConstruct.cs,ToString,The length of the statement  "					CultureInfo.InvariantCulture' "And[{0}]: ({1})"' this.ContextType' String.Join( "' "' this._expressions.Select( e => e.ToString() ).ToArray() )" is 143.
Long Statement,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderEmittingContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderEmittingContext.cs,ResetCore,The length of the statement  "			var traits = targetType.GetCollectionTraits( CollectionTraitOptions.Full' this.SerializationContext.CompatibilityOptions.AllowNonCollectionEnumerableTypes );" is 157.
Long Statement,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderEmittingContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderEmittingContext.cs,DefineUnpackingContextCore,The length of the statement  "			DefineUnpackValueMethodArguments( type' out parameterInUnpackValueMethods' out parameterInSetValueMethods' out parameterInCreateObjectFromContext );" is 148.
Long Statement,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderEmittingContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderEmittingContext.cs,DefineUnpackingContextWithResultObjectCore,The length of the statement  "			DefineUnpackValueMethodArguments( type' out parameterInUnpackValueMethods' out parameterInSetValueMethods' out parameterInCreateObjectFromContext );" is 148.
Long Statement,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,MakeUInt64Literal,The length of the statement  "			return ILConstruct.Literal( TypeDefinition.UInt64Type' constant' il => il.EmitLdc_I8( unchecked( ( long )constant ) ) );" is 120.
Long Statement,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,EmitNotExpression,The length of the statement  "					String.Format( CultureInfo.CurrentCulture' "Not expression must be Boolean elementType' but actual is '{0}'."' booleanExpression.ContextType )'" is 143.
Long Statement,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,EmitGreaterThanExpression,The length of the statement  "			Contract.Assert( left.ContextType.ResolveRuntimeType().GetIsPrimitive() && left.ContextType.ResolveRuntimeType() != typeof( string ) );" is 135.
Long Statement,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,EmitLessThanExpression,The length of the statement  "			Contract.Assert( left.ContextType.ResolveRuntimeType().GetIsPrimitive() && left.ContextType.ResolveRuntimeType() != typeof( string ) );" is 135.
Long Statement,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,EmitMethodOfExpression,The length of the statement  "				// Both of this pointer for FieldBasedSerializerEmitter and context argument of methods for ContextBasedSerializerEmitter are 0." is 128.
Long Statement,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,EmitFieldOfExpression,The length of the statement  "				// Both of this pointer for FieldBasedSerializerEmitter and context argument of methods for ContextBasedSerializerEmitter are 0." is 128.
Long Statement,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,EmitSetIndexedProperty,The length of the statement  "			var indexer = declaringType.ResolveRuntimeType().GetProperty( proeprtyName' new[] { key.ContextType.ResolveRuntimeType() } );" is 125.
Long Statement,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,CreateSerializerConstructor,The length of the statement  "			return context => codeGenerationContext.Emitter.CreateObjectInstance( codeGenerationContext' this' targetInfo' schema' capabilities );" is 134.
Long Statement,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,CreateEnumSerializerConstructor,The length of the statement  "					EnumMessagePackSerializerHelpers.DetermineEnumSerializationMethod( context' this.TargetType' EnumMemberSerializationMethod.Default )" is 132.
Long Statement,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,EmitGetActionsExpression,The length of the statement  "						isAsync ? typeof( IList<> ).MakeGenericType( typeof( Func<'''> ).MakeGenericType( typeof( Packer )' this.TargetType' typeof( CancellationToken )' typeof( Task ) ) ) :" is 166.
Long Statement,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,EmitGetActionsExpression,The length of the statement  "						isAsync ? typeof( IDictionary<'> ).MakeGenericType( typeof( string )' typeof( Func<'''> ).MakeGenericType( typeof( Packer )' this.TargetType' typeof( CancellationToken )' typeof( Task ) ) ) :" is 191.
Long Statement,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,EmitGetActionsExpression,The length of the statement  "						typeof( IDictionary<'> ).MakeGenericType( typeof( string )' typeof( Action<'> ).MakeGenericType( typeof( Packer )' this.TargetType ) );" is 135.
Long Statement,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,EmitGetActionsExpression,The length of the statement  "					type = typeof( IDictionary<'> ).MakeGenericType( typeof( string )' typeof( Func<'> ).MakeGenericType( this.TargetType' typeof( bool ) ) );" is 138.
Long Statement,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,EmitGetActionsExpression,The length of the statement  "						isAsync ? typeof( Func<''''> ).MakeGenericType( typeof( Packer )' this.TargetType' typeof( int )' typeof( CancellationToken )' typeof( Task ) ) :" is 145.
Long Statement,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,BuildSerializerCodeCore,The length of the statement  "				emittingContext.Emitter.CreateObjectConstructor( emittingContext' this' targetInfo' targetInfo.GetCapabilitiesForObject() );" is 124.
Long Statement,MsgPack.Serialization.EmittingSerializers,BinaryOperatorILConstruct,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\BinaryOperatorILConstruct.cs,ToString,The length of the statement  "			return String.Format( CultureInfo.InvariantCulture' "BinaryOperator[{0}]: ({2} {1} {3})"' this.ContextType' this._operator' this._left' this._right );" is 150.
Long Statement,MsgPack.Serialization.EmittingSerializers,ILConstruct,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\ILConstruct.cs,Literal,The length of the statement  "			return new SinglelStepILConstruct( type' "literal " + ( literalValue == null ? "(null)" : literalValue.ToString() )' false' instruction );" is 138.
Long Statement,MsgPack.Serialization.EmittingSerializers,ILConstruct,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\ILConstruct.cs,ValidateContextTypeMatch,The length of the statement  "			if ( GetNormalizedType( left.ContextType.ResolveRuntimeType() ) != GetNormalizedType( right.ContextType.ResolveRuntimeType() ) )" is 128.
Long Statement,MsgPack.Serialization.EmittingSerializers,SerializationMethodGeneratorManager,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializationMethodGeneratorManager.cs,Get,The length of the statement  "			return Get( SerializerDebugging.DumpEnabled ? SerializationMethodGeneratorOption.CanDump : SerializationMethodGeneratorOption.Fast );" is 133.
Long Statement,MsgPack.Serialization.EmittingSerializers,SerializationMethodGeneratorManager,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializationMethodGeneratorManager.cs,SetUpAssemblyBuilderAttributes,The length of the statement  "				dedicatedAssemblyBuilder.SetCustomAttribute( new CustomAttributeBuilder( _debuggableAttributeCtor' _debuggableAttributeCtorArguments ) );" is 137.
Long Statement,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,DefineMethod,The length of the statement  "				throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "Method {0} is already defined."' methodName ) );" is 129.
Long Statement,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,RegisterSerializer,The length of the statement  "			var key = new SerializerFieldKey( targetType' enumMemberSerializationMethod' dateTimeConversionMethod' polymorphismSchema );" is 124.
Long Statement,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,DefineUnpackingContext,The length of the statement  "					TypeAttributes.Class | TypeAttributes.UnicodeClass | TypeAttributes.NotPublic | TypeAttributes.Sealed | TypeAttributes.BeforeFieldInit" is 134.
Long Statement,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,CreateObjectInstance,The length of the statement  "			return this.CreateObjectConstructor( context' builder' targetInfo' capabilities )( context.SerializationContext' schema );" is 122.
Long Statement,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,CreateObjectConstructor,The length of the statement  "			var hasUnpackAsyncActionTables = hasUnpackAsyncActions && targetInfo.Members.Any( m => m.Member != null ); // Except tuples" is 123.
Long Statement,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,CreateObjectConstructor,The length of the statement  "			Func<ILConstruct> nullCheckerTableInitializtion = () => builder.EmitPackNullCheckerTableInitialization( context' targetInfo );" is 126.
Long Statement,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,CreateObjectConstructor,The length of the statement  "				isAsync => new Func<ILConstruct>( () => builder.EmitUnpackOperationListInitialization( context' targetInfo' isAsync ) );" is 120.
Long Statement,MsgPack.Serialization.EmittingSerializers,SerializerEmitter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializerEmitter.cs,CreateObjectConstructor,The length of the statement  "				isAsync => new Func<ILConstruct>( () => builder.EmitUnpackOperationTableInitialization( context' targetInfo' isAsync ) );" is 121.
Long Statement,MsgPack.Serialization.EmittingSerializers,StatementExpressionILConstruct,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\StatementExpressionILConstruct.cs,ToString,The length of the statement  "			return String.Format( CultureInfo.InvariantCulture' "Bind[{0}]: {1} context: {2}"' this.ContextType' this._binding' this._expression );" is 135.
Long Statement,MsgPack.Serialization.EmittingSerializers,UnaryOperatorILConstruct,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\UnaryOperatorILConstruct.cs,ToString,The length of the statement  "			return String.Format( CultureInfo.InvariantCulture' "UnaryOperator[{0}]: ({1} {2})"' this.ContextType' this._operator' this._input );" is 133.
Long Statement,MsgPack.Serialization.EmittingSerializers,VariableILConstruct,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\VariableILConstruct.cs,ToString,The length of the statement  "			return String.Format( CultureInfo.InvariantCulture' "Variable[{0}]: [{2}{3}]{1}({0})"' this.ContextType' this._name' this._isLocal ? "local" : "arg"' this._index );" is 164.
Long Statement,MsgPack.Serialization.Metadata,_IEnumerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Metadata\_IEnumreator.cs,FindEnumeratorCurrentProperty,The length of the statement  "						currentProperty = typeof( IEnumerator<> ).MakeGenericType( traits.ElementType ).GetProperty( nameof( IEnumerator<object>.Current ) );" is 133.
Long Statement,MsgPack.Serialization.Metadata,_IEnumerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Metadata\_IEnumreator.cs,FindEnumeratorMoveNextMethod,The length of the statement  "			var moveNextMethod = enumeratorType.GetMethod( nameof( IEnumerator<object>.MoveNext )' ReflectionAbstractions.EmptyTypes );" is 123.
Long Statement,MsgPack.Serialization.Polymorphic,KnownTypePolymorphicMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\KnownTypePolymorphicMessagePackSerializer`1.cs,PackToAsyncCore,The length of the statement  "			await this.GetActualTypeSerializer( objectTree.GetType() ).PackToAsync( packer' objectTree' cancellationToken ).ConfigureAwait( false );" is 136.
Long Statement,MsgPack.Serialization.Polymorphic,RuntimeTypeVerifier,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\RuntimeTypeVerifier.cs,Verify,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "Type verifier rejects type '{0}'"' typeFullName + "' " + assemblyFullName ) );" is 156.
Long Statement,MsgPack.Serialization.Polymorphic,TypeEmbedingPolymorphicMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeEmbedingPolymorphicMessagePackSerializer`1.cs,PackToAsyncCore,The length of the statement  "			await this.GetActualTypeSerializer( objectTree.GetType() ).PackToAsync( packer' objectTree' cancellationToken ).ConfigureAwait( false );" is 136.
Long Statement,MsgPack.Serialization.Polymorphic,TypeEmbedingPolymorphicMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeEmbedingPolymorphicMessagePackSerializer`1.cs,UnpackFromAsyncCore,The length of the statement  "					( u' c ) => TypeInfoEncoder.DecodeRuntimeTypeInfoAsync( u' this._schema.TypeVerifier' c )' // Lamda capture is more efficient." is 126.
Long Statement,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,ThrowUnknownEncodingType,The length of the statement  "			throw new SerializationException( String.Format( CultureInfo.InvariantCulture' "Unknown encoded type : {0}"' encodeType ) );" is 124.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionEnumMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionEnumMessagePackSerializer`1.cs,PackUnderlyingValueTo,The length of the statement  "			packer.Pack( UInt64.Parse( ( ( IFormattable ) enumValue ).ToString( "D"' CultureInfo.InvariantCulture )' CultureInfo.InvariantCulture ) );" is 138.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionEnumMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionEnumMessagePackSerializer`1.cs,PackUnderlyingValueToAsync,The length of the statement  "			return packer.PackAsync( UInt64.Parse( ( ( IFormattable )enumValue ).ToString( "D"' CultureInfo.InvariantCulture )' CultureInfo.InvariantCulture )' cancellationToken );" is 168.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,PackToAsyncCore,The length of the statement  "						await packer.PackStringAsync( this.OwnerContext.DictionarySerializationOptions.SafeKeyTransformer( this._contracts[ i ].Name )' cancellationToken ).ConfigureAwait( false );" is 172.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,PackToAsyncCore,The length of the statement  "						await packer.PackStringAsync( this.OwnerContext.DictionarySerializationOptions.SafeKeyTransformer( this._contracts[ i ].Name )' cancellationToken ).ConfigureAwait( false );" is 172.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackMemberValue,The length of the statement  "					else if ( index < this._getters.Length && this._getters[ index ] != null ) // null getter supposes undeclared member (should be treated as nil)" is 143.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackAndAddCollectionItem,The length of the statement  "			var traits = destination.GetType().GetCollectionTraits( CollectionTraitOptions.WithAddMethod' this.OwnerContext.CompatibilityOptions.AllowNonCollectionEnumerableTypes );" is 169.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackFromAsyncCore,The length of the statement  "					result = await this.UnpackMemberValueAsync( result' unpacker' itemsCount' unpacked' i' i' cancellationToken ).ConfigureAwait( false );" is 134.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackFromAsyncCore,The length of the statement  "					result = await this.UnpackMemberValueAsync( result' unpacker' itemsCount' unpacked' index' i' cancellationToken ).ConfigureAwait( false );" is 138.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackAndAddCollectionItemAsync,The length of the statement  "			var traits = destination.GetType().GetCollectionTraits( CollectionTraitOptions.WithAddMethod' this.OwnerContext.CompatibilityOptions.AllowNonCollectionEnumerableTypes );" is 169.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackAndAddCollectionItemAsync,The length of the statement  "			var source = await this._serializers[ index ].UnpackFromAsync( unpacker' cancellationToken ).ConfigureAwait( false ) as IEnumerable;" is 132.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,CreateCollectionSerializer,The length of the statement  "			var targetInfo = UnpackHelpers.DetermineCollectionSerializationStrategy( targetType' context.CompatibilityOptions.AllowAsymmetricSerializer );" is 142.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,CreateCollectionSerializer,The length of the statement  "						new ReflectionNonGenericCollectionMessagePackSerializer( context' typeof( T )' targetType' traits' schema' targetInfo );" is 120.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,CreateCollectionSerializer,The length of the statement  "						new ReflectionNonGenericEnumerableMessagePackSerializer( context' typeof( T )' targetType' traits' schema' targetInfo );" is 120.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,CreateCollectionSerializer,The length of the statement  "						new ReflectionNonGenericDictionaryMessagePackSerializer( context' typeof( T )' targetType' traits' schema' targetInfo );" is 120.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,GetAddItem,The length of the statement  "						"Reflection based serializer only supports collection types which implement interface to add new item such as '{0}' and '{1}'"'" is 127.
Long Statement,MsgPack.Serialization.ReflectionSerializers,NonGenericEnumerableSerializerFactory<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The length of the statement  "				return new ReflectionNonGenericEnumerableMessagePackSerializer<T>( context' targetType' collectionTraits' schema' targetInfo );" is 127.
Long Statement,MsgPack.Serialization.ReflectionSerializers,NonGenericCollectionSerializerFactory<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The length of the statement  "				return new ReflectionNonGenericCollectionMessagePackSerializer<T>( context' targetType' collectionTraits' schema' targetInfo );" is 127.
Long Statement,MsgPack.Serialization.ReflectionSerializers,NonGenericListSerializerFactory<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The length of the statement  "				return new ReflectionNonGenericListMessagePackSerializer<T>( context' targetType' collectionTraits' schema' targetInfo );" is 121.
Long Statement,MsgPack.Serialization.ReflectionSerializers,NonGenericDictionarySerializerFactory<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The length of the statement  "				return new ReflectionNonGenericDictionaryMessagePackSerializer<T>( context' targetType' collectionTraits' schema' targetInfo );" is 127.
Long Statement,MsgPack.Serialization.ReflectionSerializers,EnumerableSerializerFactory<TCollection;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The length of the statement  "				return new ReflectionEnumerableMessagePackSerializer<TCollection' TItem>( context' targetType' collectionTraits' itemSchema' targetInfo );" is 138.
Long Statement,MsgPack.Serialization.ReflectionSerializers,CollectionSerializerFactory<TCollection;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The length of the statement  "				return new ReflectionCollectionMessagePackSerializer<TCollection' TItem>( context' targetType' collectionTraits' itemSchema' targetInfo );" is 138.
Long Statement,MsgPack.Serialization.ReflectionSerializers,DictionarySerializerFactory<TDictionary;TKey;TValue>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The length of the statement  "				return new ReflectionDictionaryMessagePackSerializer<TDictionary' TKey' TValue>( context' targetType' collectionTraits' schema' targetInfo );" is 141.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionTupleMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionTupleMessagePackSerializer`1.cs,PackToAsyncCore,The length of the statement  "				await this._itemSerializers[ i ].PackToAsync( packer' this._getters[ i ]( objectTree )' cancellationToken ).ConfigureAwait( false );" is 132.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionTupleMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionTupleMessagePackSerializer`1.cs,UnpackFromAsyncCore,The length of the statement  "				unpackedItems.Add( await this._itemSerializers[ i ].UnpackFromAsync( unpacker' cancellationToken ).ConfigureAwait( false ) );" is 125.
Long Statement,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitThrowNewExceptionWithInnerException,The length of the statement  "				throw new NotSupportedException( String.Format( CultureInfo.CurrentCulture' "Exception type '{0}' does not have standard constructor '.ctor(String' Exception)'."' exceptionType ) );" is 181.
Long Statement,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitExceptionBlock,The length of the statement  "			Contract.Assert( Contract.ForAll( remainingCatchBlockEmitters' item => item != null && item.Item1 != null && item.Item2 != null ) );" is 132.
Long Statement,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitExceptionBlock,The length of the statement  "			Contract.Assert( Contract.ForAll( catchBlockEmitters' item => item != null && item.Item1 != null && item.Item2 != null ) );" is 123.
Long Statement,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitCalli,The length of the statement  "			this._underlying.EmitCalli( OpCodes.Calli' managedCallingConventions' returnType' requiredParameterTypes' optionalParameterTypes );" is 131.
Long Statement,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,WriteType,The length of the statement  "				writer.Write( "[{0}]{1}"' endOfAssemblySimpleName < 0 ? type.Assembly.FullName : type.Assembly.FullName.Remove( endOfAssemblySimpleName )' type.FullName );" is 155.
Long Statement,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,TraceField,The length of the statement  "			if ( this._isInDynamicMethod || asFieldBuilder == null ) // declaring type of the field should be omitted for same type." is 120.
Long Statement,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,TraceMethod,The length of the statement  "			else if ( this._isInDynamicMethod || !isMethodBuilder ) // declaring type of the method should be omitted for same type." is 120.
Long Statement,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,TraceMethod,The length of the statement  "					WriteType( this._trace' parameters[ i ].ParameterType.IsByRef ? parameters[ i ].ParameterType.GetElementType() : parameters[ i ].ParameterType );" is 145.
Complex Conditional,MsgPack,MessagePackStringDebuggerProxy,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,MustBeString,The conditional expression  "c < 0x20 && ( c != 0x9 && c != 0xA && c != 0xD )"  is complex.
Complex Conditional,MsgPack,Validation,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Validation.cs,ValidateNamespace,The conditional expression  "matches.Count == 1 && matches[ 0 ].Success && matches[ 0 ].Index == 0 && matches[ 0 ].Length == @namespace.Length"  is complex.
Complex Conditional,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitStoreCollectionItemsEmitSetCollectionMemberIfNullAndSettable,The conditional expression  "storeCollectionItems != null && ( asField != null && asField.IsInitOnly ) || ( asProperty != null && asProperty.GetSetMethod( true ) == null )"  is complex.
Complex Conditional,MsgPack.Serialization,DefaultConcreteTypeRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultConcreteTypeRepository.cs,Register,The conditional expression  "!abstractCollectionType.IsAssignableFrom( defaultCollectionType ) 				 && abstractCollectionType.GetIsGenericTypeDefinition() 				 && !defaultCollectionType 						 .GetInterfaces() 						 .Select( t => ( t.GetIsGenericType() && !t.GetIsGenericTypeDefinition() ) ? t.GetGenericTypeDefinition() : t ) 						 .Contains( abstractCollectionType ) 				 && !IsAnscestorType( abstractCollectionType' defaultCollectionType )"  is complex.
Complex Conditional,MsgPack.Serialization,MessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,InternalPackSingleObject,The conditional expression  "( typeof( T ).GetIsValueType() && !isT ) 				|| ( ( objectTree != null && !isT ) )"  is complex.
Complex Conditional,MsgPack.Serialization,MessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,InternalPackSingleObjectAsync,The conditional expression  "( typeof( T ).GetIsValueType() && !isT ) 				|| ( ( objectTree != null && !isT ) )"  is complex.
Complex Conditional,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,VerifyCanSerializeTargetType,The conditional expression  "context.SerializerOptions.DisablePrivilegedAccess && !targetType.GetIsPublic() && !targetType.GetIsNestedPublic() && !ThisAssembly.Equals( targetType.GetAssembly() )"  is complex.
Complex Conditional,MsgPack.Serialization,SerializationTarget,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,Prepare,The conditional expression  "getters.Length == 0 				&& !typeof( IPackable ).IsAssignableFrom( targetType ) 				&& !typeof( IUnpackable ).IsAssignableFrom( targetType ) #if FEATURE_TAP 				&& ( context.SerializerOptions.WithAsync 					&& ( !typeof( IAsyncPackable ).IsAssignableFrom( targetType ) 						&& !typeof( IAsyncUnpackable ).IsAssignableFrom( targetType ) 					) 				)"  is complex.
Complex Conditional,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,Finish,The conditional expression  "( !typeof( IPackable ).IsAssignableFrom( this.TargetType ) #if FEATURE_TAP 									|| ( !typeof( IAsyncPackable ).IsAssignableFrom( this.TargetType ) && this.WithAsync( context ) ) #endif // FEATURE_TAP 									) #if DEBUG 									&& !SerializerDebugging.UseLegacyNullMapEntryHandling"  is complex.
Complex Conditional,MsgPack.Serialization.EmittingSerializers,ILConstruct,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\ILConstruct.cs,GetNormalizedType,The conditional expression  "type == typeof( sbyte ) || type == typeof( short ) || type == typeof( int ) || 				type == typeof( byte ) || type == typeof( ushort ) || type == typeof( uint )"  is complex.
Empty Catch Block,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,GetAddItem,The method has an empty catch block.
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt16,The following statement contains a magic number: return ( short )( buffer[ offset ] << 8 | buffer[ 1 + offset ] );
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt32,The following statement contains a magic number: return buffer[ offset ] << 24 | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ];
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt32,The following statement contains a magic number: return buffer[ offset ] << 24 | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ];
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt32,The following statement contains a magic number: return buffer[ offset ] << 24 | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ];
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt32,The following statement contains a magic number: return buffer[ offset ] << 24 | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ];
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt32,The following statement contains a magic number: return buffer[ offset ] << 24 | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ];
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: return 					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: return 					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: return 					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: return 					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: return 					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: return 					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: return 					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: return 					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: return 					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: return 					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: return 					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: return 					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: return 					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt16,The following statement contains a magic number: return ( ushort )( ( buffer[ offset ] << 8 ) | buffer[ 1 + offset ] );
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt32,The following statement contains a magic number: return ( uint )( ( buffer[ offset ] << 24 ) | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ] );
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt32,The following statement contains a magic number: return ( uint )( ( buffer[ offset ] << 24 ) | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ] );
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt32,The following statement contains a magic number: return ( uint )( ( buffer[ offset ] << 24 ) | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ] );
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt32,The following statement contains a magic number: return ( uint )( ( buffer[ offset ] << 24 ) | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ] );
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt32,The following statement contains a magic number: return ( uint )( ( buffer[ offset ] << 24 ) | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ] );
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: return 					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: return 					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: return 					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: return 					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: return 					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: return 					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: return 					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: return 					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: return 					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: return 					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: return 					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: return 					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );
Magic Number,MsgPack,BigEndianBinary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: return 					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );
Magic Number,MsgPack,Binary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToHexString,The following statement contains a magic number: var buffer = new StringBuilder( blob.Length * 2 + (withPrefix ? 2 : 0 ) );
Magic Number,MsgPack,Binary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToHexString,The following statement contains a magic number: var buffer = new StringBuilder( blob.Length * 2 + (withPrefix ? 2 : 0 ) );
Magic Number,MsgPack,Binary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToHexStringCore,The following statement contains a magic number: buffer.Append( ToHexChar( b >> 4 ) );
Magic Number,MsgPack,Binary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToHexChar,The following statement contains a magic number: b < 10
Magic Number,MsgPack,Binary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToBits,The following statement contains a magic number: result = bits.Byte3 << 24;
Magic Number,MsgPack,Binary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToBits,The following statement contains a magic number: result |= bits.Byte2 << 16;
Magic Number,MsgPack,Binary,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToBits,The following statement contains a magic number: result |= bits.Byte1 << 8;
Magic Number,MsgPack,Float32Bits,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Float32Bits.cs,Float32Bits,The following statement contains a magic number: Contract.Assert( bigEndianBytes.Length - offset >= 4' bigEndianBytes.Length + "-" + offset + ">= 4" );
Magic Number,MsgPack,Float32Bits,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Float32Bits.cs,Float32Bits,The following statement contains a magic number: this.Byte0 = bigEndianBytes[ offset + 3 ];
Magic Number,MsgPack,Float32Bits,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Float32Bits.cs,Float32Bits,The following statement contains a magic number: this.Byte1 = bigEndianBytes[ offset + 2 ];
Magic Number,MsgPack,Float64Bits,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: Contract.Assert( bigEndianBytes.Length - offset >= 8' bigEndianBytes.Length + "-" + offset + ">= 4" );
Magic Number,MsgPack,Float64Bits,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: this.Byte0 = bigEndianBytes[ offset + 7 ];
Magic Number,MsgPack,Float64Bits,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: this.Byte1 = bigEndianBytes[ offset + 6 ];
Magic Number,MsgPack,Float64Bits,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: this.Byte2 = bigEndianBytes[ offset + 5 ];
Magic Number,MsgPack,Float64Bits,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: this.Byte3 = bigEndianBytes[ offset + 4 ];
Magic Number,MsgPack,Float64Bits,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: this.Byte4 = bigEndianBytes[ offset + 3 ];
Magic Number,MsgPack,Float64Bits,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: this.Byte5 = bigEndianBytes[ offset + 2 ];
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length ) 				{ 					case 1: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt1 ); 						break; 					} 					case 2: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt2 ); 						break; 					} 					case 4: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt4 ); 						break; 					} 					case 8: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt8 ); 						break; 					} 					case 16: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt16 ); 						break; 					} 					default: 					{ 						if ( body.Length < 0x100 ) 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length ); 						} 						else 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length ); 						}  						break; 					} 				}
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length ) 				{ 					case 1: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt1 ); 						break; 					} 					case 2: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt2 ); 						break; 					} 					case 4: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt4 ); 						break; 					} 					case 8: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt8 ); 						break; 					} 					case 16: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt16 ); 						break; 					} 					default: 					{ 						if ( body.Length < 0x100 ) 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length ); 						} 						else 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length ); 						}  						break; 					} 				}
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length ) 				{ 					case 1: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt1 ); 						break; 					} 					case 2: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt2 ); 						break; 					} 					case 4: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt4 ); 						break; 					} 					case 8: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt8 ); 						break; 					} 					case 16: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt16 ); 						break; 					} 					default: 					{ 						if ( body.Length < 0x100 ) 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length ); 						} 						else 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length ); 						}  						break; 					} 				}
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length ) 				{ 					case 1: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt1 ); 						break; 					} 					case 2: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt2 ); 						break; 					} 					case 4: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt4 ); 						break; 					} 					case 8: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt8 ); 						break; 					} 					case 16: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt16 ); 						break; 					} 					default: 					{ 						if ( body.Length < 0x100 ) 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length ); 						} 						else 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length ); 						}  						break; 					} 				}
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length ) 				{ 					case 1: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 2: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 4: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 8: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 16: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					default: 					{ 						if ( body.Length < 0x100 ) 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext8' ( byte )body.Length' cancellationToken ).ConfigureAwait( false ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext16' ( ushort )body.Length' cancellationToken ).ConfigureAwait( false ); 						} 						else 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext32' ( uint )body.Length' cancellationToken ).ConfigureAwait( false ); 						}  						break; 					} 				}
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length ) 				{ 					case 1: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 2: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 4: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 8: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 16: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					default: 					{ 						if ( body.Length < 0x100 ) 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext8' ( byte )body.Length' cancellationToken ).ConfigureAwait( false ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext16' ( ushort )body.Length' cancellationToken ).ConfigureAwait( false ); 						} 						else 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext32' ( uint )body.Length' cancellationToken ).ConfigureAwait( false ); 						}  						break; 					} 				}
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length ) 				{ 					case 1: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 2: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 4: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 8: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 16: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					default: 					{ 						if ( body.Length < 0x100 ) 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext8' ( byte )body.Length' cancellationToken ).ConfigureAwait( false ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext16' ( ushort )body.Length' cancellationToken ).ConfigureAwait( false ); 						} 						else 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext32' ( uint )body.Length' cancellationToken ).ConfigureAwait( false ); 						}  						break; 					} 				}
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length ) 				{ 					case 1: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 2: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 4: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 8: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 16: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					default: 					{ 						if ( body.Length < 0x100 ) 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext8' ( byte )body.Length' cancellationToken ).ConfigureAwait( false ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext16' ( ushort )body.Length' cancellationToken ).ConfigureAwait( false ); 						} 						else 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext32' ( uint )body.Length' cancellationToken ).ConfigureAwait( false ); 						}  						break; 					} 				}
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset ] = unchecked( ( byte )( value >> ( ( sizeof( byte ) - 1 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset ] = unchecked( ( byte )( value >> ( ( sizeof( ushort ) - 1 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( value >> ( ( sizeof( ushort ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( value >> ( ( sizeof( ushort ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 1 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 1 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 4 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 5 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 4 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 5 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 4 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 5 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 5 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 6 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 5 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 6 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 5 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 6 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 6 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 7 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 6 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 7 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 6 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 7 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 7 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 8 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 7 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 8 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 7 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 8 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 1 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 1 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 4 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 5 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 4 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 5 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 4 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 5 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 5 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 6 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 5 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 6 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 5 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 6 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 6 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 7 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 6 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 7 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 6 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 7 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 7 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 8 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 7 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 8 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 7 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 8 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadByteSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadSByteSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadInt16Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadUInt16Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadInt32Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadUInt32Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadInt64Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadUInt64Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadSingleSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadDoubleSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadBinary,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( Byte[] ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Raw16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( Byte[] ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( Byte[] ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( Byte[] ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Raw16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( Byte[] ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( Byte[] ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( Byte[] ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Raw16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( Byte[] ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( Byte[] ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( Byte[] ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Raw16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( Byte[] ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( Byte[] ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadString,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( String ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Raw16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( String ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( String ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( String ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Raw16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( String ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( String ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( String ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Raw16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( String ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( String ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( String ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Raw16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( String ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( String ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = source[ offset ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt16( source' offset ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = BigEndianBinary.ToUInt32( source' offset ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = source[ offset ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )source[ offset ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = source[ offset ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt16( source' offset ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt32( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToUInt64( source' offset ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToSingle( source' offset ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					if ( source.Length - offset < 8 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = BigEndianBinary.ToDouble( source' offset ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadArrayLength,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Array8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Array16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Array32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Array8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Array16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Array32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Array8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Array16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Array32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Array8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Array16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Array32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMapLength,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Map8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Map16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Map32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Map8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Map16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Map32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Map8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Map16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Map32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Map8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Map16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Map32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackExtendedTypeObject ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Ext16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackExtendedTypeObject ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackExtendedTypeObject ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackExtendedTypeObject ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Ext16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackExtendedTypeObject ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackExtendedTypeObject ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackExtendedTypeObject ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Ext16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackExtendedTypeObject ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackExtendedTypeObject ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackExtendedTypeObject ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Ext16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackExtendedTypeObject ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackExtendedTypeObject ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackExtendedTypeObject? ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Ext16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackExtendedTypeObject? ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackExtendedTypeObject? ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackExtendedTypeObject? ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Ext16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackExtendedTypeObject? ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackExtendedTypeObject? ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackExtendedTypeObject? ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Ext16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackExtendedTypeObject? ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackExtendedTypeObject? ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( source.Length - offset < 1 ) 					{ 						result = default( MessagePackExtendedTypeObject? ); 						return false; 					}  					length = BigEndianBinary.ToByte( source' offset );  					break; 				} 				case 2: // Ext16 				{ 					if ( source.Length - offset < 2 ) 					{ 						result = default( MessagePackExtendedTypeObject? ); 						return false; 					}  					length = BigEndianBinary.ToUInt16( source' offset );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					if ( source.Length - offset < 4 ) 					{ 						result = default( MessagePackExtendedTypeObject? ); 						return false; 					}  					length = BigEndianBinary.ToUInt32( source' offset );  					break; 				} 			}
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,ToString,The following statement contains a magic number: var buffer = new StringBuilder( 7 + this._body.Length * 2 );
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,ToString,The following statement contains a magic number: var buffer = new StringBuilder( 7 + this._body.Length * 2 );
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: int hashCode = this._typeCode << 24;
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: int hashCodeTargetLength = Math.Min( this._body.Length / 4' 8 );
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: int hashCodeTargetLength = Math.Min( this._body.Length / 4' 8 );
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: temp |= ( uint )( this._body[ i + 1 ] << 8 );
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: temp |= ( uint )( this._body[ i + 2 ] << 16 );
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: temp |= ( uint )( this._body[ i + 2 ] << 16 );
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: temp |= ( uint )( this._body[ i + 3 ] << 24 );
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: temp |= ( uint )( this._body[ i + 3 ] << 24 );
Magic Number,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: this._value |=  ( ulong )( bytes[ 3 ] << 24 );
Magic Number,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: this._value |=  ( ulong )( bytes[ 3 ] << 24 );
Magic Number,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: this._value |=  ( ulong )( bytes[ 2 ] << 16 );
Magic Number,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: this._value |=  ( ulong )( bytes[ 2 ] << 16 );
Magic Number,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: this._value |=  ( ulong )( bytes[ 1 ] << 8 );
Magic Number,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,AsStringUtf16,The following statement contains a magic number: asBytes.Length % 2 != 0
Magic Number,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,AsStringUtf16,The following statement contains a magic number: return Encoding.Unicode.GetString( asBytes' 2' asBytes.Length - 2 );
Magic Number,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,AsStringUtf16,The following statement contains a magic number: return Encoding.Unicode.GetString( asBytes' 2' asBytes.Length - 2 );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length ) 				{ 					case 1: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt1 ); 						break; 					} 					case 2: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt2 ); 						break; 					} 					case 4: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt4 ); 						break; 					} 					case 8: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt8 ); 						break; 					} 					case 16: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt16 ); 						break; 					} 					default: 					{ 						if ( body.Length < 0x100 ) 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length ); 						} 						else 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length ); 						}  						break; 					} 				}
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length ) 				{ 					case 1: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt1 ); 						break; 					} 					case 2: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt2 ); 						break; 					} 					case 4: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt4 ); 						break; 					} 					case 8: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt8 ); 						break; 					} 					case 16: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt16 ); 						break; 					} 					default: 					{ 						if ( body.Length < 0x100 ) 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length ); 						} 						else 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length ); 						}  						break; 					} 				}
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length ) 				{ 					case 1: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt1 ); 						break; 					} 					case 2: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt2 ); 						break; 					} 					case 4: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt4 ); 						break; 					} 					case 8: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt8 ); 						break; 					} 					case 16: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt16 ); 						break; 					} 					default: 					{ 						if ( body.Length < 0x100 ) 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length ); 						} 						else 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length ); 						}  						break; 					} 				}
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length ) 				{ 					case 1: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt1 ); 						break; 					} 					case 2: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt2 ); 						break; 					} 					case 4: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt4 ); 						break; 					} 					case 8: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt8 ); 						break; 					} 					case 16: 					{ 						this.WriteByte( ( byte )MessagePackCode.FixExt16 ); 						break; 					} 					default: 					{ 						if ( body.Length < 0x100 ) 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length ); 						} 						else 						{ 							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length ); 						}  						break; 					} 				}
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length ) 				{ 					case 1: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 2: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 4: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 8: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 16: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					default: 					{ 						if ( body.Length < 0x100 ) 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext8' ( byte )body.Length' cancellationToken ).ConfigureAwait( false ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext16' ( ushort )body.Length' cancellationToken ).ConfigureAwait( false ); 						} 						else 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext32' ( uint )body.Length' cancellationToken ).ConfigureAwait( false ); 						}  						break; 					} 				}
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length ) 				{ 					case 1: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 2: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 4: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 8: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 16: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					default: 					{ 						if ( body.Length < 0x100 ) 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext8' ( byte )body.Length' cancellationToken ).ConfigureAwait( false ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext16' ( ushort )body.Length' cancellationToken ).ConfigureAwait( false ); 						} 						else 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext32' ( uint )body.Length' cancellationToken ).ConfigureAwait( false ); 						}  						break; 					} 				}
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length ) 				{ 					case 1: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 2: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 4: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 8: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 16: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					default: 					{ 						if ( body.Length < 0x100 ) 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext8' ( byte )body.Length' cancellationToken ).ConfigureAwait( false ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext16' ( ushort )body.Length' cancellationToken ).ConfigureAwait( false ); 						} 						else 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext32' ( uint )body.Length' cancellationToken ).ConfigureAwait( false ); 						}  						break; 					} 				}
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length ) 				{ 					case 1: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 2: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 4: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 8: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					case 16: 					{ 						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false ); 						break; 					} 					default: 					{ 						if ( body.Length < 0x100 ) 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext8' ( byte )body.Length' cancellationToken ).ConfigureAwait( false ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext16' ( ushort )body.Length' cancellationToken ).ConfigureAwait( false ); 						} 						else 						{ 							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext32' ( uint )body.Length' cancellationToken ).ConfigureAwait( false ); 						}  						break; 					} 				}
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( value >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( value & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( value >> 56 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value >> 48 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value >> 48 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( value >> 40 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( value >> 40 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( value >> 32 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( value >> 32 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 5 ] = unchecked( ( byte )( value >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 5 ] = unchecked( ( byte )( value >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 6 ] = unchecked( ( byte )( value >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 6 ] = unchecked( ( byte )( value >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 7 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 7 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 8 ] = unchecked( ( byte )( value & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( bits >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( bits >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( bits >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( bits >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( bits >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( bits & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( bits >> 56 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( bits >> 48 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( bits >> 48 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( bits >> 40 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( bits >> 40 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( bits >> 32 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( bits >> 32 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 5 ] = unchecked( ( byte )( bits >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 5 ] = unchecked( ( byte )( bits >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 6 ] = unchecked( ( byte )( bits >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 6 ] = unchecked( ( byte )( bits >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 7 ] = unchecked( ( byte )( bits >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 7 ] = unchecked( ( byte )( bits >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 8 ] = unchecked( ( byte )( bits & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteStringBody,The following statement contains a magic number: var buffer = BufferManager.NewByteBuffer( value.Length * 4 );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( value >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( value & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( value >> 56 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value >> 48 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value >> 48 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( value >> 40 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( value >> 40 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( value >> 32 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( value >> 32 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 5 ] = unchecked( ( byte )( value >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 5 ] = unchecked( ( byte )( value >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 6 ] = unchecked( ( byte )( value >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 6 ] = unchecked( ( byte )( value >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 7 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 7 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 8 ] = unchecked( ( byte )( value & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( bits >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( bits >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( bits >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( bits >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( bits >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( bits & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( bits >> 56 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( bits >> 48 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( bits >> 48 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( bits >> 40 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( bits >> 40 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( bits >> 32 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( bits >> 32 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 5 ] = unchecked( ( byte )( bits >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 5 ] = unchecked( ( byte )( bits >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 6 ] = unchecked( ( byte )( bits >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 6 ] = unchecked( ( byte )( bits >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 7 ] = unchecked( ( byte )( bits >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 7 ] = unchecked( ( byte )( bits >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 8 ] = unchecked( ( byte )( bits & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteStringBodyAsync,The following statement contains a magic number: var buffer = BufferManager.NewByteBuffer( value.Length * 4 );
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringCore,The following statement contains a magic number: var byteBuffer = BufferManager.NewByteBuffer( length * 4 );
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringCoreAsync,The following statement contains a magic number: var byteBuffer = BufferManager.NewByteBuffer( length * 4 );
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadByteSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadByteSlowAsync,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSByteSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSByteSlowAsync,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt16Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt16SlowAsync,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt16Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt16SlowAsync,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt32Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt32SlowAsync,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt32Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt32SlowAsync,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt64Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt64SlowAsync,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt64Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt64SlowAsync,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSingleSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSingleSlowAsync,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadDoubleSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadDoubleSlowAsync,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinary,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( Byte[] ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Raw16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Byte[] ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Byte[] ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( Byte[] ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Raw16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Byte[] ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Byte[] ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( Byte[] ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Raw16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Byte[] ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Byte[] ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( Byte[] ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Raw16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Byte[] ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Byte[] ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinaryAsync,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinaryAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Byte[]>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Raw16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Byte[]>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Byte[]>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinaryAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Byte[]>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Raw16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Byte[]>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Byte[]>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinaryAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Byte[]>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Raw16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Byte[]>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Byte[]>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinaryAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Byte[]>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Raw16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Byte[]>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Byte[]>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadString,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( String ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Raw16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( String ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( String ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( String ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Raw16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( String ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( String ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( String ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Raw16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( String ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( String ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( String ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Raw16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( String ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( String ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringAsync,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<String>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Raw16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<String>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<String>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<String>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Raw16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<String>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<String>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<String>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Raw16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<String>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<String>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Raw8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<String>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Raw16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<String>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Raw32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<String>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackObject ); 						return false; 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask ) 			{ 				case ReadValueResult.Array16Type: 				case ReadValueResult.Map16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Array32Type: 				case ReadValueResult.Map32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Str8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Str32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					MessagePackString stringValue; 					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						stringValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( stringValue ); 					break; 				} 				case ReadValueResult.Bin8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					}  					var length = buffer[ 0 ]; 					this.CheckLength( length' header ); 					offset += 1; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 2; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.Bin32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					this.CheckLength( length' header ); 					offset += 4; 					byte[] binaryValue; 					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						offset = asyncReadResult.Value.Offset; 						binaryValue = asyncReadResult.Value.Result; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = new MessagePackObject( binaryValue' /* isBinary */true ); 					break; 				} 				case ReadValueResult.FixExtType: 				{ 					var length = ( header & ReadValueResult.ValueOrLengthMask ); 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					var length = buffer[ 0 ]; 					offset += 1; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Ext32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					var length = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					MessagePackExtendedTypeObject ext; 					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); 					if ( asyncReadResult.Success ) 					{ 						ext = asyncReadResult.Value.Result; 						offset = asyncReadResult.Value.Offset; 					} 					else 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					 					result = ext; 					break; 				} 				case ReadValueResult.Int8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = unchecked( ( sbyte )buffer[ 0 ] ); 					offset += 1; 					break; 				} 				case ReadValueResult.Int16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.Int32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Int64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.UInt8Type: 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 					} 					result = buffer[ 0 ]; 					offset += 1; 					break; 				} 				case ReadValueResult.UInt16Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt16( buffer' 0 ); 					offset += 2; 					break; 				} 				case ReadValueResult.UInt32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt32( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.UInt64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToUInt64( buffer' 0 ); 					offset += 8; 					break; 				} 				case ReadValueResult.Real32Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToSingle( buffer' 0 ); 					offset += 4; 					break; 				} 				case ReadValueResult.Real64Type: 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 8; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local 					result = BigEndianBinary.ToDouble( buffer' 0 ); 					offset += 8; 					break; 				} 				default: 				{ #if DEBUG 					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" ); #endif // DEBUG 					this.ThrowUnassignedMessageTypeException( 0xC1 ); 					// never 					result = default( MessagePackObject ); 					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLength,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Array8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Array16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Int64 ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Array32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Int64 ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Array8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Array16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Int64 ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Array32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Int64 ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Array8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Array16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Int64 ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Array32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Int64 ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Array8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Array16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Int64 ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Array32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Int64 ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLengthAsync,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLengthAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Array8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Array16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Array32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLengthAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Array8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Array16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Array32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLengthAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Array8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Array16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Array32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLengthAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Array8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Array16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Array32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLength,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Map8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Map16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Int64 ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Map32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Int64 ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Map8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Map16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Int64 ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Map32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Int64 ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Map8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Map16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Int64 ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Map32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Int64 ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Map8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( Int64 ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Map16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Int64 ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Map32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( Int64 ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLengthAsync,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLengthAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Map8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Map16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Map32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLengthAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Map8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Map16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Map32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLengthAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Map8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Map16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Map32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLengthAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Map8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<Int64>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Map16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Map32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<Int64>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackExtendedTypeObject ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Ext16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackExtendedTypeObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackExtendedTypeObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackExtendedTypeObject ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Ext16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackExtendedTypeObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackExtendedTypeObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackExtendedTypeObject ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Ext16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackExtendedTypeObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackExtendedTypeObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackExtendedTypeObject ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Ext16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackExtendedTypeObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackExtendedTypeObject ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackExtendedTypeObject? ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Ext16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackExtendedTypeObject? ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackExtendedTypeObject? ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackExtendedTypeObject? ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Ext16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackExtendedTypeObject? ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackExtendedTypeObject? ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackExtendedTypeObject? ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Ext16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackExtendedTypeObject? ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackExtendedTypeObject? ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( this._source.Read( buffer' 0' 1 ) < 1 ) 					{ 						result = default( MessagePackExtendedTypeObject? ); 						return false; 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Ext16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackExtendedTypeObject? ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = this._source.Read( buffer' bufferOffset' reading ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									result = default( MessagePackExtendedTypeObject? ); 									return false; 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObjectAsync,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObjectAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<MessagePackExtendedTypeObject>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Ext16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<MessagePackExtendedTypeObject>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<MessagePackExtendedTypeObject>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObjectAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<MessagePackExtendedTypeObject>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Ext16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<MessagePackExtendedTypeObject>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<MessagePackExtendedTypeObject>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObjectAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<MessagePackExtendedTypeObject>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Ext16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<MessagePackExtendedTypeObject>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<MessagePackExtendedTypeObject>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObjectAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<MessagePackExtendedTypeObject>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Ext16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<MessagePackExtendedTypeObject>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<MessagePackExtendedTypeObject>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Ext16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Ext16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Ext16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The following statement contains a magic number: switch ( lengthOfLength ) 			{ 				case 0: 				{ 					length = ( byte )( header & ReadValueResult.ValueOrLengthMask ); 					break; 				} 				case 1: // Ext8 				{ 					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 ) 					{ 						return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>(); 					}  					length = BigEndianBinary.ToByte( buffer' 0 );  					break; 				} 				case 2: // Ext16 				{ 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 2; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt16( buffer' 0 );  					break; 				} 				default: // Ext32 				{ #if DEBUG 					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" ); #endif // DEBUG 					// scope for local 					{ 						var bufferOffset = 0; 						var reading = 4; 						// Retrying for splitted Stream such as NetworkStream 						while( true ) 						{ 							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); 							if ( readLength < reading ) 							{ 								if ( readLength > 0 ) 								{ 									// retry reading 									bufferOffset += readLength; 									reading -= readLength; 									continue; 								} 								else 								{ 									if ( this._useStreamPosition ) 									{ 										// Rollback 										this._source.Position -= ( bufferOffset + readLength ); 									} 									else 									{ 										// Throw because rollback is not available 										this.ThrowEofException( reading ); 									} 					 									return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>(); 								} 							} // if readLength < reading 					 							break; 						} // while true 					} // scope for local  					length = BigEndianBinary.ToUInt32( buffer' 0 );  					break; 				} 			}
Magic Number,MsgPack,MessagePackString,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,GetHashCode,The following statement contains a magic number: int value = this._encoded[ i ] << ( i % 4 ) * 8;
Magic Number,MsgPack,MessagePackString,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,GetHashCode,The following statement contains a magic number: int value = this._encoded[ i ] << ( i % 4 ) * 8;
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,MustBeString,The following statement contains a magic number: i < 128 && i < value.Length
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,CreateByteArrayString,The following statement contains a magic number: var buffer = new StringBuilder( ( bytes.Length <= 128 ? bytes.Length * 3 : 128 * 3 + 3 ) + 4 );
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,CreateByteArrayString,The following statement contains a magic number: var buffer = new StringBuilder( ( bytes.Length <= 128 ? bytes.Length * 3 : 128 * 3 + 3 ) + 4 );
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,CreateByteArrayString,The following statement contains a magic number: var buffer = new StringBuilder( ( bytes.Length <= 128 ? bytes.Length * 3 : 128 * 3 + 3 ) + 4 );
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,CreateByteArrayString,The following statement contains a magic number: var buffer = new StringBuilder( ( bytes.Length <= 128 ? bytes.Length * 3 : 128 * 3 + 3 ) + 4 );
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,CreateByteArrayString,The following statement contains a magic number: var buffer = new StringBuilder( ( bytes.Length <= 128 ? bytes.Length * 3 : 128 * 3 + 3 ) + 4 );
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,CreateByteArrayString,The following statement contains a magic number: var buffer = new StringBuilder( ( bytes.Length <= 128 ? bytes.Length * 3 : 128 * 3 + 3 ) + 4 );
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,CreateByteArrayString,The following statement contains a magic number: bytes.Take( 128 )
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackTinySignedInteger,The following statement contains a magic number: value >= 0 && value < 128L
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackTinySignedInteger,The following statement contains a magic number: value >= -32L && value <= -1L
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackTinySignedIntegerAsync,The following statement contains a magic number: value >= 0 && value < 128L
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackTinySignedIntegerAsync,The following statement contains a magic number: value >= -32L && value <= -1L
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackTinyUnsignedInteger,The following statement contains a magic number: value < 128L
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackTinyUnsignedIntegerAsync,The following statement contains a magic number: value < 128L
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt16,The following statement contains a magic number: this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt16Async,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt16,The following statement contains a magic number: this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt16Async,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt32,The following statement contains a magic number: this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt32,The following statement contains a magic number: this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt32,The following statement contains a magic number: this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt32Async,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt32Async,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt32Async,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt32,The following statement contains a magic number: this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt32,The following statement contains a magic number: this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt32,The following statement contains a magic number: this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt32Async,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt32Async,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt32Async,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64,The following statement contains a magic number: this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64,The following statement contains a magic number: this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64,The following statement contains a magic number: this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64,The following statement contains a magic number: this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64,The following statement contains a magic number: this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64,The following statement contains a magic number: this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64,The following statement contains a magic number: this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64Async,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( value >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64Async,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( value >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64Async,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( value >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64Async,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( value >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64Async,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64Async,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64Async,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64,The following statement contains a magic number: this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64,The following statement contains a magic number: this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64,The following statement contains a magic number: this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64,The following statement contains a magic number: this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64,The following statement contains a magic number: this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64,The following statement contains a magic number: this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64,The following statement contains a magic number: this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64Async,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( value >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64Async,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( value >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64Async,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( value >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64Async,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( value >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64Async,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64Async,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64Async,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The following statement contains a magic number: this.WriteByte( ( byte )( ( bits >> 56 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The following statement contains a magic number: this.WriteByte( ( byte )( ( bits >> 48 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The following statement contains a magic number: this.WriteByte( ( byte )( ( bits >> 40 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The following statement contains a magic number: this.WriteByte( ( byte )( ( bits >> 32 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The following statement contains a magic number: this.WriteByte( ( byte )( ( bits >> 24 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The following statement contains a magic number: this.WriteByte( ( byte )( ( bits >> 16 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The following statement contains a magic number: this.WriteByte( ( byte )( ( bits >> 8 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackAsyncCore,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( bits >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackAsyncCore,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( bits >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackAsyncCore,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( bits >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackAsyncCore,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( bits >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackAsyncCore,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( bits >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackAsyncCore,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( bits >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackAsyncCore,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( bits >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackArrayHeaderCore,The following statement contains a magic number: count < 16
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackArrayHeaderAsyncCore,The following statement contains a magic number: count < 16
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackMapHeaderCore,The following statement contains a magic number: count < 16
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackMapHeaderAsyncCore,The following statement contains a magic number: count < 16
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackStringHeaderCore,The following statement contains a magic number: length < 32
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackStringHeaderAsyncCore,The following statement contains a magic number: length < 32
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length ) 			{ 				case 1: 				{ 					this.WriteByte( MessagePackCode.FixExt1 ); 					break; 				} 				case 2: 				{ 					this.WriteByte( MessagePackCode.FixExt2 ); 					break; 				} 				case 4: 				{ 					this.WriteByte( MessagePackCode.FixExt4 ); 					break; 				} 				case 8: 				{ 					this.WriteByte( MessagePackCode.FixExt8 ); 					break; 				} 				case 16: 				{ 					this.WriteByte( MessagePackCode.FixExt16 ); 					break; 				} 				default: 				{ 					unchecked 					{ 						if ( body.Length < 0x100 ) 						{ 							this.WriteByte( MessagePackCode.Ext8 ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							this.WriteByte( MessagePackCode.Ext16 ); 							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 						else 						{ 							this.WriteByte( MessagePackCode.Ext32 ); 							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) ); 							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) ); 							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 					}  					break; 				} 			}
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length ) 			{ 				case 1: 				{ 					this.WriteByte( MessagePackCode.FixExt1 ); 					break; 				} 				case 2: 				{ 					this.WriteByte( MessagePackCode.FixExt2 ); 					break; 				} 				case 4: 				{ 					this.WriteByte( MessagePackCode.FixExt4 ); 					break; 				} 				case 8: 				{ 					this.WriteByte( MessagePackCode.FixExt8 ); 					break; 				} 				case 16: 				{ 					this.WriteByte( MessagePackCode.FixExt16 ); 					break; 				} 				default: 				{ 					unchecked 					{ 						if ( body.Length < 0x100 ) 						{ 							this.WriteByte( MessagePackCode.Ext8 ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							this.WriteByte( MessagePackCode.Ext16 ); 							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 						else 						{ 							this.WriteByte( MessagePackCode.Ext32 ); 							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) ); 							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) ); 							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 					}  					break; 				} 			}
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length ) 			{ 				case 1: 				{ 					this.WriteByte( MessagePackCode.FixExt1 ); 					break; 				} 				case 2: 				{ 					this.WriteByte( MessagePackCode.FixExt2 ); 					break; 				} 				case 4: 				{ 					this.WriteByte( MessagePackCode.FixExt4 ); 					break; 				} 				case 8: 				{ 					this.WriteByte( MessagePackCode.FixExt8 ); 					break; 				} 				case 16: 				{ 					this.WriteByte( MessagePackCode.FixExt16 ); 					break; 				} 				default: 				{ 					unchecked 					{ 						if ( body.Length < 0x100 ) 						{ 							this.WriteByte( MessagePackCode.Ext8 ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							this.WriteByte( MessagePackCode.Ext16 ); 							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 						else 						{ 							this.WriteByte( MessagePackCode.Ext32 ); 							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) ); 							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) ); 							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 					}  					break; 				} 			}
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length ) 			{ 				case 1: 				{ 					this.WriteByte( MessagePackCode.FixExt1 ); 					break; 				} 				case 2: 				{ 					this.WriteByte( MessagePackCode.FixExt2 ); 					break; 				} 				case 4: 				{ 					this.WriteByte( MessagePackCode.FixExt4 ); 					break; 				} 				case 8: 				{ 					this.WriteByte( MessagePackCode.FixExt8 ); 					break; 				} 				case 16: 				{ 					this.WriteByte( MessagePackCode.FixExt16 ); 					break; 				} 				default: 				{ 					unchecked 					{ 						if ( body.Length < 0x100 ) 						{ 							this.WriteByte( MessagePackCode.Ext8 ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							this.WriteByte( MessagePackCode.Ext16 ); 							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 						else 						{ 							this.WriteByte( MessagePackCode.Ext32 ); 							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) ); 							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) ); 							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 					}  					break; 				} 			}
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length ) 			{ 				case 1: 				{ 					this.WriteByte( MessagePackCode.FixExt1 ); 					break; 				} 				case 2: 				{ 					this.WriteByte( MessagePackCode.FixExt2 ); 					break; 				} 				case 4: 				{ 					this.WriteByte( MessagePackCode.FixExt4 ); 					break; 				} 				case 8: 				{ 					this.WriteByte( MessagePackCode.FixExt8 ); 					break; 				} 				case 16: 				{ 					this.WriteByte( MessagePackCode.FixExt16 ); 					break; 				} 				default: 				{ 					unchecked 					{ 						if ( body.Length < 0x100 ) 						{ 							this.WriteByte( MessagePackCode.Ext8 ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							this.WriteByte( MessagePackCode.Ext16 ); 							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 						else 						{ 							this.WriteByte( MessagePackCode.Ext32 ); 							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) ); 							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) ); 							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 					}  					break; 				} 			}
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length ) 			{ 				case 1: 				{ 					this.WriteByte( MessagePackCode.FixExt1 ); 					break; 				} 				case 2: 				{ 					this.WriteByte( MessagePackCode.FixExt2 ); 					break; 				} 				case 4: 				{ 					this.WriteByte( MessagePackCode.FixExt4 ); 					break; 				} 				case 8: 				{ 					this.WriteByte( MessagePackCode.FixExt8 ); 					break; 				} 				case 16: 				{ 					this.WriteByte( MessagePackCode.FixExt16 ); 					break; 				} 				default: 				{ 					unchecked 					{ 						if ( body.Length < 0x100 ) 						{ 							this.WriteByte( MessagePackCode.Ext8 ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							this.WriteByte( MessagePackCode.Ext16 ); 							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 						else 						{ 							this.WriteByte( MessagePackCode.Ext32 ); 							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) ); 							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) ); 							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 					}  					break; 				} 			}
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length ) 			{ 				case 1: 				{ 					this.WriteByte( MessagePackCode.FixExt1 ); 					break; 				} 				case 2: 				{ 					this.WriteByte( MessagePackCode.FixExt2 ); 					break; 				} 				case 4: 				{ 					this.WriteByte( MessagePackCode.FixExt4 ); 					break; 				} 				case 8: 				{ 					this.WriteByte( MessagePackCode.FixExt8 ); 					break; 				} 				case 16: 				{ 					this.WriteByte( MessagePackCode.FixExt16 ); 					break; 				} 				default: 				{ 					unchecked 					{ 						if ( body.Length < 0x100 ) 						{ 							this.WriteByte( MessagePackCode.Ext8 ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							this.WriteByte( MessagePackCode.Ext16 ); 							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 						else 						{ 							this.WriteByte( MessagePackCode.Ext32 ); 							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) ); 							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) ); 							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 					}  					break; 				} 			}
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length ) 			{ 				case 1: 				{ 					this.WriteByte( MessagePackCode.FixExt1 ); 					break; 				} 				case 2: 				{ 					this.WriteByte( MessagePackCode.FixExt2 ); 					break; 				} 				case 4: 				{ 					this.WriteByte( MessagePackCode.FixExt4 ); 					break; 				} 				case 8: 				{ 					this.WriteByte( MessagePackCode.FixExt8 ); 					break; 				} 				case 16: 				{ 					this.WriteByte( MessagePackCode.FixExt16 ); 					break; 				} 				default: 				{ 					unchecked 					{ 						if ( body.Length < 0x100 ) 						{ 							this.WriteByte( MessagePackCode.Ext8 ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							this.WriteByte( MessagePackCode.Ext16 ); 							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 						else 						{ 							this.WriteByte( MessagePackCode.Ext32 ); 							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) ); 							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) ); 							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) ); 							this.WriteByte( ( byte )( body.Length & 0xFF ) ); 						} 					}  					break; 				} 			}
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length ) 			{ 				case 1: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 2: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 4: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 8: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 16: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				default: 				{ 					unchecked 					{ 						if ( body.Length < 0x100 ) 						{ 							await this.WriteByteAsync( MessagePackCode.Ext8' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							await this.WriteByteAsync( MessagePackCode.Ext16' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 						else 						{ 							await this.WriteByteAsync( MessagePackCode.Ext32' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 					}  					break; 				} 			}
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length ) 			{ 				case 1: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 2: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 4: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 8: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 16: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				default: 				{ 					unchecked 					{ 						if ( body.Length < 0x100 ) 						{ 							await this.WriteByteAsync( MessagePackCode.Ext8' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							await this.WriteByteAsync( MessagePackCode.Ext16' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 						else 						{ 							await this.WriteByteAsync( MessagePackCode.Ext32' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 					}  					break; 				} 			}
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length ) 			{ 				case 1: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 2: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 4: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 8: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 16: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				default: 				{ 					unchecked 					{ 						if ( body.Length < 0x100 ) 						{ 							await this.WriteByteAsync( MessagePackCode.Ext8' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							await this.WriteByteAsync( MessagePackCode.Ext16' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 						else 						{ 							await this.WriteByteAsync( MessagePackCode.Ext32' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 					}  					break; 				} 			}
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length ) 			{ 				case 1: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 2: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 4: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 8: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 16: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				default: 				{ 					unchecked 					{ 						if ( body.Length < 0x100 ) 						{ 							await this.WriteByteAsync( MessagePackCode.Ext8' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							await this.WriteByteAsync( MessagePackCode.Ext16' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 						else 						{ 							await this.WriteByteAsync( MessagePackCode.Ext32' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 					}  					break; 				} 			}
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length ) 			{ 				case 1: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 2: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 4: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 8: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 16: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				default: 				{ 					unchecked 					{ 						if ( body.Length < 0x100 ) 						{ 							await this.WriteByteAsync( MessagePackCode.Ext8' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							await this.WriteByteAsync( MessagePackCode.Ext16' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 						else 						{ 							await this.WriteByteAsync( MessagePackCode.Ext32' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 					}  					break; 				} 			}
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length ) 			{ 				case 1: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 2: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 4: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 8: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 16: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				default: 				{ 					unchecked 					{ 						if ( body.Length < 0x100 ) 						{ 							await this.WriteByteAsync( MessagePackCode.Ext8' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							await this.WriteByteAsync( MessagePackCode.Ext16' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 						else 						{ 							await this.WriteByteAsync( MessagePackCode.Ext32' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 					}  					break; 				} 			}
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length ) 			{ 				case 1: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 2: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 4: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 8: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 16: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				default: 				{ 					unchecked 					{ 						if ( body.Length < 0x100 ) 						{ 							await this.WriteByteAsync( MessagePackCode.Ext8' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							await this.WriteByteAsync( MessagePackCode.Ext16' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 						else 						{ 							await this.WriteByteAsync( MessagePackCode.Ext32' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 					}  					break; 				} 			}
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length ) 			{ 				case 1: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 2: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 4: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 8: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				case 16: 				{ 					await this.WriteByteAsync( MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false ); 					break; 				} 				default: 				{ 					unchecked 					{ 						if ( body.Length < 0x100 ) 						{ 							await this.WriteByteAsync( MessagePackCode.Ext8' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 						else if ( body.Length < 0x10000 ) 						{ 							await this.WriteByteAsync( MessagePackCode.Ext16' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 						else 						{ 							await this.WriteByteAsync( MessagePackCode.Ext32' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false ); 							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false ); 						} 					}  					break; 				} 			}
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWrite,The following statement contains a magic number: this.SeekTo( 4L );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWrite,The following statement contains a magic number: this.SeekTo( -4L );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWrite,The following statement contains a magic number: this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWrite,The following statement contains a magic number: this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWrite,The following statement contains a magic number: this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWriteAsync,The following statement contains a magic number: this.SeekTo( 4L );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWriteAsync,The following statement contains a magic number: this.SeekTo( -4L );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWriteAsync,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( bodyLength >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWriteAsync,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( bodyLength >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,Packer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWriteAsync,The following statement contains a magic number: await this.WriteByteAsync( ( byte )( ( bodyLength >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack,ReadValueResults,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,ReadValueResults,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: switch ( length ) 				{ 					case 0: 					{ 						return ( byte )( MessagePackCode.MinimumFixedArray | ( int )( source & ReadValueResult.ValueOrLengthMask ) ); 					} 					case 2: 					{ 						return ( byte )MessagePackCode.Array16; 					} 					default: 					{ #if DEBUG 						Contract.Assert( length == 4' length + " == 4" ); #endif // DEBUG 						return ( byte )MessagePackCode.Array32; 					} 				}
Magic Number,MsgPack,ReadValueResults,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: switch ( length ) 				{ 					case 0: 					{ 						return ( byte )( MessagePackCode.MinimumFixedArray | ( int )( source & ReadValueResult.ValueOrLengthMask ) ); 					} 					case 2: 					{ 						return ( byte )MessagePackCode.Array16; 					} 					default: 					{ #if DEBUG 						Contract.Assert( length == 4' length + " == 4" ); #endif // DEBUG 						return ( byte )MessagePackCode.Array32; 					} 				}
Magic Number,MsgPack,ReadValueResults,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,ReadValueResults,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: switch ( length ) 				{ 					case 0: 					{ 						return ( byte )( MessagePackCode.MinimumFixedMap | ( int )( source & ReadValueResult.ValueOrLengthMask ) ); 					} 					case 2: 					{ 						return ( byte )MessagePackCode.Map16; 					} 					default: 					{ #if DEBUG 						Contract.Assert( length == 4' length + " == 4" ); #endif // DEBUG 						return ( byte )MessagePackCode.Map32; 					} 				}
Magic Number,MsgPack,ReadValueResults,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: switch ( length ) 				{ 					case 0: 					{ 						return ( byte )( MessagePackCode.MinimumFixedMap | ( int )( source & ReadValueResult.ValueOrLengthMask ) ); 					} 					case 2: 					{ 						return ( byte )MessagePackCode.Map16; 					} 					default: 					{ #if DEBUG 						Contract.Assert( length == 4' length + " == 4" ); #endif // DEBUG 						return ( byte )MessagePackCode.Map32; 					} 				}
Magic Number,MsgPack,ReadValueResults,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,ReadValueResults,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: switch ( length ) 				{ 					case 0: 					{ 						return ( byte )( MessagePackCode.MinimumFixedRaw | ( int )( source & ReadValueResult.ValueOrLengthMask ) ); 					} 					case 1: 					{ 						return ( byte )( isBin ? MessagePackCode.Bin8 : MessagePackCode.Str8 ); 					} 					case 2: 					{ 						return ( byte )( isBin ? MessagePackCode.Bin16 : MessagePackCode.Str16 ); 					} 					default: 					{ #if DEBUG 						Contract.Assert( length == 4' length + " == 4" ); #endif // DEBUG 						return ( byte )( isBin ? MessagePackCode.Bin32 : MessagePackCode.Str32 ); 					} 				}
Magic Number,MsgPack,ReadValueResults,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: switch ( length ) 				{ 					case 0: 					{ 						return ( byte )( MessagePackCode.MinimumFixedRaw | ( int )( source & ReadValueResult.ValueOrLengthMask ) ); 					} 					case 1: 					{ 						return ( byte )( isBin ? MessagePackCode.Bin8 : MessagePackCode.Str8 ); 					} 					case 2: 					{ 						return ( byte )( isBin ? MessagePackCode.Bin16 : MessagePackCode.Str16 ); 					} 					default: 					{ #if DEBUG 						Contract.Assert( length == 4' length + " == 4" ); #endif // DEBUG 						return ( byte )( isBin ? MessagePackCode.Bin32 : MessagePackCode.Str32 ); 					} 				}
Magic Number,MsgPack,ReadValueResults,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,ReadValueResults,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: switch ( length ) 				{ 					case 0: 					{ 						switch ( ( int )( source & ReadValueResult.ValueOrLengthMask ) ) 						{ 							case 1: 							{ 								return ( byte )MessagePackCode.FixExt1; 							} 							case 2: 							{ 								return ( byte )MessagePackCode.FixExt2; 							} 							case 4: 							{ 								return ( byte )MessagePackCode.FixExt4; 							} 							case 8: 							{ 								return ( byte )MessagePackCode.FixExt8; 							} 							default: 							{ #if DEBUG 								Contract.Assert( ( int )( source & ReadValueResult.ValueOrLengthMask ) == 16' ( int )( source & ReadValueResult.ValueOrLengthMask ) + " == 16" ); #endif // DEBUG 								return ( byte )MessagePackCode.FixExt16; 							} 						} 					} 					case 1: 					{ 						return ( byte )MessagePackCode.Ext8; 					} 					case 2: 					{ 						return ( byte )MessagePackCode.Ext16; 					} 					default: 					{ #if DEBUG 						Contract.Assert( length == 4' length + " == 4" ); #endif // DEBUG 						return ( byte )MessagePackCode.Ext32; 					} 				}
Magic Number,MsgPack,ReadValueResults,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: switch ( length ) 				{ 					case 0: 					{ 						switch ( ( int )( source & ReadValueResult.ValueOrLengthMask ) ) 						{ 							case 1: 							{ 								return ( byte )MessagePackCode.FixExt1; 							} 							case 2: 							{ 								return ( byte )MessagePackCode.FixExt2; 							} 							case 4: 							{ 								return ( byte )MessagePackCode.FixExt4; 							} 							case 8: 							{ 								return ( byte )MessagePackCode.FixExt8; 							} 							default: 							{ #if DEBUG 								Contract.Assert( ( int )( source & ReadValueResult.ValueOrLengthMask ) == 16' ( int )( source & ReadValueResult.ValueOrLengthMask ) + " == 16" ); #endif // DEBUG 								return ( byte )MessagePackCode.FixExt16; 							} 						} 					} 					case 1: 					{ 						return ( byte )MessagePackCode.Ext8; 					} 					case 2: 					{ 						return ( byte )MessagePackCode.Ext16; 					} 					default: 					{ #if DEBUG 						Contract.Assert( length == 4' length + " == 4" ); #endif // DEBUG 						return ( byte )MessagePackCode.Ext32; 					} 				}
Magic Number,MsgPack,ReadValueResults,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: switch ( length ) 				{ 					case 0: 					{ 						switch ( ( int )( source & ReadValueResult.ValueOrLengthMask ) ) 						{ 							case 1: 							{ 								return ( byte )MessagePackCode.FixExt1; 							} 							case 2: 							{ 								return ( byte )MessagePackCode.FixExt2; 							} 							case 4: 							{ 								return ( byte )MessagePackCode.FixExt4; 							} 							case 8: 							{ 								return ( byte )MessagePackCode.FixExt8; 							} 							default: 							{ #if DEBUG 								Contract.Assert( ( int )( source & ReadValueResult.ValueOrLengthMask ) == 16' ( int )( source & ReadValueResult.ValueOrLengthMask ) + " == 16" ); #endif // DEBUG 								return ( byte )MessagePackCode.FixExt16; 							} 						} 					} 					case 1: 					{ 						return ( byte )MessagePackCode.Ext8; 					} 					case 2: 					{ 						return ( byte )MessagePackCode.Ext16; 					} 					default: 					{ #if DEBUG 						Contract.Assert( length == 4' length + " == 4" ); #endif // DEBUG 						return ( byte )MessagePackCode.Ext32; 					} 				}
Magic Number,MsgPack,ReadValueResults,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: switch ( length ) 				{ 					case 0: 					{ 						switch ( ( int )( source & ReadValueResult.ValueOrLengthMask ) ) 						{ 							case 1: 							{ 								return ( byte )MessagePackCode.FixExt1; 							} 							case 2: 							{ 								return ( byte )MessagePackCode.FixExt2; 							} 							case 4: 							{ 								return ( byte )MessagePackCode.FixExt4; 							} 							case 8: 							{ 								return ( byte )MessagePackCode.FixExt8; 							} 							default: 							{ #if DEBUG 								Contract.Assert( ( int )( source & ReadValueResult.ValueOrLengthMask ) == 16' ( int )( source & ReadValueResult.ValueOrLengthMask ) + " == 16" ); #endif // DEBUG 								return ( byte )MessagePackCode.FixExt16; 							} 						} 					} 					case 1: 					{ 						return ( byte )MessagePackCode.Ext8; 					} 					case 2: 					{ 						return ( byte )MessagePackCode.Ext16; 					} 					default: 					{ #if DEBUG 						Contract.Assert( length == 4' length + " == 4" ); #endif // DEBUG 						return ( byte )MessagePackCode.Ext32; 					} 				}
Magic Number,MsgPack,ReadValueResults,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: switch ( length ) 				{ 					case 0: 					{ 						switch ( ( int )( source & ReadValueResult.ValueOrLengthMask ) ) 						{ 							case 1: 							{ 								return ( byte )MessagePackCode.FixExt1; 							} 							case 2: 							{ 								return ( byte )MessagePackCode.FixExt2; 							} 							case 4: 							{ 								return ( byte )MessagePackCode.FixExt4; 							} 							case 8: 							{ 								return ( byte )MessagePackCode.FixExt8; 							} 							default: 							{ #if DEBUG 								Contract.Assert( ( int )( source & ReadValueResult.ValueOrLengthMask ) == 16' ( int )( source & ReadValueResult.ValueOrLengthMask ) + " == 16" ); #endif // DEBUG 								return ( byte )MessagePackCode.FixExt16; 							} 						} 					} 					case 1: 					{ 						return ( byte )MessagePackCode.Ext8; 					} 					case 2: 					{ 						return ( byte )MessagePackCode.Ext16; 					} 					default: 					{ #if DEBUG 						Contract.Assert( length == 4' length + " == 4" ); #endif // DEBUG 						return ( byte )MessagePackCode.Ext32; 					} 				}
Magic Number,MsgPack,ReadValueResults,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: switch ( length ) 				{ 					case 0: 					{ 						switch ( ( int )( source & ReadValueResult.ValueOrLengthMask ) ) 						{ 							case 1: 							{ 								return ( byte )MessagePackCode.FixExt1; 							} 							case 2: 							{ 								return ( byte )MessagePackCode.FixExt2; 							} 							case 4: 							{ 								return ( byte )MessagePackCode.FixExt4; 							} 							case 8: 							{ 								return ( byte )MessagePackCode.FixExt8; 							} 							default: 							{ #if DEBUG 								Contract.Assert( ( int )( source & ReadValueResult.ValueOrLengthMask ) == 16' ( int )( source & ReadValueResult.ValueOrLengthMask ) + " == 16" ); #endif // DEBUG 								return ( byte )MessagePackCode.FixExt16; 							} 						} 					} 					case 1: 					{ 						return ( byte )MessagePackCode.Ext8; 					} 					case 2: 					{ 						return ( byte )MessagePackCode.Ext16; 					} 					default: 					{ #if DEBUG 						Contract.Assert( length == 4' length + " == 4" ); #endif // DEBUG 						return ( byte )MessagePackCode.Ext32; 					} 				}
Magic Number,MsgPack,SingleArrayBufferAllocator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SingleArrayBufferAllocator.cs,Allocate,The following statement contains a magic number: return new byte[ 256 ];
Magic Number,MsgPack,SingleArrayBufferAllocator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SingleArrayBufferAllocator.cs,Allocate,The following statement contains a magic number: old.Length < 256
Magic Number,MsgPack,SingleArrayBufferAllocator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SingleArrayBufferAllocator.cs,Allocate,The following statement contains a magic number: var newSize = Math.Max( ( long )( old.Length * 1.1618 )' requestSize + ( long )old.Length );
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,SubtreeUnpacker,The following statement contains a magic number: this._unpacked = new Int64Stack( 2 );
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,SubtreeUnpacker,The following statement contains a magic number: this._itemsCount = new Int64Stack( 2 );
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,SubtreeUnpacker,The following statement contains a magic number: this._isMap = new BooleanStack( 2 );
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadCore,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadAsyncCore,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadBoolean,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableBoolean,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadByte,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableByte,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadSByte,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableSByte,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadInt16,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableInt16,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadUInt16,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableUInt16,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadInt32,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableInt32,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadUInt32,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableUInt32,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadInt64,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableInt64,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadUInt64,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableUInt64,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadSingle,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableSingle,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadDouble,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableDouble,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadString,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,SubtreeUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadObject,The following statement contains a magic number: switch ( this._internalRoot.CollectionType ) 			{ 				case CollectionType.Array: 				{ 					this._itemsCount.Push( this._root.ItemsCount ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( false ); 					break; 				} 				case CollectionType.Map: 				{ 					this._itemsCount.Push( this._root.ItemsCount * 2 ); 					this._unpacked.Push( 0 ); 					this._isMap.Push( true ); 					break; 				} 				default: 				{ 					this._unpacked.Push( this._unpacked.Pop() + 1 ); 					break; 				} 			}
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: var body = new byte[ 12 ];
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: ( this.unixEpochSeconds >> 34 ) != 0
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,FromOffsetTicks,The following statement contains a magic number: nanoSeconds = unchecked( ( int )remaining ) * 100;
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Decode,The following statement contains a magic number: switch( value.Body.Length ) 			{ 				case 4: 				{ 					// timespan32 format 					return new Timestamp( BigEndianBinary.ToUInt32( value.Body' 0 )' 0 ); 				} 				case 8: 				{ 					// timespan64 format 					var payload = BigEndianBinary.ToUInt64( value.Body' 0 ); 					return new Timestamp( unchecked( ( long )( payload & 0x00000003ffffffffL ) )' unchecked( ( int )( payload >> 34 ) ) ); 				} 				case 12: 				{ 					// timespan96 format 					return new Timestamp( BigEndianBinary.ToInt64( value.Body' sizeof( int ) )' unchecked( ( int )BigEndianBinary.ToUInt32( value.Body' 0 ) ) ); 				} 				default: 				{ 					throw new ArgumentException( "The value's length is not valid."' "value" ); 				} 			}
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Decode,The following statement contains a magic number: switch( value.Body.Length ) 			{ 				case 4: 				{ 					// timespan32 format 					return new Timestamp( BigEndianBinary.ToUInt32( value.Body' 0 )' 0 ); 				} 				case 8: 				{ 					// timespan64 format 					var payload = BigEndianBinary.ToUInt64( value.Body' 0 ); 					return new Timestamp( unchecked( ( long )( payload & 0x00000003ffffffffL ) )' unchecked( ( int )( payload >> 34 ) ) ); 				} 				case 12: 				{ 					// timespan96 format 					return new Timestamp( BigEndianBinary.ToInt64( value.Body' sizeof( int ) )' unchecked( ( int )BigEndianBinary.ToUInt32( value.Body' 0 ) ) ); 				} 				default: 				{ 					throw new ArgumentException( "The value's length is not valid."' "value" ); 				} 			}
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Decode,The following statement contains a magic number: switch( value.Body.Length ) 			{ 				case 4: 				{ 					// timespan32 format 					return new Timestamp( BigEndianBinary.ToUInt32( value.Body' 0 )' 0 ); 				} 				case 8: 				{ 					// timespan64 format 					var payload = BigEndianBinary.ToUInt64( value.Body' 0 ); 					return new Timestamp( unchecked( ( long )( payload & 0x00000003ffffffffL ) )' unchecked( ( int )( payload >> 34 ) ) ); 				} 				case 12: 				{ 					// timespan96 format 					return new Timestamp( BigEndianBinary.ToInt64( value.Body' sizeof( int ) )' unchecked( ( int )BigEndianBinary.ToUInt32( value.Body' 0 ) ) ); 				} 				default: 				{ 					throw new ArgumentException( "The value's length is not valid."' "value" ); 				} 			}
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Decode,The following statement contains a magic number: switch( value.Body.Length ) 			{ 				case 4: 				{ 					// timespan32 format 					return new Timestamp( BigEndianBinary.ToUInt32( value.Body' 0 )' 0 ); 				} 				case 8: 				{ 					// timespan64 format 					var payload = BigEndianBinary.ToUInt64( value.Body' 0 ); 					return new Timestamp( unchecked( ( long )( payload & 0x00000003ffffffffL ) )' unchecked( ( int )( payload >> 34 ) ) ); 				} 				case 12: 				{ 					// timespan96 format 					return new Timestamp( BigEndianBinary.ToInt64( value.Body' sizeof( int ) )' unchecked( ( int )BigEndianBinary.ToUInt32( value.Body' 0 ) ) ); 				} 				default: 				{ 					throw new ArgumentException( "The value's length is not valid."' "value" ); 				} 			}
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,FromComponents,The following statement contains a magic number: epoc = value.Hour * 60 * 60;
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,FromComponents,The following statement contains a magic number: epoc = value.Hour * 60 * 60;
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,FromComponents,The following statement contains a magic number: epoc += value.Minute * 60;
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,YearsToDaysOfNewYear,The following statement contains a magic number: var numberOf400Years = DivRem( years > 0 ? ( years - 1 ) : years' 400' out remainOf400Years );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,YearsToDaysOfNewYear,The following statement contains a magic number: var numberOf100Years = DivRem( remainOf400Years' 100' out remainOf100Years );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,YearsToDaysOfNewYear,The following statement contains a magic number: var numberOf4Years = DivRem( remainOf100Years' 4' out remainOf4Years );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ToDaysOffsetFromNewYear,The following statement contains a magic number: result += isLeapYear ? 29 : 28;
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ToDaysOffsetFromNewYear,The following statement contains a magic number: result += isLeapYear ? 29 : 28;
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ToDaysOffsetFromNewYear,The following statement contains a magic number: i == 2
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,IsLeapYearInternal,The following statement contains a magic number: return !( year % 4 != 0 || ( year % 100 == 0 && year % 400 != 0 ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,IsLeapYearInternal,The following statement contains a magic number: return !( year % 4 != 0 || ( year % 100 == 0 && year % 400 != 0 ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,IsLeapYearInternal,The following statement contains a magic number: return !( year % 4 != 0 || ( year % 100 == 0 && year % 400 != 0 ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetLastDay,The following statement contains a magic number: lastDay = isLeapYear ? 29 : 28;
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetLastDay,The following statement contains a magic number: lastDay = isLeapYear ? 29 : 28;
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetLastDay,The following statement contains a magic number: month == 2
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: numberOf100Years = 3;
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: numberOf100Years == 4
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: numberOf1Year = 3;
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: numberOf1Year == 4
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: year = unchecked( ( long )( numberOf400Years * 400 + numberOf100Years * 100 + numberOf4years * 4 + numberOf1Year + 1 ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: year = unchecked( ( long )( numberOf400Years * 400 + numberOf100Years * 100 + numberOf4years * 4 + numberOf1Year + 1 ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: year = unchecked( ( long )( numberOf400Years * 400 + numberOf100Years * 100 + numberOf4years * 4 + numberOf1Year + 1 ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: var isLeapYear = numberOf1Year == 3 && ( numberOf4years != 24 || numberOf100Years == 3 );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: var isLeapYear = numberOf1Year == 3 && ( numberOf4years != 24 || numberOf100Years == 3 );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: var isLeapYear = numberOf1Year == 3 && ( numberOf4years != 24 || numberOf100Years == 3 );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: var numberOfMonth = ( daysInYear >> 5 ) + 1;
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: Contract.Assert( numberOfMonth <= 12' numberOfMonth + "<= 12' daysInYear = " + daysInYear );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: Contract.Assert( numberOfMonth <= 12' numberOfMonth + "<= 12' daysInYear = " + daysInYear );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: var numberOf100Years = 				daysIn400Years <= ( DaysPer100Years  + 1 ) // 1st year is leap year (power of 400) 					? 0 					: ( ( daysIn400Years - 2 ) / DaysPer100Years );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: var numberOf1Year = 				daysIn4Years <= ( DaysPerYear + ( numberOf4years != 0 ? 1 : 0 ) ) // is leap year in 4 years range? 					? 0 					: ( ( daysIn4Years - 2 ) / DaysPerYear );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: year = -unchecked( ( long )( numberOf400Years * 400 + numberOf100Years * 100 + numberOf4years * 4 + numberOf1Year ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: year = -unchecked( ( long )( numberOf400Years * 400 + numberOf100Years * 100 + numberOf4years * 4 + numberOf1Year ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: year = -unchecked( ( long )( numberOf400Years * 400 + numberOf100Years * 100 + numberOf4years * 4 + numberOf1Year ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: var daysInYear = 				isLeapYear 				? ( 366 - daysIn4Years ) 				: ( 365 - ( daysIn4Years - 1 - numberOf1Year * DaysPerYear ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: var daysInYear = 				isLeapYear 				? ( 366 - daysIn4Years ) 				: ( 365 - ( daysIn4Years - 1 - numberOf1Year * DaysPerYear ) );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: var numberOfMonth = ( daysInYear >> 5 ) + 1;
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: Contract.Assert( numberOfMonth <= 12' numberOfMonth + "<= 12' daysInYear = " + daysInYear );
Magic Number,MsgPack,Timestamp,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: Contract.Assert( numberOfMonth <= 12' numberOfMonth + "<= 12' daysInYear = " + daysInYear );
Magic Number,MsgPack,TimestampStringConverter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: !ParseDigitRange( input' 2' ref position' 1' 12' out month )
Magic Number,MsgPack,TimestampStringConverter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: !ParseDigitRange( input' 2' ref position' 1' 12' out month )
Magic Number,MsgPack,TimestampStringConverter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: !ParseDigitRange( input' 2' ref position' 0' 23' out hour )
Magic Number,MsgPack,TimestampStringConverter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: !ParseDigitRange( input' 2' ref position' 0' 23' out hour )
Magic Number,MsgPack,TimestampStringConverter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: !ParseDigitRange( input' 2' ref position' 0' 59' out minute )
Magic Number,MsgPack,TimestampStringConverter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: !ParseDigitRange( input' 2' ref position' 0' 59' out minute )
Magic Number,MsgPack,TimestampStringConverter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: !ParseDigitRange( input' 2' ref position' 0' 59' out second )
Magic Number,MsgPack,TimestampStringConverter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: !ParseDigitRange( input' 2' ref position' 0' 59' out second )
Magic Number,MsgPack,TimestampStringConverter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: !ParseDigitRange( input' 9' ref position' 0' 999999999' out nanosecond )
Magic Number,MsgPack,TimestampStringConverter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: !ParseDigitRange( input' 9' ref position' 0' 999999999' out nanosecond )
Magic Number,MsgPack,TimestampStringConverter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,ParseDigit,The following statement contains a magic number: bits = bits * 10 + ( c - '0' );
Magic Number,MsgPack,TimestampStringConverter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,ParseYear,The following statement contains a magic number: !ParseDigit( input' 4' ref position' out digit )
Magic Number,MsgPack,TimestampStringConverter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,ParseDay,The following statement contains a magic number: !ParseDigit( input' 2' ref position' out digit )
Magic Number,MsgPack,TimestampStringConverter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,ToIso8601String,The following statement contains a magic number: var buffer = new StringBuilder( 49 + ( containsNanosecons ? 11 : 1 ) );
Magic Number,MsgPack,TimestampStringConverter,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,ToIso8601String,The following statement contains a magic number: var buffer = new StringBuilder( 49 + ( containsNanosecons ? 11 : 1 ) );
Magic Number,MsgPack,TupleItems,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TupleItems.cs,CreateTupleTypeList,The following statement contains a magic number: itemTypes.Length < 8
Magic Number,MsgPack,TupleItems,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TupleItems.cs,GetTupleItemTypes,The following statement contains a magic number: var count = itemTypes.Count == 8 ? 7 : itemTypes.Count;
Magic Number,MsgPack,TupleItems,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TupleItems.cs,GetTupleItemTypes,The following statement contains a magic number: var count = itemTypes.Count == 8 ? 7 : itemTypes.Count;
Magic Number,MsgPack,TupleItems,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TupleItems.cs,GetTupleItemTypes,The following statement contains a magic number: var trest = itemTypes[ 7 ];
Magic Number,MsgPack,TupleItems,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\TupleItems.cs,GetTupleItemTypes,The following statement contains a magic number: itemTypes.Count == 8
Magic Number,MsgPack.Serialization.AbstractSerializers,MethodDefinition,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\MethodDefinition.cs,ToString,The following statement contains a magic number: var buffer = new StringBuilder( 128 );
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitCollectionUnpackFromStatements,The following statement contains a magic number: var unpackItemValueArguments =  					new[] { context.Unpacker' context.UnpackToTarget' indexOfItemParameter' itemsCountParameter } #if FEATURE_TAP 					.Concat( isAsync ? new[] { this.ReferCancellationToken( context' 2 ) } : NoConstructs ).ToArray() #endif // FEATURE_TAP 					;
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitCollectionUnpackFromStatements,The following statement contains a magic number: unpackHelperArguments.Add( "CancellationToken"' this.ReferCancellationToken( context' 2 ) );
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,MakeDecimalLiteral,The following statement contains a magic number: return 				this.EmitCreateNewObjectExpression( 					context' 					targetVariable' 					Metadata._Decimal.Constructor' 					this.MakeInt32Literal( context' bits[ 0 ] )' // lo 					this.MakeInt32Literal( context' bits[ 1 ] )' // mid 					this.MakeInt32Literal( context' bits[ 2 ] )' // high 					this.MakeBooleanLiteral( context' ( bits[ 3 ] & 0x80000000 ) != 0 )' // sign 					this.MakeByteLiteral( context' unchecked( ( byte )( bits[ 3 ] >> 16 & 0xFF ) ) ) // scale 				);
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,MakeDecimalLiteral,The following statement contains a magic number: return 				this.EmitCreateNewObjectExpression( 					context' 					targetVariable' 					Metadata._Decimal.Constructor' 					this.MakeInt32Literal( context' bits[ 0 ] )' // lo 					this.MakeInt32Literal( context' bits[ 1 ] )' // mid 					this.MakeInt32Literal( context' bits[ 2 ] )' // high 					this.MakeBooleanLiteral( context' ( bits[ 3 ] & 0x80000000 ) != 0 )' // sign 					this.MakeByteLiteral( context' unchecked( ( byte )( bits[ 3 ] >> 16 & 0xFF ) ) ) // scale 				);
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,MakeDecimalLiteral,The following statement contains a magic number: return 				this.EmitCreateNewObjectExpression( 					context' 					targetVariable' 					Metadata._Decimal.Constructor' 					this.MakeInt32Literal( context' bits[ 0 ] )' // lo 					this.MakeInt32Literal( context' bits[ 1 ] )' // mid 					this.MakeInt32Literal( context' bits[ 2 ] )' // high 					this.MakeBooleanLiteral( context' ( bits[ 3 ] & 0x80000000 ) != 0 )' // sign 					this.MakeByteLiteral( context' unchecked( ( byte )( bits[ 3 ] >> 16 & 0xFF ) ) ) // scale 				);
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,MakeDecimalLiteral,The following statement contains a magic number: return 				this.EmitCreateNewObjectExpression( 					context' 					targetVariable' 					Metadata._Decimal.Constructor' 					this.MakeInt32Literal( context' bits[ 0 ] )' // lo 					this.MakeInt32Literal( context' bits[ 1 ] )' // mid 					this.MakeInt32Literal( context' bits[ 2 ] )' // high 					this.MakeBooleanLiteral( context' ( bits[ 3 ] & 0x80000000 ) != 0 )' // sign 					this.MakeByteLiteral( context' unchecked( ( byte )( bits[ 3 ] >> 16 & 0xFF ) ) ) // scale 				);
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitSerializeItemExpressionCore,The following statement contains a magic number: var arguments = #if FEATURE_TAP 				isAsync ? new [] { packer' item' this.ReferCancellationToken( context' 3 ) } : #endif // FEATURE_TAP 				new [] { packer' item };
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitUnpackItemValueStatement,The following statement contains a magic number: unpackHelperArguments.Add( "CancellationToken"' this.ReferCancellationToken( context' 5 ) );
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,DetermineCollectionConstructorArguments,The following statement contains a magic number: switch ( parameters.Length ) 			{ 				case 0: 				{ 					return NoConstructs; 				} 				case 1: 				{ 					return new[] { this.GetConstructorArgument( context' parameters[ 0 ] ) }; 				} 				case 2: 				{ 					return new[] { this.GetConstructorArgument( context' parameters[ 0 ] )' this.GetConstructorArgument( context' parameters[ 1 ] ) }; 				} 				default: 				{ 					throw new NotSupportedException( 						String.Format( CultureInfo.CurrentCulture' "Constructor signature '{0}' is not supported."' constructor ) 					); 				} 			}
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildPackUnderlyingValueTo,The following statement contains a magic number: var invocation = #if FEATURE_TAP 				isAsync 					? this.EmitRetrunStatement( 						context' 						this.EmitInvokeMethodExpression( 							context' 							this.ReferArgument( context' TypeDefinition.PackerType' "packer"' 1 )' 							typeof( Packer ).GetMethod( "PackAsync"' new[] { underlyingType' typeof( CancellationToken) } )' 							this.EmitEnumToUnderlyingCastExpression( context' underlyingType' this.ReferArgument( context' this.TargetType' "enumValue"' 2 ) )' 							this.ReferArgument( context'TypeDefinition.CancellationTokenType' "cancellationToken"' 3 ) 						) 					) : #endif // FEATURE_TAP 					this.EmitInvokeVoidMethod( 						context' 						this.ReferArgument( context' TypeDefinition.PackerType' "packer"' 1 )' 						typeof( Packer ).GetMethod( "Pack"' new[] { underlyingType } )' 						this.EmitEnumToUnderlyingCastExpression( context' underlyingType' this.ReferArgument( context' this.TargetType' "enumValue"' 2 ) ) 					);
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildPackUnderlyingValueTo,The following statement contains a magic number: var invocation = #if FEATURE_TAP 				isAsync 					? this.EmitRetrunStatement( 						context' 						this.EmitInvokeMethodExpression( 							context' 							this.ReferArgument( context' TypeDefinition.PackerType' "packer"' 1 )' 							typeof( Packer ).GetMethod( "PackAsync"' new[] { underlyingType' typeof( CancellationToken) } )' 							this.EmitEnumToUnderlyingCastExpression( context' underlyingType' this.ReferArgument( context' this.TargetType' "enumValue"' 2 ) )' 							this.ReferArgument( context'TypeDefinition.CancellationTokenType' "cancellationToken"' 3 ) 						) 					) : #endif // FEATURE_TAP 					this.EmitInvokeVoidMethod( 						context' 						this.ReferArgument( context' TypeDefinition.PackerType' "packer"' 1 )' 						typeof( Packer ).GetMethod( "Pack"' new[] { underlyingType } )' 						this.EmitEnumToUnderlyingCastExpression( context' underlyingType' this.ReferArgument( context' this.TargetType' "enumValue"' 2 ) ) 					);
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildPackUnderlyingValueTo,The following statement contains a magic number: var invocation = #if FEATURE_TAP 				isAsync 					? this.EmitRetrunStatement( 						context' 						this.EmitInvokeMethodExpression( 							context' 							this.ReferArgument( context' TypeDefinition.PackerType' "packer"' 1 )' 							typeof( Packer ).GetMethod( "PackAsync"' new[] { underlyingType' typeof( CancellationToken) } )' 							this.EmitEnumToUnderlyingCastExpression( context' underlyingType' this.ReferArgument( context' this.TargetType' "enumValue"' 2 ) )' 							this.ReferArgument( context'TypeDefinition.CancellationTokenType' "cancellationToken"' 3 ) 						) 					) : #endif // FEATURE_TAP 					this.EmitInvokeVoidMethod( 						context' 						this.ReferArgument( context' TypeDefinition.PackerType' "packer"' 1 )' 						typeof( Packer ).GetMethod( "Pack"' new[] { underlyingType } )' 						this.EmitEnumToUnderlyingCastExpression( context' underlyingType' this.ReferArgument( context' this.TargetType' "enumValue"' 2 ) ) 					);
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildObjectPackToCore,The following statement contains a magic number: var parameters = #if FEATURE_TAP 				isAsync ? new[] { context.Packer' context.PackToTarget' this.ReferCancellationToken( context' 3 ) } : #endif // FEATURE_TAP 				new[] { context.Packer' context.PackToTarget };
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildObjectPackToCore,The following statement contains a magic number: var argumentsForNull = #if FEATURE_TAP 				isAsync ? new[] { this.ReferCancellationToken( context' 3 ) } : #endif // FEATURE_TAP 				NoConstructs;
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildObjectPackToCore,The following statement contains a magic number: packHelperArguments.Add( "CancellationToken"' this.ReferCancellationToken( context' 3 ) );
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitObjectUnpackFromCore,The following statement contains a magic number: var unpackOperationParameters = 				new[] { context.Unpacker' context.UnpackingContextInUnpackValueMethods' context.IndexOfItem' context.ItemsCount } #if FEATURE_TAP 				.Concat( isAsync ? new [] { this.ReferCancellationToken( context' 2 ) } : NoConstructs ).ToArray() #endif // FEATURE_TAP 				;
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitObjectUnpackFromCore,The following statement contains a magic number: privateMethodBody = #if FEATURE_TAP 						isAsync 						? this.EmitRetrunStatement( 							context' 							this.EmitInvokeMethodExpression( 								context' 								context.Unpacker' 								Metadata._Unpacker.ReadAsync' 								this.ReferCancellationToken( context' 5 ) 							) 						) : #endif // FEATURE_TAP 						this.EmitInvokeVoidMethod( 							context' 							context.Unpacker' 							Metadata._Unpacker.Read 						);
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitObjectUnpackFromCore,The following statement contains a magic number: var unpackHelperArguments = 				new TConstruct[ ( ( method == SerializationMethod.Array ) ? 5 : 4 ) + ( isAsync ? 1 : 0 ) ];
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitObjectUnpackFromCore,The following statement contains a magic number: var unpackHelperArguments = 				new TConstruct[ ( ( method == SerializationMethod.Array ) ? 5 : 4 ) + ( isAsync ? 1 : 0 ) ];
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitObjectUnpackFromCore,The following statement contains a magic number: unpackHelperArguments[ 2 ] = unpackingContext.Factory;
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitObjectUnpackFromCore,The following statement contains a magic number: unpackHelperArguments[ 3 ] = this.EmitGetMemberNamesExpression( context );
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitObjectUnpackFromCore,The following statement contains a magic number: unpackHelperArguments[ 4 ] = this.EmitGetActionsExpression( context' ActionType.UnpackFromArray' isAsync );
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitObjectUnpackFromCore,The following statement contains a magic number: unpackHelperArguments[ unpackHelperArguments.Length - 1 ] = this.ReferCancellationToken( context' 2 );
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTuplePackToCore,The following statement contains a magic number: var memberInvocationChain = new List<TInfo>( itemTypes.Count % 7 + 1 );
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTuplePackToCore,The following statement contains a magic number: var packValueArguments = 				new[] { context.Packer' context.PackToTarget } #if FEATURE_TAP 				.Concat( isAsync ? new[] { this.ReferCancellationToken( context' 3 ) } : NoConstructs ).ToArray() #endif // FEATURE_TAP 				;
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTuplePackToCore,The following statement contains a magic number: i % 7 == 0
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTuplePackToCore,The following statement contains a magic number: var itemNMember = memberFactory( tupleTypeList[ depth ]' "Item" + ( ( i % 7 ) + 1 ) );
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTuplePackToCore,The following statement contains a magic number: Contract.Assert( 					itemNMember != null' 					tupleTypeList[ depth ].GetFullName() + "::Item" + ( ( i % 7 ) + 1 ) + " [ " + depth + " ] @ " + i 				);
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTuplePackToCore,The following statement contains a magic number: packHelperArguments.Add( "CancellationToken"' this.ReferCancellationToken( context' 3 ) );
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTupleUnpackFromCore,The following statement contains a magic number: var unpackValueArguments = 				new[] { context.Unpacker' context.UnpackingContextInUnpackValueMethods' context.IndexOfItem' context.ItemsCount } #if FEATURE_TAP 				.Concat( isAsync ? new[] { this.ReferCancellationToken( context' 2 ) } : NoConstructs ).ToArray() #endif // FEATURE_TAP 				;
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTupleUnpackFromCore,The following statement contains a magic number: var gets = 					Enumerable.Range( nest * 7' Math.Min( itemTypes.Count - nest * 7' 7 ) ) 						.Select( i => 							this.EmitGetFieldExpression( 								context' 								context.UnpackingContextInCreateObjectFromContext' 								new FieldDefinition( 									unpackingContext.VariableType' 									SerializationTarget.GetTupleItemNameFromIndex( i )' 									itemTypes[ i ] 								) 							) 						);
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTupleUnpackFromCore,The following statement contains a magic number: var gets = 					Enumerable.Range( nest * 7' Math.Min( itemTypes.Count - nest * 7' 7 ) ) 						.Select( i => 							this.EmitGetFieldExpression( 								context' 								context.UnpackingContextInCreateObjectFromContext' 								new FieldDefinition( 									unpackingContext.VariableType' 									SerializationTarget.GetTupleItemNameFromIndex( i )' 									itemTypes[ i ] 								) 							) 						);
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTupleUnpackFromCore,The following statement contains a magic number: var gets = 					Enumerable.Range( nest * 7' Math.Min( itemTypes.Count - nest * 7' 7 ) ) 						.Select( i => 							this.EmitGetFieldExpression( 								context' 								context.UnpackingContextInCreateObjectFromContext' 								new FieldDefinition( 									unpackingContext.VariableType' 									SerializationTarget.GetTupleItemNameFromIndex( i )' 									itemTypes[ i ] 								) 							) 						);
Magic Number,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,BuildTupleUnpackFromCore,The following statement contains a magic number: var unpackHelperArguments = 				new[] 				{ 					context.Unpacker' 					unpackingContext.Variable' 					unpackingContext.Factory' 					this.EmitGetMemberNamesExpression( context )' 					this.EmitGetActionsExpression( context' ActionType.UnpackFromArray' isAsync ) 				} #if FEATURE_TAP 				.Concat( isAsync ? new[] { this.ReferCancellationToken( context' 2 ) } : NoConstructs ).ToArray() #endif // FEATURE_TAP 				;
Magic Number,MsgPack.Serialization.AbstractSerializers,ComparablePolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerFieldKey.cs,Pack,The following statement contains a magic number: packer.PackArrayHeader( 4 );
Magic Number,MsgPack.Serialization,DefaultConcreteTypeRepository,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultConcreteTypeRepository.cs,DefaultConcreteTypeRepository,The following statement contains a magic number: this._defaultCollectionTypes = new TypeKeyRepository( 				new Dictionary<RuntimeTypeHandle' object>( #if NET35 || ( SILVERLIGHT && !WINDOWS_PHONE ) 					8 #elif NET40 					9 #else 					12 #endif 				) 				{ 					{ typeof( IEnumerable<> ).TypeHandle' typeof( List<> ) }' 					{ typeof( ICollection<> ).TypeHandle' typeof( List<> ) }' 					{ typeof( IList<> ).TypeHandle' typeof( List<> ) }' 					{ typeof( IDictionary<'> ).TypeHandle' typeof( Dictionary<'> ) }' 					{ typeof( IEnumerable ).TypeHandle' typeof( List<MessagePackObject> ) }' 					{ typeof( ICollection ).TypeHandle' typeof( List<MessagePackObject> ) }' 					{ typeof( IList ).TypeHandle' typeof( List<MessagePackObject> ) }' 					{ typeof( IDictionary ).TypeHandle' typeof( MessagePackObjectDictionary ) }' #if !NET35 && !UNITY 					{ typeof( ISet<> ).TypeHandle' typeof( HashSet<> ) }' #if !NET40 && !( SILVERLIGHT && !WINDOWS_PHONE ) 					{ typeof( IReadOnlyCollection<> ).TypeHandle' typeof( List<> ) }' 					{ typeof( IReadOnlyList<> ).TypeHandle' typeof( List<> ) }' 					{ typeof( IReadOnlyDictionary<'> ).TypeHandle' typeof( Dictionary<'> ) }' #endif // !NET40 && !( SILVERLIGHT && !WINDOWS_PHONE ) #endif // !NET35 && !UNITY 				} 			);
Magic Number,MsgPack.Serialization,ExtTypeCodeMapping,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ExtTypeCodeMapping.cs,ExtTypeCodeMapping,The following statement contains a magic number: this._index = new Dictionary<string' byte>( 2 );
Magic Number,MsgPack.Serialization,ExtTypeCodeMapping,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ExtTypeCodeMapping.cs,ExtTypeCodeMapping,The following statement contains a magic number: this._types = new Dictionary<byte' string>( 2 );
Magic Number,MsgPack.Serialization,KeyNameTransformers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\KeyNameTransformers.cs,ToUpperSnake,The following statement contains a magic number: var buffer = new StringBuilder( mayBeUpperCamel.Length * 2 );
Magic Number,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following statement contains a magic number: const int withCapacity = 10;
Magic Number,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following statement contains a magic number: const int withComparer = 11;
Magic Number,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following statement contains a magic number: const int withComparerAndCapacity = 20;
Magic Number,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following statement contains a magic number: const int withCapacityAndComparer = 21;
Magic Number,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following statement contains a magic number: switch ( parameters.Length ) 				{ 					case 0: 					{ 						if ( currentScore < noParameters ) 						{ 							constructor = candidate; 							currentScore = noParameters; 						}  						break; 					} 					case 1: 					{ 						if ( currentScore < withCapacity && parameters[ 0 ].ParameterType == typeof( int ) ) 						{ 							constructor = candidate; 							currentScore = noParameters; 						} 						else if ( currentScore < withComparer && IsIEqualityComparer( parameters[ 0 ].ParameterType ) ) 						{ 							constructor = candidate; 							currentScore = noParameters; 						} 						break; 					} 					case 2: 					{ 						if ( currentScore < withCapacityAndComparer && parameters[ 0 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 1 ].ParameterType ) ) 						{ 							constructor = candidate; 							currentScore = withCapacityAndComparer; 						} 						else if ( currentScore < withComparerAndCapacity && parameters[ 1 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 0 ].ParameterType ) ) 						{ 							constructor = candidate; 							currentScore = withComparerAndCapacity; 						}  						break; 					} 				}
Magic Number,MsgPack.Serialization.DefaultSerializers,ArraySerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\ArraySerializer.cs,InitializeArraySerializerFactories,The following statement contains a magic number: return 				new Dictionary<Type' Func<SerializationContext'object>>( 25 ) 				{ 					{ typeof( SByte[] )' context => new SByteArraySerializer( context ) }' 					{ typeof( SByte?[] )'context => new NullableSByteArraySerializer( context ) }' 					{ typeof( Int16[] )' context => new Int16ArraySerializer( context ) }' 					{ typeof( Int16?[] )'context => new NullableInt16ArraySerializer( context ) }' 					{ typeof( Int32[] )' context => new Int32ArraySerializer( context ) }' 					{ typeof( Int32?[] )'context => new NullableInt32ArraySerializer( context ) }' 					{ typeof( Int64[] )' context => new Int64ArraySerializer( context ) }' 					{ typeof( Int64?[] )'context => new NullableInt64ArraySerializer( context ) }' 					{ typeof( Byte[] )' context => new ByteArraySerializer( context ) }' 					{ typeof( Byte?[] )'context => new NullableByteArraySerializer( context ) }' 					{ typeof( UInt16[] )' context => new UInt16ArraySerializer( context ) }' 					{ typeof( UInt16?[] )'context => new NullableUInt16ArraySerializer( context ) }' 					{ typeof( UInt32[] )' context => new UInt32ArraySerializer( context ) }' 					{ typeof( UInt32?[] )'context => new NullableUInt32ArraySerializer( context ) }' 					{ typeof( UInt64[] )' context => new UInt64ArraySerializer( context ) }' 					{ typeof( UInt64?[] )'context => new NullableUInt64ArraySerializer( context ) }' 					{ typeof( Single[] )' context => new SingleArraySerializer( context ) }' 					{ typeof( Single?[] )'context => new NullableSingleArraySerializer( context ) }' 					{ typeof( Double[] )' context => new DoubleArraySerializer( context ) }' 					{ typeof( Double?[] )'context => new NullableDoubleArraySerializer( context ) }' 					{ typeof( Boolean[] )' context => new BooleanArraySerializer( context ) }' 					{ typeof( Boolean?[] )'context => new NullableBooleanArraySerializer( context ) }' 					{ typeof( string[] )' context => new StringArraySerializer( context ) }' 					{ typeof( byte[][] )' context => new BinaryArraySerializer( context ) }' 					{ typeof( MessagePackObject[] )' context => new MessagePackObjectArraySerializer( context ) }' 				};
Magic Number,MsgPack.Serialization.DefaultSerializers,InternalDateTimeExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\InternalDateTimeExtensions.cs,ToDateTime,The following statement contains a magic number: return 				_fileTimeEpocUtc.AddTicks( 					unchecked( ( ( long )source.dwHighDateTime << 32 ) | ( source.dwLowDateTime & 0xffffffff ) ) 				);
Magic Number,MsgPack.Serialization.DefaultSerializers,InternalDateTimeExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\InternalDateTimeExtensions.cs,ToWin32FileTimeUtc,The following statement contains a magic number: return 				new FILETIME 				{ 					dwHighDateTime = unchecked( ( int ) ( value >> 32 ) )' 					dwLowDateTime = unchecked( ( int ) ( value & 0xffffffff ) ) 				};
Magic Number,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,PackArrayCore,The following statement contains a magic number: packer.PackArrayHeader( 2 );
Magic Number,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,PackArrayCore,The following statement contains a magic number: bodyPacker.PackArrayHeader( 2 );
Magic Number,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,UnpackFromCore,The following statement contains a magic number: UnpackHelpers.GetItemsCount( unpacker ) != 2
Magic Number,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,PackArrayAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 2' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,PackArrayAsyncCore,The following statement contains a magic number: await bodyPacker.PackArrayHeaderAsync( 2' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,UnpackFromAsyncCore,The following statement contains a magic number: UnpackHelpers.GetItemsCount( unpacker ) != 2
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 2 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector2 )' 2 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector2 )' 2 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: length != 2
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 2' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector2 )' 2 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector2 )' 2 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: length != 2
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector3MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 3 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector3MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector3 )' 3 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector3MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector3 )' 3 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector3MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: length != 3
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector3MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 2' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector3MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 3' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector3MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector3 )' 3 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector3MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector3 )' 3 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector3MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: length != 3
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector3MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 2' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector4 )' 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector4 )' 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: length != 4
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 2' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 3' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 4' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector4 )' 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector4 )' 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: length != 4
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 2' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 3' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Plane )' 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Plane )' 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: length != 4
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 2' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 3' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 4' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Plane )' 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Plane )' 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: length != 4
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 2' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 3' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Quaternion )' 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Quaternion )' 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: length != 4
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 2' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 3' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 4' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Quaternion )' 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Quaternion )' 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: length != 4
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 2' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 3' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 6 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Matrix3x2 )' 6 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Matrix3x2 )' 6 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: length != 6
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 2' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 3' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 4' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 5' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 6' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Matrix3x2 )' 6 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Matrix3x2 )' 6 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: length != 6
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 2' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 3' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 4' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 5' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 16 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Matrix4x4 )' 16 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Matrix4x4 )' 16 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: length != 16
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 2' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 3' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 4' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 5' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 6' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 7' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 8' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 9' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 10' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 11' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 12' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 13' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 14' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 15' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 16' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Matrix4x4 )' 16 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Matrix4x4 )' 16 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: length != 16
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 2' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 3' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 4' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 5' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 6' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 7' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 8' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 9' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 10' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 11' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 12' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 13' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 14' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 15' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Collections_DictionaryEntryMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_DictionaryEntryMessagePackSerializer.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 2 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Collections_DictionaryEntryMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_DictionaryEntryMessagePackSerializer.cs,PackToAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 2' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Collections_Generic_KeyValuePair_2MessagePackSerializer<TKey;TValue>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_Generic_KeyValuePair_2MessagePackSerializer`2.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 2 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Collections_Generic_KeyValuePair_2MessagePackSerializer<TKey;TValue>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_Generic_KeyValuePair_2MessagePackSerializer`2.cs,PackToAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 2' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_ComplexMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Numerics_ComplexMessagePackSerializer.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 2 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_ComplexMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Numerics_ComplexMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Complex )' 2 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_ComplexMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Numerics_ComplexMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Complex )' 2 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_ComplexMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Numerics_ComplexMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: length != 2
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_ComplexMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Numerics_ComplexMessagePackSerializer.cs,PackToAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 2' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Version )' 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Version )' 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: length != 4
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 2' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 3' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,PackToAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 4' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Version )' 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Version )' 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromAsyncCore,The following statement contains a magic number: length != 4
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 2' unpacker );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromAsyncCore,The following statement contains a magic number: SerializationExceptions.ThrowMissingItem( 3' unpacker );
Magic Number,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderEmittingContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderEmittingContext.cs,ResetCore,The following statement contains a magic number: this.PackToTarget = ILConstruct.Argument( 2' targetTypeDefinition' "objectTree" );
Magic Number,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderEmittingContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderEmittingContext.cs,ResetCore,The following statement contains a magic number: this.IndexOfItem = ILConstruct.Argument( 3' TypeDefinition.Int32Type' "indexOfItem" );
Magic Number,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderEmittingContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderEmittingContext.cs,ResetCore,The following statement contains a magic number: this.ItemsCount = ILConstruct.Argument( 4' TypeDefinition.Int32Type' "itemsCount" );
Magic Number,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderEmittingContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderEmittingContext.cs,ResetCore,The following statement contains a magic number: this.UnpackToTarget = ILConstruct.Argument( 2' targetTypeDefinition' "collection" );
Magic Number,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderEmittingContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderEmittingContext.cs,ResetCore,The following statement contains a magic number: this.ItemToAdd = ILConstruct.Argument( 2' traits.ElementType' "item" );
Magic Number,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderEmittingContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderEmittingContext.cs,ResetCore,The following statement contains a magic number: this.KeyToAdd = ILConstruct.Argument( 2' traits.ElementType.GetGenericArguments()[ 0 ]' "key" );
Magic Number,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderEmittingContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderEmittingContext.cs,ResetCore,The following statement contains a magic number: this.ValueToAdd = ILConstruct.Argument( 3' traits.ElementType.GetGenericArguments()[ 1 ]' "value" );
Magic Number,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderEmittingContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderEmittingContext.cs,DefineUnpackValueMethodArguments,The following statement contains a magic number: parameterInUnpackValueMethods = ILConstruct.Argument( 2' type' "unpackingContext" );
Magic Number,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderEmittingContext,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderEmittingContext.cs,DefineUnpackedItemParameterInSetValueMethods,The following statement contains a magic number: return ILConstruct.Argument( 2' itemType' "unpackedValue" );
Magic Number,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,MakeIntegerLiteral,The following statement contains a magic number: switch ( constant ) 			{ 				case 0: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_0() ); 				} 				case 1: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_1() ); 				} 				case 2: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_2() ); 				} 				case 3: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_3() ); 				} 				case 4: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_4() ); 				} 				case 5: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_5() ); 				} 				case 6: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_6() ); 				} 				case 7: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_7() ); 				} 				case 8: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_8() ); 				} 				case -1: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_M1() ); 				} 				default: 				{ 					if ( SByte.MinValue <= constant && constant <= SByte.MaxValue ) 					{ 						return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_S( unchecked( ( byte )constant ) ) ); 					} 					else 					{ 						return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4( constant ) ); 					} 				} 			}
Magic Number,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,MakeIntegerLiteral,The following statement contains a magic number: switch ( constant ) 			{ 				case 0: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_0() ); 				} 				case 1: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_1() ); 				} 				case 2: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_2() ); 				} 				case 3: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_3() ); 				} 				case 4: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_4() ); 				} 				case 5: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_5() ); 				} 				case 6: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_6() ); 				} 				case 7: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_7() ); 				} 				case 8: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_8() ); 				} 				case -1: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_M1() ); 				} 				default: 				{ 					if ( SByte.MinValue <= constant && constant <= SByte.MaxValue ) 					{ 						return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_S( unchecked( ( byte )constant ) ) ); 					} 					else 					{ 						return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4( constant ) ); 					} 				} 			}
Magic Number,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,MakeIntegerLiteral,The following statement contains a magic number: switch ( constant ) 			{ 				case 0: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_0() ); 				} 				case 1: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_1() ); 				} 				case 2: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_2() ); 				} 				case 3: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_3() ); 				} 				case 4: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_4() ); 				} 				case 5: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_5() ); 				} 				case 6: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_6() ); 				} 				case 7: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_7() ); 				} 				case 8: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_8() ); 				} 				case -1: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_M1() ); 				} 				default: 				{ 					if ( SByte.MinValue <= constant && constant <= SByte.MaxValue ) 					{ 						return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_S( unchecked( ( byte )constant ) ) ); 					} 					else 					{ 						return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4( constant ) ); 					} 				} 			}
Magic Number,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,MakeIntegerLiteral,The following statement contains a magic number: switch ( constant ) 			{ 				case 0: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_0() ); 				} 				case 1: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_1() ); 				} 				case 2: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_2() ); 				} 				case 3: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_3() ); 				} 				case 4: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_4() ); 				} 				case 5: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_5() ); 				} 				case 6: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_6() ); 				} 				case 7: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_7() ); 				} 				case 8: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_8() ); 				} 				case -1: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_M1() ); 				} 				default: 				{ 					if ( SByte.MinValue <= constant && constant <= SByte.MaxValue ) 					{ 						return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_S( unchecked( ( byte )constant ) ) ); 					} 					else 					{ 						return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4( constant ) ); 					} 				} 			}
Magic Number,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,MakeIntegerLiteral,The following statement contains a magic number: switch ( constant ) 			{ 				case 0: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_0() ); 				} 				case 1: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_1() ); 				} 				case 2: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_2() ); 				} 				case 3: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_3() ); 				} 				case 4: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_4() ); 				} 				case 5: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_5() ); 				} 				case 6: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_6() ); 				} 				case 7: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_7() ); 				} 				case 8: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_8() ); 				} 				case -1: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_M1() ); 				} 				default: 				{ 					if ( SByte.MinValue <= constant && constant <= SByte.MaxValue ) 					{ 						return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_S( unchecked( ( byte )constant ) ) ); 					} 					else 					{ 						return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4( constant ) ); 					} 				} 			}
Magic Number,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,MakeIntegerLiteral,The following statement contains a magic number: switch ( constant ) 			{ 				case 0: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_0() ); 				} 				case 1: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_1() ); 				} 				case 2: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_2() ); 				} 				case 3: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_3() ); 				} 				case 4: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_4() ); 				} 				case 5: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_5() ); 				} 				case 6: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_6() ); 				} 				case 7: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_7() ); 				} 				case 8: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_8() ); 				} 				case -1: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_M1() ); 				} 				default: 				{ 					if ( SByte.MinValue <= constant && constant <= SByte.MaxValue ) 					{ 						return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_S( unchecked( ( byte )constant ) ) ); 					} 					else 					{ 						return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4( constant ) ); 					} 				} 			}
Magic Number,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,MakeIntegerLiteral,The following statement contains a magic number: switch ( constant ) 			{ 				case 0: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_0() ); 				} 				case 1: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_1() ); 				} 				case 2: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_2() ); 				} 				case 3: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_3() ); 				} 				case 4: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_4() ); 				} 				case 5: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_5() ); 				} 				case 6: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_6() ); 				} 				case 7: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_7() ); 				} 				case 8: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_8() ); 				} 				case -1: 				{ 					return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_M1() ); 				} 				default: 				{ 					if ( SByte.MinValue <= constant && constant <= SByte.MaxValue ) 					{ 						return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4_S( unchecked( ( byte )constant ) ) ); 					} 					else 					{ 						return ILConstruct.Literal( contextType' constant' il => il.EmitLdc_I4( constant ) ); 					} 				} 			}
Magic Number,MsgPack.Serialization.EmittingSerializers,SerializationMethodGeneratorManager,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\SerializationMethodGeneratorManager.cs,SetUpAssemblyBuilderAttributes,The following statement contains a magic number: dedicatedAssemblyBuilder.SetCustomAttribute( 				new CustomAttributeBuilder( 					// ReSharper disable once AssignNullToNotNullAttribute 					typeof( System.Runtime.CompilerServices.CompilationRelaxationsAttribute ).GetConstructor( new[] { typeof( int ) } )' 					new object[] { 8 } 				) 			);
Magic Number,MsgPack.Serialization.Metadata,_UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Metadata\_UnpackHelpers.cs,GetDirectUnpackMethods,The following statement contains a magic number: return 				new Dictionary<Type' MethodInfo>( 14 ) 				{ 					{ typeof( SByte )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackSByteValue ) ) }' 					{ typeof( SByte? )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackNullableSByteValue ) ) }' 					{ typeof( Int16 )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackInt16Value ) ) }' 					{ typeof( Int16? )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackNullableInt16Value ) ) }' 					{ typeof( Int32 )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackInt32Value ) ) }' 					{ typeof( Int32? )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackNullableInt32Value ) ) }' 					{ typeof( Int64 )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackInt64Value ) ) }' 					{ typeof( Int64? )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackNullableInt64Value ) ) }' 					{ typeof( Byte )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackByteValue ) ) }' 					{ typeof( Byte? )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackNullableByteValue ) ) }' 					{ typeof( UInt16 )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackUInt16Value ) ) }' 					{ typeof( UInt16? )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackNullableUInt16Value ) ) }' 					{ typeof( UInt32 )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackUInt32Value ) ) }' 					{ typeof( UInt32? )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackNullableUInt32Value ) ) }' 					{ typeof( UInt64 )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackUInt64Value ) ) }' 					{ typeof( UInt64? )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackNullableUInt64Value ) ) }' 					{ typeof( Single )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackSingleValue ) ) }' 					{ typeof( Single? )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackNullableSingleValue ) ) }' 					{ typeof( Double )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackDoubleValue ) ) }' 					{ typeof( Double? )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackNullableDoubleValue ) ) }' 					{ typeof( Boolean )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackBooleanValue ) ) }' 					{ typeof( Boolean? )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackNullableBooleanValue ) ) }' 					{ typeof( string )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackStringValue ) ) }' 					{ typeof( byte[] )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackBinaryValue ) ) }' 				};
Magic Number,MsgPack.Serialization.Metadata,_UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Metadata\_UnpackHelpers.cs,GetAsyncDirectUnpackMethods,The following statement contains a magic number: return 				new Dictionary<Type' MethodInfo>( 14 ) 				{ 					{ typeof( SByte )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackSByteValueAsync ) ) }' 					{ typeof( SByte? )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackNullableSByteValueAsync ) ) }' 					{ typeof( Int16 )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackInt16ValueAsync ) ) }' 					{ typeof( Int16? )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackNullableInt16ValueAsync ) ) }' 					{ typeof( Int32 )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackInt32ValueAsync ) ) }' 					{ typeof( Int32? )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackNullableInt32ValueAsync ) ) }' 					{ typeof( Int64 )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackInt64ValueAsync ) ) }' 					{ typeof( Int64? )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackNullableInt64ValueAsync ) ) }' 					{ typeof( Byte )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackByteValueAsync ) ) }' 					{ typeof( Byte? )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackNullableByteValueAsync ) ) }' 					{ typeof( UInt16 )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackUInt16ValueAsync ) ) }' 					{ typeof( UInt16? )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackNullableUInt16ValueAsync ) ) }' 					{ typeof( UInt32 )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackUInt32ValueAsync ) ) }' 					{ typeof( UInt32? )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackNullableUInt32ValueAsync ) ) }' 					{ typeof( UInt64 )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackUInt64ValueAsync ) ) }' 					{ typeof( UInt64? )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackNullableUInt64ValueAsync ) ) }' 					{ typeof( Single )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackSingleValueAsync ) ) }' 					{ typeof( Single? )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackNullableSingleValueAsync ) ) }' 					{ typeof( Double )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackDoubleValueAsync ) ) }' 					{ typeof( Double? )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackNullableDoubleValueAsync ) ) }' 					{ typeof( Boolean )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackBooleanValueAsync ) ) }' 					{ typeof( Boolean? )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackNullableBooleanValueAsync ) ) }' 					{ typeof( string )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackStringValueAsync ) ) }' 					{ typeof( byte[] )' typeof( UnpackHelpers ).GetMethod( nameof( UnpackHelpers.UnpackBinaryValueAsync ) ) }' 				};
Magic Number,MsgPack.Serialization.Polymorphic,RuntimeTypeVerifier,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\RuntimeTypeVerifier.cs,VerifyCore,The following statement contains a magic number: Contract.Assert( _histories.Count < 1000 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: packer.PackArrayHeader( 2 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,EncodeAsync,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 2' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: packer.PackArrayHeader( 2 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: packer.PackArrayHeader( 6 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: var version = new byte[ 16 ];
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Major )' 0' version' 0' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Minor )' 0' version' 4' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Minor )' 0' version' 4' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Build )' 0' version' 8' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Build )' 0' version' 8' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Revision )' 0' version' 12' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Revision )' 0' version' 12' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,EncodeAsync,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 2' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,EncodeAsync,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 6' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,EncodeAsync,The following statement contains a magic number: var version = new byte[ 16 ];
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,EncodeAsync,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Major )' 0' version' 0' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,EncodeAsync,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Minor )' 0' version' 4' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,EncodeAsync,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Minor )' 0' version' 4' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,EncodeAsync,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Build )' 0' version' 8' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,EncodeAsync,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Build )' 0' version' 8' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,EncodeAsync,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Revision )' 0' version' 12' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,EncodeAsync,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Revision )' 0' version' 12' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Decode,The following statement contains a magic number: !unpacker.IsArrayHeader || UnpackHelpers.GetItemsCount( unpacker ) != 2
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Decode,The following statement contains a magic number: !unpacker.IsArrayHeader || UnpackHelpers.GetItemsCount( unpacker ) != 2
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,DecodeAsync,The following statement contains a magic number: !unpacker.IsArrayHeader || UnpackHelpers.GetItemsCount( unpacker ) != 2
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,DecodeAsync,The following statement contains a magic number: !unpacker.IsArrayHeader || UnpackHelpers.GetItemsCount( unpacker ) != 2
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,CheckUnpackerForRuntimeTypeInfoDecoding,The following statement contains a magic number: unpacker.ItemsCount != 6
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,BuildAssemblyName,The following statement contains a magic number: var assemblyName = 				new AssemblyName 				{ 					Name = assemblySimpleName' 					Version = 						new Version( 							BitConverter.ToInt32( version' 0 )' 							BitConverter.ToInt32( version' 4 )' 							BitConverter.ToInt32( version' 8 )' 							BitConverter.ToInt32( version' 12 ) 						)' 					CultureInfo = 						String.IsNullOrEmpty( culture ) 							? null #if !SILVERLIGHT 							: CultureInfo.GetCultureInfo( culture )' #else 							: new CultureInfo( culture )' #endif //  !SILVERLIGHT 				};
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,BuildAssemblyName,The following statement contains a magic number: var assemblyName = 				new AssemblyName 				{ 					Name = assemblySimpleName' 					Version = 						new Version( 							BitConverter.ToInt32( version' 0 )' 							BitConverter.ToInt32( version' 4 )' 							BitConverter.ToInt32( version' 8 )' 							BitConverter.ToInt32( version' 12 ) 						)' 					CultureInfo = 						String.IsNullOrEmpty( culture ) 							? null #if !SILVERLIGHT 							: CultureInfo.GetCultureInfo( culture )' #else 							: new CultureInfo( culture )' #endif //  !SILVERLIGHT 				};
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,BuildAssemblyName,The following statement contains a magic number: var assemblyName = 				new AssemblyName 				{ 					Name = assemblySimpleName' 					Version = 						new Version( 							BitConverter.ToInt32( version' 0 )' 							BitConverter.ToInt32( version' 4 )' 							BitConverter.ToInt32( version' 8 )' 							BitConverter.ToInt32( version' 12 ) 						)' 					CultureInfo = 						String.IsNullOrEmpty( culture ) 							? null #if !SILVERLIGHT 							: CultureInfo.GetCultureInfo( culture )' #else 							: new CultureInfo( culture )' #endif //  !SILVERLIGHT 				};
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackAndAddCollectionItem,The following statement contains a magic number: switch ( traits.DetailedCollectionType ) 				{ 					case CollectionDetailedKind.GenericDictionary: 					{ 						// item should be KeyValuePair<TKey' TValue> 						var arguments = new object[ 2 ]; 						var key = default( PropertyInfo ); 						var value = default( PropertyInfo ); 						foreach ( var item in source ) 						{ 							if ( key == null ) 							{ 								key = item.GetType().GetProperty( "Key" ); 								value = item.GetType().GetProperty( "Value" ); 							}  							arguments[ 0 ] = key.GetValue( item' null ); 							arguments[ 1 ] = value.GetValue( item' null ); 							traits.AddMethod.InvokePreservingExceptionType( destination' arguments ); 						} 						break; 					} 					case CollectionDetailedKind.NonGenericDictionary: 					{ 						// item should be DictionaryEntry 						var arguments = new object[ 2 ]; 						foreach ( var item in source ) 						{ 							arguments[ 0 ] = ReflectionSerializerHelper.DictionaryEntryKeyProperty.GetValue( item' null ); 							arguments[ 1 ] = ReflectionSerializerHelper.DictionaryEntryValueProperty.GetValue( item' null ); 							traits.AddMethod.InvokePreservingExceptionType( destination' arguments ); 						} 						break; 					} 					default: 					{ 						var arguments = new object[ 1 ]; 						foreach ( var item in source ) 						{ 							arguments[ 0 ] = item; 							traits.AddMethod.InvokePreservingExceptionType( destination' arguments ); 						} 						break; 					} 				}
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackAndAddCollectionItem,The following statement contains a magic number: switch ( traits.DetailedCollectionType ) 				{ 					case CollectionDetailedKind.GenericDictionary: 					{ 						// item should be KeyValuePair<TKey' TValue> 						var arguments = new object[ 2 ]; 						var key = default( PropertyInfo ); 						var value = default( PropertyInfo ); 						foreach ( var item in source ) 						{ 							if ( key == null ) 							{ 								key = item.GetType().GetProperty( "Key" ); 								value = item.GetType().GetProperty( "Value" ); 							}  							arguments[ 0 ] = key.GetValue( item' null ); 							arguments[ 1 ] = value.GetValue( item' null ); 							traits.AddMethod.InvokePreservingExceptionType( destination' arguments ); 						} 						break; 					} 					case CollectionDetailedKind.NonGenericDictionary: 					{ 						// item should be DictionaryEntry 						var arguments = new object[ 2 ]; 						foreach ( var item in source ) 						{ 							arguments[ 0 ] = ReflectionSerializerHelper.DictionaryEntryKeyProperty.GetValue( item' null ); 							arguments[ 1 ] = ReflectionSerializerHelper.DictionaryEntryValueProperty.GetValue( item' null ); 							traits.AddMethod.InvokePreservingExceptionType( destination' arguments ); 						} 						break; 					} 					default: 					{ 						var arguments = new object[ 1 ]; 						foreach ( var item in source ) 						{ 							arguments[ 0 ] = item; 							traits.AddMethod.InvokePreservingExceptionType( destination' arguments ); 						} 						break; 					} 				}
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackAndAddCollectionItemAsync,The following statement contains a magic number: switch ( traits.DetailedCollectionType ) 				{ 					case CollectionDetailedKind.GenericDictionary: 					{ 						// item should be KeyValuePair<TKey' TValue> 						var arguments = new object[ 2 ]; 						var key = default( PropertyInfo ); 						var value = default( PropertyInfo ); 						foreach ( var item in source ) 						{ 							if ( key == null ) 							{ 								key = item.GetType().GetProperty( "Key" ); 								value = item.GetType().GetProperty( "Value" ); 							}  							arguments[ 0 ] = key.GetValue( item' null ); 							arguments[ 1 ] = value.GetValue( item' null ); 							traits.AddMethod.InvokePreservingExceptionType( destination' arguments ); 						} 						break; 					} 					case CollectionDetailedKind.NonGenericDictionary: 					{ 						// item should be DictionaryEntry 						var arguments = new object[ 2 ]; 						foreach ( var item in source ) 						{ 							arguments[ 0 ] = ReflectionSerializerHelper.DictionaryEntryKeyProperty.GetValue( item' null ); 							arguments[ 1 ] = ReflectionSerializerHelper.DictionaryEntryValueProperty.GetValue( item' null ); 							traits.AddMethod.InvokePreservingExceptionType( destination' arguments ); 						} 						break; 					} 					default: 					{ 						var arguments = new object[ 1 ]; 						foreach ( var item in source ) 						{ 							arguments[ 0 ] = item; 							traits.AddMethod.InvokePreservingExceptionType( destination' arguments ); 						} 						break; 					} 				}
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackAndAddCollectionItemAsync,The following statement contains a magic number: switch ( traits.DetailedCollectionType ) 				{ 					case CollectionDetailedKind.GenericDictionary: 					{ 						// item should be KeyValuePair<TKey' TValue> 						var arguments = new object[ 2 ]; 						var key = default( PropertyInfo ); 						var value = default( PropertyInfo ); 						foreach ( var item in source ) 						{ 							if ( key == null ) 							{ 								key = item.GetType().GetProperty( "Key" ); 								value = item.GetType().GetProperty( "Value" ); 							}  							arguments[ 0 ] = key.GetValue( item' null ); 							arguments[ 1 ] = value.GetValue( item' null ); 							traits.AddMethod.InvokePreservingExceptionType( destination' arguments ); 						} 						break; 					} 					case CollectionDetailedKind.NonGenericDictionary: 					{ 						// item should be DictionaryEntry 						var arguments = new object[ 2 ]; 						foreach ( var item in source ) 						{ 							arguments[ 0 ] = ReflectionSerializerHelper.DictionaryEntryKeyProperty.GetValue( item' null ); 							arguments[ 1 ] = ReflectionSerializerHelper.DictionaryEntryValueProperty.GetValue( item' null ); 							traits.AddMethod.InvokePreservingExceptionType( destination' arguments ); 						} 						break; 					} 					default: 					{ 						var arguments = new object[ 1 ]; 						foreach ( var item in source ) 						{ 							arguments[ 0 ] = item; 							traits.AddMethod.InvokePreservingExceptionType( destination' arguments ); 						} 						break; 					} 				}
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,CreateCollectionInstanceFactory,The following statement contains a magic number: switch ( parameters.Length ) 			{ 				case 0: 				{ 					return _ => #if !UNITY 						( T ) #endif // !UNITY 						constructor.InvokePreservingExceptionType(); 				} 				case 1: 				{ 					if ( parameters[ 0 ].ParameterType == typeof( int ) ) 					{ 						return capacity => #if !UNITY 							( T ) #endif // !UNITY 							constructor.InvokePreservingExceptionType( capacity ); 					} 					else if ( UnpackHelpers.IsIEqualityComparer( parameters[ 0 ].ParameterType ) ) 					{ 						var comparer =  #if !UNITY 							EqualityComparer<TKey>.Default; #else 							UnpackHelpers.GetEqualityComparer( comparisonType ); #endif // !UNITY 						return _ => #if !UNITY 							( T ) #endif // !UNITY 							constructor.InvokePreservingExceptionType( comparer ); 					}  					break; 				} 				case 2: 				{ 					var comparer = #if !UNITY 						EqualityComparer<TKey>.Default; #else 						UnpackHelpers.GetEqualityComparer( comparisonType ); #endif // !UNITY 					if ( parameters[ 0 ].ParameterType == typeof( int ) 						&& UnpackHelpers.IsIEqualityComparer( parameters[ 1 ].ParameterType ) ) 					{ 						return capacity => #if !UNITY 							( T ) #endif // !UNITY 							constructor.InvokePreservingExceptionType( capacity' comparer ); 					} 					else if ( UnpackHelpers.IsIEqualityComparer( parameters[ 0 ].ParameterType ) && 							parameters[ 0 ].ParameterType == typeof( int ) ) 					{ 						return capacity => #if !UNITY 							( T ) #endif // !UNITY 							constructor.InvokePreservingExceptionType( comparer' capacity ); 					}  					break; 				} 			}
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionTupleMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionTupleMessagePackSerializer`1.cs,GetGetters,The following statement contains a magic number: var memberInvocationChain = new List<TInfo>( itemTypes.Count % 7 + 1 );
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionTupleMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionTupleMessagePackSerializer`1.cs,GetGetters,The following statement contains a magic number: i % 7 == 0
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionTupleMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionTupleMessagePackSerializer`1.cs,GetGetters,The following statement contains a magic number: var itemNMember = metadataFactory( tupleTypes[ depth ]' "Item" + ( ( i % 7 ) + 1 ) );
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionTupleMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionTupleMessagePackSerializer`1.cs,GetGetters,The following statement contains a magic number: Contract.Assert( 					itemNMember != null' 					tupleTypes[ depth ].GetFullName() + "::Item" + ( ( i % 7 ) + 1 ) + " [ " + depth + " ] @ " + i );
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionTupleMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionTupleMessagePackSerializer`1.cs,CreateTuple,The following statement contains a magic number: var items = unpackedItems.Skip( nest * 7 ).Take( Math.Min( unpackedItems.Count' 7 ) ).ToList();
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionTupleMessagePackSerializer<T>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionTupleMessagePackSerializer`1.cs,CreateTuple,The following statement contains a magic number: var items = unpackedItems.Skip( nest * 7 ).Take( Math.Min( unpackedItems.Count' 7 ) ).ToList();
Magic Number,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitAnyLdarg,The following statement contains a magic number: switch ( argumentIndex ) 			{ 				case 0: 				{ 					this.EmitLdarg_0(); 					break; 				} 				case 1: 				{ 					this.EmitLdarg_1(); 					break; 				} 				case 2: 				{ 					this.EmitLdarg_2(); 					break; 				} 				case 3: 				{ 					this.EmitLdarg_3(); 					break; 				} 				default: 				{ 					// TODO:NLiblet 					if ( SByte.MinValue <= argumentIndex && argumentIndex <= SByte.MaxValue ) 					{ 						this.EmitLdarg_S( unchecked( ( byte )( sbyte )argumentIndex ) ); 					} 					else 					{ 						this.EmitLdarg( argumentIndex ); 					} 					break; 				} 			}
Magic Number,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitAnyLdarg,The following statement contains a magic number: switch ( argumentIndex ) 			{ 				case 0: 				{ 					this.EmitLdarg_0(); 					break; 				} 				case 1: 				{ 					this.EmitLdarg_1(); 					break; 				} 				case 2: 				{ 					this.EmitLdarg_2(); 					break; 				} 				case 3: 				{ 					this.EmitLdarg_3(); 					break; 				} 				default: 				{ 					// TODO:NLiblet 					if ( SByte.MinValue <= argumentIndex && argumentIndex <= SByte.MaxValue ) 					{ 						this.EmitLdarg_S( unchecked( ( byte )( sbyte )argumentIndex ) ); 					} 					else 					{ 						this.EmitLdarg( argumentIndex ); 					} 					break; 				} 			}
Magic Number,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitAnyLdloc,The following statement contains a magic number: switch ( localIndex ) 			{ 				case 0: 				{ 					this.EmitLdloc_0(); 					break; 				} 				case 1: 				{ 					this.EmitLdloc_1(); 					break; 				} 				case 2: 				{ 					this.EmitLdloc_2(); 					break; 				} 				case 3: 				{ 					this.EmitLdloc_3(); 					break; 				} 				default: 				{ 					// TODO:NLiblet 					if ( SByte.MinValue <= localIndex && localIndex <= SByte.MaxValue ) 					{ 						this.EmitLdloc_S( unchecked( ( byte )( sbyte )localIndex ) ); 					} 					else 					{ 						this.EmitLdloc( localIndex ); 					} 					break; 				} 			}
Magic Number,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitAnyLdloc,The following statement contains a magic number: switch ( localIndex ) 			{ 				case 0: 				{ 					this.EmitLdloc_0(); 					break; 				} 				case 1: 				{ 					this.EmitLdloc_1(); 					break; 				} 				case 2: 				{ 					this.EmitLdloc_2(); 					break; 				} 				case 3: 				{ 					this.EmitLdloc_3(); 					break; 				} 				default: 				{ 					// TODO:NLiblet 					if ( SByte.MinValue <= localIndex && localIndex <= SByte.MaxValue ) 					{ 						this.EmitLdloc_S( unchecked( ( byte )( sbyte )localIndex ) ); 					} 					else 					{ 						this.EmitLdloc( localIndex ); 					} 					break; 				} 			}
Magic Number,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitAnyLdc_I4,The following statement contains a magic number: switch ( value ) 			{ 				case 0: 				{ 					this.EmitLdc_I4_0(); 					break; 				} 				case 1: 				{ 					this.EmitLdc_I4_1(); 					break; 				} 				case 2: 				{ 					this.EmitLdc_I4_2(); 					break; 				} 				case 3: 				{ 					this.EmitLdc_I4_3(); 					break; 				} 				case 4: 				{ 					this.EmitLdc_I4_4(); 					break; 				} 				case 5: 				{ 					this.EmitLdc_I4_5(); 					break; 				} 				case 6: 				{ 					this.EmitLdc_I4_6(); 					break; 				} 				case 7: 				{ 					this.EmitLdc_I4_7(); 					break; 				} 				case -1: 				{ 					this.EmitLdc_I4_M1(); 					break; 				} 				default: 				{ 					if ( SByte.MinValue <= value && value <= SByte.MaxValue ) 					{ 						this.EmitLdc_I4_S( unchecked( ( byte )( sbyte )value ) ); 					} 					else 					{ 						this.EmitLdc_I4( value ); 					}  					break; 				} 			}
Magic Number,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitAnyLdc_I4,The following statement contains a magic number: switch ( value ) 			{ 				case 0: 				{ 					this.EmitLdc_I4_0(); 					break; 				} 				case 1: 				{ 					this.EmitLdc_I4_1(); 					break; 				} 				case 2: 				{ 					this.EmitLdc_I4_2(); 					break; 				} 				case 3: 				{ 					this.EmitLdc_I4_3(); 					break; 				} 				case 4: 				{ 					this.EmitLdc_I4_4(); 					break; 				} 				case 5: 				{ 					this.EmitLdc_I4_5(); 					break; 				} 				case 6: 				{ 					this.EmitLdc_I4_6(); 					break; 				} 				case 7: 				{ 					this.EmitLdc_I4_7(); 					break; 				} 				case -1: 				{ 					this.EmitLdc_I4_M1(); 					break; 				} 				default: 				{ 					if ( SByte.MinValue <= value && value <= SByte.MaxValue ) 					{ 						this.EmitLdc_I4_S( unchecked( ( byte )( sbyte )value ) ); 					} 					else 					{ 						this.EmitLdc_I4( value ); 					}  					break; 				} 			}
Magic Number,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitAnyLdc_I4,The following statement contains a magic number: switch ( value ) 			{ 				case 0: 				{ 					this.EmitLdc_I4_0(); 					break; 				} 				case 1: 				{ 					this.EmitLdc_I4_1(); 					break; 				} 				case 2: 				{ 					this.EmitLdc_I4_2(); 					break; 				} 				case 3: 				{ 					this.EmitLdc_I4_3(); 					break; 				} 				case 4: 				{ 					this.EmitLdc_I4_4(); 					break; 				} 				case 5: 				{ 					this.EmitLdc_I4_5(); 					break; 				} 				case 6: 				{ 					this.EmitLdc_I4_6(); 					break; 				} 				case 7: 				{ 					this.EmitLdc_I4_7(); 					break; 				} 				case -1: 				{ 					this.EmitLdc_I4_M1(); 					break; 				} 				default: 				{ 					if ( SByte.MinValue <= value && value <= SByte.MaxValue ) 					{ 						this.EmitLdc_I4_S( unchecked( ( byte )( sbyte )value ) ); 					} 					else 					{ 						this.EmitLdc_I4( value ); 					}  					break; 				} 			}
Magic Number,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitAnyLdc_I4,The following statement contains a magic number: switch ( value ) 			{ 				case 0: 				{ 					this.EmitLdc_I4_0(); 					break; 				} 				case 1: 				{ 					this.EmitLdc_I4_1(); 					break; 				} 				case 2: 				{ 					this.EmitLdc_I4_2(); 					break; 				} 				case 3: 				{ 					this.EmitLdc_I4_3(); 					break; 				} 				case 4: 				{ 					this.EmitLdc_I4_4(); 					break; 				} 				case 5: 				{ 					this.EmitLdc_I4_5(); 					break; 				} 				case 6: 				{ 					this.EmitLdc_I4_6(); 					break; 				} 				case 7: 				{ 					this.EmitLdc_I4_7(); 					break; 				} 				case -1: 				{ 					this.EmitLdc_I4_M1(); 					break; 				} 				default: 				{ 					if ( SByte.MinValue <= value && value <= SByte.MaxValue ) 					{ 						this.EmitLdc_I4_S( unchecked( ( byte )( sbyte )value ) ); 					} 					else 					{ 						this.EmitLdc_I4( value ); 					}  					break; 				} 			}
Magic Number,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitAnyLdc_I4,The following statement contains a magic number: switch ( value ) 			{ 				case 0: 				{ 					this.EmitLdc_I4_0(); 					break; 				} 				case 1: 				{ 					this.EmitLdc_I4_1(); 					break; 				} 				case 2: 				{ 					this.EmitLdc_I4_2(); 					break; 				} 				case 3: 				{ 					this.EmitLdc_I4_3(); 					break; 				} 				case 4: 				{ 					this.EmitLdc_I4_4(); 					break; 				} 				case 5: 				{ 					this.EmitLdc_I4_5(); 					break; 				} 				case 6: 				{ 					this.EmitLdc_I4_6(); 					break; 				} 				case 7: 				{ 					this.EmitLdc_I4_7(); 					break; 				} 				case -1: 				{ 					this.EmitLdc_I4_M1(); 					break; 				} 				default: 				{ 					if ( SByte.MinValue <= value && value <= SByte.MaxValue ) 					{ 						this.EmitLdc_I4_S( unchecked( ( byte )( sbyte )value ) ); 					} 					else 					{ 						this.EmitLdc_I4( value ); 					}  					break; 				} 			}
Magic Number,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitAnyLdc_I4,The following statement contains a magic number: switch ( value ) 			{ 				case 0: 				{ 					this.EmitLdc_I4_0(); 					break; 				} 				case 1: 				{ 					this.EmitLdc_I4_1(); 					break; 				} 				case 2: 				{ 					this.EmitLdc_I4_2(); 					break; 				} 				case 3: 				{ 					this.EmitLdc_I4_3(); 					break; 				} 				case 4: 				{ 					this.EmitLdc_I4_4(); 					break; 				} 				case 5: 				{ 					this.EmitLdc_I4_5(); 					break; 				} 				case 6: 				{ 					this.EmitLdc_I4_6(); 					break; 				} 				case 7: 				{ 					this.EmitLdc_I4_7(); 					break; 				} 				case -1: 				{ 					this.EmitLdc_I4_M1(); 					break; 				} 				default: 				{ 					if ( SByte.MinValue <= value && value <= SByte.MaxValue ) 					{ 						this.EmitLdc_I4_S( unchecked( ( byte )( sbyte )value ) ); 					} 					else 					{ 						this.EmitLdc_I4( value ); 					}  					break; 				} 			}
Magic Number,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitAnyStloc,The following statement contains a magic number: switch ( localIndex ) 			{ 				case 0: 				{ 					this.EmitStloc_0(); 					break; 				} 				case 1: 				{ 					this.EmitStloc_1(); 					break; 				} 				case 2: 				{ 					this.EmitStloc_2(); 					break; 				} 				case 3: 				{ 					this.EmitStloc_3(); 					break; 				} 				default: 				{ 					// TODO:NLiblet 					if ( SByte.MinValue <= localIndex && localIndex <= SByte.MaxValue ) 					{ 						this.EmitStloc_S( unchecked( ( byte )( sbyte )localIndex ) ); 					} 					else 					{ 						this.EmitStloc( localIndex ); 					} 					break; 				} 			}
Magic Number,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitAnyStloc,The following statement contains a magic number: switch ( localIndex ) 			{ 				case 0: 				{ 					this.EmitStloc_0(); 					break; 				} 				case 1: 				{ 					this.EmitStloc_1(); 					break; 				} 				case 2: 				{ 					this.EmitStloc_2(); 					break; 				} 				case 3: 				{ 					this.EmitStloc_3(); 					break; 				} 				default: 				{ 					// TODO:NLiblet 					if ( SByte.MinValue <= localIndex && localIndex <= SByte.MaxValue ) 					{ 						this.EmitStloc_S( unchecked( ( byte )( sbyte )localIndex ) ); 					} 					else 					{ 						this.EmitStloc( localIndex ); 					} 					break; 				} 			}
Magic Number,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitLiteralInteger,The following statement contains a magic number: switch ( value ) 			{ 				case -1: 				{ 					this.EmitLdc_I4_M1(); 					break; 				} 				case 0: 				{ 					this.EmitLdc_I4_0(); 					break; 				} 				case 1: 				{ 					this.EmitLdc_I4_1(); 					break; 				} 				case 2: 				{ 					this.EmitLdc_I4_2(); 					break; 				} 				case 3: 				{ 					this.EmitLdc_I4_3(); 					break; 				} 				case 4: 				{ 					this.EmitLdc_I4_4(); 					break; 				} 				case 5: 				{ 					this.EmitLdc_I4_5(); 					break; 				} 				case 6: 				{ 					this.EmitLdc_I4_6(); 					break; 				} 				case 7: 				{ 					this.EmitLdc_I4_7(); 					break; 				} 				case 8: 				{ 					this.EmitLdc_I4_8(); 					break; 				} 				default: 				{ 					if ( SByte.MinValue <= value && value <= SByte.MaxValue ) 					{ 						this.EmitLdc_I4_S( unchecked( ( byte )value ) ); 					} 					else if ( Int32.MinValue <= value && value <= Int32.MaxValue ) 					{ 						this.EmitLdc_I4( unchecked( ( int )value ) ); 					} 					else 					{ 						this.EmitLdc_I8( value ); 					}  					break; 				} 			}
Magic Number,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitLiteralInteger,The following statement contains a magic number: switch ( value ) 			{ 				case -1: 				{ 					this.EmitLdc_I4_M1(); 					break; 				} 				case 0: 				{ 					this.EmitLdc_I4_0(); 					break; 				} 				case 1: 				{ 					this.EmitLdc_I4_1(); 					break; 				} 				case 2: 				{ 					this.EmitLdc_I4_2(); 					break; 				} 				case 3: 				{ 					this.EmitLdc_I4_3(); 					break; 				} 				case 4: 				{ 					this.EmitLdc_I4_4(); 					break; 				} 				case 5: 				{ 					this.EmitLdc_I4_5(); 					break; 				} 				case 6: 				{ 					this.EmitLdc_I4_6(); 					break; 				} 				case 7: 				{ 					this.EmitLdc_I4_7(); 					break; 				} 				case 8: 				{ 					this.EmitLdc_I4_8(); 					break; 				} 				default: 				{ 					if ( SByte.MinValue <= value && value <= SByte.MaxValue ) 					{ 						this.EmitLdc_I4_S( unchecked( ( byte )value ) ); 					} 					else if ( Int32.MinValue <= value && value <= Int32.MaxValue ) 					{ 						this.EmitLdc_I4( unchecked( ( int )value ) ); 					} 					else 					{ 						this.EmitLdc_I8( value ); 					}  					break; 				} 			}
Magic Number,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitLiteralInteger,The following statement contains a magic number: switch ( value ) 			{ 				case -1: 				{ 					this.EmitLdc_I4_M1(); 					break; 				} 				case 0: 				{ 					this.EmitLdc_I4_0(); 					break; 				} 				case 1: 				{ 					this.EmitLdc_I4_1(); 					break; 				} 				case 2: 				{ 					this.EmitLdc_I4_2(); 					break; 				} 				case 3: 				{ 					this.EmitLdc_I4_3(); 					break; 				} 				case 4: 				{ 					this.EmitLdc_I4_4(); 					break; 				} 				case 5: 				{ 					this.EmitLdc_I4_5(); 					break; 				} 				case 6: 				{ 					this.EmitLdc_I4_6(); 					break; 				} 				case 7: 				{ 					this.EmitLdc_I4_7(); 					break; 				} 				case 8: 				{ 					this.EmitLdc_I4_8(); 					break; 				} 				default: 				{ 					if ( SByte.MinValue <= value && value <= SByte.MaxValue ) 					{ 						this.EmitLdc_I4_S( unchecked( ( byte )value ) ); 					} 					else if ( Int32.MinValue <= value && value <= Int32.MaxValue ) 					{ 						this.EmitLdc_I4( unchecked( ( int )value ) ); 					} 					else 					{ 						this.EmitLdc_I8( value ); 					}  					break; 				} 			}
Magic Number,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitLiteralInteger,The following statement contains a magic number: switch ( value ) 			{ 				case -1: 				{ 					this.EmitLdc_I4_M1(); 					break; 				} 				case 0: 				{ 					this.EmitLdc_I4_0(); 					break; 				} 				case 1: 				{ 					this.EmitLdc_I4_1(); 					break; 				} 				case 2: 				{ 					this.EmitLdc_I4_2(); 					break; 				} 				case 3: 				{ 					this.EmitLdc_I4_3(); 					break; 				} 				case 4: 				{ 					this.EmitLdc_I4_4(); 					break; 				} 				case 5: 				{ 					this.EmitLdc_I4_5(); 					break; 				} 				case 6: 				{ 					this.EmitLdc_I4_6(); 					break; 				} 				case 7: 				{ 					this.EmitLdc_I4_7(); 					break; 				} 				case 8: 				{ 					this.EmitLdc_I4_8(); 					break; 				} 				default: 				{ 					if ( SByte.MinValue <= value && value <= SByte.MaxValue ) 					{ 						this.EmitLdc_I4_S( unchecked( ( byte )value ) ); 					} 					else if ( Int32.MinValue <= value && value <= Int32.MaxValue ) 					{ 						this.EmitLdc_I4( unchecked( ( int )value ) ); 					} 					else 					{ 						this.EmitLdc_I8( value ); 					}  					break; 				} 			}
Magic Number,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitLiteralInteger,The following statement contains a magic number: switch ( value ) 			{ 				case -1: 				{ 					this.EmitLdc_I4_M1(); 					break; 				} 				case 0: 				{ 					this.EmitLdc_I4_0(); 					break; 				} 				case 1: 				{ 					this.EmitLdc_I4_1(); 					break; 				} 				case 2: 				{ 					this.EmitLdc_I4_2(); 					break; 				} 				case 3: 				{ 					this.EmitLdc_I4_3(); 					break; 				} 				case 4: 				{ 					this.EmitLdc_I4_4(); 					break; 				} 				case 5: 				{ 					this.EmitLdc_I4_5(); 					break; 				} 				case 6: 				{ 					this.EmitLdc_I4_6(); 					break; 				} 				case 7: 				{ 					this.EmitLdc_I4_7(); 					break; 				} 				case 8: 				{ 					this.EmitLdc_I4_8(); 					break; 				} 				default: 				{ 					if ( SByte.MinValue <= value && value <= SByte.MaxValue ) 					{ 						this.EmitLdc_I4_S( unchecked( ( byte )value ) ); 					} 					else if ( Int32.MinValue <= value && value <= Int32.MaxValue ) 					{ 						this.EmitLdc_I4( unchecked( ( int )value ) ); 					} 					else 					{ 						this.EmitLdc_I8( value ); 					}  					break; 				} 			}
Magic Number,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitLiteralInteger,The following statement contains a magic number: switch ( value ) 			{ 				case -1: 				{ 					this.EmitLdc_I4_M1(); 					break; 				} 				case 0: 				{ 					this.EmitLdc_I4_0(); 					break; 				} 				case 1: 				{ 					this.EmitLdc_I4_1(); 					break; 				} 				case 2: 				{ 					this.EmitLdc_I4_2(); 					break; 				} 				case 3: 				{ 					this.EmitLdc_I4_3(); 					break; 				} 				case 4: 				{ 					this.EmitLdc_I4_4(); 					break; 				} 				case 5: 				{ 					this.EmitLdc_I4_5(); 					break; 				} 				case 6: 				{ 					this.EmitLdc_I4_6(); 					break; 				} 				case 7: 				{ 					this.EmitLdc_I4_7(); 					break; 				} 				case 8: 				{ 					this.EmitLdc_I4_8(); 					break; 				} 				default: 				{ 					if ( SByte.MinValue <= value && value <= SByte.MaxValue ) 					{ 						this.EmitLdc_I4_S( unchecked( ( byte )value ) ); 					} 					else if ( Int32.MinValue <= value && value <= Int32.MaxValue ) 					{ 						this.EmitLdc_I4( unchecked( ( int )value ) ); 					} 					else 					{ 						this.EmitLdc_I8( value ); 					}  					break; 				} 			}
Magic Number,MsgPack.Serialization.Reflection,TracingILGenerator,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\TracingILGenerator.conveniences.cs,EmitLiteralInteger,The following statement contains a magic number: switch ( value ) 			{ 				case -1: 				{ 					this.EmitLdc_I4_M1(); 					break; 				} 				case 0: 				{ 					this.EmitLdc_I4_0(); 					break; 				} 				case 1: 				{ 					this.EmitLdc_I4_1(); 					break; 				} 				case 2: 				{ 					this.EmitLdc_I4_2(); 					break; 				} 				case 3: 				{ 					this.EmitLdc_I4_3(); 					break; 				} 				case 4: 				{ 					this.EmitLdc_I4_4(); 					break; 				} 				case 5: 				{ 					this.EmitLdc_I4_5(); 					break; 				} 				case 6: 				{ 					this.EmitLdc_I4_6(); 					break; 				} 				case 7: 				{ 					this.EmitLdc_I4_7(); 					break; 				} 				case 8: 				{ 					this.EmitLdc_I4_8(); 					break; 				} 				default: 				{ 					if ( SByte.MinValue <= value && value <= SByte.MaxValue ) 					{ 						this.EmitLdc_I4_S( unchecked( ( byte )value ) ); 					} 					else if ( Int32.MinValue <= value && value <= Int32.MaxValue ) 					{ 						this.EmitLdc_I4( unchecked( ( int )value ) ); 					} 					else 					{ 						this.EmitLdc_I8( value ); 					}  					break; 				} 			}
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinary,The method contains a code clone-set at the following line numbers (starting from the method definition): ((57' 91)' (105' 139))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinaryAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((56' 89)' (103' 136))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadString,The method contains a code clone-set at the following line numbers (starting from the method definition): ((57' 91)' (105' 139))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((56' 89)' (103' 136))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((6' 44)' (116' 154)' (245' 283)' (385' 423)' (500' 538)' (643' 681))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((6' 48)' (643' 685)' (116' 158)' (245' 287))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((11' 30)' (56' 75)' (121' 140)' (175' 194)' (250' 269)' (304' 323)' (390' 409)' (442' 461)' (505' 524)' (549' 568)' (593' 612)' (648' 667)' (692' 711)' (736' 755)' (780' 799)' (824' 843))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((11' 44)' (56' 89)' (175' 208)' (304' 337)' (442' 475)' (549' 582)' (593' 626)' (692' 725)' (736' 769)' (780' 813)' (824' 857)' (121' 154)' (250' 283)' (390' 423)' (505' 538)' (648' 681))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((56' 93)' (692' 729)' (175' 212)' (304' 341))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((121' 155)' (175' 209)' (304' 338)' (250' 284))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((51' 74)' (170' 193)' (299' 322)' (437' 460)' (544' 567)' (687' 710)' (775' 798))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((588' 611)' (731' 754)' (819' 842))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((7' 44)' (119' 156)' (260' 297)' (417' 454)' (539' 576)' (678' 715))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((7' 48)' (678' 719)' (119' 160)' (260' 301))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((12' 31)' (56' 75)' (124' 143)' (182' 201)' (265' 284)' (323' 342)' (422' 441)' (478' 497)' (544' 563)' (587' 606)' (630' 649)' (683' 702)' (726' 745)' (769' 788)' (812' 831)' (855' 874))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((12' 44)' (56' 88)' (182' 214)' (323' 355)' (478' 510)' (587' 619)' (630' 662)' (726' 758)' (769' 801)' (812' 844)' (855' 887)' (124' 156)' (265' 297)' (422' 454)' (544' 576)' (683' 715))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((56' 92)' (726' 762)' (182' 218)' (323' 359))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((124' 157)' (182' 215)' (323' 356)' (265' 298))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((51' 74)' (177' 200)' (318' 341)' (473' 496)' (582' 605)' (721' 744)' (807' 830))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((625' 648)' (764' 787)' (850' 873))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLength,The method contains a code clone-set at the following line numbers (starting from the method definition): ((48' 82)' (96' 130))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLengthAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((47' 80)' (94' 127))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLength,The method contains a code clone-set at the following line numbers (starting from the method definition): ((48' 82)' (96' 130))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLengthAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((47' 80)' (94' 127))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObject,The method contains a code clone-set at the following line numbers (starting from the method definition): ((48' 82)' (96' 130))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The method contains a code clone-set at the following line numbers (starting from the method definition): ((53' 87)' (101' 135))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObjectAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((47' 80)' (94' 127))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((51' 84)' (98' 131))
Duplicate Code,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitConstructPolymorphismSchema,The method contains a code clone-set at the following line numbers (starting from the method definition): ((72' 96)' (198' 222))
Duplicate Code,MsgPack.Serialization.CodeDomSerializers,CodeDomSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CodeDomSerializers\CodeDomSerializerBuilder.cs,EmitGetActionsExpression,The method contains a code clone-set at the following line numbers (starting from the method definition): ((37' 56)' (66' 85))
Duplicate Code,MsgPack.Serialization.EmittingSerializers,AssemblyBuilderSerializerBuilder,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EmittingSerializers\AssemblyBuilderSerializerBuilder.cs,EmitGetActionsExpression,The method contains a code clone-set at the following line numbers (starting from the method definition): ((36' 57)' (66' 87))
Missing Default,MsgPack,MessagePackCode,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackCode.cs,ToString,The following switch statement is missing a default case: switch( code ) 			{ 				case 0xC0: 				{ 					return "Nil"; 				} 				case 0xC3: 				{ 					return "True"; 				} 				case 0xD0: 				{ 					return "SingnedInt8"; 				} 				case 0xCC: 				{ 					return "UnsignedInt8"; 				} 				case 0xD1: 				{ 					return "SignedInt16"; 				} 				case 0xCD: 				{ 					return "UnsignedInt16"; 				} 				case 0xD2: 				{ 					return "SignedInt32"; 				} 				case 0xCE: 				{ 					return "UnsignedInt32"; 				} 				case 0xD3: 				{ 					return "SignedInt64"; 				} 				case 0xCF: 				{ 					return "UnsignedInt64"; 				} 				case 0xCA: 				{ 					return "Real32"; 				} 				case 0xCB: 				{ 					return "Real64"; 				} 				case 0xDC: 				{ 					return "Array16"; 				} 				case 0xDD: 				{ 					return "Array32"; 				} 				case 0xDE: 				{ 					return "Map16"; 				} 				case 0xDF: 				{ 					return "Map32"; 				} 				case 0xDA: 				{ 					return "Raw16"; 				} 				case 0xDB: 				{ 					return "Raw32"; 				} 			}
Missing Default,MsgPack,MessagePackCode,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackCode.cs,ToString,The following switch statement is missing a default case: switch( ( code & 0xF0)) 			{ 				case 0x80: 				{ 					return "FixedMap"; 				} 				case 0x90: 				{ 					return "FixedArray"; 				} 				case 0xA0: 				case 0xB0: 				{ 					return "FixedRaw"; 				} 			}
Missing Default,MsgPack,MessagePackObject,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,IsTypeOf,The following switch statement is missing a default case: switch ( Type.GetTypeCode( type ) ) #endif // NETSTANDARD1_1 || NETSTANDARD1_3 			{ 				case TypeCode.SByte: 				{ 					return typeCode.IsInteger && ( this._value < 0x80 || ( 0xFFFFFFFFFFFFFF80 <= this._value && typeCode.IsSigned ) ); 				} 				case TypeCode.Byte: 				{ 					return typeCode.IsInteger && this._value < 0x100; 				} 				case TypeCode.Int16: 				{ 					return typeCode.IsInteger && ( this._value < 0x8000 || ( 0xFFFFFFFFFFFF8000 <= this._value && typeCode.IsSigned ) ); 				} 				case TypeCode.UInt16: 				{ 					return typeCode.IsInteger && this._value < 0x10000; 				} 				case TypeCode.Int32: 				{ 					return typeCode.IsInteger && ( this._value < 0x80000000 || ( 0xFFFFFFFF80000000 <= this._value && typeCode.IsSigned ) ); 				} 				case TypeCode.UInt32: 				{ 					return typeCode.IsInteger && this._value < 0x100000000L; 				} 				case TypeCode.Int64: 				{ 					return typeCode.IsInteger && ( this._value < 0x8000000000000000L || typeCode.IsSigned ); 				} 				case TypeCode.UInt64: 				{ 					return typeCode.IsInteger && ( this._value < 0x8000000000000000L || !typeCode.IsSigned ); 				} 				case TypeCode.Double: 				{ 					return 						typeCode.Type == typeof( float ) 						|| typeCode.Type == typeof( double ); 				} 			}
Missing Default,MsgPack,ReadValueResults,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following switch statement is missing a default case: switch ( source ) 			{ 				case ReadValueResult.Nil: 				{ 					return ( byte )MessagePackCode.NilValue; 				} 				case ReadValueResult.True: 				{ 					return ( byte )MessagePackCode.TrueValue; 				} 				case ReadValueResult.False: 				{ 					return ( byte )MessagePackCode.FalseValue; 				} 				case ReadValueResult.InvalidCode: 				{ 					return 0xC1; 				} 			}
Missing Default,MsgPack,StringEscape,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\StringEscape.cs,ForDisplay,The following switch statement is missing a default case: switch ( c ) 				{ 					case '\0': 					{ 						buffer.Append( "\\0" ); 						continue; 					} 					case '\t': 					{ 						buffer.Append( "\\t" ); 						continue; 					} 					case '\r': 					{ 						buffer.Append( "\\r" ); 						continue; 					} 					case '\n': 					{ 						buffer.Append( "\\n" ); 						continue; 					} 					case '\a': 					{ 						buffer.Append( "\\a" ); 						continue; 					} 					case '\b': 					{ 						buffer.Append( "\\b" ); 						continue; 					} 					case '\f': 					{ 						buffer.Append( "\\f" ); 						continue; 					} 					case '\v': 					{ 						buffer.Append( "\\v" ); 						continue; 					} 				}
Missing Default,MsgPack,SeekableUnpackingStream,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Unpacking.Streaming.cs,Seek,The following switch statement is missing a default case: switch ( origin ) 				{ 					case SeekOrigin.Begin: 					{ 						this.SeekTo( offset ); 						break; 					} 					case SeekOrigin.End: 					{ 						this.SeekTo( this.RawLength + offset ); 						break; 					} 					case SeekOrigin.Current: 					{ 						this.SeekTo( this.Position + offset ); 						break; 					} 				}
Missing Default,MsgPack.Serialization.AbstractSerializers,SerializerBuilder<TContext;TConstruct>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\AbstractSerializers\SerializerBuilder`2.Collection.cs,EmitSetMemberValueStatement,The following switch statement is missing a default case: switch ( traits.CollectionType ) 			{ 				case CollectionKind.Array: 				{ 					/* 					 *	foreach ( var item in unpacked ) 					 *	{ 					 *		target.Prop.Add(item); 					 *	} 					 */ 					var store = 						this.EmitStoreCollectionItemsEmitSetCollectionMemberIfNullAndSettable( 							context' 							instance' 							value' 							existent' 							member.GetMemberValueType()' 							asField' 							asProperty' 							traits.AddMethod == null 								? null 								: this.EmitForEachLoop( 									context' 									traits' 									value' 									current => 										this.EmitAppendCollectionItem( 											context' 											member' 											traits' 											existent' 											current 											) 									) 							); 					return 						this.EmitSequentialStatements( 							context' 							store.ContextType' 							existent' 							existentInitialization' 							store 						); 				} 				case CollectionKind.Map: 				{ 					/* 					 *	foreach ( var item in unpacked ) 					 *	{ 					 *		target.Prop.Add(item.Key' item.Value); 					 *	} 					 */ 					Type keyType' valueType; 					GetDictionaryKeyValueType( traits.ElementType' out keyType' out valueType );  					var store = 							this.EmitStoreCollectionItemsEmitSetCollectionMemberIfNullAndSettable( 								context' 								instance' 								value' 								existent' 								member.GetMemberValueType()' 								asField' 								asProperty' 								traits.AddMethod == null 									? null 									: this.EmitForEachLoop( 										context' 										traits' 										value' 										// ReSharper disable ImplicitlyCapturedClosure 										current => 											this.EmitAppendDictionaryItem( 												context' 												traits' 												existent' 												keyType' 												this.EmitGetPropertyExpression( 													context' 													current' #if !NETFX_CORE 													traits.ElementType == typeof( DictionaryEntry ) 														? Metadata._DictionaryEntry.Key 														: traits.ElementType.GetProperty( "Key" ) #else 													traits.ElementType.GetProperty( "Key" ) #endif // !NETFX_CORE 												)' 												valueType' 												this.EmitGetPropertyExpression( 													context' 													current' #if !NETFX_CORE 													traits.ElementType == typeof( DictionaryEntry ) 														? Metadata._DictionaryEntry.Value 														: traits.ElementType.GetProperty( "Value" ) #else 													traits.ElementType.GetProperty( "Value" ) #endif // !NETFX_CORE 												)' 												false 											) 										// ReSharper restore ImplicitlyCapturedClosure 									) 							);  					return 						this.EmitSequentialStatements( 							context' 							store.ContextType' 							existent' 							existentInitialization' 							store 						); 				} 			}
Missing Default,MsgPack.Serialization,EnumMessagePackSerializerProvider,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EnumMessagePackSerializerProvider.cs,Get,The following switch statement is missing a default case: switch ( ( EnumSerializationMethod )providerParameter ) 				{ 					case EnumSerializationMethod.ByName: 					{ 						return this._serializerForName; 					} 					case EnumSerializationMethod.ByUnderlyingValue: 					{ 						return this._serializerForIntegral; 					} 				}
Missing Default,MsgPack.Serialization,NilImplicationHandler<TAction;TCondition;TPackingParameter;TUnpackedParameter>,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\NilImplicationHandler`4.cs,OnPacking,The following switch statement is missing a default case: switch ( nilImplication ) 			{ 				case NilImplication.Prohibit: 				{ 					TCondition condition = null; 					if ( parameter.ItemType == typeof( MessagePackObject ) ) 					{ 						condition = this.OnPackingMessagePackObject( parameter ); 					} 					else if ( !parameter.ItemType.GetIsValueType() ) 					{ 						condition = this.OnPackingReferenceTypeObject( parameter ); 					} 					else if ( Nullable.GetUnderlyingType( parameter.ItemType ) != null ) 					{ 						condition = this.OnPackingNullableValueTypeObject( parameter ); 					}  					if ( condition != null ) 					{ 						return this.OnPackingCore( parameter' condition ); 					}  					break; 				} 			}
Missing Default,MsgPack.Serialization,PolymorphismSchema,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,ToDebugString,The following switch statement is missing a default case: switch ( this.ChildrenType ) 			{ 				case PolymorphismSchemaChildrenType.CollectionItems: 				{ 					buffer.Append( "' CollectionItemsSchema:" ); 					if ( this.ItemSchema == null ) 					{ 						buffer.Append( "null" ); 					} 					else 					{ 						this.ItemSchema.ToDebugString( buffer ); 					}  					break; 				} 				case PolymorphismSchemaChildrenType.DictionaryKeyValues: 				{ 					buffer.Append( "' DictinoaryKeysSchema:" ); 					if ( this.KeySchema == null ) 					{ 						buffer.Append( "null" ); 					} 					else 					{ 						this.KeySchema.ToDebugString( buffer ); 					}  					buffer.Append( "' DictinoaryValuesSchema:" ); 					if ( this.ItemSchema == null ) 					{ 						buffer.Append( "null" ); 					} 					else 					{ 						this.ItemSchema.ToDebugString( buffer ); 					}  					break; 				} #if !NET35 && !UNITY 				case PolymorphismSchemaChildrenType.TupleItems: 				{ 					buffer.Append( "' TupleItemsSchema:[" ); 					var isFirst = true; 					foreach ( var child in this._children ) 					{ 						if ( isFirst ) 						{ 							isFirst = false; 						} 						else 						{ 							buffer.Append( "' " ); 						}  						if ( child == null ) 						{ 							buffer.Append( "null" ); 						} 						else 						{ 							child.ToDebugString( buffer ); 						} 					}  					break; 				} #endif // !NET35 && !UNITY 			}
Missing Default,MsgPack.Serialization,TypeTableEntry,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,SetDefault,The following switch statement is missing a default case: switch ( defaultSchema.PolymorphismType ) 				{ 					case PolymorphismType.KnownTypes: 					{ 						foreach ( var typeMapping in defaultSchema.CodeTypeMapping ) 						{ 							this.SetKnownType( target' memberName' tupleItemNumber' typeMapping.Key' typeMapping.Value ); 						}  						break; 					} 					case PolymorphismType.RuntimeType: 					{ 						this.SetRuntimeType( target' memberName' tupleItemNumber' defaultSchema.TypeVerifier ); 						break; 					} 				}
Missing Default,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following switch statement is missing a default case: switch ( parameters.Length ) 				{ 					case 0: 					{ 						if ( currentScore < noParameters ) 						{ 							constructor = candidate; 							currentScore = noParameters; 						}  						break; 					} 					case 1: 					{ 						if ( currentScore < withCapacity && parameters[ 0 ].ParameterType == typeof( int ) ) 						{ 							constructor = candidate; 							currentScore = noParameters; 						} 						else if ( currentScore < withComparer && IsIEqualityComparer( parameters[ 0 ].ParameterType ) ) 						{ 							constructor = candidate; 							currentScore = noParameters; 						} 						break; 					} 					case 2: 					{ 						if ( currentScore < withCapacityAndComparer && parameters[ 0 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 1 ].ParameterType ) ) 						{ 							constructor = candidate; 							currentScore = withCapacityAndComparer; 						} 						else if ( currentScore < withComparerAndCapacity && parameters[ 1 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 0 ].ParameterType ) ) 						{ 							constructor = candidate; 							currentScore = withComparerAndCapacity; 						}  						break; 					} 				}
Missing Default,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValueCore,The following switch statement is missing a default case: switch ( nilImplication ) 				{ 					case NilImplication.Prohibit: 					{ 						SerializationExceptions.ThrowNullIsProhibited( memberName ); 						break; 					} 					case NilImplication.MemberDefault: 					{ 						return; 					} 				}
Missing Default,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValueAsyncCore,The following switch statement is missing a default case: switch ( nilImplication ) 				{ 					case NilImplication.Prohibit: 					{ 						SerializationExceptions.ThrowNullIsProhibited( memberName ); 						break; 					} 					case NilImplication.MemberDefault: 					{ 						return; 					} 				}
Missing Default,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValueCore,The following switch statement is missing a default case: switch ( nilImplication ) 				{ 					case NilImplication.Prohibit: 					{ 						SerializationExceptions.ThrowNullIsProhibited( memberName ); 						break; 					} 					case NilImplication.MemberDefault: 					{ 						return; 					} 				}
Missing Default,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValueAsyncCore,The following switch statement is missing a default case: switch ( nilImplication ) 				{ 					case NilImplication.Prohibit: 					{ 						SerializationExceptions.ThrowNullIsProhibited( memberName ); 						break; 					} 					case NilImplication.MemberDefault: 					{ 						return; 					} 				}
Missing Default,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMessagePackObjectValueCore,The following switch statement is missing a default case: switch ( nilImplication ) 				{ 					case NilImplication.Prohibit: 					{ 						SerializationExceptions.ThrowNullIsProhibited( memberName ); 						break; 					} 					case NilImplication.MemberDefault: 					{ 						return; 					} 				}
Missing Default,MsgPack.Serialization,UnpackHelpers,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMessagePackObjectValueAsyncCore,The following switch statement is missing a default case: switch ( nilImplication ) 				{ 					case NilImplication.Prohibit: 					{ 						SerializationExceptions.ThrowNullIsProhibited( memberName ); 						break; 					} 					case NilImplication.MemberDefault: 					{ 						return; 					} 				}
Missing Default,MsgPack.Serialization.DefaultSerializers,DateTimeMessagePackSerializerProvider,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DateTimeMessagePackSerializerProvider.cs,Get,The following switch statement is missing a default case: switch ( ( DateTimeConversionMethod )providerParameter ) 				{ 					case DateTimeConversionMethod.Native: 					{ 						return this._native; 					} 					case DateTimeConversionMethod.UnixEpoc: 					{ 						return this._unixEpoc; 					} 					case DateTimeConversionMethod.Timestamp: 					{ 						return this._timestamp; 					} 				}
Missing Default,MsgPack.Serialization.DefaultSerializers,DateTimeOffsetMessagePackSerializerProvider,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DateTimeOffsetMessagePackSerializerProvider.cs,Get,The following switch statement is missing a default case: switch ( ( DateTimeConversionMethod )providerParameter ) 				{ 					case DateTimeConversionMethod.Native: 					{ 						return this._native; 					} 					case DateTimeConversionMethod.UnixEpoc: 					{ 						return this._unixEpoc; 					} 					case DateTimeConversionMethod.Timestamp: 					{ 						return this._timestamp; 					} 				}
Missing Default,MsgPack.Serialization.DefaultSerializers,FileTimeMessagePackSerializerProvider,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\FileTimeMessagePackSerializerProvider.cs,Get,The following switch statement is missing a default case: switch ( ( DateTimeConversionMethod )providerParameter ) 				{ 					case DateTimeConversionMethod.Native: 					{ 						return this._native; 					} 					case DateTimeConversionMethod.UnixEpoc: 					{ 						return this._unixEpoc; 					} 					case DateTimeConversionMethod.Timestamp: 					{ 						return this._timestamp; 					} 				}
Missing Default,MsgPack.Serialization.DefaultSerializers,System_Collections_DictionaryEntryMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_DictionaryEntryMessagePackSerializer.cs,UnpackFromCore,The following switch statement is missing a default case: switch ( propertyName ) 					{ 						case "Key": 						{ 							if ( !unpacker.ReadObject( out key ) ) 							{ 								SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker ); 							}  							isKeyFound = true; 							break; 						} 						case "Value": 						{ 							if ( !unpacker.ReadObject( out value ) ) 							{ 								SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker ); 							}  							isValueFound = true; 							break; 						} 					}
Missing Default,MsgPack.Serialization.DefaultSerializers,System_Collections_DictionaryEntryMessagePackSerializer,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_DictionaryEntryMessagePackSerializer.cs,UnpackFromAsyncCore,The following switch statement is missing a default case: switch ( propertyName.Value ) 					{ 						case "Key": 						{ 							key = await unpacker.ReadObjectAsync( cancellationToken ).ConfigureAwait( false ); 							if ( !key.Success ) 							{ 								SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker ); 							}  							break; 						} 						case "Value": 						{ 							value = await unpacker.ReadObjectAsync( cancellationToken ).ConfigureAwait( false ); 							if ( !value.Success ) 							{ 								SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker ); 							}  							break; 						} 					}
Missing Default,MsgPack.Serialization.DefaultSerializers,TimestampMessagePackSerializerProvider,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\TimestampMessagePackSerializerProvider.cs,Get,The following switch statement is missing a default case: switch ( ( DateTimeConversionMethod )providerParameter ) 				{ 					case DateTimeConversionMethod.Native: 					{ 						return this._native; 					} 					case DateTimeConversionMethod.UnixEpoc: 					{ 						return this._unixEpoc; 					} 					case DateTimeConversionMethod.Timestamp: 					{ 						return this._timestamp; 					} 				}
Missing Default,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,CreateCollectionInstanceFactory,The following switch statement is missing a default case: switch ( parameters.Length ) 			{ 				case 0: 				{ 					return _ => #if !UNITY 						( T ) #endif // !UNITY 						constructor.InvokePreservingExceptionType(); 				} 				case 1: 				{ 					if ( parameters[ 0 ].ParameterType == typeof( int ) ) 					{ 						return capacity => #if !UNITY 							( T ) #endif // !UNITY 							constructor.InvokePreservingExceptionType( capacity ); 					} 					else if ( UnpackHelpers.IsIEqualityComparer( parameters[ 0 ].ParameterType ) ) 					{ 						var comparer =  #if !UNITY 							EqualityComparer<TKey>.Default; #else 							UnpackHelpers.GetEqualityComparer( comparisonType ); #endif // !UNITY 						return _ => #if !UNITY 							( T ) #endif // !UNITY 							constructor.InvokePreservingExceptionType( comparer ); 					}  					break; 				} 				case 2: 				{ 					var comparer = #if !UNITY 						EqualityComparer<TKey>.Default; #else 						UnpackHelpers.GetEqualityComparer( comparisonType ); #endif // !UNITY 					if ( parameters[ 0 ].ParameterType == typeof( int ) 						&& UnpackHelpers.IsIEqualityComparer( parameters[ 1 ].ParameterType ) ) 					{ 						return capacity => #if !UNITY 							( T ) #endif // !UNITY 							constructor.InvokePreservingExceptionType( capacity' comparer ); 					} 					else if ( UnpackHelpers.IsIEqualityComparer( parameters[ 0 ].ParameterType ) && 							parameters[ 0 ].ParameterType == typeof( int ) ) 					{ 						return capacity => #if !UNITY 							( T ) #endif // !UNITY 							constructor.InvokePreservingExceptionType( comparer' capacity ); 					}  					break; 				} 			}
Missing Default,MsgPack.Serialization.Reflection,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\ReflectionExtensions.cs,ToILString,The following switch statement is missing a default case: switch ( memberAccess ) 			{ 				case MethodAttributes.PrivateScope: 				{ 					result.Append( "privatescope" ); 					break; 				} 				case MethodAttributes.Private: 				{ 					result.Append( "private" ); 					break; 				} 				case MethodAttributes.FamANDAssem: 				{ 					result.Append( "famandassem" ); 					break; 				} 				case MethodAttributes.Assembly: 				{ 					result.Append( "assembly" ); 					break; 				} 				case MethodAttributes.Family: 				{ 					result.Append( "family" ); 					break; 				} 				case MethodAttributes.FamORAssem: 				{ 					result.Append( "famorassem" ); 					break; 				} 				case MethodAttributes.Public: 				{ 					result.Append( "public" ); 					break; 				} 			}
Missing Default,MsgPack.Serialization.Reflection,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\ReflectionExtensions.cs,ToILString,The following switch statement is missing a default case: switch ( (source & CallingConventions.Any) ) 			{ 				case CallingConventions.Standard: 				{ 					if ( result.Length > 0 ) 					{ 						result.Append( ' ' ); 					}  					result.Append( "standard" ); 					break; 				} 				case CallingConventions.VarArgs: 				{ 					if ( result.Length > 0 ) 					{ 						result.Append( ' ' ); 					}  					result.Append( "vararg" ); 					break; 				} 				case CallingConventions.Any: 				{ 					if ( result.Length > 0 ) 					{ 						result.Append( ' ' ); 					}  					result.Append( "any" ); 					break; 				} 			}
Missing Default,MsgPack.Serialization.Reflection,ReflectionExtensions,C:\research\architectureSmells\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\ReflectionExtensions.cs,ToILString,The following switch statement is missing a default case: switch ( codeType ) 			{ 				case MethodImplAttributes.IL: 				{ 					result.Append( "cil" ); 					break; 				} 				case MethodImplAttributes.Native: 				{ 					result.Append( "native" ); 					break; 				} 				case MethodImplAttributes.OPTIL: 				{ 					result.Append( "optil" ); 					break; 				} 				case MethodImplAttributes.Runtime: 				{ 					result.Append( "runtime" ); 					break; 				} 			}
