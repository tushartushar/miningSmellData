Implementation smell,Namespace,Class,File,Method,Description
Long Method,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The method has 340 lines of code.
Long Method,MsgPack,MessagePackCode,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackCode.cs,ToString,The method has 102 lines of code.
Long Method,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ToString,The method has 139 lines of code.
Long Method,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ToStringBinary,The method has 106 lines of code.
Long Method,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,PackToMessage,The method has 122 lines of code.
Long Method,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ToObject,The method has 102 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadByteSlow,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSByteSlow,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt16Slow,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt16Slow,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt32Slow,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt32Slow,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt64Slow,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt64Slow,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSingleSlow,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadDoubleSlow,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinary,The method has 146 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadString,The method has 146 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method has 868 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLength,The method has 134 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLength,The method has 134 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObject,The method has 138 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The method has 145 lines of code.
Long Method,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The method has 193 lines of code.
Long Method,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,HandleParseResult,The method has 161 lines of code.
Long Method,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The method has 124 lines of code.
Long Method,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The method has 393 lines of code.
Long Method,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,CreateCore,The method has 113 lines of code.
Long Method,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,The method has 156 lines of code.
Long Method,MsgPack.Serialization,SerializationContext,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationContext.cs,GetSerializer,The method has 143 lines of code.
Long Method,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The method has 156 lines of code.
Long Method,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,TryCreateAbstractCollectionSerializer,The method has 127 lines of code.
Long Method,MsgPack.Serialization.DefaultSerializers,UnityMultidimensionalArraySerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,UnpackFromCore,The method has 116 lines of code.
Long Method,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,CreateCollectionSerializer,The method has 116 lines of code.
Long Method,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,GetMetadata,The method has 137 lines of code.
Complex Method,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackCore,Cyclomatic complexity of the method is 8
Complex Method,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackCore,Cyclomatic complexity of the method is 10
Complex Method,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,Equals,Cyclomatic complexity of the method is 15
Complex Method,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ToString,Cyclomatic complexity of the method is 16
Complex Method,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,IsTypeOf,Cyclomatic complexity of the method is 9
Complex Method,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ToObject,Cyclomatic complexity of the method is 8
Complex Method,MsgPack,MessagePackObjectDictionary,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObjectDictionary.cs,AddCore,Cyclomatic complexity of the method is 8
Complex Method,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackCore,Cyclomatic complexity of the method is 8
Complex Method,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackCore,Cyclomatic complexity of the method is 10
Complex Method,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,Cyclomatic complexity of the method is 12
Complex Method,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,Cyclomatic complexity of the method is 20
Complex Method,MsgPack.Serialization,DefaultConcreteTypeRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultConcreteTypeRepository.cs,Register,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,PackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PackHelpers.cs,PackToMap,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,Cyclomatic complexity of the method is 17
Complex Method,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,ComplementMembers,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackArrayTo,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionTo,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionTo,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionTo,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionTo,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMapTo,Cyclomatic complexity of the method is 11
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMapTo,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValue,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValue,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValue,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValue,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValue,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValue,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromCore,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackMemberValue,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,GetMetadata,Cyclomatic complexity of the method is 10
Complex Method,System.Runtime.CompilerServices,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackArrayTo,Cyclomatic complexity of the method is 8
Complex Method,System.Runtime.CompilerServices,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionTo,Cyclomatic complexity of the method is 8
Complex Method,System.Runtime.CompilerServices,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionTo,Cyclomatic complexity of the method is 9
Complex Method,System.Runtime.CompilerServices,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionTo,Cyclomatic complexity of the method is 8
Complex Method,System.Runtime.CompilerServices,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionTo,Cyclomatic complexity of the method is 9
Complex Method,System.Runtime.CompilerServices,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMapTo,Cyclomatic complexity of the method is 11
Complex Method,System.Runtime.CompilerServices,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMapTo,Cyclomatic complexity of the method is 9
Long Parameter List,MsgPack,CollectionOperation,C:\repos\msgpack_msgpack-cli\src\MsgPack\CollectionOperation.cs,CopyTo,The method has 6 parameters. Parameters: source' sourceCount' index' array' arrayIndex' count
Long Parameter List,MsgPack,CollectionOperation,C:\repos\msgpack_msgpack-cli\src\MsgPack\CollectionOperation.cs,CopyTo,The method has 7 parameters. Parameters: source' sourceCount' index' array' arrayIndex' count' converter
Long Parameter List,MsgPack,CollectionOperation,C:\repos\msgpack_msgpack-cli\src\MsgPack\CollectionOperation.cs,ValidateCopyToArguments,The method has 5 parameters. Parameters: sourceCount' index' array' arrayIndex' count
Long Parameter List,MsgPack,EncodingExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\EncodingExtensions.cs,EncodeString,The method has 9 parameters. Parameters: source' chars' charsOffset' charsLength' buffer' bufferOffset' bufferCount' charsUsed' bytesUsed
Long Parameter List,MsgPack,EncodingExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\EncodingExtensions.cs,DecodeString,The method has 6 parameters. Parameters: source' bytes' bytesOffset' bytesLength' buffer' result
Long Parameter List,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadItems,The method has 5 parameters. Parameters: count' isMap' source' offset' result
Long Parameter List,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,EncodeString,The method has 7 parameters. Parameters: encoder' value' startOffset' count' buffer' charsUsed' bytesUsed
Long Parameter List,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadItems,The method has 5 parameters. Parameters: count' isMap' buffer' offset' result
Long Parameter List,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,TryParseExact,The method has 5 parameters. Parameters: input' format' formatProvider' styles' result
Long Parameter List,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,TryParseExact,The method has 5 parameters. Parameters: input' formats' formatProvider' styles' result
Long Parameter List,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,TryParseExactCore,The method has 5 parameters. Parameters: input' format' formatProvider' styles' result
Long Parameter List,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,TryParseExactCore,The method has 5 parameters. Parameters: input' formats' formatProvider' styles' result
Long Parameter List,MsgPack,Value,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.cs,Value,The method has 7 parameters. Parameters: year' month' day' hour' minute' second' nanoseconds
Long Parameter List,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The method has 5 parameters. Parameters: input' format' formatProvider' styles' result
Long Parameter List,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,ParseDigitRange,The method has 6 parameters. Parameters: input' minLength' position' min' max' result
Long Parameter List,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,ParseDay,The method has 5 parameters. Parameters: input' position' month' isLeapYear' day
Long Parameter List,MsgPack.Serialization,CollectionTraits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CollectionTraits.cs,CollectionTraits,The method has 5 parameters. Parameters: type' elementType' getEnumeratorMethod' addMethod' countPropertyGetter
Long Parameter List,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,PolymorphismSchema,The method has 5 parameters. Parameters: targetType' polymorphismType' typeVerifier' childrenType' childItemSchemaList
Long Parameter List,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,PolymorphismSchema,The method has 6 parameters. Parameters: targetType' polymorphismType' codeTypeMapping' typeVerifier' childrenType' childItemSchemaList
Long Parameter List,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,PolymorphismSchema,The method has 6 parameters. Parameters: targetType' polymorphismType' codeTypeMapping' typeVerifier' childrenType' childItemSchemaList
Long Parameter List,MsgPack.Serialization,TypeTableEntry,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,SetKnownType,The method has 5 parameters. Parameters: target' memberName' tupleItemNumber' typeCode' bindingType
Long Parameter List,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,TryCreateCollectionTraitsForIEnumerableT,The method has 5 parameters. Parameters: source' genericTypes' options' getMethod' result
Long Parameter List,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,DetermineCollectionInterfaces,The method has 6 parameters. Parameters: type' genericTypes' idictionary' ilist' icollection' ienumerable
Long Parameter List,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,DetermineCanDeserialize,The method has 5 parameters. Parameters: kind' context' targetType' correspondingMemberNames' allowDefault
Long Parameter List,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,Register,The method has 5 parameters. Parameters: targetType' serializerProvider' nullableType' nullableSerializerProvider' options
Long Parameter List,MsgPack.Serialization,TypeKeyRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\TypeKeyRepository.cs,Register,The method has 5 parameters. Parameters: type' entry' nullableType' nullableValue' options
Long Parameter List,MsgPack.Serialization,TypeKeyRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\TypeKeyRepository.cs,RegisterCore,The method has 5 parameters. Parameters: key' value' nullableType' nullableValue' options
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,Trace,The method has 5 parameters. Parameters: context' label' unpacker' index' itemNames
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,Trace,The method has 5 parameters. Parameters: context' label' unpacker' index' key
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValue,The method has 9 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' directRead' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValueCore,The method has 9 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' directRead' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValue,The method has 10 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' nilImplication' directRead' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValueCore,The method has 10 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' nilImplication' directRead' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValue,The method has 10 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' nilImplication' directRead' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValueCore,The method has 10 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' nilImplication' directRead' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMessagePackObjectValueFromArray,The method has 7 parameters. Parameters: unpacker' context' itemsCount' unpacked' memberName' nilImplication' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMessagePackObjectValueFromMap,The method has 7 parameters. Parameters: unpacker' context' itemsCount' unpacked' memberName' nilImplication' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMessagePackObjectValueCore,The method has 7 parameters. Parameters: unpacker' unpackingContext' itemsCount' unpacked' memberName' nilImplication' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackFromArray,The method has 5 parameters. Parameters: unpacker' context' factory' itemNames' operations
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackFromArrayCore,The method has 5 parameters. Parameters: unpacker' unpackingContext' factory' itemNames' operations
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollection,The method has 5 parameters. Parameters: unpacker' itemsCount' collection' bulkOperation' eachOperation
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionCore,The method has 5 parameters. Parameters: unpacker' itemsCount' collection' bulkOperation' eachOperation
Long Parameter List,MsgPack.Serialization.CollectionSerializers,UnityCollectionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CollectionSerializers\CollectionMessagePackSerializer`2.cs,UnityCollectionMessagePackSerializer,The method has 5 parameters. Parameters: ownerContext' targetType' traits' schema' capabilities
Long Parameter List,MsgPack.Serialization.CollectionSerializers,UnityDictionaryMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CollectionSerializers\DictionaryMessagePackSerializer`3.cs,UnityDictionaryMessagePackSerializer,The method has 7 parameters. Parameters: ownerContext' targetType' keyType' valueType' traits' schema' capabilities
Long Parameter List,MsgPack.Serialization.CollectionSerializers,UnityEnumerableMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CollectionSerializers\EnumerableMessagePackSerializer`2.cs,UnityEnumerableMessagePackSerializer,The method has 5 parameters. Parameters: ownerContext' targetType' traits' schema' capabilities
Long Parameter List,MsgPack.Serialization.CollectionSerializers,UnityEnumerableMessagePackSerializerBase,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CollectionSerializers\EnumerableMessagePackSerializerBase`2.cs,UnityEnumerableMessagePackSerializerBase,The method has 5 parameters. Parameters: ownerContext' targetType' itemType' schema' capabilities
Long Parameter List,MsgPack.Serialization.DefaultSerializers,AbstractCollectionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractCollectionMessagePackSerializer`2.cs,AbstractCollectionMessagePackSerializer,The method has 5 parameters. Parameters: ownerContext' abstractType' concreteType' traits' schema
Long Parameter List,MsgPack.Serialization.DefaultSerializers,AbstractCollectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractCollectionSerializerHelper.cs,GetConcreteSerializer,The method has 7 parameters. Parameters: context' schema' abstractType' targetType' exampleType' factory' serializer
Long Parameter List,MsgPack.Serialization.DefaultSerializers,AbstractDictionaryMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractDictionaryMessagePackSerializer`3.cs,AbstractDictionaryMessagePackSerializer,The method has 7 parameters. Parameters: ownerContext' abstractType' concreteType' keyType' valueType' traits' schema
Long Parameter List,MsgPack.Serialization.DefaultSerializers,AbstractEnumerableMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractEnumerableMessagePackSerializer`2.cs,AbstractEnumerableMessagePackSerializer,The method has 5 parameters. Parameters: ownerContext' abstractType' concreteType' traits' schema
Long Parameter List,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,CreateDictionarySerializer,The method has 6 parameters. Parameters: context' targetType' traits' keyType' valueType' schema
Long Parameter List,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,TryCreateAbstractCollectionSerializer,The method has 5 parameters. Parameters: context' abstractType' concreteType' schema' traits
Long Parameter List,MsgPack.Serialization.DefaultSerializers,UnityMultidimensionalArraySerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,ForEach,The method has 5 parameters. Parameters: array' totalLength' lowerBounds' lengths' action
Long Parameter List,MsgPack.Serialization.DefaultSerializers,System_Collections_Generic_Dictionary_2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_Generic_Dictionary_2MessagePackSerializer`2.cs,System_Collections_Generic_Dictionary_2MessagePackSerializer,The method has 7 parameters. Parameters: ownerContext' targetType' traits' keyType' valueType' keysSchema' valuesSchema
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionCollectionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionCollectionMessagePackSerializer`2.cs,ReflectionCollectionMessagePackSerializer,The method has 6 parameters. Parameters: ownerContext' abstractType' concreteType' concreteTypeCollectionTraits' itemsSchema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionDictionaryMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionDictionaryMessagePackSerializer`3.cs,ReflectionDictionaryMessagePackSerializer,The method has 8 parameters. Parameters: ownerContext' abstractType' concreteType' keyType' valueType' concreteTypeCollectionTraits' itemsSchema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionEnumerableMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionEnumerableMessagePackSerializer`2.cs,ReflectionEnumerableMessagePackSerializer,The method has 6 parameters. Parameters: ownerContext' abstractType' concreteType' concreteTypeCollectionTraits' itemsSchema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionNonGenericCollectionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionNonGeenricCollectionMessagePackSerializer`1.cs,ReflectionNonGenericCollectionMessagePackSerializer,The method has 6 parameters. Parameters: ownerContext' abstractType' concreteType' concreteTypeCollectionTraits' itemsSchema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionNonGenericEnumerableMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionNonGeenricEnumerableMessagePackSerializer`1.cs,ReflectionNonGenericEnumerableMessagePackSerializer,The method has 6 parameters. Parameters: ownerContext' abstractType' concreteType' concreteTypeCollectionTraits' itemsSchema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionNonGenericDictionaryMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionNonGenericDictionaryMessagePackSerializer`1.cs,ReflectionNonGenericDictionaryMessagePackSerializer,The method has 6 parameters. Parameters: ownerContext' abstractType' concreteType' concreteTypeCollectionTraits' itemsSchema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionNonGenericListMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionNonGenericListMessagePackSerializer`1.cs,ReflectionNonGenericListMessagePackSerializer,The method has 6 parameters. Parameters: ownerContext' abstractType' concreteType' concreteTypeCollectionTraits' itemsSchema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackMemberValue,The method has 6 parameters. Parameters: objectGraph' unpacker' itemsCount' unpacked' index' unpackerOffset
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,GetMetadata,The method has 8 parameters. Parameters: targetType' members' context' getters' setters' memberInfos' contracts' serializers
Long Parameter List,System.Runtime.CompilerServices,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,Trace,The method has 5 parameters. Parameters: context' label' unpacker' index' itemNames
Long Parameter List,System.Runtime.CompilerServices,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,Trace,The method has 5 parameters. Parameters: context' label' unpacker' index' key
Long Identifier,MsgPack,PackerUnpackerStreamOptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\PackerUnpackerStreamOptions.cs,,The length of the parameter _knownMemoryOrBufferingStreams is 30.
Long Identifier,MsgPack.Serialization,DateTimeMessagePackSerializerHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DateTimeMessagePackSerializerHelpers.cs,DetermineDateTimeConversionMethod,The length of the parameter dateTimeMemberConversionMethod is 30.
Long Identifier,MsgPack.Serialization,MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,,The length of the parameter _packerCompatibilityOptionsForCompatibility is 43.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForPolymorphicObjectTypeEmbeddingMethod is 39.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForPolymorphicObjectCodeTypeMappingMethod is 41.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForContextSpecifiedCollectionMethod is 35.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForPolymorphicCollectionTypeEmbeddingMethod is 43.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForPolymorphicCollectionCodeTypeMappingMethod is 45.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForContextSpecifiedDictionaryMethod is 35.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForPolymorphicDictionaryTypeEmbeddingMethod is 43.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForPolymorphicDictionaryCodeTypeMappingMethod is 45.
Long Identifier,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,The length of the parameter allowNonCollectionEnumerableTypes is 33.
Long Identifier,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,,The length of the parameter ExceptionConstructorWithInnerParameterTypes is 43.
Long Identifier,MsgPack.Serialization,SerializationCompatibilityOptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationCompatibilityOptions.cs,,The length of the parameter _ignorePackabilityForCollection is 31.
Long Identifier,MsgPack.Serialization,SerializationCompatibilityOptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationCompatibilityOptions.cs,,The length of the parameter _allowNonCollectionEnumerableTypes is 34.
Long Identifier,MsgPack.Serialization,SerializationContext,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationContext.cs,,The length of the parameter _dictionarySerializationOptions is 31.
Long Identifier,MsgPack.Serialization,SerializationContext,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationContext.cs,,The length of the parameter _defaultDateTimeConversionMethod is 32.
Long Identifier,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,,The length of the parameter MessagePackMemberAttributeTypeName is 34.
Long Identifier,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,,The length of the parameter MessagePackIgnoreAttributeTypeName is 34.
Long Identifier,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,,The length of the parameter MessagePackDeserializationConstructorAttributeTypeName is 54.
Long Identifier,MsgPack.Serialization,SerializerDebugging,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerDebugging.cs,,The length of the parameter _useLegacyNullMapEntryHandling is 30.
Long Identifier,MsgPack.Serialization,SerializerTypeKeyRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerTypeKeyRepository.cs,,The length of the parameter NonGenericSerializerConstructorParameterTypes is 45.
Long Identifier,MsgPack.Serialization,SerializingMember,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializingMember.cs,GetEnumMemberSerializationMethod,The length of the parameter messagePackEnumMemberAttributes is 31.
Long Identifier,MsgPack.Serialization,SerializingMember,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializingMember.cs,GetDateTimeMemberConversionMethod,The length of the parameter messagePackDateTimeMemberAttribute is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractCollectionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractCollectionMessagePackSerializer`2.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractDictionaryMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractDictionaryMessagePackSerializer`3.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractEnumerableMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractEnumerableMessagePackSerializer`2.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractNonGenericCollectionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractNonGenericCollectionMessagePackSerializer`1.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractNonGenericDictionaryMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractNonGenericDictionaryMessagePackSerializer`1.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractNonGenericEnumerableMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractNonGenericEnumerableMessagePackSerializer`1.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractNonGenericListMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractNonGenericListMessagePackSerializer`1.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,IsSupported,The length of the parameter preferReflectionBasedSerializer is 31.
Long Identifier,MsgPack.Serialization.DefaultSerializers,System_Collections_Generic_List_1MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_Generic_List_1MessagePackSerializer`1.cs,,The length of the parameter ConstructorWithCapacityParameterTypes is 37.
Long Statement,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The length of the statement  "					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 " is 141.
Long Statement,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The length of the statement  "					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ]; " is 133.
Long Statement,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt16,The length of the statement  "			Contract.Assert( buffer.Length >= offset + sizeof( ushort )' buffer.Length + ">=" + offset + " + " + sizeof( ushort ) ); " is 120.
Long Statement,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt32,The length of the statement  "				return ( uint )( ( buffer[ offset ] << 24 ) | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ] ); " is 126.
Long Statement,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The length of the statement  "					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 " is 152.
Long Statement,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The length of the statement  "					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] ); " is 135.
Long Statement,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToBits,The length of the statement  "			// Float32Bits usage is effectively pointer dereference operation rather than shifting operators' so we must consider endianness here. " is 134.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectCore,The length of the statement  "				if ( ( header & ReadValueResult.RawTypeMask ) == ReadValueResult.RawTypeMask && ( header & ReadValueResult.LengthOfLengthMask ) == 0 ) " is 134.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large array (0x{0:X} elements) which has more than Int32.MaxValue elements' at position {1:#'0}" " is 133.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large array (0x{0:X} elements) which has more than Int32.MaxValue elements' at offset {1:#'0}"; " is 132.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large map (0x{0:X} entries) which has more than Int32.MaxValue entries' at position {1:#'0}" " is 129.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large map (0x{0:X} entries) which has more than Int32.MaxValue entries' at offset {1:#'0}"; " is 128.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large ext type (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at position {1:#'0}" " is 130.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large ext type (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at offset {1:#'0}"; " is 129.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large binary or string (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at position {1:#'0}" " is 138.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large binary or string (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at offset {1:#'0}"; " is 137.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,Equals,The length of the statement  "			Contract.Assert( false' String.Format( "Unknown handle type this:'{0}'(value: '{1}')' other:'{2}'(value: '{3}')"' this._handleOrTypeCode.GetType()' this._handleOrTypeCode' other._handleOrTypeCode.GetType()' other._handleOrTypeCode ) ); " is 235.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,GetHashCode,The length of the statement  "				Contract.Assert( false' String.Format( "(this._handleOrTypeCode is string) but {0}"' this._handleOrTypeCode.GetType() ) ); " is 122.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ToString,The length of the statement  "			Contract.Assert( false' String.Format( "(this._handleOrTypeCode is string) but {0}"' this._handleOrTypeCode.GetType() ) ); " is 122.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,IsTypeOf,The length of the statement  "					return typeCode.IsInteger && ( this._value < 0x80000000 || ( 0xFFFFFFFF80000000 <= this._value && typeCode.IsSigned ) ); " is 120.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,PackToMessage,The length of the statement  "					if ( asString.GetUnderlyingType() == typeof( string ) || ( packer.CompatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) != 0 ) " is 140.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,AsString,The length of the statement  "				throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "Not '{0}' string."' encoding.WebName )' ex ); " is 126.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,VerifyUnderlyingType,The length of the statement  "					throw new ArgumentException( String.Format( CultureInfo.CurrentCulture' "Do not convert nil MessagePackObject to {0}."' typeof( T ) )' parameterName ); " is 151.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,VerifyUnderlyingType,The length of the statement  "					throw new ArgumentException( String.Format( CultureInfo.CurrentCulture' "Do not convert {0} MessagePackObject to {1}."' instance.UnderlyingType' typeof( T ) )' parameterName ); " is 176.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,VerifyUnderlyingRawType,The length of the statement  "				throw new ArgumentException( String.Format( CultureInfo.CurrentCulture' "Do not convert {0} MessagePackObject to {1}."' instance.UnderlyingType' typeof( T ) )' parameterName ); " is 176.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ThrowCannotBeNilAs,The length of the statement  "			throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "Do not convert nil MessagePackObject to {0}."' typeof( T ) ) ); " is 144.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ThrowInvalidTypeAs,The length of the statement  "				throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "Do not convert {0} (binary:0x{2:x}) MessagePackObject to {1}."' instance.UnderlyingType' typeof( T )' instance._value ) ); " is 203.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ThrowInvalidTypeAs,The length of the statement  "				throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "Do not convert {0} MessagePackObject to {1}."' instance.UnderlyingType' typeof( T ) ) ); " is 169.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,FromObject,The length of the statement  "			throw new MessageTypeException( String.Format( CultureInfo.CurrentCulture' "Type '{0}' is not supported."' boxedValue.GetType() ) ); " is 132.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,DebugDump,The length of the statement  "				return String.Format( CultureInfo.InvariantCulture' "{0}([{1}])"' this._handleOrTypeCode' this._handleOrTypeCode.GetType() ); " is 125.
Long Statement,MsgPack,MessagePackObjectDictionary,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObjectDictionary.cs,ThrowDuplicatedKeyException,The length of the statement  "			throw new ArgumentException( String.Format( CultureInfo.CurrentCulture' "Key '{0}'({1} type) already exists in this dictionary."' key' key.UnderlyingType )' parameterName ); " is 173.
Long Statement,MsgPack,MessagePackObjectDictionary,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObjectDictionary.cs,ValidateObjectArgument,The length of the statement  "				throw new ArgumentException( String.Format( CultureInfo.CurrentCulture' "Cannot convert '{1}' to {0}."' typeof( MessagePackObject ).Name' obj.GetType() )' parameterName ); " is 171.
Long Statement,MsgPack,MessagePackObjectDictionary,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObjectDictionary.cs,AddCore,The length of the statement  "				this._dictionary = new Dictionary<MessagePackObject' MessagePackObject>( DictionaryInitialCapacity' MessagePackObjectEqualityComparer.Instance ); " is 145.
Long Statement,MsgPack,MessagePackObjectDictionary,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObjectDictionary.cs,CopyTo,The length of the statement  "				CollectionOperation.CopyTo( this' this.Count' 0' asDictionaryEntries' index' array.Length' kv => new DictionaryEntry( kv.Key' kv.Value ) ); " is 139.
Long Statement,MsgPack,Enumerator,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObjectDictionary.Enumerator.cs,GetCurrentStrict,The length of the statement  "					throw new InvalidOperationException( "The enumerator is positioned before the first element of the collection or after the last element." ); " is 140.
Long Statement,MsgPack,Enumerator,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObjectDictionary.Enumerator.cs,MoveNext,The length of the statement  "				this._current = new KeyValuePair<MessagePackObject' MessagePackObject>( this._underlying._keys[ this._position ]' this._underlying._values[ this._position ] ); " is 159.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectCore,The length of the statement  "				if ( ( header & ReadValueResult.RawTypeMask ) == ReadValueResult.RawTypeMask && ( header & ReadValueResult.LengthOfLengthMask ) == 0 ) " is 134.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large array (0x{0:X} elements) which has more than Int32.MaxValue elements' at position {1:#'0}" " is 133.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large array (0x{0:X} elements) which has more than Int32.MaxValue elements' at offset {1:#'0}"; " is 132.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large map (0x{0:X} entries) which has more than Int32.MaxValue entries' at position {1:#'0}" " is 129.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large map (0x{0:X} entries) which has more than Int32.MaxValue entries' at offset {1:#'0}"; " is 128.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large ext type (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at position {1:#'0}" " is 130.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large ext type (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at offset {1:#'0}"; " is 129.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large binary or string (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at position {1:#'0}" " is 138.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large binary or string (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at offset {1:#'0}"; " is 137.
Long Statement,MsgPack,MessagePackString,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,GetString,The length of the statement  "				throw new InvalidOperationException( "This bytes is not UTF-8 string."' this._decodingError == IsBinary ? default( Exception ) : this._decodingError ); " is 151.
Long Statement,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,ThrowCannotBeNegativeException,The length of the statement  "			throw new ArgumentOutOfRangeException( parameterName' String.Format( CultureInfo.CurrentCulture' "'{0}' is negative."' parameterName ) ); " is 137.
Long Statement,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,Create,The length of the statement  "			return new MessagePackStreamPacker( stream' ownsStream ? PackerUnpackerStreamOptions.SingletonOwnsStream : PackerUnpackerStreamOptions.None' compatibilityOptions ); " is 164.
Long Statement,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,Create,The length of the statement  "			return new MessagePackByteArrayPacker( buffer' 0' allowsBufferExpansion ? SingleArrayBufferAllocator.Default : FixedArrayBufferAllocator.Instance' compatibilityOptions ); " is 170.
Long Statement,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,Create,The length of the statement  "			return new MessagePackByteArrayPacker( buffer' startOffset' allowsBufferExpansion ? SingleArrayBufferAllocator.Default : FixedArrayBufferAllocator.Instance' compatibilityOptions ); " is 180.
Long Statement,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,Create,The length of the statement  "			return new MessagePackByteArrayPacker( buffer' startOffset' new SingleArrayBufferAllocator( allocator )' compatibilityOptions ); " is 128.
Long Statement,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The length of the statement  "			// Float32Bits usage is effectively pointer dereference operation rather than shifting operators' so we must consider endianness here. " is 134.
Long Statement,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The length of the statement  "								Contract.Assert( ( int )( source & ReadValueResult.ValueOrLengthMask ) == 16' ( int )( source & ReadValueResult.ValueOrLengthMask ) + " == 16" ); " is 145.
Long Statement,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The length of the statement  "					Contract.Assert( ( source & ReadValueResult.TypeCodeMask ) == ReadValueResult.Real64Type' ( source & ReadValueResult.TypeCodeMask ) + " == ReadValueResult.Real64Type" ); " is 169.
Long Statement,MsgPack,ReflectionAbstractions,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReflectionAbstractions.cs,GetRuntimeConstructor,The length of the statement  "			return source.GetTypeInfo().DeclaredConstructors.SingleOrDefault( c => c.GetParameters().Select( p => p.ParameterType ).SequenceEqual( parameters ) ); " is 150.
Long Statement,MsgPack,ReflectionAbstractions,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReflectionAbstractions.cs,GetRuntimeConstructor,The length of the statement  "			return source.GetConstructor( BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance' null' parameters' null ); " is 125.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ToTicks,The length of the statement  "				throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "This value is too small for '{0}'."' destination ) ); " is 134.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ToTicks,The length of the statement  "				throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "This value is too large for '{0}'."' destination ) ); " is 134.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,FromDateTime,The length of the statement  "			FromDateTimeTicks( ( value.Kind == DateTimeKind.Local ? value.ToUniversalTime() : value ).Ticks' out unixEpocSeconds' out nanoSeconds ); " is 136.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Decode,The length of the statement  "					return new Timestamp( BigEndianBinary.ToInt64( value.Body' sizeof( int ) )' unchecked( ( int )BigEndianBinary.ToUInt32( value.Body' 0 ) ) ); " is 140.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,FromComponents,The length of the statement  "				var days = YearsToDaysOfNewYear( value.Year ) + ToDaysOffsetFromNewYear( value.Month' value.Day' isLeapYear ) - Timestamp.UnixEpochInSeconds / Timestamp.SecondsPerDay; " is 167.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ParseExact,The length of the statement  "			HandleParseResult( TryParseExactCore( input' format' formatProvider' styles' out result )' "Cannot parse specified input with specified format." ); " is 147.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ParseExact,The length of the statement  "			HandleParseResult( TryParseExactCore( input' formats' formatProvider' styles' out result )' "Cannot parse specified input with any specified formats." ); " is 153.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,HandleParseResult,The length of the statement  "					Contract.Assert( kind == TimestampParseResult.KindNoMatchedFormats' kind + " == TimestampParseResult.KindNoMatchedFormats" ); " is 125.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The length of the statement  "			Contract.Assert( this.unixEpochSeconds >= -UnixEpochInSeconds' this.unixEpochSeconds + " > " + ( -UnixEpochInSeconds ) ); " is 121.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The length of the statement  "			// https://github.com/dotnet/coreclr/blob/0825741447c14a6a70c60b7c429e16f95214e74e/src/mscorlib/shared/System/DateTime.cs#L863 " is 126.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The length of the statement  "			year = unchecked( ( long )( numberOf400Years * 400 + numberOf100Years * 100 + numberOf4years * 4 + numberOf1Year + 1 ) ); " is 121.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The length of the statement  "			Contract.Assert( this.unixEpochSeconds < -UnixEpochInSeconds' this.unixEpochSeconds + " > " + ( -UnixEpochInSeconds ) ); " is 120.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The length of the statement  "			// https://github.com/dotnet/coreclr/blob/0825741447c14a6a70c60b7c429e16f95214e74e/src/mscorlib/shared/System/DateTime.cs#L863 " is 126.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,TryParseExactCore,The length of the statement  "				if ( TimestampStringConverter.TryParseExact( input' format' formatProvider' styles' out result ) == TimestampParseResult.Success ) " is 130.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ValidateParseStyles,The length of the statement  "			if ( styles != DateTimeStyles.None && ( styles & ~( DateTimeStyles.AllowLeadingWhite | DateTimeStyles.AllowTrailingWhite ) ) != 0 ) " is 131.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ValidateParseStyles,The length of the statement  "				throw new ArgumentException( "Timestamp currently only support DateTimeStyles.None' DateTimeStyles.AllowLeadingWhite' and DateTimeStyles.AllowTrailingWhite."' "styles" ); " is 170.
Long Statement,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The length of the statement  "			if ( !ParseWhitespace( input' ref position' ( styles & DateTimeStyles.AllowLeadingWhite ) != 0' /* isTrailing */false ) ) " is 121.
Long Statement,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The length of the statement  "			if ( !ParseWhitespace( input' ref position' ( styles & DateTimeStyles.AllowTrailingWhite ) != 0' /* isTrailing */true ) ) " is 121.
Long Statement,MsgPack,Unpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\Unpacker.cs,ThrowInvalidModeException,The length of the statement  "			throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "Reader is in '{0}' mode."' this._mode ) ); " is 123.
Long Statement,MsgPack,Unpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\Unpacker.cs,ReadNullableMessagePackExtendedTypeObject,The length of the statement  "			result = this.LastReadData.IsNil ? default( MessagePackExtendedTypeObject? ) : this.LastReadData.AsMessagePackExtendedTypeObject(); " is 131.
Long Statement,MsgPack,Unpacking,C:\repos\msgpack_msgpack-cli\src\MsgPack\Unpacking.cs,NewTypeMismatchException,The length of the statement  "			return new MessageTypeException( String.Format( CultureInfo.CurrentCulture' "Message type is not compatible to {0}."' requestedType )' innerException ); " is 152.
Long Statement,MsgPack,Unpacking,C:\repos\msgpack_msgpack-cli\src\MsgPack\Unpacking.cs,NewInvalidEncodingException,The length of the statement  "			return new MessageTypeException( String.Format( CultureInfo.CurrentCulture' "The stream cannot be decoded as {0} string."' encoding.WebName )' innerException ); " is 160.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,HandleAotError,The length of the statement  "						api = String.Format( CultureInfo.InvariantCulture' "MessagePackSerializer.PrepareCollectionType<{0}>"' mayBeGenericArgument.GetGenericArguments()[ 0 ].GetFullName() ); " is 167.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,HandleAotError,The length of the statement  "						api = String.Format( CultureInfo.InvariantCulture' "MessagePackSerializer.PrepareDictionaryType<{0}' {1}>"' genericArguments[ 0 ].GetFullName()' genericArguments[ 1 ].GetFullName() ); " is 183.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,HandleAotError,The length of the statement  "					api = String.Format( CultureInfo.InvariantCulture' "MessagePackSerializer.PrepareType<{0}>"' mayBeGenericArgument.GetFullName() ); " is 130.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.AppDomainManagerInitializationOptions ).TypeHandle' new System_AppDomainManagerInitializationOptionsEqualityComparer() ); " is 148.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.AppDomainManagerInitializationOptions? ).TypeHandle' new NullableSystem_AppDomainManagerInitializationOptionsEqualityComparer() ); " is 157.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Base64FormattingOptions ).TypeHandle' new System_Base64FormattingOptionsEqualityComparer() ); " is 120.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Base64FormattingOptions? ).TypeHandle' new NullableSystem_Base64FormattingOptionsEqualityComparer() ); " is 129.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.EnvironmentVariableTarget ).TypeHandle' new System_EnvironmentVariableTargetEqualityComparer() ); " is 124.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.EnvironmentVariableTarget? ).TypeHandle' new NullableSystem_EnvironmentVariableTargetEqualityComparer() ); " is 133.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.GCNotificationStatus? ).TypeHandle' new NullableSystem_GCNotificationStatusEqualityComparer() ); " is 123.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.RuntimeMethodHandle? ).TypeHandle' new NullableSystem_RuntimeMethodHandleEqualityComparer() ); " is 121.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Collections.DictionaryEntry ).TypeHandle' new System_Collections_DictionaryEntryEqualityComparer() ); " is 128.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Collections.DictionaryEntry? ).TypeHandle' new NullableSystem_Collections_DictionaryEntryEqualityComparer() ); " is 137.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Diagnostics.DebuggerBrowsableState ).TypeHandle' new System_Diagnostics_DebuggerBrowsableStateEqualityComparer() ); " is 142.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Diagnostics.DebuggerBrowsableState? ).TypeHandle' new NullableSystem_Diagnostics_DebuggerBrowsableStateEqualityComparer() ); " is 151.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Diagnostics.SymbolStore.SymAddressKind ).TypeHandle' new System_Diagnostics_SymbolStore_SymAddressKindEqualityComparer() ); " is 150.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Diagnostics.SymbolStore.SymAddressKind? ).TypeHandle' new NullableSystem_Diagnostics_SymbolStore_SymAddressKindEqualityComparer() ); " is 159.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Diagnostics.SymbolStore.SymbolToken ).TypeHandle' new System_Diagnostics_SymbolStore_SymbolTokenEqualityComparer() ); " is 144.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Diagnostics.SymbolStore.SymbolToken? ).TypeHandle' new NullableSystem_Diagnostics_SymbolStore_SymbolTokenEqualityComparer() ); " is 153.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Globalization.CalendarAlgorithmType ).TypeHandle' new System_Globalization_CalendarAlgorithmTypeEqualityComparer() ); " is 144.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Globalization.CalendarAlgorithmType? ).TypeHandle' new NullableSystem_Globalization_CalendarAlgorithmTypeEqualityComparer() ); " is 153.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Globalization.CalendarWeekRule ).TypeHandle' new System_Globalization_CalendarWeekRuleEqualityComparer() ); " is 134.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Globalization.CalendarWeekRule? ).TypeHandle' new NullableSystem_Globalization_CalendarWeekRuleEqualityComparer() ); " is 143.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Globalization.CompareOptions ).TypeHandle' new System_Globalization_CompareOptionsEqualityComparer() ); " is 130.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Globalization.CompareOptions? ).TypeHandle' new NullableSystem_Globalization_CompareOptionsEqualityComparer() ); " is 139.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Globalization.CultureTypes ).TypeHandle' new System_Globalization_CultureTypesEqualityComparer() ); " is 126.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Globalization.CultureTypes? ).TypeHandle' new NullableSystem_Globalization_CultureTypesEqualityComparer() ); " is 135.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Globalization.DateTimeStyles ).TypeHandle' new System_Globalization_DateTimeStylesEqualityComparer() ); " is 130.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Globalization.DateTimeStyles? ).TypeHandle' new NullableSystem_Globalization_DateTimeStylesEqualityComparer() ); " is 139.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Globalization.DigitShapes ).TypeHandle' new System_Globalization_DigitShapesEqualityComparer() ); " is 124.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Globalization.DigitShapes? ).TypeHandle' new NullableSystem_Globalization_DigitShapesEqualityComparer() ); " is 133.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Globalization.GregorianCalendarTypes ).TypeHandle' new System_Globalization_GregorianCalendarTypesEqualityComparer() ); " is 146.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Globalization.GregorianCalendarTypes? ).TypeHandle' new NullableSystem_Globalization_GregorianCalendarTypesEqualityComparer() ); " is 155.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Globalization.NumberStyles ).TypeHandle' new System_Globalization_NumberStylesEqualityComparer() ); " is 126.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Globalization.NumberStyles? ).TypeHandle' new NullableSystem_Globalization_NumberStylesEqualityComparer() ); " is 135.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Globalization.UnicodeCategory ).TypeHandle' new System_Globalization_UnicodeCategoryEqualityComparer() ); " is 132.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Globalization.UnicodeCategory? ).TypeHandle' new NullableSystem_Globalization_UnicodeCategoryEqualityComparer() ); " is 141.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.IO.HandleInheritability ).TypeHandle' new System_IO_HandleInheritabilityEqualityComparer() ); " is 120.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.IO.HandleInheritability? ).TypeHandle' new NullableSystem_IO_HandleInheritabilityEqualityComparer() ); " is 129.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.IO.Pipes.PipeAccessRights ).TypeHandle' new System_IO_Pipes_PipeAccessRightsEqualityComparer() ); " is 124.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.IO.Pipes.PipeAccessRights? ).TypeHandle' new NullableSystem_IO_Pipes_PipeAccessRightsEqualityComparer() ); " is 133.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.IO.Pipes.PipeDirection? ).TypeHandle' new NullableSystem_IO_Pipes_PipeDirectionEqualityComparer() ); " is 127.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.IO.Pipes.PipeOptions? ).TypeHandle' new NullableSystem_IO_Pipes_PipeOptionsEqualityComparer() ); " is 123.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.IO.Pipes.PipeTransmissionMode ).TypeHandle' new System_IO_Pipes_PipeTransmissionModeEqualityComparer() ); " is 132.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.IO.Pipes.PipeTransmissionMode? ).TypeHandle' new NullableSystem_IO_Pipes_PipeTransmissionModeEqualityComparer() ); " is 141.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.AssemblyNameFlags ).TypeHandle' new System_Reflection_AssemblyNameFlagsEqualityComparer() ); " is 130.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.AssemblyNameFlags? ).TypeHandle' new NullableSystem_Reflection_AssemblyNameFlagsEqualityComparer() ); " is 139.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.BindingFlags ).TypeHandle' new System_Reflection_BindingFlagsEqualityComparer() ); " is 120.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.BindingFlags? ).TypeHandle' new NullableSystem_Reflection_BindingFlagsEqualityComparer() ); " is 129.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.CallingConventions ).TypeHandle' new System_Reflection_CallingConventionsEqualityComparer() ); " is 132.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.CallingConventions? ).TypeHandle' new NullableSystem_Reflection_CallingConventionsEqualityComparer() ); " is 141.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.CustomAttributeNamedArgument ).TypeHandle' new System_Reflection_CustomAttributeNamedArgumentEqualityComparer() ); " is 152.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.CustomAttributeNamedArgument? ).TypeHandle' new NullableSystem_Reflection_CustomAttributeNamedArgumentEqualityComparer() ); " is 161.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.CustomAttributeTypedArgument ).TypeHandle' new System_Reflection_CustomAttributeTypedArgumentEqualityComparer() ); " is 152.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.CustomAttributeTypedArgument? ).TypeHandle' new NullableSystem_Reflection_CustomAttributeTypedArgumentEqualityComparer() ); " is 161.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.EventAttributes ).TypeHandle' new System_Reflection_EventAttributesEqualityComparer() ); " is 126.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.EventAttributes? ).TypeHandle' new NullableSystem_Reflection_EventAttributesEqualityComparer() ); " is 135.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.ExceptionHandlingClauseOptions ).TypeHandle' new System_Reflection_ExceptionHandlingClauseOptionsEqualityComparer() ); " is 156.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.ExceptionHandlingClauseOptions? ).TypeHandle' new NullableSystem_Reflection_ExceptionHandlingClauseOptionsEqualityComparer() ); " is 165.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.FieldAttributes ).TypeHandle' new System_Reflection_FieldAttributesEqualityComparer() ); " is 126.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.FieldAttributes? ).TypeHandle' new NullableSystem_Reflection_FieldAttributesEqualityComparer() ); " is 135.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.GenericParameterAttributes ).TypeHandle' new System_Reflection_GenericParameterAttributesEqualityComparer() ); " is 148.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.GenericParameterAttributes? ).TypeHandle' new NullableSystem_Reflection_GenericParameterAttributesEqualityComparer() ); " is 157.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.ImageFileMachine ).TypeHandle' new System_Reflection_ImageFileMachineEqualityComparer() ); " is 128.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.ImageFileMachine? ).TypeHandle' new NullableSystem_Reflection_ImageFileMachineEqualityComparer() ); " is 137.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.InterfaceMapping ).TypeHandle' new System_Reflection_InterfaceMappingEqualityComparer() ); " is 128.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.InterfaceMapping? ).TypeHandle' new NullableSystem_Reflection_InterfaceMappingEqualityComparer() ); " is 137.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.MemberTypes? ).TypeHandle' new NullableSystem_Reflection_MemberTypesEqualityComparer() ); " is 127.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.MethodAttributes ).TypeHandle' new System_Reflection_MethodAttributesEqualityComparer() ); " is 128.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.MethodAttributes? ).TypeHandle' new NullableSystem_Reflection_MethodAttributesEqualityComparer() ); " is 137.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.MethodImplAttributes ).TypeHandle' new System_Reflection_MethodImplAttributesEqualityComparer() ); " is 136.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.MethodImplAttributes? ).TypeHandle' new NullableSystem_Reflection_MethodImplAttributesEqualityComparer() ); " is 145.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.ParameterAttributes ).TypeHandle' new System_Reflection_ParameterAttributesEqualityComparer() ); " is 134.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.ParameterAttributes? ).TypeHandle' new NullableSystem_Reflection_ParameterAttributesEqualityComparer() ); " is 143.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.ParameterModifier ).TypeHandle' new System_Reflection_ParameterModifierEqualityComparer() ); " is 130.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.ParameterModifier? ).TypeHandle' new NullableSystem_Reflection_ParameterModifierEqualityComparer() ); " is 139.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.PortableExecutableKinds ).TypeHandle' new System_Reflection_PortableExecutableKindsEqualityComparer() ); " is 142.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.PortableExecutableKinds? ).TypeHandle' new NullableSystem_Reflection_PortableExecutableKindsEqualityComparer() ); " is 151.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.ProcessorArchitecture ).TypeHandle' new System_Reflection_ProcessorArchitectureEqualityComparer() ); " is 138.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.ProcessorArchitecture? ).TypeHandle' new NullableSystem_Reflection_ProcessorArchitectureEqualityComparer() ); " is 147.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.PropertyAttributes ).TypeHandle' new System_Reflection_PropertyAttributesEqualityComparer() ); " is 132.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.PropertyAttributes? ).TypeHandle' new NullableSystem_Reflection_PropertyAttributesEqualityComparer() ); " is 141.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.ResourceAttributes ).TypeHandle' new System_Reflection_ResourceAttributesEqualityComparer() ); " is 132.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.ResourceAttributes? ).TypeHandle' new NullableSystem_Reflection_ResourceAttributesEqualityComparer() ); " is 141.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.ResourceLocation ).TypeHandle' new System_Reflection_ResourceLocationEqualityComparer() ); " is 128.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.ResourceLocation? ).TypeHandle' new NullableSystem_Reflection_ResourceLocationEqualityComparer() ); " is 137.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.TypeAttributes ).TypeHandle' new System_Reflection_TypeAttributesEqualityComparer() ); " is 124.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Reflection.TypeAttributes? ).TypeHandle' new NullableSystem_Reflection_TypeAttributesEqualityComparer() ); " is 133.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Resources.UltimateResourceFallbackLocation ).TypeHandle' new System_Resources_UltimateResourceFallbackLocationEqualityComparer() ); " is 158.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Resources.UltimateResourceFallbackLocation? ).TypeHandle' new NullableSystem_Resources_UltimateResourceFallbackLocationEqualityComparer() ); " is 167.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.GCLatencyMode? ).TypeHandle' new NullableSystem_Runtime_GCLatencyModeEqualityComparer() ); " is 125.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.CompilerServices.CompilationRelaxations ).TypeHandle' new System_Runtime_CompilerServices_CompilationRelaxationsEqualityComparer() ); " is 168.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.CompilerServices.CompilationRelaxations? ).TypeHandle' new NullableSystem_Runtime_CompilerServices_CompilationRelaxationsEqualityComparer() ); " is 177.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.CompilerServices.LoadHint ).TypeHandle' new System_Runtime_CompilerServices_LoadHintEqualityComparer() ); " is 140.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.CompilerServices.LoadHint? ).TypeHandle' new NullableSystem_Runtime_CompilerServices_LoadHintEqualityComparer() ); " is 149.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.CompilerServices.MethodCodeType ).TypeHandle' new System_Runtime_CompilerServices_MethodCodeTypeEqualityComparer() ); " is 152.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.CompilerServices.MethodCodeType? ).TypeHandle' new NullableSystem_Runtime_CompilerServices_MethodCodeTypeEqualityComparer() ); " is 161.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.CompilerServices.MethodImplOptions ).TypeHandle' new System_Runtime_CompilerServices_MethodImplOptionsEqualityComparer() ); " is 158.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.CompilerServices.MethodImplOptions? ).TypeHandle' new NullableSystem_Runtime_CompilerServices_MethodImplOptionsEqualityComparer() ); " is 167.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.ConstrainedExecution.Cer ).TypeHandle' new System_Runtime_ConstrainedExecution_CerEqualityComparer() ); " is 138.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.ConstrainedExecution.Cer? ).TypeHandle' new NullableSystem_Runtime_ConstrainedExecution_CerEqualityComparer() ); " is 147.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.ConstrainedExecution.Consistency ).TypeHandle' new System_Runtime_ConstrainedExecution_ConsistencyEqualityComparer() ); " is 154.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.ConstrainedExecution.Consistency? ).TypeHandle' new NullableSystem_Runtime_ConstrainedExecution_ConsistencyEqualityComparer() ); " is 163.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.ArrayWithOffset ).TypeHandle' new System_Runtime_InteropServices_ArrayWithOffsetEqualityComparer() ); " is 152.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.ArrayWithOffset? ).TypeHandle' new NullableSystem_Runtime_InteropServices_ArrayWithOffsetEqualityComparer() ); " is 161.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.AssemblyRegistrationFlags ).TypeHandle' new System_Runtime_InteropServices_AssemblyRegistrationFlagsEqualityComparer() ); " is 172.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.AssemblyRegistrationFlags? ).TypeHandle' new NullableSystem_Runtime_InteropServices_AssemblyRegistrationFlagsEqualityComparer() ); " is 181.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.CallingConvention ).TypeHandle' new System_Runtime_InteropServices_CallingConventionEqualityComparer() ); " is 156.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.CallingConvention? ).TypeHandle' new NullableSystem_Runtime_InteropServices_CallingConventionEqualityComparer() ); " is 165.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.CharSet ).TypeHandle' new System_Runtime_InteropServices_CharSetEqualityComparer() ); " is 136.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.CharSet? ).TypeHandle' new NullableSystem_Runtime_InteropServices_CharSetEqualityComparer() ); " is 145.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.ClassInterfaceType ).TypeHandle' new System_Runtime_InteropServices_ClassInterfaceTypeEqualityComparer() ); " is 158.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.ClassInterfaceType? ).TypeHandle' new NullableSystem_Runtime_InteropServices_ClassInterfaceTypeEqualityComparer() ); " is 167.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.ComInterfaceType ).TypeHandle' new System_Runtime_InteropServices_ComInterfaceTypeEqualityComparer() ); " is 154.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.ComInterfaceType? ).TypeHandle' new NullableSystem_Runtime_InteropServices_ComInterfaceTypeEqualityComparer() ); " is 163.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.ComMemberType ).TypeHandle' new System_Runtime_InteropServices_ComMemberTypeEqualityComparer() ); " is 148.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.ComMemberType? ).TypeHandle' new NullableSystem_Runtime_InteropServices_ComMemberTypeEqualityComparer() ); " is 157.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.ExporterEventKind ).TypeHandle' new System_Runtime_InteropServices_ExporterEventKindEqualityComparer() ); " is 156.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.ExporterEventKind? ).TypeHandle' new NullableSystem_Runtime_InteropServices_ExporterEventKindEqualityComparer() ); " is 165.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.GCHandle ).TypeHandle' new System_Runtime_InteropServices_GCHandleEqualityComparer() ); " is 138.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.GCHandle? ).TypeHandle' new NullableSystem_Runtime_InteropServices_GCHandleEqualityComparer() ); " is 147.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.GCHandleType ).TypeHandle' new System_Runtime_InteropServices_GCHandleTypeEqualityComparer() ); " is 146.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.GCHandleType? ).TypeHandle' new NullableSystem_Runtime_InteropServices_GCHandleTypeEqualityComparer() ); " is 155.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.HandleRef ).TypeHandle' new System_Runtime_InteropServices_HandleRefEqualityComparer() ); " is 140.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.HandleRef? ).TypeHandle' new NullableSystem_Runtime_InteropServices_HandleRefEqualityComparer() ); " is 149.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.ImporterEventKind ).TypeHandle' new System_Runtime_InteropServices_ImporterEventKindEqualityComparer() ); " is 156.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.ImporterEventKind? ).TypeHandle' new NullableSystem_Runtime_InteropServices_ImporterEventKindEqualityComparer() ); " is 165.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.LayoutKind ).TypeHandle' new System_Runtime_InteropServices_LayoutKindEqualityComparer() ); " is 142.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.LayoutKind? ).TypeHandle' new NullableSystem_Runtime_InteropServices_LayoutKindEqualityComparer() ); " is 151.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.RegistrationClassContext ).TypeHandle' new System_Runtime_InteropServices_RegistrationClassContextEqualityComparer() ); " is 170.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.RegistrationClassContext? ).TypeHandle' new NullableSystem_Runtime_InteropServices_RegistrationClassContextEqualityComparer() ); " is 179.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.RegistrationConnectionType ).TypeHandle' new System_Runtime_InteropServices_RegistrationConnectionTypeEqualityComparer() ); " is 174.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.RegistrationConnectionType? ).TypeHandle' new NullableSystem_Runtime_InteropServices_RegistrationConnectionTypeEqualityComparer() ); " is 183.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.TypeLibExporterFlags ).TypeHandle' new System_Runtime_InteropServices_TypeLibExporterFlagsEqualityComparer() ); " is 162.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.TypeLibExporterFlags? ).TypeHandle' new NullableSystem_Runtime_InteropServices_TypeLibExporterFlagsEqualityComparer() ); " is 171.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.TypeLibFuncFlags ).TypeHandle' new System_Runtime_InteropServices_TypeLibFuncFlagsEqualityComparer() ); " is 154.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.TypeLibFuncFlags? ).TypeHandle' new NullableSystem_Runtime_InteropServices_TypeLibFuncFlagsEqualityComparer() ); " is 163.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.TypeLibImporterFlags ).TypeHandle' new System_Runtime_InteropServices_TypeLibImporterFlagsEqualityComparer() ); " is 162.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.TypeLibImporterFlags? ).TypeHandle' new NullableSystem_Runtime_InteropServices_TypeLibImporterFlagsEqualityComparer() ); " is 171.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.TypeLibTypeFlags ).TypeHandle' new System_Runtime_InteropServices_TypeLibTypeFlagsEqualityComparer() ); " is 154.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.TypeLibTypeFlags? ).TypeHandle' new NullableSystem_Runtime_InteropServices_TypeLibTypeFlagsEqualityComparer() ); " is 163.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.TypeLibVarFlags ).TypeHandle' new System_Runtime_InteropServices_TypeLibVarFlagsEqualityComparer() ); " is 152.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.TypeLibVarFlags? ).TypeHandle' new NullableSystem_Runtime_InteropServices_TypeLibVarFlagsEqualityComparer() ); " is 161.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.UnmanagedType ).TypeHandle' new System_Runtime_InteropServices_UnmanagedTypeEqualityComparer() ); " is 148.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.UnmanagedType? ).TypeHandle' new NullableSystem_Runtime_InteropServices_UnmanagedTypeEqualityComparer() ); " is 157.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.VarEnum ).TypeHandle' new System_Runtime_InteropServices_VarEnumEqualityComparer() ); " is 136.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.InteropServices.VarEnum? ).TypeHandle' new NullableSystem_Runtime_InteropServices_VarEnumEqualityComparer() ); " is 145.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Remoting.CustomErrorsModes ).TypeHandle' new System_Runtime_Remoting_CustomErrorsModesEqualityComparer() ); " is 142.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Remoting.CustomErrorsModes? ).TypeHandle' new NullableSystem_Runtime_Remoting_CustomErrorsModesEqualityComparer() ); " is 151.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Remoting.WellKnownObjectMode ).TypeHandle' new System_Runtime_Remoting_WellKnownObjectModeEqualityComparer() ); " is 146.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Remoting.WellKnownObjectMode? ).TypeHandle' new NullableSystem_Runtime_Remoting_WellKnownObjectModeEqualityComparer() ); " is 155.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Remoting.Activation.ActivatorLevel ).TypeHandle' new System_Runtime_Remoting_Activation_ActivatorLevelEqualityComparer() ); " is 158.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Remoting.Activation.ActivatorLevel? ).TypeHandle' new NullableSystem_Runtime_Remoting_Activation_ActivatorLevelEqualityComparer() ); " is 167.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Remoting.Channels.ServerProcessing ).TypeHandle' new System_Runtime_Remoting_Channels_ServerProcessingEqualityComparer() ); " is 158.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Remoting.Channels.ServerProcessing? ).TypeHandle' new NullableSystem_Runtime_Remoting_Channels_ServerProcessingEqualityComparer() ); " is 167.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Remoting.Lifetime.LeaseState ).TypeHandle' new System_Runtime_Remoting_Lifetime_LeaseStateEqualityComparer() ); " is 146.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Remoting.Lifetime.LeaseState? ).TypeHandle' new NullableSystem_Runtime_Remoting_Lifetime_LeaseStateEqualityComparer() ); " is 155.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Remoting.Metadata.SoapOption ).TypeHandle' new System_Runtime_Remoting_Metadata_SoapOptionEqualityComparer() ); " is 146.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Remoting.Metadata.SoapOption? ).TypeHandle' new NullableSystem_Runtime_Remoting_Metadata_SoapOptionEqualityComparer() ); " is 155.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Remoting.Metadata.XmlFieldOrderOption ).TypeHandle' new System_Runtime_Remoting_Metadata_XmlFieldOrderOptionEqualityComparer() ); " is 164.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Remoting.Metadata.XmlFieldOrderOption? ).TypeHandle' new NullableSystem_Runtime_Remoting_Metadata_XmlFieldOrderOptionEqualityComparer() ); " is 173.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Serialization.SerializationEntry ).TypeHandle' new System_Runtime_Serialization_SerializationEntryEqualityComparer() ); " is 154.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Serialization.SerializationEntry? ).TypeHandle' new NullableSystem_Runtime_Serialization_SerializationEntryEqualityComparer() ); " is 163.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Serialization.StreamingContext ).TypeHandle' new System_Runtime_Serialization_StreamingContextEqualityComparer() ); " is 150.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Serialization.StreamingContext? ).TypeHandle' new NullableSystem_Runtime_Serialization_StreamingContextEqualityComparer() ); " is 159.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Serialization.StreamingContextStates ).TypeHandle' new System_Runtime_Serialization_StreamingContextStatesEqualityComparer() ); " is 162.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Serialization.StreamingContextStates? ).TypeHandle' new NullableSystem_Runtime_Serialization_StreamingContextStatesEqualityComparer() ); " is 171.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Serialization.Formatters.FormatterAssemblyStyle ).TypeHandle' new System_Runtime_Serialization_Formatters_FormatterAssemblyStyleEqualityComparer() ); " is 184.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Serialization.Formatters.FormatterAssemblyStyle? ).TypeHandle' new NullableSystem_Runtime_Serialization_Formatters_FormatterAssemblyStyleEqualityComparer() ); " is 193.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Serialization.Formatters.FormatterTypeStyle ).TypeHandle' new System_Runtime_Serialization_Formatters_FormatterTypeStyleEqualityComparer() ); " is 176.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Serialization.Formatters.FormatterTypeStyle? ).TypeHandle' new NullableSystem_Runtime_Serialization_Formatters_FormatterTypeStyleEqualityComparer() ); " is 185.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Serialization.Formatters.TypeFilterLevel ).TypeHandle' new System_Runtime_Serialization_Formatters_TypeFilterLevelEqualityComparer() ); " is 170.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Serialization.Formatters.TypeFilterLevel? ).TypeHandle' new NullableSystem_Runtime_Serialization_Formatters_TypeFilterLevelEqualityComparer() ); " is 179.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Versioning.ResourceScope ).TypeHandle' new System_Runtime_Versioning_ResourceScopeEqualityComparer() ); " is 138.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Runtime.Versioning.ResourceScope? ).TypeHandle' new NullableSystem_Runtime_Versioning_ResourceScopeEqualityComparer() ); " is 147.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.HostSecurityManagerOptions ).TypeHandle' new System_Security_HostSecurityManagerOptionsEqualityComparer() ); " is 144.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.HostSecurityManagerOptions? ).TypeHandle' new NullableSystem_Security_HostSecurityManagerOptionsEqualityComparer() ); " is 153.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.PolicyLevelType ).TypeHandle' new System_Security_PolicyLevelTypeEqualityComparer() ); " is 122.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.PolicyLevelType? ).TypeHandle' new NullableSystem_Security_PolicyLevelTypeEqualityComparer() ); " is 131.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.SecurityZone? ).TypeHandle' new NullableSystem_Security_SecurityZoneEqualityComparer() ); " is 125.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.AccessControlActions ).TypeHandle' new System_Security_AccessControl_AccessControlActionsEqualityComparer() ); " is 160.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.AccessControlActions? ).TypeHandle' new NullableSystem_Security_AccessControl_AccessControlActionsEqualityComparer() ); " is 169.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.AccessControlModification ).TypeHandle' new System_Security_AccessControl_AccessControlModificationEqualityComparer() ); " is 170.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.AccessControlModification? ).TypeHandle' new NullableSystem_Security_AccessControl_AccessControlModificationEqualityComparer() ); " is 179.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.AccessControlSections ).TypeHandle' new System_Security_AccessControl_AccessControlSectionsEqualityComparer() ); " is 162.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.AccessControlSections? ).TypeHandle' new NullableSystem_Security_AccessControl_AccessControlSectionsEqualityComparer() ); " is 171.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.AccessControlType ).TypeHandle' new System_Security_AccessControl_AccessControlTypeEqualityComparer() ); " is 154.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.AccessControlType? ).TypeHandle' new NullableSystem_Security_AccessControl_AccessControlTypeEqualityComparer() ); " is 163.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.AceFlags ).TypeHandle' new System_Security_AccessControl_AceFlagsEqualityComparer() ); " is 136.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.AceFlags? ).TypeHandle' new NullableSystem_Security_AccessControl_AceFlagsEqualityComparer() ); " is 145.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.AceQualifier ).TypeHandle' new System_Security_AccessControl_AceQualifierEqualityComparer() ); " is 144.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.AceQualifier? ).TypeHandle' new NullableSystem_Security_AccessControl_AceQualifierEqualityComparer() ); " is 153.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.AceType ).TypeHandle' new System_Security_AccessControl_AceTypeEqualityComparer() ); " is 134.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.AceType? ).TypeHandle' new NullableSystem_Security_AccessControl_AceTypeEqualityComparer() ); " is 143.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.AuditFlags ).TypeHandle' new System_Security_AccessControl_AuditFlagsEqualityComparer() ); " is 140.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.AuditFlags? ).TypeHandle' new NullableSystem_Security_AccessControl_AuditFlagsEqualityComparer() ); " is 149.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.CompoundAceType ).TypeHandle' new System_Security_AccessControl_CompoundAceTypeEqualityComparer() ); " is 150.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.CompoundAceType? ).TypeHandle' new NullableSystem_Security_AccessControl_CompoundAceTypeEqualityComparer() ); " is 159.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.ControlFlags ).TypeHandle' new System_Security_AccessControl_ControlFlagsEqualityComparer() ); " is 144.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.ControlFlags? ).TypeHandle' new NullableSystem_Security_AccessControl_ControlFlagsEqualityComparer() ); " is 153.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.CryptoKeyRights ).TypeHandle' new System_Security_AccessControl_CryptoKeyRightsEqualityComparer() ); " is 150.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.CryptoKeyRights? ).TypeHandle' new NullableSystem_Security_AccessControl_CryptoKeyRightsEqualityComparer() ); " is 159.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.EventWaitHandleRights ).TypeHandle' new System_Security_AccessControl_EventWaitHandleRightsEqualityComparer() ); " is 162.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.EventWaitHandleRights? ).TypeHandle' new NullableSystem_Security_AccessControl_EventWaitHandleRightsEqualityComparer() ); " is 171.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.FileSystemRights ).TypeHandle' new System_Security_AccessControl_FileSystemRightsEqualityComparer() ); " is 152.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.FileSystemRights? ).TypeHandle' new NullableSystem_Security_AccessControl_FileSystemRightsEqualityComparer() ); " is 161.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.InheritanceFlags ).TypeHandle' new System_Security_AccessControl_InheritanceFlagsEqualityComparer() ); " is 152.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.InheritanceFlags? ).TypeHandle' new NullableSystem_Security_AccessControl_InheritanceFlagsEqualityComparer() ); " is 161.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.MutexRights ).TypeHandle' new System_Security_AccessControl_MutexRightsEqualityComparer() ); " is 142.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.MutexRights? ).TypeHandle' new NullableSystem_Security_AccessControl_MutexRightsEqualityComparer() ); " is 151.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.ObjectAceFlags ).TypeHandle' new System_Security_AccessControl_ObjectAceFlagsEqualityComparer() ); " is 148.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.ObjectAceFlags? ).TypeHandle' new NullableSystem_Security_AccessControl_ObjectAceFlagsEqualityComparer() ); " is 157.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.PropagationFlags ).TypeHandle' new System_Security_AccessControl_PropagationFlagsEqualityComparer() ); " is 152.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.PropagationFlags? ).TypeHandle' new NullableSystem_Security_AccessControl_PropagationFlagsEqualityComparer() ); " is 161.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.RegistryRights ).TypeHandle' new System_Security_AccessControl_RegistryRightsEqualityComparer() ); " is 148.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.RegistryRights? ).TypeHandle' new NullableSystem_Security_AccessControl_RegistryRightsEqualityComparer() ); " is 157.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.ResourceType ).TypeHandle' new System_Security_AccessControl_ResourceTypeEqualityComparer() ); " is 144.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.ResourceType? ).TypeHandle' new NullableSystem_Security_AccessControl_ResourceTypeEqualityComparer() ); " is 153.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.SecurityInfos ).TypeHandle' new System_Security_AccessControl_SecurityInfosEqualityComparer() ); " is 146.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.AccessControl.SecurityInfos? ).TypeHandle' new NullableSystem_Security_AccessControl_SecurityInfosEqualityComparer() ); " is 155.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Cryptography.CipherMode ).TypeHandle' new System_Security_Cryptography_CipherModeEqualityComparer() ); " is 138.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Cryptography.CipherMode? ).TypeHandle' new NullableSystem_Security_Cryptography_CipherModeEqualityComparer() ); " is 147.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Cryptography.CryptoStreamMode ).TypeHandle' new System_Security_Cryptography_CryptoStreamModeEqualityComparer() ); " is 150.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Cryptography.CryptoStreamMode? ).TypeHandle' new NullableSystem_Security_Cryptography_CryptoStreamModeEqualityComparer() ); " is 159.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Cryptography.CspProviderFlags ).TypeHandle' new System_Security_Cryptography_CspProviderFlagsEqualityComparer() ); " is 150.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Cryptography.CspProviderFlags? ).TypeHandle' new NullableSystem_Security_Cryptography_CspProviderFlagsEqualityComparer() ); " is 159.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Cryptography.DSAParameters ).TypeHandle' new System_Security_Cryptography_DSAParametersEqualityComparer() ); " is 144.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Cryptography.DSAParameters? ).TypeHandle' new NullableSystem_Security_Cryptography_DSAParametersEqualityComparer() ); " is 153.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Cryptography.FromBase64TransformMode ).TypeHandle' new System_Security_Cryptography_FromBase64TransformModeEqualityComparer() ); " is 164.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Cryptography.FromBase64TransformMode? ).TypeHandle' new NullableSystem_Security_Cryptography_FromBase64TransformModeEqualityComparer() ); " is 173.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Cryptography.KeyNumber ).TypeHandle' new System_Security_Cryptography_KeyNumberEqualityComparer() ); " is 136.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Cryptography.KeyNumber? ).TypeHandle' new NullableSystem_Security_Cryptography_KeyNumberEqualityComparer() ); " is 145.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Cryptography.PaddingMode ).TypeHandle' new System_Security_Cryptography_PaddingModeEqualityComparer() ); " is 140.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Cryptography.PaddingMode? ).TypeHandle' new NullableSystem_Security_Cryptography_PaddingModeEqualityComparer() ); " is 149.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Cryptography.RSAParameters ).TypeHandle' new System_Security_Cryptography_RSAParametersEqualityComparer() ); " is 144.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Cryptography.RSAParameters? ).TypeHandle' new NullableSystem_Security_Cryptography_RSAParametersEqualityComparer() ); " is 153.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Cryptography.X509Certificates.X509ContentType ).TypeHandle' new System_Security_Cryptography_X509Certificates_X509ContentTypeEqualityComparer() ); " is 182.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Cryptography.X509Certificates.X509ContentType? ).TypeHandle' new NullableSystem_Security_Cryptography_X509Certificates_X509ContentTypeEqualityComparer() ); " is 191.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Cryptography.X509Certificates.X509KeyStorageFlags ).TypeHandle' new System_Security_Cryptography_X509Certificates_X509KeyStorageFlagsEqualityComparer() ); " is 190.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Cryptography.X509Certificates.X509KeyStorageFlags? ).TypeHandle' new NullableSystem_Security_Cryptography_X509Certificates_X509KeyStorageFlagsEqualityComparer() ); " is 199.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Policy.ApplicationVersionMatch ).TypeHandle' new System_Security_Policy_ApplicationVersionMatchEqualityComparer() ); " is 152.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Policy.ApplicationVersionMatch? ).TypeHandle' new NullableSystem_Security_Policy_ApplicationVersionMatchEqualityComparer() ); " is 161.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Policy.PolicyStatementAttribute ).TypeHandle' new System_Security_Policy_PolicyStatementAttributeEqualityComparer() ); " is 154.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Policy.PolicyStatementAttribute? ).TypeHandle' new NullableSystem_Security_Policy_PolicyStatementAttributeEqualityComparer() ); " is 163.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Policy.TrustManagerUIContext ).TypeHandle' new System_Security_Policy_TrustManagerUIContextEqualityComparer() ); " is 148.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Policy.TrustManagerUIContext? ).TypeHandle' new NullableSystem_Security_Policy_TrustManagerUIContextEqualityComparer() ); " is 157.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Principal.PrincipalPolicy ).TypeHandle' new System_Security_Principal_PrincipalPolicyEqualityComparer() ); " is 142.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Principal.PrincipalPolicy? ).TypeHandle' new NullableSystem_Security_Principal_PrincipalPolicyEqualityComparer() ); " is 151.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Principal.TokenAccessLevels ).TypeHandle' new System_Security_Principal_TokenAccessLevelsEqualityComparer() ); " is 146.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Principal.TokenAccessLevels? ).TypeHandle' new NullableSystem_Security_Principal_TokenAccessLevelsEqualityComparer() ); " is 155.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Principal.TokenImpersonationLevel ).TypeHandle' new System_Security_Principal_TokenImpersonationLevelEqualityComparer() ); " is 158.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Principal.TokenImpersonationLevel? ).TypeHandle' new NullableSystem_Security_Principal_TokenImpersonationLevelEqualityComparer() ); " is 167.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Principal.WellKnownSidType ).TypeHandle' new System_Security_Principal_WellKnownSidTypeEqualityComparer() ); " is 144.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Principal.WellKnownSidType? ).TypeHandle' new NullableSystem_Security_Principal_WellKnownSidTypeEqualityComparer() ); " is 153.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Principal.WindowsAccountType ).TypeHandle' new System_Security_Principal_WindowsAccountTypeEqualityComparer() ); " is 148.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Principal.WindowsAccountType? ).TypeHandle' new NullableSystem_Security_Principal_WindowsAccountTypeEqualityComparer() ); " is 157.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Principal.WindowsBuiltInRole ).TypeHandle' new System_Security_Principal_WindowsBuiltInRoleEqualityComparer() ); " is 148.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Security.Principal.WindowsBuiltInRole? ).TypeHandle' new NullableSystem_Security_Principal_WindowsBuiltInRoleEqualityComparer() ); " is 157.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Text.NormalizationForm? ).TypeHandle' new NullableSystem_Text_NormalizationFormEqualityComparer() ); " is 127.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Threading.ApartmentState ).TypeHandle' new System_Threading_ApartmentStateEqualityComparer() ); " is 122.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Threading.ApartmentState? ).TypeHandle' new NullableSystem_Threading_ApartmentStateEqualityComparer() ); " is 131.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Threading.AsyncFlowControl ).TypeHandle' new System_Threading_AsyncFlowControlEqualityComparer() ); " is 126.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Threading.AsyncFlowControl? ).TypeHandle' new NullableSystem_Threading_AsyncFlowControlEqualityComparer() ); " is 135.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Threading.EventResetMode ).TypeHandle' new System_Threading_EventResetModeEqualityComparer() ); " is 122.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Threading.EventResetMode? ).TypeHandle' new NullableSystem_Threading_EventResetModeEqualityComparer() ); " is 131.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Threading.LockCookie? ).TypeHandle' new NullableSystem_Threading_LockCookieEqualityComparer() ); " is 123.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Threading.LockRecursionPolicy ).TypeHandle' new System_Threading_LockRecursionPolicyEqualityComparer() ); " is 132.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Threading.LockRecursionPolicy? ).TypeHandle' new NullableSystem_Threading_LockRecursionPolicyEqualityComparer() ); " is 141.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Threading.NativeOverlapped ).TypeHandle' new System_Threading_NativeOverlappedEqualityComparer() ); " is 126.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Threading.NativeOverlapped? ).TypeHandle' new NullableSystem_Threading_NativeOverlappedEqualityComparer() ); " is 135.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Threading.ThreadPriority ).TypeHandle' new System_Threading_ThreadPriorityEqualityComparer() ); " is 122.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Threading.ThreadPriority? ).TypeHandle' new NullableSystem_Threading_ThreadPriorityEqualityComparer() ); " is 131.
Long Statement,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The length of the statement  "			result.Add( typeof( System.Threading.ThreadState? ).TypeHandle' new NullableSystem_Threading_ThreadStateEqualityComparer() ); " is 125.
Long Statement,MsgPack.Serialization,TraceSource,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Tracer.cs,TraceEvent,The length of the statement  "			Debug.WriteLine( String.Format( CultureInfo.InvariantCulture' "{0} {1}: {2} : {3}"' this._name' eventType' id' String.Format( CultureInfo.InvariantCulture' format' args ) ) ); " is 175.
Long Statement,MsgPack.Serialization,TraceSource,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Tracer.cs,TraceData,The length of the statement  "			Debug.WriteLine( String.Format( CultureInfo.InvariantCulture' "{0} {1}: {2} : {3}"' this._name' eventType' id' data ) ); " is 120.
Long Statement,MsgPack.Serialization,DefaultConcreteTypeRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultConcreteTypeRepository.cs,GetConcreteType,The length of the statement  "			if ( typeOrDefinition == null || !typeOrDefinition.GetIsGenericTypeDefinition() || !abstractCollectionType.GetIsGenericType() ) " is 127.
Long Statement,MsgPack.Serialization,DefaultConcreteTypeRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultConcreteTypeRepository.cs,Register,The length of the statement  "					String.Format( CultureInfo.CurrentCulture' "The defaultCollectionType cannot be abstract class nor interface. The type '{0}' is abstract type."' defaultCollectionType )' " is 169.
Long Statement,MsgPack.Serialization,DefaultConcreteTypeRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultConcreteTypeRepository.cs,Register,The length of the statement  "			this._defaultCollectionTypes.Register( abstractCollectionType' defaultCollectionType' null' null' SerializerRegistrationOptions.AllowOverride ); " is 144.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,Create,The length of the statement  "			// Old Create behavior was effectively Get() because the Builder internally register genreated serializer and returned existent one if it had been already registered.  " is 166.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateInternal,The length of the statement  "				typeof( T ).GetCollectionTraits( CollectionTraitOptions.None' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes ); " is 127.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateInternal,The length of the statement  "				typeof( T ).GetCollectionTraits( CollectionTraitOptions.Full' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes ); " is 127.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateInternal,The length of the statement  "						GenericSerializer.TryCreateAbstractCollectionSerializer( context' typeof( T )' concreteType' schema ) as MessagePackSerializer<T> " is 129.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateInternal,The length of the statement  "			return ( MessagePackSerializer<T> ) builder.BuildSerializerInstance( context' concreteType' schema == null ? null : schema.FilterSelf() ); " is 138.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateInternal,The length of the statement  "				( CreateInternal_2.MakeGenericMethod( targetType ).CreateDelegate( typeof( Func<SerializationContext' PolymorphismSchema' object> ) )  " is 133.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateReflectionInternal,The length of the statement  "				typeof( T ).GetCollectionTraits( CollectionTraitOptions.WithAddMethod' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes ); " is 136.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateReflectionInternal,The length of the statement  "				typeof( T ).GetCollectionTraits( CollectionTraitOptions.WithAddMethod | CollectionTraitOptions.WithCountPropertyGetter' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes ); " is 185.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateReflectionInternal,The length of the statement  "						ReflectionSerializerHelper.CreateCollectionSerializer<T>( context' concreteType' traits' ( schema ?? PolymorphismSchema.Default ) ); " is 132.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateReflectionInternal,The length of the statement  "							ReflectionSerializerHelper.CreateCollectionSerializer<T>( context' concreteType' traits' ( schema ?? PolymorphismSchema.Default ) ) " is 131.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,InferCapatibity,The length of the statement  "			var traits = typeof( T ).GetCollectionTraits( CollectionTraitOptions.WithAddMethod' allowNonCollectionEnumerableTypes: false ); " is 127.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,PackSingleObjectAsBytes,The length of the statement  "			var packer = Packer.Create( BufferManager.NewByteBuffer( BufferSize )' /* allowExpansion */true' this.PackerCompatibilityOptions ); " is 131.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,InternalPackTo,The length of the statement  "					ThrowArgumentException( String.Format( CultureInfo.CurrentCulture' "'{0}' is not compatible for '{1}'."' objectTree.GetType()' typeof( T ) )' "objectTree" ); " is 157.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,InternalUnpackTo,The length of the statement  "				ThrowArgumentException( String.Format( CultureInfo.CurrentCulture' "'{0}' is not compatible for '{1}'."' collection.GetType()' typeof( T ) )' "collection" ); " is 157.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,InternalPackSingleObject,The length of the statement  "				ThrowArgumentException( String.Format( CultureInfo.CurrentCulture' "'{0}' is not compatible for '{1}'."' objectTree == null ? "(null)" : objectTree.GetType().FullName' typeof( T ) )' "objectTree" ); " is 198.
Long Statement,MsgPack.Serialization,PackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PackHelpers.cs,PackToMap,The length of the statement  "				&& parameter.SerializationContext != null && parameter.SerializationContext.DictionarySerlaizationOptions.OmitNullEntry ) " is 121.
Long Statement,MsgPack.Serialization,PolymorphicTypeVerificationContext,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphicTypeVerificationContext.cs,Equals,The length of the statement  "			return this._loadingTypeFullName == other._loadingTypeFullName && this._loadingAssemblyFullName == other._loadingAssemblyFullName; " is 130.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,ForPolymorphicObject,The length of the statement  "			return new PolymorphismSchema( targetType' PolymorphismType.RuntimeType' DefaultTypeVerfiier' PolymorphismSchemaChildrenType.None ); " is 132.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,ForPolymorphicObject,The length of the statement  "			return new PolymorphismSchema( targetType' PolymorphismType.RuntimeType' typeVerifier' PolymorphismSchemaChildrenType.None ); " is 125.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,FilterSelf,The length of the statement  "			return new PolymorphismSchema( this.TargetType' PolymorphismType.None' this._codeTypeMapping' this.TypeVerifier' this.ChildrenType' this._children ); " is 149.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,CreateCore,The length of the statement  "			var traits = member.GetMemberValueType().GetCollectionTraits( CollectionTraitOptions.None' allowNonCollectionEnumerableTypes: false ); " is 134.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,CreateCore,The length of the statement  "						SerializerDebugging.TracePolimorphicSchemaEvent( "Returns default because '{0}' does not have own nor items schema: {1}"' member' defaultSchema ); " is 146.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,CreateCore,The length of the statement  "						SerializerDebugging.TracePolimorphicSchemaEvent( "Returns default because '{0}' does not have own' keys' nor items schema: {1}"' member' defaultSchema ); " is 153.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,CreateCore,The length of the statement  "							SerializerDebugging.TracePolimorphicSchemaEvent( "Returns default because '{0}' does not have any tuple items schema: {1}"' member' defaultSchema ); " is 148.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,CreateCore,The length of the statement  "							SerializerDebugging.TracePolimorphicSchemaEvent( "Returns default because '{0}' does not have own schema: {1}"' member' defaultSchema ); " is 136.
Long Statement,MsgPack.Serialization,TypeTableEntry,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,Interpret,The length of the statement  "					Contract.Assert( attribute.Target == PolymorphismTarget.TupleItem' attribute.Target + " == PolymorphismTarget.TupleItem" ); " is 123.
Long Statement,MsgPack.Serialization,TypeTableEntry,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,Interpret,The length of the statement  "				this.SetRuntimeType( attribute.Target' memberName' tupleItemNumber' GetVerifier( attribute as IPolymorphicRuntimeTypeAttribute ) ); " is 131.
Long Statement,MsgPack.Serialization,TypeTableEntry,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,GetVerifier,The length of the statement  "				var method = attribute.VerifierType.GetRuntimeMethods().SingleOrDefault( m => IsVerificationMethod( m' attribute.VerifierMethodName ) ); " is 136.
Long Statement,MsgPack.Serialization,TypeTableEntry,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,GetVerifier,The length of the statement  "					throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "A public static or instance method named '{0}' with single parameter typed PolymorphicTypeVerificationContext in type '{1}'."' attribute.VerifierMethodName' attribute.VerifierMethodName ) ); " is 268.
Long Statement,MsgPack.Serialization,TypeTableEntry,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,GetVerifier,The length of the statement  "					return method.CreateDelegate( typeof( Func<PolymorphicTypeVerificationContext' bool> ) ) as Func<PolymorphicTypeVerificationContext' bool>; " is 139.
Long Statement,MsgPack.Serialization,TypeTableEntry,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,GetVerifier,The length of the statement  "					return method.CreateDelegate( typeof( Func<PolymorphicTypeVerificationContext' bool> )' Activator.CreateInstance( attribute.VerifierType ) ) as Func<PolymorphicTypeVerificationContext' bool>; " is 191.
Long Statement,MsgPack.Serialization,TypeTableEntry,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,IsVerificationMethod,The length of the statement  "				return parameters.Length == 1 && parameters[ 0 ].ParameterType.IsAssignableFrom( typeof( PolymorphicTypeVerificationContext ) ); " is 128.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,The length of the statement  "			 * If the object has single public method TEnumerator GetEnumerator() ( where TEnumerator implements IEnumerator<TItem>)' " is 120.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,The length of the statement  "			 * Else' if the object has single public method IEnumerator GetEnumerator()' then the object is considered as the collection of Object. " is 134.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,The length of the statement  "			 * First' if the object implements IDictionary<MessagePackObject'MessagePackObject>' then it is considered as MPO dictionary. " is 124.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,The length of the statement  "			 * Third' if the object implement SINGLE IDictionary<TKey'TValue> and multiple IEnumerable<T>' then it is considered as dictionary of TKey and TValue. " is 149.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,The length of the statement  "			 * Fourth' the object is considered as UNSERIALIZABLE member. This behavior similer to DataContract serialization behavor " is 120.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,TryCreateGenericCollectionTraits,The length of the statement  "						( source == typeof( IDictionary<MessagePackObject' MessagePackObject> ) || source.Implements( typeof( IDictionary<MessagePackObject' MessagePackObject> ) ) ) " is 157.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,TryCreateGenericCollectionTraits,The length of the statement  "						GetGetEnumeratorMethodFromEnumerableType( source' typeof( IEnumerable<KeyValuePair<MessagePackObject' MessagePackObject>> )' options )' " is 135.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,TryCreateGenericCollectionTraits,The length of the statement  "									: ( source == typeof( IReadOnlyList<MessagePackObject> ) || source.Implements( typeof( IReadOnlyList<MessagePackObject> ) ) ) " is 125.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,TryCreateGenericCollectionTraits,The length of the statement  "												: ( source == typeof( IReadOnlyCollection<MessagePackObject> ) || source.Implements( typeof( IReadOnlyCollection<MessagePackObject> ) ) ) " is 137.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetGetEnumeratorMethodFromElementType,The length of the statement  "			return FindInterfaceMethod( targetType' typeof( IEnumerable<> ).MakeGenericType( elementType )' "GetEnumerator"' ReflectionAbstractions.EmptyTypes ); " is 149.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,FindInterfaceMethod,The length of the statement  "				return targetType.FindInterfaces( ( type' _ ) => type == interfaceType' null ).Single().GetMethod( name' parameterTypes ); " is 122.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,FindInterfaceMethod,The length of the statement  "			int index = Array.FindIndex( map.InterfaceMethods' method => method.Name == name && method.GetParameters().Select( p => p.ParameterType ).SequenceEqual( parameterTypes ) ); " is 172.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,FindInterfaceMethod,The length of the statement  "			int index = map.InterfaceMethods.FindIndex( method => method.Name == name && method.GetParameters().Select( p => p.ParameterType ).SequenceEqual( parameterTypes ) ); " is 165.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,FindInterfaceMethod,The length of the statement  "				Contract.Assert( false' interfaceType + "::" + name + "(" + String.Join<Type>( "' "' parameterTypes ) + ") is not found in " + targetType ); " is 140.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,FindInterfaceMethod,The length of the statement  "				Contract.Assert( false' interfaceType + "::" + name + "(" + String.Join( "' "' parameterTypes.Select( t => t.ToString() ).ToArray() ) + ") is not found in " + targetType ); " is 172.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,FilterCollectionType,The length of the statement  "			return type.GetAssembly().Equals( typeof( Array ).GetAssembly() ) && ( type.Namespace == "System.Collections" || type.Namespace == "System.Collections.Generic" ); " is 162.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,FilterCollectionType,The length of the statement  "			return typeInfo.Assembly.Equals( typeof( Array ).GetTypeInfo().Assembly ) && ( type.Namespace == "System.Collections" || type.Namespace == "System.Collections.Generic" ); " is 170.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetMemberValueType,The length of the statement  "			Contract.Assert( typeof( MemberInfo ).IsAssignableFrom( typeof( Type ) )' "Type is assginable to MemberInfo on this platform' so should not step in this line." ); " is 162.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetMemberValueType,The length of the statement  "			Contract.Assert( typeof( Type ).IsAssignableFrom( typeof( TypeInfo ) )' "TypeInfo is assginable to Type on this platform' so should not step in this line." ); " is 158.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetMemberValueType,The length of the statement  "				throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "'{0}'({1}) is not field nor property."' source' source.GetType() ) ); " is 150.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,HoistUpInnerException,The length of the statement  "			var ctor = targetInvocationException.InnerException.GetType().GetConstructor( ExceptionConstructorWithInnerParameterTypes ); " is 124.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,HoistUpInnerException,The length of the statement  "				return ctor.Invoke( new object[] { targetInvocationException.InnerException.Message' targetInvocationException } ) as Exception; " is 128.
Long Statement,MsgPack.Serialization,ReflectionHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionHelpers.cs,GetMethod,The length of the statement  "						.Where( m => !m.IsGenericMethod && !m.IsStatic && m.GetParameters().Select( p => p.ParameterType ).SequenceEqual( parameterTypes ) ) " is 132.
Long Statement,MsgPack.Serialization,SerializationContext,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationContext.cs,GetSerializer,The length of the statement  "						Contract.Assert( typeof( T ).GetIsEnum()' typeof( T ) + " is not enum but generated serializer is ICustomizableEnumSerializer" ); " is 129.
Long Statement,MsgPack.Serialization,SerializationContext,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationContext.cs,GetSerializer,The length of the statement  "						Contract.Assert( !typeof( T ).GetIsEnum()' typeof( T ) + " is enum but generated serializer is not ICustomizableEnumSerializer : " + ( serializer == null ? "null" : serializer.GetType().FullName ) ); " is 199.
Long Statement,MsgPack.Serialization,SerializationContext,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationContext.cs,GetSerializer,The length of the statement  "					// If T is null and schema is not provided or default schema is provided' then exception will be thrown here from the new provider. " is 131.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewValueTypeCannotBeNull,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Member '{0}' of type '{1}' cannot be null because it is value type('{2}')."' name' declaringType' memberType ) ); " is 192.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewValueTypeCannotBeNull,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Cannot be null '{0}' type value."' type ) ); " is 123.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewTypeCannotDeserialize,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Cannot deserialize '{0}' type."' type ) ); " is 121.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewTypeCannotDeserialize,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Cannot deserialize member '{1}' of type '{0}'."' type' memberName )' inner ); " is 156.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewMissingItem,The length of the statement  "			return new InvalidMessagePackStreamException( String.Format( CultureInfo.CurrentCulture' "Items at index '{0}' is missing."' index ) ); " is 135.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewTargetDoesNotHavePublicDefaultConstructor,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Type '{0}' does not have default (parameterless) public constructor."' type ) ); " is 159.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewTargetDoesNotHavePublicDefaultConstructorNorInitialCapacity,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Type '{0}' does not have both of default (parameterless) public constructor and  public constructor with an Int32 parameter."' type ) ); " is 215.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewMissingAddMethod,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Type '{0}' does not have appropriate Add method."' type ) ); " is 139.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewNotSupportedBecauseCannotInstanciateAbstractType,The length of the statement  "			return new NotSupportedException( String.Format( CultureInfo.CurrentCulture' "This operation is not supported because '{0}' cannot be instanciated."' type ) ); " is 159.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewTupleCardinarityIsNotMatch,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "The length of array ({0}) does not match to tuple cardinality ({1})."' actualArrayLength' expectedTupleCardinality ) ); " is 198.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewNullIsProhibited,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "The member '{0}' cannot be nil."' memberName ) ); " is 128.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewReadOnlyMemberItemsMustNotBeNull,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "The member '{0}' cannot be nil because it is read only member."' memberName ) ); " is 159.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewStreamDoesNotContainCollectionForMember,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Cannot deserialize member '{0}' because the underlying stream does not contain collection."' memberName ) ); " is 187.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewUnexpectedArrayLength,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "The MessagePack stream is invalid. Expected array length is {0}' but actual is {1}."' expectedLength' actualLength ) ); " is 198.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewFailedToDeserializeMember,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Cannot deserialize member '{0}' of type '{1}'."' memberName' targetType )' inner ); " is 162.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewUnpackFromIsNotSupported,The length of the statement  "			return new NotSupportedException( String.Format( CultureInfo.CurrentCulture' "This operation is not supported for '{0}' because the serializer does not support UnpackFrom method."' targetType ) ); " is 196.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewCreateInstanceIsNotSupported,The length of the statement  "			return new NotSupportedException( String.Format( CultureInfo.CurrentCulture' "This operation is not supported for '{0}' because the serializer does not support CreateInstance method."' targetType ) ); " is 200.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewUnpackToIsNotSupported,The length of the statement  "			return new NotSupportedException( String.Format( CultureInfo.CurrentCulture' "This operation is not supported for '{0}' because it does not have accesible Add(T) method."' type )' inner ); " is 188.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewUnknownTypeEmbedding,The length of the statement  "			return new SerializationException( "Cannot deserialize with type-embedding based serializer. Root object must be 3 element array." ); " is 133.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewIncompatibleCollectionSerializer,The length of the statement  "						"Cannot serialize type '{0}' because registered or generated serializer '{1}' does not implement '{2}'' which is implemented by '{3}'' for example."' " is 149.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,ThrowArgumentNullException,The length of the statement  "			throw new ArgumentNullException( parameterName' String.Format( CultureInfo.CurrentCulture' "Field '{0}' of parameter '{1}' cannot be null."' fieldName' parameterName ) ); " is 170.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,ThrowArgumentCannotBeNegativeException,The length of the statement  "			throw new ArgumentOutOfRangeException( parameterName' String.Format( CultureInfo.CurrentCulture' "Field '{0}' of parameter '{1}' cannot be negative number."' fieldName' parameterName ) ); " is 187.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,ThrowInvalidArrayItemsCount,The length of the statement  "							"Cannot deserialize type '{0}' because stream is not {1} elements array. Current type is {2} and its element count is {3}."' " is 124.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,GetCapabilitiesForObject,The length of the statement  "			return this.CanDeserialize ? ( SerializerCapabilities.PackTo | SerializerCapabilities.UnpackFrom ) : SerializerCapabilities.PackTo; " is 131.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,VerifyCanSerializeTargetType,The length of the statement  "			if ( context.SerializerOptions.DisablePrivilegedAccess && !targetType.GetIsPublic() && !targetType.GetIsNestedPublic() && !ThisAssembly.Equals( targetType.GetAssembly() ) ) " is 172.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,VerifyCanSerializeTargetType,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "Cannot serialize type '{0}' because it is not public to the serializer."' targetType ) ); " is 167.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,Prepare,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "Cannot serialize type '{0}' because it does not have any serializable fields nor properties."' targetType ) ); " is 188.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,Prepare,The length of the statement  "						// For backward compatibility' no exceptions are thrown here even if mulitiple deserialization constructor attributes in the type " is 129.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,Prepare,The length of the statement  "						canDeserialize ?? DetermineCanDeserialize( constructorKind' context' targetType' correspondingMemberNames' allowDefault: true ) " is 127.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,DetermineCanDeserialize,The length of the statement  "					Trace( "SerializationTarget::DetermineCanDeserialize({0}' {1}) -> {2}: HasAnyCorrespondingMembers"' targetType' kind' result ); " is 127.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,DetermineCanDeserialize,The length of the statement  "					Contract.Assert( kind == ConstructorKind.None || kind == ConstructorKind.Ambiguous' "kind == ConstructorKind.None || kind == ConstructorKind.Ambiguous : " + kind ); " is 164.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,GetTargetMembers,The length of the statement  "			var filtered = members.Where( item => item.GetCustomAttributesData().Any( a => a.GetAttributeType().FullName == MessagePackMemberAttributeTypeName ) ).ToArray(); " is 161.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,GetAnnotatedMembersWithDuplicationDetection,The length of the statement  "					member => member.GetCustomAttributesData().Any( a => a.GetAttributeType().FullName == MessagePackIgnoreAttributeTypeName ) " is 122.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,GetSystemRuntimeSerializationCompatibleMembers,The length of the statement  "								// Shim for Silverlight returns -1 because GetNamedArguments() extension method cannot recognize whether the argument was actually specified or not. " is 148.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,FindDeserializationConstructor,The length of the statement  "			Trace( "SerializationTarget::FindDeserializationConstructor.MostRich({0}) -> {1}"' targetType' String.Join( ";"' mostRichConstructors.Select( x => x.ToString() ).ToArray() ) ); " is 176.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,FindDeserializationConstructor,The length of the statement  "								"Cannot serialize type '{0}' because it does not have any serializable fields nor properties' and serializer generator failed to determine constructor to deserialize among({1})."' " is 179.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,FindExplicitDeserializationConstructors,The length of the statement  "			return construtors.Where( ctor => ctor.GetCustomAttributesData().Any( a => a.GetAttributeType().FullName == MessagePackDeserializationConstructorAttributeTypeName ) ).ToArray(); " is 177.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,NewTypeCannotBeSerializedException,The length of the statement  "						"Cannot serialize type '{0}' because it does not have any serializable fields nor properties' and it does not have any public constructors with parameters."' " is 157.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,CheckTargetEligibility,The length of the statement  "			var traits = returnType.GetCollectionTraits( CollectionTraitOptions.WithAddMethod' allowNonCollectionEnumerableTypes: false ); " is 126.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,ComplementMembers,The length of the statement  "					"Cannot specify order value 0 on DataMemberAttribute when SerializationContext.CompatibilityOptions.OneBoundDataMemberOrder is set to true." " is 140.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,VerifyKeyUniqueness,The length of the statement  "						duplicated.Add( member.Contract.Name' new List<MemberInfo> { existents[ member.Contract.Name ].Member' member.Member } ); " is 121.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,VerifyKeyUniqueness,The length of the statement  "									String.Join( "'"' kv.Value.Select( m => String.Format( CultureInfo.InvariantCulture' "{0}.{1}({2})"' m.DeclaringType' m.Name' ( m is FieldInfo ) ? "Field" : "Property" ) ).ToArray() ) " is 183.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,CreateForTuple,The length of the statement  "			return new SerializationTarget( itemTypes.Select( ( _' i ) => new SerializingMember( GetTupleItemNameFromIndex( i ) ) ).ToArray()' null' null' true ); " is 150.
Long Statement,MsgPack.Serialization,MemberConstructorParameterEqualityComparer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,GetHashCode,The length of the statement  "				return ( obj.Key == null ? 0 : StringComparer.OrdinalIgnoreCase.GetHashCode( obj.Key ) ) ^ ( obj.Value == null ? 0 : obj.Value.GetHashCode() ); " is 143.
Long Statement,MsgPack.Serialization,SerializerDebugging,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerDebugging.cs,TracePolimorphicSchemaEvent,The length of the statement  "			Tracer.Emit.TraceEvent( Tracer.EventType.PolimorphicSchema' Tracer.EventId.PolimorphicSchema' format' memberInfo' schema == null ? "(null)" : schema.DebugString ); " is 163.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,Register,The length of the statement  "				GetNullableCompanion( typeof( T )' serializer.OwnerContext' serializer' out nullableType' out nullableSerializerProvider ); " is 123.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,Register,The length of the statement  "			return this.Register( typeof( T )' new PolymorphicSerializerProvider<T>( serializer )' nullableType' nullableSerializerProvider' options ); " is 139.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,Register,The length of the statement  "			return this.Register( typeof( T )' new PolymorphicSerializerProvider<T>(  serializer.OwnerContext' serializer )' nullableType' nullableSerializerProvider' options ); " is 165.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( MessagePackObject ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.MsgPack_MessagePackObjectMessagePackSerializer( ownerContext ) ); " is 166.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( MessagePackObjectDictionary ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.MsgPack_MessagePackObjectDictionaryMessagePackSerializer( ownerContext ) ); " is 186.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( MessagePackExtendedTypeObject ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.MsgPack_MessagePackExtendedTypeObjectMessagePackSerializer( ownerContext ) ); " is 190.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( List<MessagePackObject> ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_ListOfMessagePackObjectMessagePackSerializer( ownerContext ) ); " is 197.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( Object ).TypeHandle' new MsgPack.Serialization.Polymorphic.PolymorphicSerializerProvider<object>( new MsgPack.Serialization.DefaultSerializers.System_ObjectMessagePackSerializer( ownerContext ) ) ); " is 222.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( Object ).TypeHandle' new MsgPack.Serialization.Polymorphic.PolymorphicSerializerProvider<object>( ownerContext' new MsgPack.Serialization.DefaultSerializers.System_ObjectMessagePackSerializer( ownerContext ) ) ); " is 236.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( String ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_StringMessagePackSerializer( ownerContext ) ); " is 143.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( StringBuilder ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Text_StringBuilderMessagePackSerializer( ownerContext ) ); " is 162.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( Char[] ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_CharArrayMessagePackSerializer( ownerContext ) ); " is 146.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( Byte[] ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_ByteArrayMessagePackSerializer( ownerContext ) ); " is 146.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( DateTime ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.DateTimeMessagePackSerializerProvider( ownerContext' false ) ); " is 155.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( DateTimeOffset ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.DateTimeOffsetMessagePackSerializerProvider( ownerContext' false ) ); " is 167.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( Timestamp ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.TimestampMessagePackSerializerProvider( ownerContext' false ) ); " is 157.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Runtime.InteropServices.ComTypes.FILETIME ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.FileTimeMessagePackSerializerProvider( ownerContext' false ) ); " is 195.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( DateTime? ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.DateTimeMessagePackSerializerProvider( ownerContext' true ) ); " is 155.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( DateTimeOffset? ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.DateTimeOffsetMessagePackSerializerProvider( ownerContext' true ) ); " is 167.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( Timestamp? ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.TimestampMessagePackSerializerProvider( ownerContext' true ) ); " is 157.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Runtime.InteropServices.ComTypes.FILETIME? ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.FileTimeMessagePackSerializerProvider( ownerContext' true ) ); " is 195.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( DBNull ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_DBNullMessagePackSerializer( ownerContext ) ); " is 143.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Boolean ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_BooleanMessagePackSerializer( ownerContext ) ); " is 152.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Byte ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_ByteMessagePackSerializer( ownerContext ) ); " is 146.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Char ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_CharMessagePackSerializer( ownerContext ) ); " is 146.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Decimal ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_DecimalMessagePackSerializer( ownerContext ) ); " is 152.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Double ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_DoubleMessagePackSerializer( ownerContext ) ); " is 150.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Guid ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_GuidMessagePackSerializer( ownerContext ) ); " is 146.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Int16 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Int16MessagePackSerializer( ownerContext ) ); " is 148.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Int32 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Int32MessagePackSerializer( ownerContext ) ); " is 148.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Int64 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Int64MessagePackSerializer( ownerContext ) ); " is 148.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.SByte ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_SByteMessagePackSerializer( ownerContext ) ); " is 148.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Single ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_SingleMessagePackSerializer( ownerContext ) ); " is 150.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.TimeSpan ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_TimeSpanMessagePackSerializer( ownerContext ) ); " is 154.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.UInt16 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_UInt16MessagePackSerializer( ownerContext ) ); " is 150.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.UInt32 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_UInt32MessagePackSerializer( ownerContext ) ); " is 150.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.UInt64 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_UInt64MessagePackSerializer( ownerContext ) ); " is 150.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Security.Cryptography.HashAlgorithmName ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Security_Cryptography_HashAlgorithmNameMessagePackSerializer( ownerContext ) ); " is 216.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.Specialized.BitVector32 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Collections_Specialized_BitVector32MessagePackSerializer( ownerContext ) ); " is 208.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.BigInteger ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_BigIntegerMessagePackSerializer( ownerContext ) ); " is 176.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Matrix3x2 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_Matrix3x2MessagePackSerializer( ownerContext ) ); " is 174.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Matrix4x4 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_Matrix4x4MessagePackSerializer( ownerContext ) ); " is 174.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Plane ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_PlaneMessagePackSerializer( ownerContext ) ); " is 166.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Quaternion ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_QuaternionMessagePackSerializer( ownerContext ) ); " is 176.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Vector2 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_Vector2MessagePackSerializer( ownerContext ) ); " is 170.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Vector3 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_Vector3MessagePackSerializer( ownerContext ) ); " is 170.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Vector4 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_Vector4MessagePackSerializer( ownerContext ) ); " is 170.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Globalization.CultureInfo ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Globalization_CultureInfoMessagePackSerializer( ownerContext ) ); " is 188.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.DictionaryEntry ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Collections_DictionaryEntryMessagePackSerializer( ownerContext ) ); " is 192.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.Stack ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Collections_StackMessagePackSerializer( ownerContext ) ); " is 172.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.Queue ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Collections_QueueMessagePackSerializer( ownerContext ) ); " is 172.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.Generic.KeyValuePair<'> ).TypeHandle' typeof( System_Collections_Generic_KeyValuePair_2MessagePackSerializer<' > ) ); " is 160.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.Generic.Stack<> ).TypeHandle' typeof( System_Collections_Generic_Stack_1MessagePackSerializer<> ) ); " is 143.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.Generic.Queue<> ).TypeHandle' typeof( System_Collections_Generic_Queue_1MessagePackSerializer<> ) ); " is 143.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Complex ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_ComplexMessagePackSerializer( ownerContext ) ); " is 170.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Uri ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_UriMessagePackSerializer( ownerContext ) ); " is 144.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Version ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_VersionMessagePackSerializer( ownerContext ) ); " is 152.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.Specialized.NameValueCollection ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Collections_Specialized_NameValueCollectionMessagePackSerializer( ownerContext ) ); " is 224.
Long Statement,MsgPack.Serialization,SerializingMember,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializingMember.cs,ToString,The length of the statement  "			return String.Format( CultureInfo.InvariantCulture' "{{\"Name\": \"{0}\"' \"Id\": {1}' \"Member\": \"{2}\"' \"NilImplication\": \"{3}\" }}"' this.MemberName' this.Contract.Id' this.MemberName' this.Contract.NilImplication ); " is 224.
Long Statement,MsgPack.Serialization,TypeKeyRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\TypeKeyRepository.cs,GetEntries,The length of the statement  "				return this._table.Select( kv => new KeyValuePair<Type' object>( Type.GetTypeFromHandle( kv.Key )' kv.Value ) ).ToArray(); " is 122.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The length of the statement  "						if ( currentScore < withCapacityAndComparer && parameters[ 0 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 1 ].ParameterType ) ) " is 151.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The length of the statement  "						else if ( currentScore < withComparerAndCapacity && parameters[ 1 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 0 ].ParameterType ) ) " is 156.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,GetEqualityComparer,The length of the statement  "			// AotHelper is internal because it should not be API -- it is subject to change when the Unity's Mono is updated or IL2CPP becomes stable. " is 139.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValue,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "directRead"' "directRead cannot be null if serializer argument is null." ); " is 124.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValue,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "parameter"' "DirectRead cannot be null if Serializer field is null." ); " is 120.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValue,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "directRead"' "directRead cannot be null if serializer argument is null." ); " is 124.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValue,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "parameter"' "DirectRead cannot be null if Serializer field is null." ); " is 120.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValue,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "directRead"' "directRead cannot be null if serializer argument is null." ); " is 124.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValue,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "parameter"' "DirectRead cannot be null if Serializer field is null." ); " is 120.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionCore,The length of the statement  "					SerializationExceptions.ThrowArgumentException( "eachOperation"' "eachOperation cannot not be null when bulkOperation is null." ); " is 130.
Long Statement,MsgPack.Serialization.DefaultSerializers,ArraySegmentMessageSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\ArraySegmentMessageSerializer.cs,PackCharArraySegmentTo,The length of the statement  "			packer.PackRawBody( MessagePackConvert.EncodeString( new string( objectTree.Array.Skip( objectTree.Offset ).Take( objectTree.Count ).ToArray() ) ) ); " is 149.
Long Statement,MsgPack.Serialization.DefaultSerializers,ArraySerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\ArraySerializer.cs,Create,The length of the statement  "			// Check the T is SZArray -- Type.GetArrayRank() returns 1 for single dimension' non-zero based arrays' so use (SZArrayType).IsAssinableFrom() instead. " is 151.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_BooleanMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Boolean )' ex.Message ) ); " is 163.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_ByteMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Byte )' ex.Message ) ); " is 160.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_CharMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex ); " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_CharMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex ); " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_DecimalMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex ); " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_DecimalMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex ); " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_DoubleMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Double )' ex.Message ) ); " is 162.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_GuidMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex ); " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_GuidMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex ); " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Int16MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Int16 )' ex.Message ) ); " is 161.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Int32MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Int32 )' ex.Message ) ); " is 161.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Int64MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Int64 )' ex.Message ) ); " is 161.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_SByteMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.SByte )' ex.Message ) ); " is 161.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_SingleMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Single )' ex.Message ) ); " is 162.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_TimeSpanMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Int64 )' ex.Message ) ); " is 161.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_UInt16MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.UInt16 )' ex.Message ) ); " is 162.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_UInt32MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.UInt32 )' ex.Message ) ); " is 162.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_UInt64MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.UInt64 )' ex.Message ) ); " is 162.
Long Statement,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,Create,The length of the statement  "					return CreateListSerializer( context' targetType' targetType.GetCollectionTraits( CollectionTraitOptions.WithAddMethod' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes )' schema ); " is 195.
Long Statement,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,Create,The length of the statement  "					return CreateDictionarySerializer( context' targetType' targetType.GetCollectionTraits( CollectionTraitOptions.WithAddMethod' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes )' genericTypeArguments[ 0 ]' genericTypeArguments[ 1 ]' schema ); " is 255.
Long Statement,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,CreateListSerializer,The length of the statement  "			return new System_Collections_Generic_List_1MessagePackSerializer( context' targetType' traits' ( schema ?? PolymorphismSchema.Default ).ItemSchema ); " is 150.
Long Statement,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,TryCreateAbstractCollectionSerializer,The length of the statement  "					abstractType.GetCollectionTraits( CollectionTraitOptions.None' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes ) " is 127.
Long Statement,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,TryCreateAbstractCollectionSerializer,The length of the statement  "					return new AbstractDictionaryMessagePackSerializer( context' abstractType' concreteType' genericArgumentOfKeyValuePair[ 0 ]' genericArgumentOfKeyValuePair[ 1 ]' traits' schema ); " is 178.
Long Statement,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,TryCreateAbstractCollectionSerializer,The length of the statement  "					return new AbstractDictionaryMessagePackSerializer( context' abstractType' concreteType' genericArgumentOfKeyValuePair[ 0 ]' genericArgumentOfKeyValuePair[ 1 ]' traits' schema ); " is 178.
Long Statement,MsgPack.Serialization.DefaultSerializers,MessagePackObjectExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MessagePackObjectExtensions.cs,DeserializeAsInt64,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex ); " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,MessagePackObjectExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MessagePackObjectExtensions.cs,DeserializeAsString,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex ); " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,MessagePackObjectExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MessagePackObjectExtensions.cs,DeserializeAsMessagePackExtendedTypeObject,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex ); " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,MsgPack_MessagePackExtendedTypeObjectMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MsgPack_MessagePackExtendedTypeObjectMessagePackSerializer.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex ); " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,UnityMultidimensionalArraySerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,PackArrayCore,The length of the statement  "				packer.PackExtendedTypeValue( this.OwnerContext.ExtTypeCodeMapping[ KnownExtTypeName.MultidimensionalArray ]' buffer.ToArray() ); " is 129.
Long Statement,MsgPack.Serialization.DefaultSerializers,UnityMultidimensionalArraySerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,UnpackFromCore,The length of the statement  "						SerializationExceptions.ThrowSerializationException( "Multidimensional metadata array must be encoded as 2 element array." ); " is 125.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_ObjectMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_ObjectMessagePackSerializer.cs,PackToCore,The length of the statement  "				// Prevents stack overflow -- System.Object cannot be serialized anyway because it does not have any properties/fields to serialize. " is 132.
Long Statement,MsgPack.Serialization.Polymorphic,RuntimeTypeVerifier,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\RuntimeTypeVerifier.cs,Verify,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "Type verifier rejects type '{0}'"' typeFullName + "' " + assemblyFullName ) ); " is 156.
Long Statement,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,ThrowUnknownEncodingType,The length of the statement  "			throw new SerializationException( String.Format( CultureInfo.InvariantCulture' "Unknown encoded type : {0}"' encodeType ) ); " is 124.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionEnumMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionEnumMessagePackSerializer`1.cs,PackUnderlyingValueTo,The length of the statement  "			packer.Pack( UInt64.Parse( ( ( IFormattable ) enumValue ).ToString( "D"' CultureInfo.InvariantCulture )' CultureInfo.InvariantCulture ) ); " is 138.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackMemberValue,The length of the statement  "					else if ( index < this._getters.Length && this._getters[ index ] != null ) // null getter supposes undeclared member (should be treated as nil) " is 143.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackAndAddCollectionItem,The length of the statement  "			var traits = destination.GetType().GetCollectionTraits( CollectionTraitOptions.WithAddMethod' this.OwnerContext.CompatibilityOptions.AllowNonCollectionEnumerableTypes ); " is 169.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,CreateCollectionSerializer,The length of the statement  "			var targetInfo = UnpackHelpers.DetermineCollectionSerializationStrategy( targetType' context.CompatibilityOptions.AllowAsymmetricSerializer ); " is 142.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,CreateCollectionSerializer,The length of the statement  "						new ReflectionNonGenericCollectionMessagePackSerializer( context' typeof( T )' targetType' traits' schema' targetInfo ); " is 120.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,CreateCollectionSerializer,The length of the statement  "						new ReflectionNonGenericEnumerableMessagePackSerializer( context' typeof( T )' targetType' traits' schema' targetInfo ); " is 120.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,CreateCollectionSerializer,The length of the statement  "						new ReflectionNonGenericDictionaryMessagePackSerializer( context' typeof( T )' targetType' traits' schema' targetInfo ); " is 120.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,GetAddItem,The length of the statement  "						"Reflection based serializer only supports collection types which implement interface to add new item such as '{0}' and '{1}'"' " is 127.
Long Statement,System.Runtime.CompilerServices,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The length of the statement  "						if ( currentScore < withCapacityAndComparer && parameters[ 0 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 1 ].ParameterType ) ) " is 151.
Long Statement,System.Runtime.CompilerServices,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The length of the statement  "						else if ( currentScore < withComparerAndCapacity && parameters[ 1 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 0 ].ParameterType ) ) " is 156.
Long Statement,System.Runtime.CompilerServices,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,GetEqualityComparer,The length of the statement  "			// AotHelper is internal because it should not be API -- it is subject to change when the Unity's Mono is updated or IL2CPP becomes stable. " is 139.
Complex Conditional,MsgPack,MessagePackStringDebuggerProxy,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,MustBeString,The conditional expression  "c < 0x20 && ( c != 0x9 && c != 0xA && c != 0xD )"  is complex.
Complex Conditional,MsgPack.Serialization,DefaultConcreteTypeRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultConcreteTypeRepository.cs,Register,The conditional expression  "!abstractCollectionType.IsAssignableFrom( defaultCollectionType )  				 && abstractCollectionType.GetIsGenericTypeDefinition()  				 && !defaultCollectionType  						 .GetInterfaces()  						 .Select( t => ( t.GetIsGenericType() && !t.GetIsGenericTypeDefinition() ) ? t.GetGenericTypeDefinition() : t )  						 .Contains( abstractCollectionType )  				 && !IsAnscestorType( abstractCollectionType' defaultCollectionType )"  is complex.
Complex Conditional,MsgPack.Serialization,MessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,InternalPackSingleObject,The conditional expression  "( typeof( T ).GetIsValueType() && !isT )  				|| ( ( objectTree != null && !isT ) )"  is complex.
Complex Conditional,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,VerifyCanSerializeTargetType,The conditional expression  "context.SerializerOptions.DisablePrivilegedAccess && !targetType.GetIsPublic() && !targetType.GetIsNestedPublic() && !ThisAssembly.Equals( targetType.GetAssembly() )"  is complex.
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt16,The following statement contains a magic number: unchecked  			{  				return ( short )( buffer[ offset ] << 8 | buffer[ 1 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt32,The following statement contains a magic number: unchecked  			{  				return buffer[ offset ] << 24 | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt32,The following statement contains a magic number: unchecked  			{  				return buffer[ offset ] << 24 | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt32,The following statement contains a magic number: unchecked  			{  				return buffer[ offset ] << 24 | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt32,The following statement contains a magic number: unchecked  			{  				return buffer[ offset ] << 24 | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt32,The following statement contains a magic number: unchecked  			{  				return buffer[ offset ] << 24 | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt16,The following statement contains a magic number: unchecked  			{  				return ( ushort )( ( buffer[ offset ] << 8 ) | buffer[ 1 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt32,The following statement contains a magic number: unchecked  			{  				return ( uint )( ( buffer[ offset ] << 24 ) | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt32,The following statement contains a magic number: unchecked  			{  				return ( uint )( ( buffer[ offset ] << 24 ) | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt32,The following statement contains a magic number: unchecked  			{  				return ( uint )( ( buffer[ offset ] << 24 ) | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt32,The following statement contains a magic number: unchecked  			{  				return ( uint )( ( buffer[ offset ] << 24 ) | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt32,The following statement contains a magic number: unchecked  			{  				return ( uint )( ( buffer[ offset ] << 24 ) | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToHexString,The following statement contains a magic number: var buffer = new StringBuilder( blob.Length * 2 + (withPrefix ? 2 : 0 ) );
Magic Number,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToHexString,The following statement contains a magic number: var buffer = new StringBuilder( blob.Length * 2 + (withPrefix ? 2 : 0 ) );
Magic Number,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToHexStringCore,The following statement contains a magic number: foreach ( var b in blob )  			{  				buffer.Append( ToHexChar( b >> 4 ) );  				buffer.Append( ToHexChar( b & 0xF ) );  			}
Magic Number,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToHexChar,The following statement contains a magic number: if ( b < 10 )  			{  				return unchecked( ( char )( '0' + b ) );  			}  			else  			{  				return unchecked( ( char )( 'A' + ( b - 10 ) ) );  			}
Magic Number,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToHexChar,The following statement contains a magic number: if ( b < 10 )  			{  				return unchecked( ( char )( '0' + b ) );  			}  			else  			{  				return unchecked( ( char )( 'A' + ( b - 10 ) ) );  			}
Magic Number,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToBits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				result = bits.Byte3 << 24;  				result |= bits.Byte2 << 16;  				result |= bits.Byte1 << 8;  				result |= bits.Byte0;  			}  			else  			{  				result = bits.Byte0 << 24;  				result |= bits.Byte1 << 16;  				result |= bits.Byte2 << 8;  				result |= bits.Byte3;  			}
Magic Number,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToBits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				result = bits.Byte3 << 24;  				result |= bits.Byte2 << 16;  				result |= bits.Byte1 << 8;  				result |= bits.Byte0;  			}  			else  			{  				result = bits.Byte0 << 24;  				result |= bits.Byte1 << 16;  				result |= bits.Byte2 << 8;  				result |= bits.Byte3;  			}
Magic Number,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToBits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				result = bits.Byte3 << 24;  				result |= bits.Byte2 << 16;  				result |= bits.Byte1 << 8;  				result |= bits.Byte0;  			}  			else  			{  				result = bits.Byte0 << 24;  				result |= bits.Byte1 << 16;  				result |= bits.Byte2 << 8;  				result |= bits.Byte3;  			}
Magic Number,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToBits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				result = bits.Byte3 << 24;  				result |= bits.Byte2 << 16;  				result |= bits.Byte1 << 8;  				result |= bits.Byte0;  			}  			else  			{  				result = bits.Byte0 << 24;  				result |= bits.Byte1 << 16;  				result |= bits.Byte2 << 8;  				result |= bits.Byte3;  			}
Magic Number,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToBits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				result = bits.Byte3 << 24;  				result |= bits.Byte2 << 16;  				result |= bits.Byte1 << 8;  				result |= bits.Byte0;  			}  			else  			{  				result = bits.Byte0 << 24;  				result |= bits.Byte1 << 16;  				result |= bits.Byte2 << 8;  				result |= bits.Byte3;  			}
Magic Number,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToBits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				result = bits.Byte3 << 24;  				result |= bits.Byte2 << 16;  				result |= bits.Byte1 << 8;  				result |= bits.Byte0;  			}  			else  			{  				result = bits.Byte0 << 24;  				result |= bits.Byte1 << 16;  				result |= bits.Byte2 << 8;  				result |= bits.Byte3;  			}
Magic Number,MsgPack,Float32Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float32Bits.cs,Float32Bits,The following statement contains a magic number: Contract.Assert( bigEndianBytes.Length - offset >= 4' bigEndianBytes.Length + "-" + offset + ">= 4" );
Magic Number,MsgPack,Float32Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float32Bits.cs,Float32Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 3 ];  				this.Byte1 = bigEndianBytes[ offset + 2 ];  				this.Byte2 = bigEndianBytes[ offset + 1 ];  				this.Byte3 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  			}
Magic Number,MsgPack,Float32Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float32Bits.cs,Float32Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 3 ];  				this.Byte1 = bigEndianBytes[ offset + 2 ];  				this.Byte2 = bigEndianBytes[ offset + 1 ];  				this.Byte3 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  			}
Magic Number,MsgPack,Float32Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float32Bits.cs,Float32Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 3 ];  				this.Byte1 = bigEndianBytes[ offset + 2 ];  				this.Byte2 = bigEndianBytes[ offset + 1 ];  				this.Byte3 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  			}
Magic Number,MsgPack,Float32Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float32Bits.cs,Float32Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 3 ];  				this.Byte1 = bigEndianBytes[ offset + 2 ];  				this.Byte2 = bigEndianBytes[ offset + 1 ];  				this.Byte3 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: Contract.Assert( bigEndianBytes.Length - offset >= 8' bigEndianBytes.Length + "-" + offset + ">= 4" );
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt1 );  						break;  					}  					case 2:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt2 );  						break;  					}  					case 4:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt4 );  						break;  					}  					case 8:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt8 );  						break;  					}  					case 16:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt16 );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length );  						}  						else  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt1 );  						break;  					}  					case 2:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt2 );  						break;  					}  					case 4:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt4 );  						break;  					}  					case 8:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt8 );  						break;  					}  					case 16:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt16 );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length );  						}  						else  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt1 );  						break;  					}  					case 2:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt2 );  						break;  					}  					case 4:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt4 );  						break;  					}  					case 8:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt8 );  						break;  					}  					case 16:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt16 );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length );  						}  						else  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt1 );  						break;  					}  					case 2:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt2 );  						break;  					}  					case 4:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt4 );  						break;  					}  					case 8:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt8 );  						break;  					}  					case 16:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt16 );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length );  						}  						else  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset ] = unchecked( ( byte )( value >> ( ( sizeof( byte ) - 1 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset ] = unchecked( ( byte )( value >> ( ( sizeof( ushort ) - 1 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( value >> ( ( sizeof( ushort ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( value >> ( ( sizeof( ushort ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 1 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 1 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 4 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 5 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 4 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 5 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 4 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 5 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 5 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 6 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 5 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 6 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 5 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 6 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 6 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 7 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 6 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 7 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 6 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 7 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 7 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 8 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 7 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 8 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 7 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 8 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 1 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 1 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 4 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 5 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 4 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 5 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 4 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 5 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 5 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 6 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 5 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 6 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 5 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 6 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 6 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 7 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 6 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 7 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 6 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 7 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 7 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 8 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 7 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 8 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 7 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 8 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadByteSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadSByteSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadInt16Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadUInt16Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadInt32Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadUInt32Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadInt64Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadUInt64Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadSingleSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadDoubleSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadBinary,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Raw16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Raw16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Raw16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Raw16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadString,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Raw16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Raw16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Raw16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Raw16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadArrayLength,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Array8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Array16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Array32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Array8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Array16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Array32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Array8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Array16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Array32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Array8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Array16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Array32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMapLength,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Map8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Map16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Map32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Map8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Map16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Map32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Map8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Map16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Map32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Map8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Map16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Map32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Ext16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Ext16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Ext16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Ext16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Ext16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Ext16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Ext16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Ext16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,ToString,The following statement contains a magic number: var buffer = new StringBuilder( 7 + this._body.Length * 2 );
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,ToString,The following statement contains a magic number: var buffer = new StringBuilder( 7 + this._body.Length * 2 );
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int hashCode = this._typeCode << 24;  				hashCode ^= this._body.Length;  				int hashCodeTargetLength = Math.Min( this._body.Length / 4' 8 );  				for ( int i = 0; i < hashCodeTargetLength; i++ )  				{  					uint temp = this._body[ i ];  					temp |= ( uint )( this._body[ i + 1 ] << 8 );  					temp |= ( uint )( this._body[ i + 2 ] << 16 );  					temp |= ( uint )( this._body[ i + 3 ] << 24 );    					hashCode ^= ( int )temp;  				}    				return hashCode;  			}
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int hashCode = this._typeCode << 24;  				hashCode ^= this._body.Length;  				int hashCodeTargetLength = Math.Min( this._body.Length / 4' 8 );  				for ( int i = 0; i < hashCodeTargetLength; i++ )  				{  					uint temp = this._body[ i ];  					temp |= ( uint )( this._body[ i + 1 ] << 8 );  					temp |= ( uint )( this._body[ i + 2 ] << 16 );  					temp |= ( uint )( this._body[ i + 3 ] << 24 );    					hashCode ^= ( int )temp;  				}    				return hashCode;  			}
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int hashCode = this._typeCode << 24;  				hashCode ^= this._body.Length;  				int hashCodeTargetLength = Math.Min( this._body.Length / 4' 8 );  				for ( int i = 0; i < hashCodeTargetLength; i++ )  				{  					uint temp = this._body[ i ];  					temp |= ( uint )( this._body[ i + 1 ] << 8 );  					temp |= ( uint )( this._body[ i + 2 ] << 16 );  					temp |= ( uint )( this._body[ i + 3 ] << 24 );    					hashCode ^= ( int )temp;  				}    				return hashCode;  			}
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int hashCode = this._typeCode << 24;  				hashCode ^= this._body.Length;  				int hashCodeTargetLength = Math.Min( this._body.Length / 4' 8 );  				for ( int i = 0; i < hashCodeTargetLength; i++ )  				{  					uint temp = this._body[ i ];  					temp |= ( uint )( this._body[ i + 1 ] << 8 );  					temp |= ( uint )( this._body[ i + 2 ] << 16 );  					temp |= ( uint )( this._body[ i + 3 ] << 24 );    					hashCode ^= ( int )temp;  				}    				return hashCode;  			}
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int hashCode = this._typeCode << 24;  				hashCode ^= this._body.Length;  				int hashCodeTargetLength = Math.Min( this._body.Length / 4' 8 );  				for ( int i = 0; i < hashCodeTargetLength; i++ )  				{  					uint temp = this._body[ i ];  					temp |= ( uint )( this._body[ i + 1 ] << 8 );  					temp |= ( uint )( this._body[ i + 2 ] << 16 );  					temp |= ( uint )( this._body[ i + 3 ] << 24 );    					hashCode ^= ( int )temp;  				}    				return hashCode;  			}
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int hashCode = this._typeCode << 24;  				hashCode ^= this._body.Length;  				int hashCodeTargetLength = Math.Min( this._body.Length / 4' 8 );  				for ( int i = 0; i < hashCodeTargetLength; i++ )  				{  					uint temp = this._body[ i ];  					temp |= ( uint )( this._body[ i + 1 ] << 8 );  					temp |= ( uint )( this._body[ i + 2 ] << 16 );  					temp |= ( uint )( this._body[ i + 3 ] << 24 );    					hashCode ^= ( int )temp;  				}    				return hashCode;  			}
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int hashCode = this._typeCode << 24;  				hashCode ^= this._body.Length;  				int hashCodeTargetLength = Math.Min( this._body.Length / 4' 8 );  				for ( int i = 0; i < hashCodeTargetLength; i++ )  				{  					uint temp = this._body[ i ];  					temp |= ( uint )( this._body[ i + 1 ] << 8 );  					temp |= ( uint )( this._body[ i + 2 ] << 16 );  					temp |= ( uint )( this._body[ i + 3 ] << 24 );    					hashCode ^= ( int )temp;  				}    				return hashCode;  			}
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int hashCode = this._typeCode << 24;  				hashCode ^= this._body.Length;  				int hashCodeTargetLength = Math.Min( this._body.Length / 4' 8 );  				for ( int i = 0; i < hashCodeTargetLength; i++ )  				{  					uint temp = this._body[ i ];  					temp |= ( uint )( this._body[ i + 1 ] << 8 );  					temp |= ( uint )( this._body[ i + 2 ] << 16 );  					temp |= ( uint )( this._body[ i + 3 ] << 24 );    					hashCode ^= ( int )temp;  				}    				return hashCode;  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: unchecked  			{  #pragma warning disable 0675  				if( BitConverter.IsLittleEndian )  				{  					this._value |=  ( ulong )( bytes[ 3 ] << 24 );  					this._value |=  ( ulong )( bytes[ 2 ] << 16 );  					this._value |=  ( ulong )( bytes[ 1 ] << 8 );  					this._value |=  bytes[ 0 ];  				}  				else  				{  					this._value |=  ( ulong )( bytes[ 0 ] << 24 );  					this._value |=  ( ulong )( bytes[ 1 ] << 16 );  					this._value |=  ( ulong )( bytes[ 2 ] << 8 );  					this._value |=  bytes[ 3 ];  				}  #pragma warning restore 0675  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: unchecked  			{  #pragma warning disable 0675  				if( BitConverter.IsLittleEndian )  				{  					this._value |=  ( ulong )( bytes[ 3 ] << 24 );  					this._value |=  ( ulong )( bytes[ 2 ] << 16 );  					this._value |=  ( ulong )( bytes[ 1 ] << 8 );  					this._value |=  bytes[ 0 ];  				}  				else  				{  					this._value |=  ( ulong )( bytes[ 0 ] << 24 );  					this._value |=  ( ulong )( bytes[ 1 ] << 16 );  					this._value |=  ( ulong )( bytes[ 2 ] << 8 );  					this._value |=  bytes[ 3 ];  				}  #pragma warning restore 0675  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: unchecked  			{  #pragma warning disable 0675  				if( BitConverter.IsLittleEndian )  				{  					this._value |=  ( ulong )( bytes[ 3 ] << 24 );  					this._value |=  ( ulong )( bytes[ 2 ] << 16 );  					this._value |=  ( ulong )( bytes[ 1 ] << 8 );  					this._value |=  bytes[ 0 ];  				}  				else  				{  					this._value |=  ( ulong )( bytes[ 0 ] << 24 );  					this._value |=  ( ulong )( bytes[ 1 ] << 16 );  					this._value |=  ( ulong )( bytes[ 2 ] << 8 );  					this._value |=  bytes[ 3 ];  				}  #pragma warning restore 0675  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: unchecked  			{  #pragma warning disable 0675  				if( BitConverter.IsLittleEndian )  				{  					this._value |=  ( ulong )( bytes[ 3 ] << 24 );  					this._value |=  ( ulong )( bytes[ 2 ] << 16 );  					this._value |=  ( ulong )( bytes[ 1 ] << 8 );  					this._value |=  bytes[ 0 ];  				}  				else  				{  					this._value |=  ( ulong )( bytes[ 0 ] << 24 );  					this._value |=  ( ulong )( bytes[ 1 ] << 16 );  					this._value |=  ( ulong )( bytes[ 2 ] << 8 );  					this._value |=  bytes[ 3 ];  				}  #pragma warning restore 0675  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: unchecked  			{  #pragma warning disable 0675  				if( BitConverter.IsLittleEndian )  				{  					this._value |=  ( ulong )( bytes[ 3 ] << 24 );  					this._value |=  ( ulong )( bytes[ 2 ] << 16 );  					this._value |=  ( ulong )( bytes[ 1 ] << 8 );  					this._value |=  bytes[ 0 ];  				}  				else  				{  					this._value |=  ( ulong )( bytes[ 0 ] << 24 );  					this._value |=  ( ulong )( bytes[ 1 ] << 16 );  					this._value |=  ( ulong )( bytes[ 2 ] << 8 );  					this._value |=  bytes[ 3 ];  				}  #pragma warning restore 0675  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: unchecked  			{  #pragma warning disable 0675  				if( BitConverter.IsLittleEndian )  				{  					this._value |=  ( ulong )( bytes[ 3 ] << 24 );  					this._value |=  ( ulong )( bytes[ 2 ] << 16 );  					this._value |=  ( ulong )( bytes[ 1 ] << 8 );  					this._value |=  bytes[ 0 ];  				}  				else  				{  					this._value |=  ( ulong )( bytes[ 0 ] << 24 );  					this._value |=  ( ulong )( bytes[ 1 ] << 16 );  					this._value |=  ( ulong )( bytes[ 2 ] << 8 );  					this._value |=  bytes[ 3 ];  				}  #pragma warning restore 0675  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: unchecked  			{  #pragma warning disable 0675  				if( BitConverter.IsLittleEndian )  				{  					this._value |=  ( ulong )( bytes[ 3 ] << 24 );  					this._value |=  ( ulong )( bytes[ 2 ] << 16 );  					this._value |=  ( ulong )( bytes[ 1 ] << 8 );  					this._value |=  bytes[ 0 ];  				}  				else  				{  					this._value |=  ( ulong )( bytes[ 0 ] << 24 );  					this._value |=  ( ulong )( bytes[ 1 ] << 16 );  					this._value |=  ( ulong )( bytes[ 2 ] << 8 );  					this._value |=  bytes[ 3 ];  				}  #pragma warning restore 0675  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: unchecked  			{  #pragma warning disable 0675  				if( BitConverter.IsLittleEndian )  				{  					this._value |=  ( ulong )( bytes[ 3 ] << 24 );  					this._value |=  ( ulong )( bytes[ 2 ] << 16 );  					this._value |=  ( ulong )( bytes[ 1 ] << 8 );  					this._value |=  bytes[ 0 ];  				}  				else  				{  					this._value |=  ( ulong )( bytes[ 0 ] << 24 );  					this._value |=  ( ulong )( bytes[ 1 ] << 16 );  					this._value |=  ( ulong )( bytes[ 2 ] << 8 );  					this._value |=  bytes[ 3 ];  				}  #pragma warning restore 0675  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: unchecked  			{  #pragma warning disable 0675  				if( BitConverter.IsLittleEndian )  				{  					this._value |=  ( ulong )( bytes[ 3 ] << 24 );  					this._value |=  ( ulong )( bytes[ 2 ] << 16 );  					this._value |=  ( ulong )( bytes[ 1 ] << 8 );  					this._value |=  bytes[ 0 ];  				}  				else  				{  					this._value |=  ( ulong )( bytes[ 0 ] << 24 );  					this._value |=  ( ulong )( bytes[ 1 ] << 16 );  					this._value |=  ( ulong )( bytes[ 2 ] << 8 );  					this._value |=  bytes[ 3 ];  				}  #pragma warning restore 0675  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: unchecked  			{  #pragma warning disable 0675  				if( BitConverter.IsLittleEndian )  				{  					this._value |=  ( ulong )( bytes[ 3 ] << 24 );  					this._value |=  ( ulong )( bytes[ 2 ] << 16 );  					this._value |=  ( ulong )( bytes[ 1 ] << 8 );  					this._value |=  bytes[ 0 ];  				}  				else  				{  					this._value |=  ( ulong )( bytes[ 0 ] << 24 );  					this._value |=  ( ulong )( bytes[ 1 ] << 16 );  					this._value |=  ( ulong )( bytes[ 2 ] << 8 );  					this._value |=  bytes[ 3 ];  				}  #pragma warning restore 0675  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,AsStringUtf16,The following statement contains a magic number: try  			{  				MessagePackString asMessagePackString = this._handleOrTypeCode as MessagePackString;  #if DEBUG  				Contract.Assert( asMessagePackString != null' "asMessagePackString != null" );  #endif // DEBUG    				if ( asMessagePackString.UnsafeGetString() != null )  				{  					return asMessagePackString.UnsafeGetString();  				}    				byte[] asBytes = asMessagePackString.UnsafeGetBuffer();    				if ( asBytes.Length == 0 )  				{  					return String.Empty;  				}    				if ( asBytes.Length % 2 != 0 )  				{  					throw new InvalidOperationException( "Not UTF-16 string." );  				}    				if ( asBytes[ 0 ] == 0xff && asBytes[ 1 ] == 0xfe )  				{  					return Encoding.Unicode.GetString( asBytes' 2' asBytes.Length - 2 );  				}  				else if ( asBytes[ 0 ] == 0xfe && asBytes[ 1 ] == 0xff )  				{  					return Encoding.BigEndianUnicode.GetString( asBytes' 2' asBytes.Length - 2 );  				}  				else  				{  					return Encoding.BigEndianUnicode.GetString( asBytes' 0' asBytes.Length );  				}  			}  			catch ( ArgumentException ex )  			{  				throw new InvalidOperationException( "Not UTF-16 string."' ex );  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,AsStringUtf16,The following statement contains a magic number: try  			{  				MessagePackString asMessagePackString = this._handleOrTypeCode as MessagePackString;  #if DEBUG  				Contract.Assert( asMessagePackString != null' "asMessagePackString != null" );  #endif // DEBUG    				if ( asMessagePackString.UnsafeGetString() != null )  				{  					return asMessagePackString.UnsafeGetString();  				}    				byte[] asBytes = asMessagePackString.UnsafeGetBuffer();    				if ( asBytes.Length == 0 )  				{  					return String.Empty;  				}    				if ( asBytes.Length % 2 != 0 )  				{  					throw new InvalidOperationException( "Not UTF-16 string." );  				}    				if ( asBytes[ 0 ] == 0xff && asBytes[ 1 ] == 0xfe )  				{  					return Encoding.Unicode.GetString( asBytes' 2' asBytes.Length - 2 );  				}  				else if ( asBytes[ 0 ] == 0xfe && asBytes[ 1 ] == 0xff )  				{  					return Encoding.BigEndianUnicode.GetString( asBytes' 2' asBytes.Length - 2 );  				}  				else  				{  					return Encoding.BigEndianUnicode.GetString( asBytes' 0' asBytes.Length );  				}  			}  			catch ( ArgumentException ex )  			{  				throw new InvalidOperationException( "Not UTF-16 string."' ex );  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,AsStringUtf16,The following statement contains a magic number: try  			{  				MessagePackString asMessagePackString = this._handleOrTypeCode as MessagePackString;  #if DEBUG  				Contract.Assert( asMessagePackString != null' "asMessagePackString != null" );  #endif // DEBUG    				if ( asMessagePackString.UnsafeGetString() != null )  				{  					return asMessagePackString.UnsafeGetString();  				}    				byte[] asBytes = asMessagePackString.UnsafeGetBuffer();    				if ( asBytes.Length == 0 )  				{  					return String.Empty;  				}    				if ( asBytes.Length % 2 != 0 )  				{  					throw new InvalidOperationException( "Not UTF-16 string." );  				}    				if ( asBytes[ 0 ] == 0xff && asBytes[ 1 ] == 0xfe )  				{  					return Encoding.Unicode.GetString( asBytes' 2' asBytes.Length - 2 );  				}  				else if ( asBytes[ 0 ] == 0xfe && asBytes[ 1 ] == 0xff )  				{  					return Encoding.BigEndianUnicode.GetString( asBytes' 2' asBytes.Length - 2 );  				}  				else  				{  					return Encoding.BigEndianUnicode.GetString( asBytes' 0' asBytes.Length );  				}  			}  			catch ( ArgumentException ex )  			{  				throw new InvalidOperationException( "Not UTF-16 string."' ex );  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,AsStringUtf16,The following statement contains a magic number: try  			{  				MessagePackString asMessagePackString = this._handleOrTypeCode as MessagePackString;  #if DEBUG  				Contract.Assert( asMessagePackString != null' "asMessagePackString != null" );  #endif // DEBUG    				if ( asMessagePackString.UnsafeGetString() != null )  				{  					return asMessagePackString.UnsafeGetString();  				}    				byte[] asBytes = asMessagePackString.UnsafeGetBuffer();    				if ( asBytes.Length == 0 )  				{  					return String.Empty;  				}    				if ( asBytes.Length % 2 != 0 )  				{  					throw new InvalidOperationException( "Not UTF-16 string." );  				}    				if ( asBytes[ 0 ] == 0xff && asBytes[ 1 ] == 0xfe )  				{  					return Encoding.Unicode.GetString( asBytes' 2' asBytes.Length - 2 );  				}  				else if ( asBytes[ 0 ] == 0xfe && asBytes[ 1 ] == 0xff )  				{  					return Encoding.BigEndianUnicode.GetString( asBytes' 2' asBytes.Length - 2 );  				}  				else  				{  					return Encoding.BigEndianUnicode.GetString( asBytes' 0' asBytes.Length );  				}  			}  			catch ( ArgumentException ex )  			{  				throw new InvalidOperationException( "Not UTF-16 string."' ex );  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,AsStringUtf16,The following statement contains a magic number: try  			{  				MessagePackString asMessagePackString = this._handleOrTypeCode as MessagePackString;  #if DEBUG  				Contract.Assert( asMessagePackString != null' "asMessagePackString != null" );  #endif // DEBUG    				if ( asMessagePackString.UnsafeGetString() != null )  				{  					return asMessagePackString.UnsafeGetString();  				}    				byte[] asBytes = asMessagePackString.UnsafeGetBuffer();    				if ( asBytes.Length == 0 )  				{  					return String.Empty;  				}    				if ( asBytes.Length % 2 != 0 )  				{  					throw new InvalidOperationException( "Not UTF-16 string." );  				}    				if ( asBytes[ 0 ] == 0xff && asBytes[ 1 ] == 0xfe )  				{  					return Encoding.Unicode.GetString( asBytes' 2' asBytes.Length - 2 );  				}  				else if ( asBytes[ 0 ] == 0xfe && asBytes[ 1 ] == 0xff )  				{  					return Encoding.BigEndianUnicode.GetString( asBytes' 2' asBytes.Length - 2 );  				}  				else  				{  					return Encoding.BigEndianUnicode.GetString( asBytes' 0' asBytes.Length );  				}  			}  			catch ( ArgumentException ex )  			{  				throw new InvalidOperationException( "Not UTF-16 string."' ex );  			}
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt1 );  						break;  					}  					case 2:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt2 );  						break;  					}  					case 4:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt4 );  						break;  					}  					case 8:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt8 );  						break;  					}  					case 16:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt16 );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length );  						}  						else  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt1 );  						break;  					}  					case 2:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt2 );  						break;  					}  					case 4:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt4 );  						break;  					}  					case 8:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt8 );  						break;  					}  					case 16:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt16 );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length );  						}  						else  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt1 );  						break;  					}  					case 2:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt2 );  						break;  					}  					case 4:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt4 );  						break;  					}  					case 8:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt8 );  						break;  					}  					case 16:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt16 );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length );  						}  						else  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt1 );  						break;  					}  					case 2:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt2 );  						break;  					}  					case 4:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt4 );  						break;  					}  					case 8:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt8 );  						break;  					}  					case 16:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt16 );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length );  						}  						else  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( value >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( value & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( value >> 56 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value >> 48 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value >> 48 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( value >> 40 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( value >> 40 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( value >> 32 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( value >> 32 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 5 ] = unchecked( ( byte )( value >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 5 ] = unchecked( ( byte )( value >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 6 ] = unchecked( ( byte )( value >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 6 ] = unchecked( ( byte )( value >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 7 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 7 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 8 ] = unchecked( ( byte )( value & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( bits >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( bits >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( bits >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( bits >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( bits >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( bits & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( bits >> 56 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( bits >> 48 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( bits >> 48 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( bits >> 40 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( bits >> 40 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( bits >> 32 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( bits >> 32 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 5 ] = unchecked( ( byte )( bits >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 5 ] = unchecked( ( byte )( bits >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 6 ] = unchecked( ( byte )( bits >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 6 ] = unchecked( ( byte )( bits >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 7 ] = unchecked( ( byte )( bits >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 7 ] = unchecked( ( byte )( bits >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 8 ] = unchecked( ( byte )( bits & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteStringBody,The following statement contains a magic number: var buffer = BufferManager.NewByteBuffer( value.Length * 4 );
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringCore,The following statement contains a magic number: var byteBuffer = BufferManager.NewByteBuffer( length * 4 );
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadByteSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSByteSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt16Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt16Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt32Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt32Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt64Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt64Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSingleSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadDoubleSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinary,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Byte[] );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Byte[] );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Byte[] );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Byte[] );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Byte[] );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Byte[] );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Byte[] );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Byte[] );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadString,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( String );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( String );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( String );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( String );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( String );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( String );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( String );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( String );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLength,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Array8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Array16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Array32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Array8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Array16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Array32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Array8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Array16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Array32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Array8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Array16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Array32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLength,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Map8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Map16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Map32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Map8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Map16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Map32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Map8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Map16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Map32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Map8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Map16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Map32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject? );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject? );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject? );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject? );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject? );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject? );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject? );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject? );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackString,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,GetHashCode,The following statement contains a magic number: if ( this._encoded != null )  			{  				int hashCode = 0;  				for ( int i = 0; i < this._encoded.Length; i++ )  				{  					int value = this._encoded[ i ] << ( i % 4 ) * 8;  					hashCode ^= value;  				}    				return hashCode;  			}
Magic Number,MsgPack,MessagePackString,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,GetHashCode,The following statement contains a magic number: if ( this._encoded != null )  			{  				int hashCode = 0;  				for ( int i = 0; i < this._encoded.Length; i++ )  				{  					int value = this._encoded[ i ] << ( i % 4 ) * 8;  					hashCode ^= value;  				}    				return hashCode;  			}
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,MustBeString,The following statement contains a magic number: for ( int i = 0; i < 128 && i < value.Length; i++ )  				{  					var c = value[ i ];  					if ( c < 0x20 && ( c != 0x9 && c != 0xA && c != 0xD ) )  					{  						return false;  					}  					else if ( 0x7E < c && c < 0xA0 )  					{  						return false;  					}  				}
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,CreateByteArrayString,The following statement contains a magic number: var buffer = new StringBuilder( ( bytes.Length <= 128 ? bytes.Length * 3 : 128 * 3 + 3 ) + 4 );
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,CreateByteArrayString,The following statement contains a magic number: var buffer = new StringBuilder( ( bytes.Length <= 128 ? bytes.Length * 3 : 128 * 3 + 3 ) + 4 );
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,CreateByteArrayString,The following statement contains a magic number: var buffer = new StringBuilder( ( bytes.Length <= 128 ? bytes.Length * 3 : 128 * 3 + 3 ) + 4 );
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,CreateByteArrayString,The following statement contains a magic number: var buffer = new StringBuilder( ( bytes.Length <= 128 ? bytes.Length * 3 : 128 * 3 + 3 ) + 4 );
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,CreateByteArrayString,The following statement contains a magic number: var buffer = new StringBuilder( ( bytes.Length <= 128 ? bytes.Length * 3 : 128 * 3 + 3 ) + 4 );
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,CreateByteArrayString,The following statement contains a magic number: var buffer = new StringBuilder( ( bytes.Length <= 128 ? bytes.Length * 3 : 128 * 3 + 3 ) + 4 );
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,CreateByteArrayString,The following statement contains a magic number: foreach ( var b in bytes.Take( 128 ) )  				{  					buffer.Append( ' ' );  					buffer.Append( b.ToString( "X2"' CultureInfo.InvariantCulture ) );  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt16,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt16,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt32,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt32,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt32,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt32,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt32,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt32,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The following statement contains a magic number: unchecked  			{  				long bits = BitConverter.DoubleToInt64Bits( value );  				this.WriteByte( ( byte )( ( bits >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( bits & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The following statement contains a magic number: unchecked  			{  				long bits = BitConverter.DoubleToInt64Bits( value );  				this.WriteByte( ( byte )( ( bits >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( bits & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The following statement contains a magic number: unchecked  			{  				long bits = BitConverter.DoubleToInt64Bits( value );  				this.WriteByte( ( byte )( ( bits >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( bits & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The following statement contains a magic number: unchecked  			{  				long bits = BitConverter.DoubleToInt64Bits( value );  				this.WriteByte( ( byte )( ( bits >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( bits & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The following statement contains a magic number: unchecked  			{  				long bits = BitConverter.DoubleToInt64Bits( value );  				this.WriteByte( ( byte )( ( bits >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( bits & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The following statement contains a magic number: unchecked  			{  				long bits = BitConverter.DoubleToInt64Bits( value );  				this.WriteByte( ( byte )( ( bits >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( bits & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The following statement contains a magic number: unchecked  			{  				long bits = BitConverter.DoubleToInt64Bits( value );  				this.WriteByte( ( byte )( ( bits >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( bits & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackArrayHeaderCore,The following statement contains a magic number: if ( count < 16 )  			{  				this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixedArray | count ) ) );  			}  			else if ( count <= UInt16.MaxValue )  			{  				this.WriteByte( MessagePackCode.Array16 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}  			else  			{  				this.WriteByte( MessagePackCode.Array32 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackArrayHeaderCore,The following statement contains a magic number: if ( count < 16 )  			{  				this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixedArray | count ) ) );  			}  			else if ( count <= UInt16.MaxValue )  			{  				this.WriteByte( MessagePackCode.Array16 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}  			else  			{  				this.WriteByte( MessagePackCode.Array32 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackArrayHeaderCore,The following statement contains a magic number: if ( count < 16 )  			{  				this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixedArray | count ) ) );  			}  			else if ( count <= UInt16.MaxValue )  			{  				this.WriteByte( MessagePackCode.Array16 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}  			else  			{  				this.WriteByte( MessagePackCode.Array32 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackArrayHeaderCore,The following statement contains a magic number: if ( count < 16 )  			{  				this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixedArray | count ) ) );  			}  			else if ( count <= UInt16.MaxValue )  			{  				this.WriteByte( MessagePackCode.Array16 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}  			else  			{  				this.WriteByte( MessagePackCode.Array32 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackArrayHeaderCore,The following statement contains a magic number: if ( count < 16 )  			{  				this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixedArray | count ) ) );  			}  			else if ( count <= UInt16.MaxValue )  			{  				this.WriteByte( MessagePackCode.Array16 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}  			else  			{  				this.WriteByte( MessagePackCode.Array32 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackMapHeaderCore,The following statement contains a magic number: if ( count < 16 )  			{  				this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixedMap | count ) ) );  			}  			else if ( count <= UInt16.MaxValue )  			{  				this.WriteByte( MessagePackCode.Map16 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}  			else  			{  				this.WriteByte( MessagePackCode.Map32 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackMapHeaderCore,The following statement contains a magic number: if ( count < 16 )  			{  				this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixedMap | count ) ) );  			}  			else if ( count <= UInt16.MaxValue )  			{  				this.WriteByte( MessagePackCode.Map16 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}  			else  			{  				this.WriteByte( MessagePackCode.Map32 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackMapHeaderCore,The following statement contains a magic number: if ( count < 16 )  			{  				this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixedMap | count ) ) );  			}  			else if ( count <= UInt16.MaxValue )  			{  				this.WriteByte( MessagePackCode.Map16 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}  			else  			{  				this.WriteByte( MessagePackCode.Map32 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackMapHeaderCore,The following statement contains a magic number: if ( count < 16 )  			{  				this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixedMap | count ) ) );  			}  			else if ( count <= UInt16.MaxValue )  			{  				this.WriteByte( MessagePackCode.Map16 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}  			else  			{  				this.WriteByte( MessagePackCode.Map32 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackMapHeaderCore,The following statement contains a magic number: if ( count < 16 )  			{  				this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixedMap | count ) ) );  			}  			else if ( count <= UInt16.MaxValue )  			{  				this.WriteByte( MessagePackCode.Map16 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}  			else  			{  				this.WriteByte( MessagePackCode.Map32 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackStringHeaderCore,The following statement contains a magic number: if ( length < 32 )  			{  				this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixedRaw | length ) ) );  				return;  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackStringHeaderCore,The following statement contains a magic number: if ( length <= Byte.MaxValue && ( this._compatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) == 0 )  				{  					this.WriteByte( MessagePackCode.Str8 );  					unchecked  					{  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					this.WriteByte( MessagePackCode.Str16 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else  				{  					this.WriteByte( MessagePackCode.Str32 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 24 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 16 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackStringHeaderCore,The following statement contains a magic number: if ( length <= Byte.MaxValue && ( this._compatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) == 0 )  				{  					this.WriteByte( MessagePackCode.Str8 );  					unchecked  					{  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					this.WriteByte( MessagePackCode.Str16 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else  				{  					this.WriteByte( MessagePackCode.Str32 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 24 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 16 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackStringHeaderCore,The following statement contains a magic number: if ( length <= Byte.MaxValue && ( this._compatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) == 0 )  				{  					this.WriteByte( MessagePackCode.Str8 );  					unchecked  					{  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					this.WriteByte( MessagePackCode.Str16 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else  				{  					this.WriteByte( MessagePackCode.Str32 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 24 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 16 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackStringHeaderCore,The following statement contains a magic number: if ( length <= Byte.MaxValue && ( this._compatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) == 0 )  				{  					this.WriteByte( MessagePackCode.Str8 );  					unchecked  					{  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					this.WriteByte( MessagePackCode.Str16 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else  				{  					this.WriteByte( MessagePackCode.Str32 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 24 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 16 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackBinaryHeaderCore,The following statement contains a magic number: if ( length <= Byte.MaxValue )  				{  					this.WriteByte( MessagePackCode.Bin8 );  					unchecked  					{  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					this.WriteByte( MessagePackCode.Bin16 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else  				{  					this.WriteByte( MessagePackCode.Bin32 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 24 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 16 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackBinaryHeaderCore,The following statement contains a magic number: if ( length <= Byte.MaxValue )  				{  					this.WriteByte( MessagePackCode.Bin8 );  					unchecked  					{  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					this.WriteByte( MessagePackCode.Bin16 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else  				{  					this.WriteByte( MessagePackCode.Bin32 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 24 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 16 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackBinaryHeaderCore,The following statement contains a magic number: if ( length <= Byte.MaxValue )  				{  					this.WriteByte( MessagePackCode.Bin8 );  					unchecked  					{  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					this.WriteByte( MessagePackCode.Bin16 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else  				{  					this.WriteByte( MessagePackCode.Bin32 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 24 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 16 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackBinaryHeaderCore,The following statement contains a magic number: if ( length <= Byte.MaxValue )  				{  					this.WriteByte( MessagePackCode.Bin8 );  					unchecked  					{  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					this.WriteByte( MessagePackCode.Bin16 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else  				{  					this.WriteByte( MessagePackCode.Bin32 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 24 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 16 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					this.WriteByte( MessagePackCode.FixExt1 );  					break;  				}  				case 2:  				{  					this.WriteByte( MessagePackCode.FixExt2 );  					break;  				}  				case 4:  				{  					this.WriteByte( MessagePackCode.FixExt4 );  					break;  				}  				case 8:  				{  					this.WriteByte( MessagePackCode.FixExt8 );  					break;  				}  				case 16:  				{  					this.WriteByte( MessagePackCode.FixExt16 );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							this.WriteByte( MessagePackCode.Ext8 );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteByte( MessagePackCode.Ext16 );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else  						{  							this.WriteByte( MessagePackCode.Ext32 );  							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					this.WriteByte( MessagePackCode.FixExt1 );  					break;  				}  				case 2:  				{  					this.WriteByte( MessagePackCode.FixExt2 );  					break;  				}  				case 4:  				{  					this.WriteByte( MessagePackCode.FixExt4 );  					break;  				}  				case 8:  				{  					this.WriteByte( MessagePackCode.FixExt8 );  					break;  				}  				case 16:  				{  					this.WriteByte( MessagePackCode.FixExt16 );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							this.WriteByte( MessagePackCode.Ext8 );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteByte( MessagePackCode.Ext16 );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else  						{  							this.WriteByte( MessagePackCode.Ext32 );  							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					this.WriteByte( MessagePackCode.FixExt1 );  					break;  				}  				case 2:  				{  					this.WriteByte( MessagePackCode.FixExt2 );  					break;  				}  				case 4:  				{  					this.WriteByte( MessagePackCode.FixExt4 );  					break;  				}  				case 8:  				{  					this.WriteByte( MessagePackCode.FixExt8 );  					break;  				}  				case 16:  				{  					this.WriteByte( MessagePackCode.FixExt16 );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							this.WriteByte( MessagePackCode.Ext8 );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteByte( MessagePackCode.Ext16 );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else  						{  							this.WriteByte( MessagePackCode.Ext32 );  							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					this.WriteByte( MessagePackCode.FixExt1 );  					break;  				}  				case 2:  				{  					this.WriteByte( MessagePackCode.FixExt2 );  					break;  				}  				case 4:  				{  					this.WriteByte( MessagePackCode.FixExt4 );  					break;  				}  				case 8:  				{  					this.WriteByte( MessagePackCode.FixExt8 );  					break;  				}  				case 16:  				{  					this.WriteByte( MessagePackCode.FixExt16 );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							this.WriteByte( MessagePackCode.Ext8 );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteByte( MessagePackCode.Ext16 );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else  						{  							this.WriteByte( MessagePackCode.Ext32 );  							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					this.WriteByte( MessagePackCode.FixExt1 );  					break;  				}  				case 2:  				{  					this.WriteByte( MessagePackCode.FixExt2 );  					break;  				}  				case 4:  				{  					this.WriteByte( MessagePackCode.FixExt4 );  					break;  				}  				case 8:  				{  					this.WriteByte( MessagePackCode.FixExt8 );  					break;  				}  				case 16:  				{  					this.WriteByte( MessagePackCode.FixExt16 );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							this.WriteByte( MessagePackCode.Ext8 );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteByte( MessagePackCode.Ext16 );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else  						{  							this.WriteByte( MessagePackCode.Ext32 );  							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					this.WriteByte( MessagePackCode.FixExt1 );  					break;  				}  				case 2:  				{  					this.WriteByte( MessagePackCode.FixExt2 );  					break;  				}  				case 4:  				{  					this.WriteByte( MessagePackCode.FixExt4 );  					break;  				}  				case 8:  				{  					this.WriteByte( MessagePackCode.FixExt8 );  					break;  				}  				case 16:  				{  					this.WriteByte( MessagePackCode.FixExt16 );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							this.WriteByte( MessagePackCode.Ext8 );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteByte( MessagePackCode.Ext16 );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else  						{  							this.WriteByte( MessagePackCode.Ext32 );  							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					this.WriteByte( MessagePackCode.FixExt1 );  					break;  				}  				case 2:  				{  					this.WriteByte( MessagePackCode.FixExt2 );  					break;  				}  				case 4:  				{  					this.WriteByte( MessagePackCode.FixExt4 );  					break;  				}  				case 8:  				{  					this.WriteByte( MessagePackCode.FixExt8 );  					break;  				}  				case 16:  				{  					this.WriteByte( MessagePackCode.FixExt16 );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							this.WriteByte( MessagePackCode.Ext8 );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteByte( MessagePackCode.Ext16 );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else  						{  							this.WriteByte( MessagePackCode.Ext32 );  							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					this.WriteByte( MessagePackCode.FixExt1 );  					break;  				}  				case 2:  				{  					this.WriteByte( MessagePackCode.FixExt2 );  					break;  				}  				case 4:  				{  					this.WriteByte( MessagePackCode.FixExt4 );  					break;  				}  				case 8:  				{  					this.WriteByte( MessagePackCode.FixExt8 );  					break;  				}  				case 16:  				{  					this.WriteByte( MessagePackCode.FixExt16 );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							this.WriteByte( MessagePackCode.Ext8 );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteByte( MessagePackCode.Ext16 );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else  						{  							this.WriteByte( MessagePackCode.Ext32 );  							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWrite,The following statement contains a magic number: if ( this.CanSeek )  			{  				// Reserve length  				this.SeekTo( 4L );  				var headerPosition = this.Position;  				// Write body  				writeBody( value' options );  				var bodyLength = this.Position - headerPosition;  				// Back to reserved length  				this.SeekTo( -bodyLength );  				this.SeekTo( -4L );  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}  				// Forward to body tail  				this.SeekTo( bodyLength );  			}  			else  			{  				// Copying is better than forcing stream is seekable...  				var asCollection = value as ICollection<TItem> ?? value.ToArray();    				var bodyLength = asCollection.Count;  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}    				writeBody( asCollection' options );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWrite,The following statement contains a magic number: if ( this.CanSeek )  			{  				// Reserve length  				this.SeekTo( 4L );  				var headerPosition = this.Position;  				// Write body  				writeBody( value' options );  				var bodyLength = this.Position - headerPosition;  				// Back to reserved length  				this.SeekTo( -bodyLength );  				this.SeekTo( -4L );  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}  				// Forward to body tail  				this.SeekTo( bodyLength );  			}  			else  			{  				// Copying is better than forcing stream is seekable...  				var asCollection = value as ICollection<TItem> ?? value.ToArray();    				var bodyLength = asCollection.Count;  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}    				writeBody( asCollection' options );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWrite,The following statement contains a magic number: if ( this.CanSeek )  			{  				// Reserve length  				this.SeekTo( 4L );  				var headerPosition = this.Position;  				// Write body  				writeBody( value' options );  				var bodyLength = this.Position - headerPosition;  				// Back to reserved length  				this.SeekTo( -bodyLength );  				this.SeekTo( -4L );  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}  				// Forward to body tail  				this.SeekTo( bodyLength );  			}  			else  			{  				// Copying is better than forcing stream is seekable...  				var asCollection = value as ICollection<TItem> ?? value.ToArray();    				var bodyLength = asCollection.Count;  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}    				writeBody( asCollection' options );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWrite,The following statement contains a magic number: if ( this.CanSeek )  			{  				// Reserve length  				this.SeekTo( 4L );  				var headerPosition = this.Position;  				// Write body  				writeBody( value' options );  				var bodyLength = this.Position - headerPosition;  				// Back to reserved length  				this.SeekTo( -bodyLength );  				this.SeekTo( -4L );  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}  				// Forward to body tail  				this.SeekTo( bodyLength );  			}  			else  			{  				// Copying is better than forcing stream is seekable...  				var asCollection = value as ICollection<TItem> ?? value.ToArray();    				var bodyLength = asCollection.Count;  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}    				writeBody( asCollection' options );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWrite,The following statement contains a magic number: if ( this.CanSeek )  			{  				// Reserve length  				this.SeekTo( 4L );  				var headerPosition = this.Position;  				// Write body  				writeBody( value' options );  				var bodyLength = this.Position - headerPosition;  				// Back to reserved length  				this.SeekTo( -bodyLength );  				this.SeekTo( -4L );  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}  				// Forward to body tail  				this.SeekTo( bodyLength );  			}  			else  			{  				// Copying is better than forcing stream is seekable...  				var asCollection = value as ICollection<TItem> ?? value.ToArray();    				var bodyLength = asCollection.Count;  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}    				writeBody( asCollection' options );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWrite,The following statement contains a magic number: if ( this.CanSeek )  			{  				// Reserve length  				this.SeekTo( 4L );  				var headerPosition = this.Position;  				// Write body  				writeBody( value' options );  				var bodyLength = this.Position - headerPosition;  				// Back to reserved length  				this.SeekTo( -bodyLength );  				this.SeekTo( -4L );  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}  				// Forward to body tail  				this.SeekTo( bodyLength );  			}  			else  			{  				// Copying is better than forcing stream is seekable...  				var asCollection = value as ICollection<TItem> ?? value.ToArray();    				var bodyLength = asCollection.Count;  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}    				writeBody( asCollection' options );  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.ArrayTypeMask ) == ReadValueResult.ArrayTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						return ( byte )( MessagePackCode.MinimumFixedArray | ( int )( source & ReadValueResult.ValueOrLengthMask ) );  					}  					case 2:  					{  						return ( byte )MessagePackCode.Array16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Array32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.ArrayTypeMask ) == ReadValueResult.ArrayTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						return ( byte )( MessagePackCode.MinimumFixedArray | ( int )( source & ReadValueResult.ValueOrLengthMask ) );  					}  					case 2:  					{  						return ( byte )MessagePackCode.Array16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Array32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.ArrayTypeMask ) == ReadValueResult.ArrayTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						return ( byte )( MessagePackCode.MinimumFixedArray | ( int )( source & ReadValueResult.ValueOrLengthMask ) );  					}  					case 2:  					{  						return ( byte )MessagePackCode.Array16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Array32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.MapTypeMask ) == ReadValueResult.MapTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						return ( byte )( MessagePackCode.MinimumFixedMap | ( int )( source & ReadValueResult.ValueOrLengthMask ) );  					}  					case 2:  					{  						return ( byte )MessagePackCode.Map16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Map32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.MapTypeMask ) == ReadValueResult.MapTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						return ( byte )( MessagePackCode.MinimumFixedMap | ( int )( source & ReadValueResult.ValueOrLengthMask ) );  					}  					case 2:  					{  						return ( byte )MessagePackCode.Map16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Map32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.MapTypeMask ) == ReadValueResult.MapTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						return ( byte )( MessagePackCode.MinimumFixedMap | ( int )( source & ReadValueResult.ValueOrLengthMask ) );  					}  					case 2:  					{  						return ( byte )MessagePackCode.Map16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Map32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.RawTypeMask ) == ReadValueResult.RawTypeMask )  			{  				var isBin = ( source & ReadValueResult.BinTypeMask ) == ReadValueResult.BinTypeMask;  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						return ( byte )( MessagePackCode.MinimumFixedRaw | ( int )( source & ReadValueResult.ValueOrLengthMask ) );  					}  					case 1:  					{  						return ( byte )( isBin ? MessagePackCode.Bin8 : MessagePackCode.Str8 );  					}  					case 2:  					{  						return ( byte )( isBin ? MessagePackCode.Bin16 : MessagePackCode.Str16 );  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )( isBin ? MessagePackCode.Bin32 : MessagePackCode.Str32 );  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.RawTypeMask ) == ReadValueResult.RawTypeMask )  			{  				var isBin = ( source & ReadValueResult.BinTypeMask ) == ReadValueResult.BinTypeMask;  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						return ( byte )( MessagePackCode.MinimumFixedRaw | ( int )( source & ReadValueResult.ValueOrLengthMask ) );  					}  					case 1:  					{  						return ( byte )( isBin ? MessagePackCode.Bin8 : MessagePackCode.Str8 );  					}  					case 2:  					{  						return ( byte )( isBin ? MessagePackCode.Bin16 : MessagePackCode.Str16 );  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )( isBin ? MessagePackCode.Bin32 : MessagePackCode.Str32 );  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.RawTypeMask ) == ReadValueResult.RawTypeMask )  			{  				var isBin = ( source & ReadValueResult.BinTypeMask ) == ReadValueResult.BinTypeMask;  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						return ( byte )( MessagePackCode.MinimumFixedRaw | ( int )( source & ReadValueResult.ValueOrLengthMask ) );  					}  					case 1:  					{  						return ( byte )( isBin ? MessagePackCode.Bin8 : MessagePackCode.Str8 );  					}  					case 2:  					{  						return ( byte )( isBin ? MessagePackCode.Bin16 : MessagePackCode.Str16 );  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )( isBin ? MessagePackCode.Bin32 : MessagePackCode.Str32 );  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.ExtTypeMask ) == ReadValueResult.ExtTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						switch ( ( int )( source & ReadValueResult.ValueOrLengthMask ) )  						{  							case 1:  							{  								return ( byte )MessagePackCode.FixExt1;  							}  							case 2:  							{  								return ( byte )MessagePackCode.FixExt2;  							}  							case 4:  							{  								return ( byte )MessagePackCode.FixExt4;  							}  							case 8:  							{  								return ( byte )MessagePackCode.FixExt8;  							}  							default:  							{  #if DEBUG  								Contract.Assert( ( int )( source & ReadValueResult.ValueOrLengthMask ) == 16' ( int )( source & ReadValueResult.ValueOrLengthMask ) + " == 16" );  #endif // DEBUG  								return ( byte )MessagePackCode.FixExt16;  							}  						}  					}  					case 1:  					{  						return ( byte )MessagePackCode.Ext8;  					}  					case 2:  					{  						return ( byte )MessagePackCode.Ext16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Ext32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.ExtTypeMask ) == ReadValueResult.ExtTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						switch ( ( int )( source & ReadValueResult.ValueOrLengthMask ) )  						{  							case 1:  							{  								return ( byte )MessagePackCode.FixExt1;  							}  							case 2:  							{  								return ( byte )MessagePackCode.FixExt2;  							}  							case 4:  							{  								return ( byte )MessagePackCode.FixExt4;  							}  							case 8:  							{  								return ( byte )MessagePackCode.FixExt8;  							}  							default:  							{  #if DEBUG  								Contract.Assert( ( int )( source & ReadValueResult.ValueOrLengthMask ) == 16' ( int )( source & ReadValueResult.ValueOrLengthMask ) + " == 16" );  #endif // DEBUG  								return ( byte )MessagePackCode.FixExt16;  							}  						}  					}  					case 1:  					{  						return ( byte )MessagePackCode.Ext8;  					}  					case 2:  					{  						return ( byte )MessagePackCode.Ext16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Ext32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.ExtTypeMask ) == ReadValueResult.ExtTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						switch ( ( int )( source & ReadValueResult.ValueOrLengthMask ) )  						{  							case 1:  							{  								return ( byte )MessagePackCode.FixExt1;  							}  							case 2:  							{  								return ( byte )MessagePackCode.FixExt2;  							}  							case 4:  							{  								return ( byte )MessagePackCode.FixExt4;  							}  							case 8:  							{  								return ( byte )MessagePackCode.FixExt8;  							}  							default:  							{  #if DEBUG  								Contract.Assert( ( int )( source & ReadValueResult.ValueOrLengthMask ) == 16' ( int )( source & ReadValueResult.ValueOrLengthMask ) + " == 16" );  #endif // DEBUG  								return ( byte )MessagePackCode.FixExt16;  							}  						}  					}  					case 1:  					{  						return ( byte )MessagePackCode.Ext8;  					}  					case 2:  					{  						return ( byte )MessagePackCode.Ext16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Ext32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.ExtTypeMask ) == ReadValueResult.ExtTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						switch ( ( int )( source & ReadValueResult.ValueOrLengthMask ) )  						{  							case 1:  							{  								return ( byte )MessagePackCode.FixExt1;  							}  							case 2:  							{  								return ( byte )MessagePackCode.FixExt2;  							}  							case 4:  							{  								return ( byte )MessagePackCode.FixExt4;  							}  							case 8:  							{  								return ( byte )MessagePackCode.FixExt8;  							}  							default:  							{  #if DEBUG  								Contract.Assert( ( int )( source & ReadValueResult.ValueOrLengthMask ) == 16' ( int )( source & ReadValueResult.ValueOrLengthMask ) + " == 16" );  #endif // DEBUG  								return ( byte )MessagePackCode.FixExt16;  							}  						}  					}  					case 1:  					{  						return ( byte )MessagePackCode.Ext8;  					}  					case 2:  					{  						return ( byte )MessagePackCode.Ext16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Ext32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.ExtTypeMask ) == ReadValueResult.ExtTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						switch ( ( int )( source & ReadValueResult.ValueOrLengthMask ) )  						{  							case 1:  							{  								return ( byte )MessagePackCode.FixExt1;  							}  							case 2:  							{  								return ( byte )MessagePackCode.FixExt2;  							}  							case 4:  							{  								return ( byte )MessagePackCode.FixExt4;  							}  							case 8:  							{  								return ( byte )MessagePackCode.FixExt8;  							}  							default:  							{  #if DEBUG  								Contract.Assert( ( int )( source & ReadValueResult.ValueOrLengthMask ) == 16' ( int )( source & ReadValueResult.ValueOrLengthMask ) + " == 16" );  #endif // DEBUG  								return ( byte )MessagePackCode.FixExt16;  							}  						}  					}  					case 1:  					{  						return ( byte )MessagePackCode.Ext8;  					}  					case 2:  					{  						return ( byte )MessagePackCode.Ext16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Ext32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.ExtTypeMask ) == ReadValueResult.ExtTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						switch ( ( int )( source & ReadValueResult.ValueOrLengthMask ) )  						{  							case 1:  							{  								return ( byte )MessagePackCode.FixExt1;  							}  							case 2:  							{  								return ( byte )MessagePackCode.FixExt2;  							}  							case 4:  							{  								return ( byte )MessagePackCode.FixExt4;  							}  							case 8:  							{  								return ( byte )MessagePackCode.FixExt8;  							}  							default:  							{  #if DEBUG  								Contract.Assert( ( int )( source & ReadValueResult.ValueOrLengthMask ) == 16' ( int )( source & ReadValueResult.ValueOrLengthMask ) + " == 16" );  #endif // DEBUG  								return ( byte )MessagePackCode.FixExt16;  							}  						}  					}  					case 1:  					{  						return ( byte )MessagePackCode.Ext8;  					}  					case 2:  					{  						return ( byte )MessagePackCode.Ext16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Ext32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.ExtTypeMask ) == ReadValueResult.ExtTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						switch ( ( int )( source & ReadValueResult.ValueOrLengthMask ) )  						{  							case 1:  							{  								return ( byte )MessagePackCode.FixExt1;  							}  							case 2:  							{  								return ( byte )MessagePackCode.FixExt2;  							}  							case 4:  							{  								return ( byte )MessagePackCode.FixExt4;  							}  							case 8:  							{  								return ( byte )MessagePackCode.FixExt8;  							}  							default:  							{  #if DEBUG  								Contract.Assert( ( int )( source & ReadValueResult.ValueOrLengthMask ) == 16' ( int )( source & ReadValueResult.ValueOrLengthMask ) + " == 16" );  #endif // DEBUG  								return ( byte )MessagePackCode.FixExt16;  							}  						}  					}  					case 1:  					{  						return ( byte )MessagePackCode.Ext8;  					}  					case 2:  					{  						return ( byte )MessagePackCode.Ext16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Ext32;  					}  				}  			}
Magic Number,MsgPack,SingleArrayBufferAllocator,C:\repos\msgpack_msgpack-cli\src\MsgPack\SingleArrayBufferAllocator.cs,Allocate,The following statement contains a magic number: if ( old.Length < 256 )  			{  				return new byte[ 256 ];  			}
Magic Number,MsgPack,SingleArrayBufferAllocator,C:\repos\msgpack_msgpack-cli\src\MsgPack\SingleArrayBufferAllocator.cs,Allocate,The following statement contains a magic number: if ( old.Length < 256 )  			{  				return new byte[ 256 ];  			}
Magic Number,MsgPack,SingleArrayBufferAllocator,C:\repos\msgpack_msgpack-cli\src\MsgPack\SingleArrayBufferAllocator.cs,Allocate,The following statement contains a magic number: var newSize = Math.Max( ( long )( old.Length * 1.1618 )' requestSize + ( long )old.Length );
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,SubtreeUnpacker,The following statement contains a magic number: this._unpacked = new Int64Stack( 2 );
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,SubtreeUnpacker,The following statement contains a magic number: this._itemsCount = new Int64Stack( 2 );
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,SubtreeUnpacker,The following statement contains a magic number: this._isMap = new BooleanStack( 2 );
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadCore,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadBoolean,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableBoolean,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadByte,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableByte,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadSByte,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableSByte,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadInt16,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableInt16,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadUInt16,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableUInt16,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadInt32,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableInt32,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadUInt32,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableUInt32,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadInt64,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableInt64,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadUInt64,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableUInt64,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadSingle,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableSingle,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadDouble,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableDouble,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadString,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadObject,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,FromOffsetTicks,The following statement contains a magic number: nanoSeconds = unchecked( ( int )remaining ) * 100;
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Decode,The following statement contains a magic number: switch( value.Body.Length )  			{  				case 4:  				{  					// timespan32 format  					return new Timestamp( BigEndianBinary.ToUInt32( value.Body' 0 )' 0 );  				}  				case 8:  				{  					// timespan64 format  					var payload = BigEndianBinary.ToUInt64( value.Body' 0 );  					return new Timestamp( unchecked( ( long )( payload & 0x00000003ffffffffL ) )' unchecked( ( int )( payload >> 34 ) ) );  				}  				case 12:  				{  					// timespan96 format  					return new Timestamp( BigEndianBinary.ToInt64( value.Body' sizeof( int ) )' unchecked( ( int )BigEndianBinary.ToUInt32( value.Body' 0 ) ) );  				}  				default:  				{  					throw new ArgumentException( "The value's length is not valid."' "value" );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Decode,The following statement contains a magic number: switch( value.Body.Length )  			{  				case 4:  				{  					// timespan32 format  					return new Timestamp( BigEndianBinary.ToUInt32( value.Body' 0 )' 0 );  				}  				case 8:  				{  					// timespan64 format  					var payload = BigEndianBinary.ToUInt64( value.Body' 0 );  					return new Timestamp( unchecked( ( long )( payload & 0x00000003ffffffffL ) )' unchecked( ( int )( payload >> 34 ) ) );  				}  				case 12:  				{  					// timespan96 format  					return new Timestamp( BigEndianBinary.ToInt64( value.Body' sizeof( int ) )' unchecked( ( int )BigEndianBinary.ToUInt32( value.Body' 0 ) ) );  				}  				default:  				{  					throw new ArgumentException( "The value's length is not valid."' "value" );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Decode,The following statement contains a magic number: switch( value.Body.Length )  			{  				case 4:  				{  					// timespan32 format  					return new Timestamp( BigEndianBinary.ToUInt32( value.Body' 0 )' 0 );  				}  				case 8:  				{  					// timespan64 format  					var payload = BigEndianBinary.ToUInt64( value.Body' 0 );  					return new Timestamp( unchecked( ( long )( payload & 0x00000003ffffffffL ) )' unchecked( ( int )( payload >> 34 ) ) );  				}  				case 12:  				{  					// timespan96 format  					return new Timestamp( BigEndianBinary.ToInt64( value.Body' sizeof( int ) )' unchecked( ( int )BigEndianBinary.ToUInt32( value.Body' 0 ) ) );  				}  				default:  				{  					throw new ArgumentException( "The value's length is not valid."' "value" );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Decode,The following statement contains a magic number: switch( value.Body.Length )  			{  				case 4:  				{  					// timespan32 format  					return new Timestamp( BigEndianBinary.ToUInt32( value.Body' 0 )' 0 );  				}  				case 8:  				{  					// timespan64 format  					var payload = BigEndianBinary.ToUInt64( value.Body' 0 );  					return new Timestamp( unchecked( ( long )( payload & 0x00000003ffffffffL ) )' unchecked( ( int )( payload >> 34 ) ) );  				}  				case 12:  				{  					// timespan96 format  					return new Timestamp( BigEndianBinary.ToInt64( value.Body' sizeof( int ) )' unchecked( ( int )BigEndianBinary.ToUInt32( value.Body' 0 ) ) );  				}  				default:  				{  					throw new ArgumentException( "The value's length is not valid."' "value" );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,FromComponents,The following statement contains a magic number: checked  			{  				var days = YearsToDaysOfNewYear( value.Year ) + ToDaysOffsetFromNewYear( value.Month' value.Day' isLeapYear ) - Timestamp.UnixEpochInSeconds / Timestamp.SecondsPerDay;  				// First set time offset to avoid overflow.  				epoc = value.Hour * 60 * 60;  				epoc += value.Minute * 60;  				epoc += value.Second;  				if ( days < 0 )  				{  					// Avoid right side overflow.  					epoc += ( days + 1 ) * Timestamp.SecondsPerDay;  					epoc -= Timestamp.SecondsPerDay;  				}  				else  				{  					epoc += days * Timestamp.SecondsPerDay;  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,FromComponents,The following statement contains a magic number: checked  			{  				var days = YearsToDaysOfNewYear( value.Year ) + ToDaysOffsetFromNewYear( value.Month' value.Day' isLeapYear ) - Timestamp.UnixEpochInSeconds / Timestamp.SecondsPerDay;  				// First set time offset to avoid overflow.  				epoc = value.Hour * 60 * 60;  				epoc += value.Minute * 60;  				epoc += value.Second;  				if ( days < 0 )  				{  					// Avoid right side overflow.  					epoc += ( days + 1 ) * Timestamp.SecondsPerDay;  					epoc -= Timestamp.SecondsPerDay;  				}  				else  				{  					epoc += days * Timestamp.SecondsPerDay;  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,FromComponents,The following statement contains a magic number: checked  			{  				var days = YearsToDaysOfNewYear( value.Year ) + ToDaysOffsetFromNewYear( value.Month' value.Day' isLeapYear ) - Timestamp.UnixEpochInSeconds / Timestamp.SecondsPerDay;  				// First set time offset to avoid overflow.  				epoc = value.Hour * 60 * 60;  				epoc += value.Minute * 60;  				epoc += value.Second;  				if ( days < 0 )  				{  					// Avoid right side overflow.  					epoc += ( days + 1 ) * Timestamp.SecondsPerDay;  					epoc -= Timestamp.SecondsPerDay;  				}  				else  				{  					epoc += days * Timestamp.SecondsPerDay;  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,YearsToDaysOfNewYear,The following statement contains a magic number: var numberOf400Years = DivRem( years > 0 ? ( years - 1 ) : years' 400' out remainOf400Years );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,YearsToDaysOfNewYear,The following statement contains a magic number: var numberOf100Years = DivRem( remainOf400Years' 100' out remainOf100Years );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,YearsToDaysOfNewYear,The following statement contains a magic number: var numberOf4Years = DivRem( remainOf100Years' 4' out remainOf4Years );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ToDaysOffsetFromNewYear,The following statement contains a magic number: for ( var i = 1; i < month; i++ )  			{  				result += LastDays[ i ];  				if ( i == 2 )  				{  					result += isLeapYear ? 29 : 28;  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ToDaysOffsetFromNewYear,The following statement contains a magic number: for ( var i = 1; i < month; i++ )  			{  				result += LastDays[ i ];  				if ( i == 2 )  				{  					result += isLeapYear ? 29 : 28;  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ToDaysOffsetFromNewYear,The following statement contains a magic number: for ( var i = 1; i < month; i++ )  			{  				result += LastDays[ i ];  				if ( i == 2 )  				{  					result += isLeapYear ? 29 : 28;  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,IsLeapYearInternal,The following statement contains a magic number: return !( year % 4 != 0 || ( year % 100 == 0 && year % 400 != 0 ) );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,IsLeapYearInternal,The following statement contains a magic number: return !( year % 4 != 0 || ( year % 100 == 0 && year % 400 != 0 ) );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,IsLeapYearInternal,The following statement contains a magic number: return !( year % 4 != 0 || ( year % 100 == 0 && year % 400 != 0 ) );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetLastDay,The following statement contains a magic number: if ( month == 2 )  			{  				lastDay = isLeapYear ? 29 : 28;  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetLastDay,The following statement contains a magic number: if ( month == 2 )  			{  				lastDay = isLeapYear ? 29 : 28;  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetLastDay,The following statement contains a magic number: if ( month == 2 )  			{  				lastDay = isLeapYear ? 29 : 28;  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: if ( numberOf100Years == 4 )  			{  				numberOf100Years = 3;  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: if ( numberOf100Years == 4 )  			{  				numberOf100Years = 3;  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: if ( numberOf1Year == 4 )  			{  				numberOf1Year = 3;  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: if ( numberOf1Year == 4 )  			{  				numberOf1Year = 3;  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: year = unchecked( ( long )( numberOf400Years * 400 + numberOf100Years * 100 + numberOf4years * 4 + numberOf1Year + 1 ) );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: year = unchecked( ( long )( numberOf400Years * 400 + numberOf100Years * 100 + numberOf4years * 4 + numberOf1Year + 1 ) );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: year = unchecked( ( long )( numberOf400Years * 400 + numberOf100Years * 100 + numberOf4years * 4 + numberOf1Year + 1 ) );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: var isLeapYear = numberOf1Year == 3 && ( numberOf4years != 24 || numberOf100Years == 3 );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: var isLeapYear = numberOf1Year == 3 && ( numberOf4years != 24 || numberOf100Years == 3 );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: var isLeapYear = numberOf1Year == 3 && ( numberOf4years != 24 || numberOf100Years == 3 );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: var numberOfMonth = ( daysInYear >> 5 ) + 1;
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: Contract.Assert( numberOfMonth <= 12' numberOfMonth + "<= 12' daysInYear = " + daysInYear );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: while ( daysInYear >= days[ numberOfMonth ] )  			{  				numberOfMonth++;  #if DEBUG  				Contract.Assert( numberOfMonth <= 12' numberOfMonth + "<= 12' daysInYear = " + daysInYear );  #endif // DEBUG  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: var numberOf100Years =  				daysIn400Years <= ( DaysPer100Years  + 1 ) // 1st year is leap year (power of 400)  					? 0  					: ( ( daysIn400Years - 2 ) / DaysPer100Years );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: var numberOf1Year =  				daysIn4Years <= ( DaysPerYear + ( numberOf4years != 0 ? 1 : 0 ) ) // is leap year in 4 years range?  					? 0  					: ( ( daysIn4Years - 2 ) / DaysPerYear );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: year = -unchecked( ( long )( numberOf400Years * 400 + numberOf100Years * 100 + numberOf4years * 4 + numberOf1Year ) );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: year = -unchecked( ( long )( numberOf400Years * 400 + numberOf100Years * 100 + numberOf4years * 4 + numberOf1Year ) );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: year = -unchecked( ( long )( numberOf400Years * 400 + numberOf100Years * 100 + numberOf4years * 4 + numberOf1Year ) );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: var daysInYear =  				isLeapYear  				? ( 366 - daysIn4Years )  				: ( 365 - ( daysIn4Years - 1 - numberOf1Year * DaysPerYear ) );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: var daysInYear =  				isLeapYear  				? ( 366 - daysIn4Years )  				: ( 365 - ( daysIn4Years - 1 - numberOf1Year * DaysPerYear ) );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: var numberOfMonth = ( daysInYear >> 5 ) + 1;
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: Contract.Assert( numberOfMonth <= 12' numberOfMonth + "<= 12' daysInYear = " + daysInYear );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: while ( daysInYear >= days[ numberOfMonth ] )  			{  				numberOfMonth++;  #if DEBUG  				Contract.Assert( numberOfMonth <= 12' numberOfMonth + "<= 12' daysInYear = " + daysInYear );  #endif // DEBUG  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: if ( !ParseDigitRange( input' 2' ref position' 1' 12' out month ) )  			{  				result = default( Timestamp );  				return TimestampParseResult.InvalidMonth;  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: if ( !ParseDigitRange( input' 2' ref position' 1' 12' out month ) )  			{  				result = default( Timestamp );  				return TimestampParseResult.InvalidMonth;  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: if ( !ParseDigitRange( input' 2' ref position' 0' 23' out hour ) )  			{  				result = default( Timestamp );  				return TimestampParseResult.InvalidHour;  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: if ( !ParseDigitRange( input' 2' ref position' 0' 23' out hour ) )  			{  				result = default( Timestamp );  				return TimestampParseResult.InvalidHour;  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: if ( !ParseDigitRange( input' 2' ref position' 0' 59' out minute ) )  			{  				result = default( Timestamp );  				return TimestampParseResult.InvalidMinute;  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: if ( !ParseDigitRange( input' 2' ref position' 0' 59' out minute ) )  			{  				result = default( Timestamp );  				return TimestampParseResult.InvalidMinute;  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: if ( !ParseDigitRange( input' 2' ref position' 0' 59' out second ) )  			{  				result = default( Timestamp );  				return TimestampParseResult.InvalidSecond;  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: if ( !ParseDigitRange( input' 2' ref position' 0' 59' out second ) )  			{  				result = default( Timestamp );  				return TimestampParseResult.InvalidSecond;  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: if ( format != "s" )  			{  				// "o" or "O"  				if ( !ParseDelimiter( input' ref position' SubsecondDelimiter ) )  				{  					result = default( Timestamp );  					return TimestampParseResult.InvalidSubsecondDelimiter;  				}    				if ( !ParseDigitRange( input' 9' ref position' 0' 999999999' out nanosecond ) )  				{  					result = default( Timestamp );  					return TimestampParseResult.InvalidNanoSecond;  				}  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: if ( format != "s" )  			{  				// "o" or "O"  				if ( !ParseDelimiter( input' ref position' SubsecondDelimiter ) )  				{  					result = default( Timestamp );  					return TimestampParseResult.InvalidSubsecondDelimiter;  				}    				if ( !ParseDigitRange( input' 9' ref position' 0' 999999999' out nanosecond ) )  				{  					result = default( Timestamp );  					return TimestampParseResult.InvalidNanoSecond;  				}  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,ParseDigit,The following statement contains a magic number: while ( position < input.Length )  			{  				var c = input[ position ];  				if ( !IsDigit( c ) )  				{  					break;  				}    				bits = bits * 10 + ( c - '0' );  				position++;  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,ParseYear,The following statement contains a magic number: if ( !ParseDigit( input' 4' ref position' out digit ) )  			{  				year = default( long );  				return false;  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,ParseDay,The following statement contains a magic number: if ( !ParseDigit( input' 2' ref position' out digit ) )  			{  				day = default( int );  				return false;  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,ToIso8601String,The following statement contains a magic number: var buffer = new StringBuilder( 49 + ( containsNanosecons ? 11 : 1 ) );
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,ToIso8601String,The following statement contains a magic number: var buffer = new StringBuilder( 49 + ( containsNanosecons ? 11 : 1 ) );
Magic Number,MsgPack,Unpacking,C:\repos\msgpack_msgpack-cli\src\MsgPack\Unpacking.cs,UnpackRawLengthCore,The following statement contains a magic number: if ( header == MessagePackCode.NilValue )  			{  				// Nil should be as empty stream because returning byte stream should not be null.  				return 0;  			}  			else if ( MessagePackCode.MinimumFixedRaw <= header && header <= MessagePackCode.MaximumFixedRaw )  			{  				return unchecked( ( uint )( header - MessagePackCode.MinimumFixedRaw ) );  			}  			else if ( header == MessagePackCode.Str8 || header == MessagePackCode.Bin8 )  			{  				var bytes = ReadBytes( source' sizeof( byte ) );  				unchecked  				{  					return bytes[ 0 ];  				}  			}  			else if ( header == MessagePackCode.Raw16 || header == MessagePackCode.Bin16 )  			{  				var bytes = ReadBytes( source' sizeof( short ) );  				unchecked  				{  					ushort buffer = bytes[ 1 ];  					buffer |= ( ushort )( bytes[ 0 ] << 8 );  					return buffer;  				}  			}  			else if ( header == MessagePackCode.Raw32 || header == MessagePackCode.Bin32 )  			{  				var bytes = ReadBytes( source' sizeof( int ) );  				unchecked  				{  					uint buffer = bytes[ 3 ];  					buffer |= ( uint )( bytes[ 2 ] << 8 );  					buffer |= ( uint )( bytes[ 1 ] << 16 );  					buffer |= ( uint )( bytes[ 0 ] << 24 );  					return buffer;  				}  			}  			else  			{  				throw new MessageTypeException( "The underlying stream is not raw type." );  			}
Magic Number,MsgPack,Unpacking,C:\repos\msgpack_msgpack-cli\src\MsgPack\Unpacking.cs,UnpackRawLengthCore,The following statement contains a magic number: if ( header == MessagePackCode.NilValue )  			{  				// Nil should be as empty stream because returning byte stream should not be null.  				return 0;  			}  			else if ( MessagePackCode.MinimumFixedRaw <= header && header <= MessagePackCode.MaximumFixedRaw )  			{  				return unchecked( ( uint )( header - MessagePackCode.MinimumFixedRaw ) );  			}  			else if ( header == MessagePackCode.Str8 || header == MessagePackCode.Bin8 )  			{  				var bytes = ReadBytes( source' sizeof( byte ) );  				unchecked  				{  					return bytes[ 0 ];  				}  			}  			else if ( header == MessagePackCode.Raw16 || header == MessagePackCode.Bin16 )  			{  				var bytes = ReadBytes( source' sizeof( short ) );  				unchecked  				{  					ushort buffer = bytes[ 1 ];  					buffer |= ( ushort )( bytes[ 0 ] << 8 );  					return buffer;  				}  			}  			else if ( header == MessagePackCode.Raw32 || header == MessagePackCode.Bin32 )  			{  				var bytes = ReadBytes( source' sizeof( int ) );  				unchecked  				{  					uint buffer = bytes[ 3 ];  					buffer |= ( uint )( bytes[ 2 ] << 8 );  					buffer |= ( uint )( bytes[ 1 ] << 16 );  					buffer |= ( uint )( bytes[ 0 ] << 24 );  					return buffer;  				}  			}  			else  			{  				throw new MessageTypeException( "The underlying stream is not raw type." );  			}
Magic Number,MsgPack,Unpacking,C:\repos\msgpack_msgpack-cli\src\MsgPack\Unpacking.cs,UnpackRawLengthCore,The following statement contains a magic number: if ( header == MessagePackCode.NilValue )  			{  				// Nil should be as empty stream because returning byte stream should not be null.  				return 0;  			}  			else if ( MessagePackCode.MinimumFixedRaw <= header && header <= MessagePackCode.MaximumFixedRaw )  			{  				return unchecked( ( uint )( header - MessagePackCode.MinimumFixedRaw ) );  			}  			else if ( header == MessagePackCode.Str8 || header == MessagePackCode.Bin8 )  			{  				var bytes = ReadBytes( source' sizeof( byte ) );  				unchecked  				{  					return bytes[ 0 ];  				}  			}  			else if ( header == MessagePackCode.Raw16 || header == MessagePackCode.Bin16 )  			{  				var bytes = ReadBytes( source' sizeof( short ) );  				unchecked  				{  					ushort buffer = bytes[ 1 ];  					buffer |= ( ushort )( bytes[ 0 ] << 8 );  					return buffer;  				}  			}  			else if ( header == MessagePackCode.Raw32 || header == MessagePackCode.Bin32 )  			{  				var bytes = ReadBytes( source' sizeof( int ) );  				unchecked  				{  					uint buffer = bytes[ 3 ];  					buffer |= ( uint )( bytes[ 2 ] << 8 );  					buffer |= ( uint )( bytes[ 1 ] << 16 );  					buffer |= ( uint )( bytes[ 0 ] << 24 );  					return buffer;  				}  			}  			else  			{  				throw new MessageTypeException( "The underlying stream is not raw type." );  			}
Magic Number,MsgPack,Unpacking,C:\repos\msgpack_msgpack-cli\src\MsgPack\Unpacking.cs,UnpackRawLengthCore,The following statement contains a magic number: if ( header == MessagePackCode.NilValue )  			{  				// Nil should be as empty stream because returning byte stream should not be null.  				return 0;  			}  			else if ( MessagePackCode.MinimumFixedRaw <= header && header <= MessagePackCode.MaximumFixedRaw )  			{  				return unchecked( ( uint )( header - MessagePackCode.MinimumFixedRaw ) );  			}  			else if ( header == MessagePackCode.Str8 || header == MessagePackCode.Bin8 )  			{  				var bytes = ReadBytes( source' sizeof( byte ) );  				unchecked  				{  					return bytes[ 0 ];  				}  			}  			else if ( header == MessagePackCode.Raw16 || header == MessagePackCode.Bin16 )  			{  				var bytes = ReadBytes( source' sizeof( short ) );  				unchecked  				{  					ushort buffer = bytes[ 1 ];  					buffer |= ( ushort )( bytes[ 0 ] << 8 );  					return buffer;  				}  			}  			else if ( header == MessagePackCode.Raw32 || header == MessagePackCode.Bin32 )  			{  				var bytes = ReadBytes( source' sizeof( int ) );  				unchecked  				{  					uint buffer = bytes[ 3 ];  					buffer |= ( uint )( bytes[ 2 ] << 8 );  					buffer |= ( uint )( bytes[ 1 ] << 16 );  					buffer |= ( uint )( bytes[ 0 ] << 24 );  					return buffer;  				}  			}  			else  			{  				throw new MessageTypeException( "The underlying stream is not raw type." );  			}
Magic Number,MsgPack,Unpacking,C:\repos\msgpack_msgpack-cli\src\MsgPack\Unpacking.cs,UnpackRawLengthCore,The following statement contains a magic number: if ( header == MessagePackCode.NilValue )  			{  				// Nil should be as empty stream because returning byte stream should not be null.  				return 0;  			}  			else if ( MessagePackCode.MinimumFixedRaw <= header && header <= MessagePackCode.MaximumFixedRaw )  			{  				return unchecked( ( uint )( header - MessagePackCode.MinimumFixedRaw ) );  			}  			else if ( header == MessagePackCode.Str8 || header == MessagePackCode.Bin8 )  			{  				var bytes = ReadBytes( source' sizeof( byte ) );  				unchecked  				{  					return bytes[ 0 ];  				}  			}  			else if ( header == MessagePackCode.Raw16 || header == MessagePackCode.Bin16 )  			{  				var bytes = ReadBytes( source' sizeof( short ) );  				unchecked  				{  					ushort buffer = bytes[ 1 ];  					buffer |= ( ushort )( bytes[ 0 ] << 8 );  					return buffer;  				}  			}  			else if ( header == MessagePackCode.Raw32 || header == MessagePackCode.Bin32 )  			{  				var bytes = ReadBytes( source' sizeof( int ) );  				unchecked  				{  					uint buffer = bytes[ 3 ];  					buffer |= ( uint )( bytes[ 2 ] << 8 );  					buffer |= ( uint )( bytes[ 1 ] << 16 );  					buffer |= ( uint )( bytes[ 0 ] << 24 );  					return buffer;  				}  			}  			else  			{  				throw new MessageTypeException( "The underlying stream is not raw type." );  			}
Magic Number,MsgPack,Unpacking,C:\repos\msgpack_msgpack-cli\src\MsgPack\Unpacking.cs,UnpackRawLengthCore,The following statement contains a magic number: if ( header == MessagePackCode.NilValue )  			{  				// Nil should be as empty stream because returning byte stream should not be null.  				return 0;  			}  			else if ( MessagePackCode.MinimumFixedRaw <= header && header <= MessagePackCode.MaximumFixedRaw )  			{  				return unchecked( ( uint )( header - MessagePackCode.MinimumFixedRaw ) );  			}  			else if ( header == MessagePackCode.Str8 || header == MessagePackCode.Bin8 )  			{  				var bytes = ReadBytes( source' sizeof( byte ) );  				unchecked  				{  					return bytes[ 0 ];  				}  			}  			else if ( header == MessagePackCode.Raw16 || header == MessagePackCode.Bin16 )  			{  				var bytes = ReadBytes( source' sizeof( short ) );  				unchecked  				{  					ushort buffer = bytes[ 1 ];  					buffer |= ( ushort )( bytes[ 0 ] << 8 );  					return buffer;  				}  			}  			else if ( header == MessagePackCode.Raw32 || header == MessagePackCode.Bin32 )  			{  				var bytes = ReadBytes( source' sizeof( int ) );  				unchecked  				{  					uint buffer = bytes[ 3 ];  					buffer |= ( uint )( bytes[ 2 ] << 8 );  					buffer |= ( uint )( bytes[ 1 ] << 16 );  					buffer |= ( uint )( bytes[ 0 ] << 24 );  					return buffer;  				}  			}  			else  			{  				throw new MessageTypeException( "The underlying stream is not raw type." );  			}
Magic Number,MsgPack.Serialization,AotHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack.Unity.Full\Serialization\AotHelper.cs,InitializeEqualityComparerTable,The following statement contains a magic number: var result = new Dictionary<RuntimeTypeHandle' object>( 190 );
Magic Number,MsgPack.Serialization,DefaultConcreteTypeRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultConcreteTypeRepository.cs,DefaultConcreteTypeRepository,The following statement contains a magic number: this._defaultCollectionTypes = new TypeKeyRepository(  				new Dictionary<RuntimeTypeHandle' object>(  #if NET35 || ( SILVERLIGHT && !WINDOWS_PHONE )  					8  #elif NET40  					9  #else  					12  #endif  				)  				{  					{ typeof( IEnumerable<> ).TypeHandle' typeof( List<> ) }'  					{ typeof( ICollection<> ).TypeHandle' typeof( List<> ) }'  					{ typeof( IList<> ).TypeHandle' typeof( List<> ) }'  					{ typeof( IDictionary<'> ).TypeHandle' typeof( Dictionary<'> ) }'  					{ typeof( IEnumerable ).TypeHandle' typeof( List<MessagePackObject> ) }'  					{ typeof( ICollection ).TypeHandle' typeof( List<MessagePackObject> ) }'  					{ typeof( IList ).TypeHandle' typeof( List<MessagePackObject> ) }'  					{ typeof( IDictionary ).TypeHandle' typeof( MessagePackObjectDictionary ) }'  #if !NET35 && !UNITY  					{ typeof( ISet<> ).TypeHandle' typeof( HashSet<> ) }'  #if !NET40 && !( SILVERLIGHT && !WINDOWS_PHONE )  					{ typeof( IReadOnlyCollection<> ).TypeHandle' typeof( List<> ) }'  					{ typeof( IReadOnlyList<> ).TypeHandle' typeof( List<> ) }'  					{ typeof( IReadOnlyDictionary<'> ).TypeHandle' typeof( Dictionary<'> ) }'  #endif // !NET40 && !( SILVERLIGHT && !WINDOWS_PHONE )  #endif // !NET35 && !UNITY  				}  			);
Magic Number,MsgPack.Serialization,ExtTypeCodeMapping,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ExtTypeCodeMapping.cs,ExtTypeCodeMapping,The following statement contains a magic number: this._index = new Dictionary<string' byte>( 2 );
Magic Number,MsgPack.Serialization,ExtTypeCodeMapping,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ExtTypeCodeMapping.cs,ExtTypeCodeMapping,The following statement contains a magic number: this._types = new Dictionary<byte' string>( 2 );
Magic Number,MsgPack.Serialization,KeyNameTransformers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\KeyNameTransformers.cs,ToUpperSnake,The following statement contains a magic number: var buffer = new StringBuilder( mayBeUpperCamel.Length * 2 );
Magic Number,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following statement contains a magic number: const int withCapacity = 10;
Magic Number,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following statement contains a magic number: const int withComparer = 11;
Magic Number,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following statement contains a magic number: const int withComparerAndCapacity = 20;
Magic Number,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following statement contains a magic number: const int withCapacityAndComparer = 21;
Magic Number,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following statement contains a magic number: foreach ( var candidate in instanceType.GetConstructors() )  			{  				var parameters = candidate.GetParameters();  				switch ( parameters.Length )  				{  					case 0:  					{  						if ( currentScore < noParameters )  						{  							constructor = candidate;  							currentScore = noParameters;  						}    						break;  					}  					case 1:  					{  						if ( currentScore < withCapacity && parameters[ 0 ].ParameterType == typeof( int ) )  						{  							constructor = candidate;  							currentScore = noParameters;  						}  						else if ( currentScore < withComparer && IsIEqualityComparer( parameters[ 0 ].ParameterType ) )  						{  							constructor = candidate;  							currentScore = noParameters;  						}  						break;  					}  					case 2:  					{  						if ( currentScore < withCapacityAndComparer && parameters[ 0 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 1 ].ParameterType ) )  						{  							constructor = candidate;  							currentScore = withCapacityAndComparer;  						}  						else if ( currentScore < withComparerAndCapacity && parameters[ 1 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 0 ].ParameterType ) )  						{  							constructor = candidate;  							currentScore = withComparerAndCapacity;  						}    						break;  					}  				}  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,ArraySerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\ArraySerializer.cs,InitializeArraySerializerFactories,The following statement contains a magic number: return  				new Dictionary<Type' Func<SerializationContext'object>>( 25 )  				{  					{ typeof( SByte[] )' context => new SByteArraySerializer( context ) }'  					{ typeof( SByte?[] )'context => new NullableSByteArraySerializer( context ) }'  					{ typeof( Int16[] )' context => new Int16ArraySerializer( context ) }'  					{ typeof( Int16?[] )'context => new NullableInt16ArraySerializer( context ) }'  					{ typeof( Int32[] )' context => new Int32ArraySerializer( context ) }'  					{ typeof( Int32?[] )'context => new NullableInt32ArraySerializer( context ) }'  					{ typeof( Int64[] )' context => new Int64ArraySerializer( context ) }'  					{ typeof( Int64?[] )'context => new NullableInt64ArraySerializer( context ) }'  					{ typeof( Byte[] )' context => new ByteArraySerializer( context ) }'  					{ typeof( Byte?[] )'context => new NullableByteArraySerializer( context ) }'  					{ typeof( UInt16[] )' context => new UInt16ArraySerializer( context ) }'  					{ typeof( UInt16?[] )'context => new NullableUInt16ArraySerializer( context ) }'  					{ typeof( UInt32[] )' context => new UInt32ArraySerializer( context ) }'  					{ typeof( UInt32?[] )'context => new NullableUInt32ArraySerializer( context ) }'  					{ typeof( UInt64[] )' context => new UInt64ArraySerializer( context ) }'  					{ typeof( UInt64?[] )'context => new NullableUInt64ArraySerializer( context ) }'  					{ typeof( Single[] )' context => new SingleArraySerializer( context ) }'  					{ typeof( Single?[] )'context => new NullableSingleArraySerializer( context ) }'  					{ typeof( Double[] )' context => new DoubleArraySerializer( context ) }'  					{ typeof( Double?[] )'context => new NullableDoubleArraySerializer( context ) }'  					{ typeof( Boolean[] )' context => new BooleanArraySerializer( context ) }'  					{ typeof( Boolean?[] )'context => new NullableBooleanArraySerializer( context ) }'  					{ typeof( string[] )' context => new StringArraySerializer( context ) }'  					{ typeof( byte[][] )' context => new BinaryArraySerializer( context ) }'  					{ typeof( MessagePackObject[] )' context => new MessagePackObjectArraySerializer( context ) }'  				};
Magic Number,MsgPack.Serialization.DefaultSerializers,DateTimeOffsetMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DateTimeOffsetMessagePackSerializer.cs,PackToCore,The following statement contains a magic number: if ( this._conversion == DateTimeConversionMethod.Timestamp )  			{  				packer.Pack( Timestamp.FromDateTimeOffset( objectTree ).Encode() );  			}  			else if ( this._conversion == DateTimeConversionMethod.Native )  			{  				packer.PackArrayHeader( 2 );  				packer.Pack( objectTree.DateTime.ToBinary() );  				unchecked  				{  					packer.Pack( ( short )( objectTree.Offset.Hours * 60 + objectTree.Offset.Minutes ) );  				}  			}  			else  			{  #if DEBUG  				Contract.Assert( this._conversion == DateTimeConversionMethod.UnixEpoc );  #endif // DEBUG  				packer.Pack( MessagePackConvert.FromDateTimeOffset( objectTree ) );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,DateTimeOffsetMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DateTimeOffsetMessagePackSerializer.cs,PackToCore,The following statement contains a magic number: if ( this._conversion == DateTimeConversionMethod.Timestamp )  			{  				packer.Pack( Timestamp.FromDateTimeOffset( objectTree ).Encode() );  			}  			else if ( this._conversion == DateTimeConversionMethod.Native )  			{  				packer.PackArrayHeader( 2 );  				packer.Pack( objectTree.DateTime.ToBinary() );  				unchecked  				{  					packer.Pack( ( short )( objectTree.Offset.Hours * 60 + objectTree.Offset.Minutes ) );  				}  			}  			else  			{  #if DEBUG  				Contract.Assert( this._conversion == DateTimeConversionMethod.UnixEpoc );  #endif // DEBUG  				packer.Pack( MessagePackConvert.FromDateTimeOffset( objectTree ) );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,DateTimeOffsetMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DateTimeOffsetMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: if ( unpacker.LastReadData.IsTypeOf<MessagePackExtendedTypeObject>().GetValueOrDefault() )  			{  				return Timestamp.Decode( unpacker.LastReadData.DeserializeAsMessagePackExtendedTypeObject() ).ToDateTimeOffset();  			}  			else if ( unpacker.IsArrayHeader )  			{  				if ( UnpackHelpers.GetItemsCount( unpacker ) != 2 )  				{  					SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( DateTimeOffset )' 2 );  				}    				long ticks;  				if ( !unpacker.ReadInt64( out ticks ) )  				{  					SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  				}    				short offsetMinutes;  				if ( !unpacker.ReadInt16( out offsetMinutes ) )  				{  					SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  				}    				return new DateTimeOffset( DateTime.FromBinary( ticks )' TimeSpan.FromMinutes( offsetMinutes ) );  			}  			else  			{  				return MessagePackConvert.ToDateTimeOffset( unpacker.LastReadData.DeserializeAsInt64() );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,DateTimeOffsetMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DateTimeOffsetMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: if ( unpacker.LastReadData.IsTypeOf<MessagePackExtendedTypeObject>().GetValueOrDefault() )  			{  				return Timestamp.Decode( unpacker.LastReadData.DeserializeAsMessagePackExtendedTypeObject() ).ToDateTimeOffset();  			}  			else if ( unpacker.IsArrayHeader )  			{  				if ( UnpackHelpers.GetItemsCount( unpacker ) != 2 )  				{  					SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( DateTimeOffset )' 2 );  				}    				long ticks;  				if ( !unpacker.ReadInt64( out ticks ) )  				{  					SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  				}    				short offsetMinutes;  				if ( !unpacker.ReadInt16( out offsetMinutes ) )  				{  					SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  				}    				return new DateTimeOffset( DateTime.FromBinary( ticks )' TimeSpan.FromMinutes( offsetMinutes ) );  			}  			else  			{  				return MessagePackConvert.ToDateTimeOffset( unpacker.LastReadData.DeserializeAsInt64() );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,UnityMultidimensionalArraySerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,PackArrayCore,The following statement contains a magic number: packer.PackArrayHeader( 2 );
Magic Number,MsgPack.Serialization.DefaultSerializers,UnityMultidimensionalArraySerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,PackArrayCore,The following statement contains a magic number: using ( var buffer = new MemoryStream() )  			using ( var bodyPacker = Packer.Create( buffer' false ) )  			{  				bodyPacker.PackArrayHeader( 2 );  				this._int32ArraySerializer.PackTo( bodyPacker' lengths );  				this._int32ArraySerializer.PackTo( bodyPacker' lowerBounds );  				packer.PackExtendedTypeValue( this.OwnerContext.ExtTypeCodeMapping[ KnownExtTypeName.MultidimensionalArray ]' buffer.ToArray() );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,UnityMultidimensionalArraySerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,UnpackFromCore,The following statement contains a magic number: if ( UnpackHelpers.GetItemsCount( unpacker ) != 2 )  			{  				SerializationExceptions.ThrowSerializationException( "Multidimensional array must be encoded as 2 element array." );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,UnityMultidimensionalArraySerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,UnpackFromCore,The following statement contains a magic number: using ( var wholeUnpacker = unpacker.ReadSubtree() )  			{  				if ( !wholeUnpacker.Read() )  				{  					SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  				}    				MessagePackExtendedTypeObject metadata;  				try  				{  					metadata = wholeUnpacker.LastReadData.AsMessagePackExtendedTypeObject();  				}  				catch ( InvalidOperationException ex )  				{  					SerializationExceptions.ThrowSerializationException( "Multidimensional array must be encoded as ext type."' ex );  					metadata = default ( MessagePackExtendedTypeObject ); // never reaches  				}    				if ( metadata.TypeCode != this.OwnerContext.ExtTypeCodeMapping[ KnownExtTypeName.MultidimensionalArray ] )  				{  					SerializationExceptions.ThrowSerializationException(  						String.Format(  							CultureInfo.CurrentCulture'  							"Multidimensional array must be encoded as ext type 0x{0:X2}."'  							this.OwnerContext.ExtTypeCodeMapping[ KnownExtTypeName.MultidimensionalArray ]  							)  						);  				}    				int[] lengths' lowerBounds;    				using ( var arrayMetadata = new MemoryStream( metadata.Body ) )  				using ( var metadataUnpacker = Unpacker.Create( arrayMetadata' false ) )  				{  					if ( !metadataUnpacker.Read() )  					{  						SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  					}    					if ( !metadataUnpacker.IsArrayHeader )  					{  						SerializationExceptions.ThrowIsNotArrayHeader( unpacker );  					}    					if ( UnpackHelpers.GetItemsCount( metadataUnpacker ) != 2 )  					{  						SerializationExceptions.ThrowSerializationException( "Multidimensional metadata array must be encoded as 2 element array." );  					}    					this.ReadArrayMetadata( metadataUnpacker' out lengths' out lowerBounds );  				}    #if SILVERLIGHT  				// Simulate lowerbounds because Array.Initialize() in Silverlight does not support lowerbounds.  				var inflatedLengths = new int[ lengths.Length ];  				for ( var i = 0; i < lowerBounds.Length; i++ )  				{  					inflatedLengths[ i ] = lengths[ i ] + lowerBounds[ i ];  				}    #endif // SILVERLIGHT  				if ( !wholeUnpacker.Read() )  				{  					SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  				}    				if ( !wholeUnpacker.IsArrayHeader )  				{  					SerializationExceptions.ThrowIsNotArrayHeader( unpacker );  				}    				using ( var arrayUnpacker = wholeUnpacker.ReadSubtree() )  				{  					var result =  						Array.CreateInstance(  #if !UNITY  							typeof( TItem )'  #else  							this._itemType'  #endif // !UNITY  #if !SILVERLIGHT  							lengths'  							lowerBounds  #else  							inflatedLengths  #endif // !SILVERLIGHT  						);    					var totalLength = UnpackHelpers.GetItemsCount( arrayUnpacker );  					if ( totalLength > 0 )  					{  						ForEach(  							result'  							totalLength'  							lowerBounds'  							lengths'  							indices =>  							{  								// ReSharper disable AccessToDisposedClosure  								if ( !arrayUnpacker.Read() )  								{  									SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  								}    								result.SetValue(  									this._itemSerializer.UnpackFrom( arrayUnpacker )'  									indices  								);  								// ReSharper restore AccessToDisposedClosure  							}  						);  					}    #if !UNITY  					return ( TArray ) ( object ) result;  #else  					return result;  #endif // !UNITY  				}  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Collections_DictionaryEntryMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_DictionaryEntryMessagePackSerializer.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 2 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Collections_Generic_KeyValuePair_2MessagePackSerializer<TKey;TValue>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_Generic_KeyValuePair_2MessagePackSerializer`2.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 2 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.IsArrayHeader )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Version )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: if ( length != 4 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Version )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: if ( length != 4 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Version )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadInt32( out build ) )  			{  				SerializationExceptions.ThrowMissingItem( 2' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadInt32( out revision ) )  			{  				SerializationExceptions.ThrowMissingItem( 3' unpacker );  			}
Magic Number,MsgPack.Serialization.Polymorphic,RuntimeTypeVerifier,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\RuntimeTypeVerifier.cs,VerifyCore,The following statement contains a magic number: try  			{  				int count = _resultCache.Count;  				_resultCache[ key ] = result;  				if ( count < _resultCache.Count && CacheSize < _resultCache.Count )  				{  					// Added. Start eviction.  					var removalKey = _histories.Dequeue();  					var removed = _resultCache.Remove( removalKey );  #if ASSERT  					Contract.Assert( removed );  #endif // ASSERT  				}    #if ASSERT  				Contract.Assert( _histories.Count < 1000 );  #endif // ASSERT  				_histories.Enqueue( key );  			}  			finally  			{  				_resultCacheLock.ExitWriteLock();  			}
Magic Number,MsgPack.Serialization.Polymorphic,Queue<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\RuntimeTypeVerifier.cs,Enqueue,The following statement contains a magic number: if ( _size == _array.Length )  				{  					int newcapacity = (int)((long)_array.Length * (long)GrowFactor / 100);  					if ( newcapacity < _array.Length + MinimumGrow )  					{  						newcapacity = _array.Length + MinimumGrow;  					}  					SetCapacity( newcapacity );  				}
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: packer.PackArrayHeader( 2 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: packer.PackArrayHeader( 2 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: packer.PackArrayHeader( 6 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: var version = new byte[ 16 ];
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Major )' 0' version' 0' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Minor )' 0' version' 4' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Minor )' 0' version' 4' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Build )' 0' version' 8' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Build )' 0' version' 8' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Revision )' 0' version' 12' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Revision )' 0' version' 12' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Decode,The following statement contains a magic number: if ( !unpacker.IsArrayHeader || UnpackHelpers.GetItemsCount( unpacker ) != 2 )  			{  				throw SerializationExceptions.NewUnknownTypeEmbedding();  			}
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Decode,The following statement contains a magic number: if ( !unpacker.IsArrayHeader || UnpackHelpers.GetItemsCount( unpacker ) != 2 )  			{  				throw SerializationExceptions.NewUnknownTypeEmbedding();  			}
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,CheckUnpackerForRuntimeTypeInfoDecoding,The following statement contains a magic number: if ( unpacker.ItemsCount != 6 )  			{  				ThrowEncodedTypeDoesNotHaveValidArrayItems();  			}
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,BuildAssemblyName,The following statement contains a magic number: var assemblyName =  				new AssemblyName  				{  					Name = assemblySimpleName'  					Version =  						new Version(  							BitConverter.ToInt32( version' 0 )'  							BitConverter.ToInt32( version' 4 )'  							BitConverter.ToInt32( version' 8 )'  							BitConverter.ToInt32( version' 12 )  						)'  					CultureInfo =  						String.IsNullOrEmpty( culture )  							? null  #if !SILVERLIGHT  							: CultureInfo.GetCultureInfo( culture )'  #else  							: new CultureInfo( culture )'  #endif //  !SILVERLIGHT  				};
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,BuildAssemblyName,The following statement contains a magic number: var assemblyName =  				new AssemblyName  				{  					Name = assemblySimpleName'  					Version =  						new Version(  							BitConverter.ToInt32( version' 0 )'  							BitConverter.ToInt32( version' 4 )'  							BitConverter.ToInt32( version' 8 )'  							BitConverter.ToInt32( version' 12 )  						)'  					CultureInfo =  						String.IsNullOrEmpty( culture )  							? null  #if !SILVERLIGHT  							: CultureInfo.GetCultureInfo( culture )'  #else  							: new CultureInfo( culture )'  #endif //  !SILVERLIGHT  				};
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,BuildAssemblyName,The following statement contains a magic number: var assemblyName =  				new AssemblyName  				{  					Name = assemblySimpleName'  					Version =  						new Version(  							BitConverter.ToInt32( version' 0 )'  							BitConverter.ToInt32( version' 4 )'  							BitConverter.ToInt32( version' 8 )'  							BitConverter.ToInt32( version' 12 )  						)'  					CultureInfo =  						String.IsNullOrEmpty( culture )  							? null  #if !SILVERLIGHT  							: CultureInfo.GetCultureInfo( culture )'  #else  							: new CultureInfo( culture )'  #endif //  !SILVERLIGHT  				};
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackAndAddCollectionItem,The following statement contains a magic number: if ( source != null )  			{  				switch ( traits.DetailedCollectionType )  				{  					case CollectionDetailedKind.GenericDictionary:  					{  						// item should be KeyValuePair<TKey' TValue>  						var arguments = new object[ 2 ];  						var key = default( PropertyInfo );  						var value = default( PropertyInfo );  						foreach ( var item in source )  						{  							if ( key == null )  							{  								key = item.GetType().GetProperty( "Key" );  								value = item.GetType().GetProperty( "Value" );  							}    							arguments[ 0 ] = key.GetValue( item' null );  							arguments[ 1 ] = value.GetValue( item' null );  							traits.AddMethod.InvokePreservingExceptionType( destination' arguments );  						}  						break;  					}  					case CollectionDetailedKind.NonGenericDictionary:  					{  						// item should be DictionaryEntry  						var arguments = new object[ 2 ];  						foreach ( var item in source )  						{  							arguments[ 0 ] = ReflectionSerializerHelper.DictionaryEntryKeyProperty.GetValue( item' null );  							arguments[ 1 ] = ReflectionSerializerHelper.DictionaryEntryValueProperty.GetValue( item' null );  							traits.AddMethod.InvokePreservingExceptionType( destination' arguments );  						}  						break;  					}  					default:  					{  						var arguments = new object[ 1 ];  						foreach ( var item in source )  						{  							arguments[ 0 ] = item;  							traits.AddMethod.InvokePreservingExceptionType( destination' arguments );  						}  						break;  					}  				}  			}
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackAndAddCollectionItem,The following statement contains a magic number: if ( source != null )  			{  				switch ( traits.DetailedCollectionType )  				{  					case CollectionDetailedKind.GenericDictionary:  					{  						// item should be KeyValuePair<TKey' TValue>  						var arguments = new object[ 2 ];  						var key = default( PropertyInfo );  						var value = default( PropertyInfo );  						foreach ( var item in source )  						{  							if ( key == null )  							{  								key = item.GetType().GetProperty( "Key" );  								value = item.GetType().GetProperty( "Value" );  							}    							arguments[ 0 ] = key.GetValue( item' null );  							arguments[ 1 ] = value.GetValue( item' null );  							traits.AddMethod.InvokePreservingExceptionType( destination' arguments );  						}  						break;  					}  					case CollectionDetailedKind.NonGenericDictionary:  					{  						// item should be DictionaryEntry  						var arguments = new object[ 2 ];  						foreach ( var item in source )  						{  							arguments[ 0 ] = ReflectionSerializerHelper.DictionaryEntryKeyProperty.GetValue( item' null );  							arguments[ 1 ] = ReflectionSerializerHelper.DictionaryEntryValueProperty.GetValue( item' null );  							traits.AddMethod.InvokePreservingExceptionType( destination' arguments );  						}  						break;  					}  					default:  					{  						var arguments = new object[ 1 ];  						foreach ( var item in source )  						{  							arguments[ 0 ] = item;  							traits.AddMethod.InvokePreservingExceptionType( destination' arguments );  						}  						break;  					}  				}  			}
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,CreateCollectionInstanceFactory,The following statement contains a magic number: switch ( parameters.Length )  			{  				case 0:  				{  					return _ =>  #if !UNITY  						( T )  #endif // !UNITY  						constructor.InvokePreservingExceptionType();  				}  				case 1:  				{  					if ( parameters[ 0 ].ParameterType == typeof( int ) )  					{  						return capacity =>  #if !UNITY  							( T )  #endif // !UNITY  							constructor.InvokePreservingExceptionType( capacity );  					}  					else if ( UnpackHelpers.IsIEqualityComparer( parameters[ 0 ].ParameterType ) )  					{  						var comparer =   #if !UNITY  							EqualityComparer<TKey>.Default;  #else  							UnpackHelpers.GetEqualityComparer( comparisonType );  #endif // !UNITY  						return _ =>  #if !UNITY  							( T )  #endif // !UNITY  							constructor.InvokePreservingExceptionType( comparer );  					}    					break;  				}  				case 2:  				{  					var comparer =  #if !UNITY  						EqualityComparer<TKey>.Default;  #else  						UnpackHelpers.GetEqualityComparer( comparisonType );  #endif // !UNITY  					if ( parameters[ 0 ].ParameterType == typeof( int )  						&& UnpackHelpers.IsIEqualityComparer( parameters[ 1 ].ParameterType ) )  					{  						return capacity =>  #if !UNITY  							( T )  #endif // !UNITY  							constructor.InvokePreservingExceptionType( capacity' comparer );  					}  					else if ( UnpackHelpers.IsIEqualityComparer( parameters[ 0 ].ParameterType ) &&  							parameters[ 0 ].ParameterType == typeof( int ) )  					{  						return capacity =>  #if !UNITY  							( T )  #endif // !UNITY  							constructor.InvokePreservingExceptionType( comparer' capacity );  					}    					break;  				}  			}
Magic Number,System.Runtime.CompilerServices,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following statement contains a magic number: const int withCapacity = 10;
Magic Number,System.Runtime.CompilerServices,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following statement contains a magic number: const int withComparer = 11;
Magic Number,System.Runtime.CompilerServices,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following statement contains a magic number: const int withComparerAndCapacity = 20;
Magic Number,System.Runtime.CompilerServices,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following statement contains a magic number: const int withCapacityAndComparer = 21;
Magic Number,System.Runtime.CompilerServices,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following statement contains a magic number: foreach ( var candidate in instanceType.GetConstructors() )  			{  				var parameters = candidate.GetParameters();  				switch ( parameters.Length )  				{  					case 0:  					{  						if ( currentScore < noParameters )  						{  							constructor = candidate;  							currentScore = noParameters;  						}    						break;  					}  					case 1:  					{  						if ( currentScore < withCapacity && parameters[ 0 ].ParameterType == typeof( int ) )  						{  							constructor = candidate;  							currentScore = noParameters;  						}  						else if ( currentScore < withComparer && IsIEqualityComparer( parameters[ 0 ].ParameterType ) )  						{  							constructor = candidate;  							currentScore = noParameters;  						}  						break;  					}  					case 2:  					{  						if ( currentScore < withCapacityAndComparer && parameters[ 0 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 1 ].ParameterType ) )  						{  							constructor = candidate;  							currentScore = withCapacityAndComparer;  						}  						else if ( currentScore < withComparerAndCapacity && parameters[ 1 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 0 ].ParameterType ) )  						{  							constructor = candidate;  							currentScore = withComparerAndCapacity;  						}    						break;  					}  				}  			}
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinary,The method contains a code clone-set at the following line numbers (starting from the method definition): ((57' 91)' (105' 139))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadString,The method contains a code clone-set at the following line numbers (starting from the method definition): ((57' 91)' (105' 139))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((6' 44)' (116' 154)' (245' 283)' (385' 423)' (500' 538)' (643' 681))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((6' 48)' (643' 685)' (116' 158)' (245' 287))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((11' 30)' (56' 75)' (121' 140)' (175' 194)' (250' 269)' (304' 323)' (390' 409)' (442' 461)' (505' 524)' (549' 568)' (593' 612)' (648' 667)' (692' 711)' (736' 755)' (780' 799)' (824' 843))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((11' 44)' (56' 89)' (175' 208)' (304' 337)' (442' 475)' (549' 582)' (593' 626)' (692' 725)' (736' 769)' (780' 813)' (824' 857)' (121' 154)' (250' 283)' (390' 423)' (505' 538)' (648' 681))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((56' 93)' (692' 729)' (175' 212)' (304' 341))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((121' 155)' (175' 209)' (304' 338)' (250' 284))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((51' 74)' (170' 193)' (299' 322)' (437' 460)' (544' 567)' (687' 710)' (775' 798))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((588' 611)' (731' 754)' (819' 842))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLength,The method contains a code clone-set at the following line numbers (starting from the method definition): ((48' 82)' (96' 130))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLength,The method contains a code clone-set at the following line numbers (starting from the method definition): ((48' 82)' (96' 130))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObject,The method contains a code clone-set at the following line numbers (starting from the method definition): ((48' 82)' (96' 130))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The method contains a code clone-set at the following line numbers (starting from the method definition): ((53' 87)' (101' 135))
Missing Default,MsgPack,MessagePackCode,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackCode.cs,ToString,The following switch statement is missing a default case: switch( code )  			{  				case 0xC0:  				{  					return "Nil";  				}  				case 0xC3:  				{  					return "True";  				}  				case 0xD0:  				{  					return "SingnedInt8";  				}  				case 0xCC:  				{  					return "UnsignedInt8";  				}  				case 0xD1:  				{  					return "SignedInt16";  				}  				case 0xCD:  				{  					return "UnsignedInt16";  				}  				case 0xD2:  				{  					return "SignedInt32";  				}  				case 0xCE:  				{  					return "UnsignedInt32";  				}  				case 0xD3:  				{  					return "SignedInt64";  				}  				case 0xCF:  				{  					return "UnsignedInt64";  				}  				case 0xCA:  				{  					return "Real32";  				}  				case 0xCB:  				{  					return "Real64";  				}  				case 0xDC:  				{  					return "Array16";  				}  				case 0xDD:  				{  					return "Array32";  				}  				case 0xDE:  				{  					return "Map16";  				}  				case 0xDF:  				{  					return "Map32";  				}  				case 0xDA:  				{  					return "Raw16";  				}  				case 0xDB:  				{  					return "Raw32";  				}  			}
Missing Default,MsgPack,MessagePackCode,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackCode.cs,ToString,The following switch statement is missing a default case: switch( ( code & 0xF0))  			{  				case 0x80:  				{  					return "FixedMap";  				}  				case 0x90:  				{  					return "FixedArray";  				}  				case 0xA0:  				case 0xB0:  				{  					return "FixedRaw";  				}  			}
Missing Default,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,IsTypeOf,The following switch statement is missing a default case: switch ( Type.GetTypeCode( type ) )  #endif // NETSTANDARD1_1 || NETSTANDARD1_3  			{  				case TypeCode.SByte:  				{  					return typeCode.IsInteger && ( this._value < 0x80 || ( 0xFFFFFFFFFFFFFF80 <= this._value && typeCode.IsSigned ) );  				}  				case TypeCode.Byte:  				{  					return typeCode.IsInteger && this._value < 0x100;  				}  				case TypeCode.Int16:  				{  					return typeCode.IsInteger && ( this._value < 0x8000 || ( 0xFFFFFFFFFFFF8000 <= this._value && typeCode.IsSigned ) );  				}  				case TypeCode.UInt16:  				{  					return typeCode.IsInteger && this._value < 0x10000;  				}  				case TypeCode.Int32:  				{  					return typeCode.IsInteger && ( this._value < 0x80000000 || ( 0xFFFFFFFF80000000 <= this._value && typeCode.IsSigned ) );  				}  				case TypeCode.UInt32:  				{  					return typeCode.IsInteger && this._value < 0x100000000L;  				}  				case TypeCode.Int64:  				{  					return typeCode.IsInteger && ( this._value < 0x8000000000000000L || typeCode.IsSigned );  				}  				case TypeCode.UInt64:  				{  					return typeCode.IsInteger && ( this._value < 0x8000000000000000L || !typeCode.IsSigned );  				}  				case TypeCode.Double:  				{  					return  						typeCode.Type == typeof( float )  						|| typeCode.Type == typeof( double );  				}  			}
Missing Default,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following switch statement is missing a default case: switch ( source )  			{  				case ReadValueResult.Nil:  				{  					return ( byte )MessagePackCode.NilValue;  				}  				case ReadValueResult.True:  				{  					return ( byte )MessagePackCode.TrueValue;  				}  				case ReadValueResult.False:  				{  					return ( byte )MessagePackCode.FalseValue;  				}  				case ReadValueResult.InvalidCode:  				{  					return 0xC1;  				}  			}
Missing Default,MsgPack,StringEscape,C:\repos\msgpack_msgpack-cli\src\MsgPack\StringEscape.cs,ForDisplay,The following switch statement is missing a default case: switch ( c )  				{  					case '\0':  					{  						buffer.Append( "\\0" );  						continue;  					}  					case '\t':  					{  						buffer.Append( "\\t" );  						continue;  					}  					case '\r':  					{  						buffer.Append( "\\r" );  						continue;  					}  					case '\n':  					{  						buffer.Append( "\\n" );  						continue;  					}  					case '\a':  					{  						buffer.Append( "\\a" );  						continue;  					}  					case '\b':  					{  						buffer.Append( "\\b" );  						continue;  					}  					case '\f':  					{  						buffer.Append( "\\f" );  						continue;  					}  					case '\v':  					{  						buffer.Append( "\\v" );  						continue;  					}  				}
Missing Default,MsgPack,SeekableUnpackingStream,C:\repos\msgpack_msgpack-cli\src\MsgPack\Unpacking.Streaming.cs,Seek,The following switch statement is missing a default case: switch ( origin )  				{  					case SeekOrigin.Begin:  					{  						this.SeekTo( offset );  						break;  					}  					case SeekOrigin.End:  					{  						this.SeekTo( this.RawLength + offset );  						break;  					}  					case SeekOrigin.Current:  					{  						this.SeekTo( this.Position + offset );  						break;  					}  				}
Missing Default,MsgPack.Serialization,EnumMessagePackSerializerProvider,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EnumMessagePackSerializerProvider.cs,Get,The following switch statement is missing a default case: switch ( ( EnumSerializationMethod )providerParameter )  				{  					case EnumSerializationMethod.ByName:  					{  						return this._serializerForName;  					}  					case EnumSerializationMethod.ByUnderlyingValue:  					{  						return this._serializerForIntegral;  					}  				}
Missing Default,MsgPack.Serialization,NilImplicationHandler<TAction;TCondition;TPackingParameter;TUnpackedParameter>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\NilImplicationHandler`4.cs,OnPacking,The following switch statement is missing a default case: switch ( nilImplication )  			{  				case NilImplication.Prohibit:  				{  					TCondition condition = null;  					if ( parameter.ItemType == typeof( MessagePackObject ) )  					{  						condition = this.OnPackingMessagePackObject( parameter );  					}  					else if ( !parameter.ItemType.GetIsValueType() )  					{  						condition = this.OnPackingReferenceTypeObject( parameter );  					}  					else if ( Nullable.GetUnderlyingType( parameter.ItemType ) != null )  					{  						condition = this.OnPackingNullableValueTypeObject( parameter );  					}    					if ( condition != null )  					{  						return this.OnPackingCore( parameter' condition );  					}    					break;  				}  			}
Missing Default,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,ToDebugString,The following switch statement is missing a default case: switch ( this.ChildrenType )  			{  				case PolymorphismSchemaChildrenType.CollectionItems:  				{  					buffer.Append( "' CollectionItemsSchema:" );  					if ( this.ItemSchema == null )  					{  						buffer.Append( "null" );  					}  					else  					{  						this.ItemSchema.ToDebugString( buffer );  					}    					break;  				}  				case PolymorphismSchemaChildrenType.DictionaryKeyValues:  				{  					buffer.Append( "' DictinoaryKeysSchema:" );  					if ( this.KeySchema == null )  					{  						buffer.Append( "null" );  					}  					else  					{  						this.KeySchema.ToDebugString( buffer );  					}    					buffer.Append( "' DictinoaryValuesSchema:" );  					if ( this.ItemSchema == null )  					{  						buffer.Append( "null" );  					}  					else  					{  						this.ItemSchema.ToDebugString( buffer );  					}    					break;  				}  #if !NET35 && !UNITY  				case PolymorphismSchemaChildrenType.TupleItems:  				{  					buffer.Append( "' TupleItemsSchema:[" );  					var isFirst = true;  					foreach ( var child in this._children )  					{  						if ( isFirst )  						{  							isFirst = false;  						}  						else  						{  							buffer.Append( "' " );  						}    						if ( child == null )  						{  							buffer.Append( "null" );  						}  						else  						{  							child.ToDebugString( buffer );  						}  					}    					break;  				}  #endif // !NET35 && !UNITY  			}
Missing Default,MsgPack.Serialization,TypeTableEntry,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,SetDefault,The following switch statement is missing a default case: switch ( defaultSchema.PolymorphismType )  				{  					case PolymorphismType.KnownTypes:  					{  						foreach ( var typeMapping in defaultSchema.CodeTypeMapping )  						{  							this.SetKnownType( target' memberName' tupleItemNumber' typeMapping.Key' typeMapping.Value );  						}    						break;  					}  					case PolymorphismType.RuntimeType:  					{  						this.SetRuntimeType( target' memberName' tupleItemNumber' defaultSchema.TypeVerifier );  						break;  					}  				}
Missing Default,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following switch statement is missing a default case: switch ( parameters.Length )  				{  					case 0:  					{  						if ( currentScore < noParameters )  						{  							constructor = candidate;  							currentScore = noParameters;  						}    						break;  					}  					case 1:  					{  						if ( currentScore < withCapacity && parameters[ 0 ].ParameterType == typeof( int ) )  						{  							constructor = candidate;  							currentScore = noParameters;  						}  						else if ( currentScore < withComparer && IsIEqualityComparer( parameters[ 0 ].ParameterType ) )  						{  							constructor = candidate;  							currentScore = noParameters;  						}  						break;  					}  					case 2:  					{  						if ( currentScore < withCapacityAndComparer && parameters[ 0 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 1 ].ParameterType ) )  						{  							constructor = candidate;  							currentScore = withCapacityAndComparer;  						}  						else if ( currentScore < withComparerAndCapacity && parameters[ 1 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 0 ].ParameterType ) )  						{  							constructor = candidate;  							currentScore = withComparerAndCapacity;  						}    						break;  					}  				}
Missing Default,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValueCore,The following switch statement is missing a default case: switch ( nilImplication )  				{  					case NilImplication.Prohibit:  					{  						SerializationExceptions.ThrowNullIsProhibited( memberName );  						break;  					}  					case NilImplication.MemberDefault:  					{  						return;  					}  				}
Missing Default,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValueCore,The following switch statement is missing a default case: switch ( nilImplication )  				{  					case NilImplication.Prohibit:  					{  						SerializationExceptions.ThrowNullIsProhibited( memberName );  						break;  					}  					case NilImplication.MemberDefault:  					{  						return;  					}  				}
Missing Default,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMessagePackObjectValueCore,The following switch statement is missing a default case: switch ( nilImplication )  				{  					case NilImplication.Prohibit:  					{  						SerializationExceptions.ThrowNullIsProhibited( memberName );  						break;  					}  					case NilImplication.MemberDefault:  					{  						return;  					}  				}
Missing Default,MsgPack.Serialization.DefaultSerializers,DateTimeMessagePackSerializerProvider,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DateTimeMessagePackSerializerProvider.cs,Get,The following switch statement is missing a default case: switch ( ( DateTimeConversionMethod )providerParameter )  				{  					case DateTimeConversionMethod.Native:  					{  						return this._native;  					}  					case DateTimeConversionMethod.UnixEpoc:  					{  						return this._unixEpoc;  					}  					case DateTimeConversionMethod.Timestamp:  					{  						return this._timestamp;  					}  				}
Missing Default,MsgPack.Serialization.DefaultSerializers,DateTimeOffsetMessagePackSerializerProvider,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DateTimeOffsetMessagePackSerializerProvider.cs,Get,The following switch statement is missing a default case: switch ( ( DateTimeConversionMethod )providerParameter )  				{  					case DateTimeConversionMethod.Native:  					{  						return this._native;  					}  					case DateTimeConversionMethod.UnixEpoc:  					{  						return this._unixEpoc;  					}  					case DateTimeConversionMethod.Timestamp:  					{  						return this._timestamp;  					}  				}
Missing Default,MsgPack.Serialization.DefaultSerializers,System_Collections_DictionaryEntryMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_DictionaryEntryMessagePackSerializer.cs,UnpackFromCore,The following switch statement is missing a default case: switch ( propertyName )  					{  						case "Key":  						{  							if ( !unpacker.ReadObject( out key ) )  							{  								SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  							}    							isKeyFound = true;  							break;  						}  						case "Value":  						{  							if ( !unpacker.ReadObject( out value ) )  							{  								SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  							}    							isValueFound = true;  							break;  						}  					}
Missing Default,MsgPack.Serialization.DefaultSerializers,TimestampMessagePackSerializerProvider,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\TimestampMessagePackSerializerProvider.cs,Get,The following switch statement is missing a default case: switch ( ( DateTimeConversionMethod )providerParameter )  				{  					case DateTimeConversionMethod.Native:  					{  						return this._native;  					}  					case DateTimeConversionMethod.UnixEpoc:  					{  						return this._unixEpoc;  					}  					case DateTimeConversionMethod.Timestamp:  					{  						return this._timestamp;  					}  				}
Missing Default,MsgPack.Serialization.Reflection,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\ReflectionExtensions.cs,ToILString,The following switch statement is missing a default case: switch ( memberAccess )  			{  				case MethodAttributes.PrivateScope:  				{  					result.Append( "privatescope" );  					break;  				}  				case MethodAttributes.Private:  				{  					result.Append( "private" );  					break;  				}  				case MethodAttributes.FamANDAssem:  				{  					result.Append( "famandassem" );  					break;  				}  				case MethodAttributes.Assembly:  				{  					result.Append( "assembly" );  					break;  				}  				case MethodAttributes.Family:  				{  					result.Append( "family" );  					break;  				}  				case MethodAttributes.FamORAssem:  				{  					result.Append( "famorassem" );  					break;  				}  				case MethodAttributes.Public:  				{  					result.Append( "public" );  					break;  				}  			}
Missing Default,MsgPack.Serialization.Reflection,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\ReflectionExtensions.cs,ToILString,The following switch statement is missing a default case: switch ( (source & CallingConventions.Any) )  			{  				case CallingConventions.Standard:  				{  					if ( result.Length > 0 )  					{  						result.Append( ' ' );  					}    					result.Append( "standard" );  					break;  				}  				case CallingConventions.VarArgs:  				{  					if ( result.Length > 0 )  					{  						result.Append( ' ' );  					}    					result.Append( "vararg" );  					break;  				}  				case CallingConventions.Any:  				{  					if ( result.Length > 0 )  					{  						result.Append( ' ' );  					}    					result.Append( "any" );  					break;  				}  			}
Missing Default,MsgPack.Serialization.Reflection,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\ReflectionExtensions.cs,ToILString,The following switch statement is missing a default case: switch ( codeType )  			{  				case MethodImplAttributes.IL:  				{  					result.Append( "cil" );  					break;  				}  				case MethodImplAttributes.Native:  				{  					result.Append( "native" );  					break;  				}  				case MethodImplAttributes.OPTIL:  				{  					result.Append( "optil" );  					break;  				}  				case MethodImplAttributes.Runtime:  				{  					result.Append( "runtime" );  					break;  				}  			}
Missing Default,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,CreateCollectionInstanceFactory,The following switch statement is missing a default case: switch ( parameters.Length )  			{  				case 0:  				{  					return _ =>  #if !UNITY  						( T )  #endif // !UNITY  						constructor.InvokePreservingExceptionType();  				}  				case 1:  				{  					if ( parameters[ 0 ].ParameterType == typeof( int ) )  					{  						return capacity =>  #if !UNITY  							( T )  #endif // !UNITY  							constructor.InvokePreservingExceptionType( capacity );  					}  					else if ( UnpackHelpers.IsIEqualityComparer( parameters[ 0 ].ParameterType ) )  					{  						var comparer =   #if !UNITY  							EqualityComparer<TKey>.Default;  #else  							UnpackHelpers.GetEqualityComparer( comparisonType );  #endif // !UNITY  						return _ =>  #if !UNITY  							( T )  #endif // !UNITY  							constructor.InvokePreservingExceptionType( comparer );  					}    					break;  				}  				case 2:  				{  					var comparer =  #if !UNITY  						EqualityComparer<TKey>.Default;  #else  						UnpackHelpers.GetEqualityComparer( comparisonType );  #endif // !UNITY  					if ( parameters[ 0 ].ParameterType == typeof( int )  						&& UnpackHelpers.IsIEqualityComparer( parameters[ 1 ].ParameterType ) )  					{  						return capacity =>  #if !UNITY  							( T )  #endif // !UNITY  							constructor.InvokePreservingExceptionType( capacity' comparer );  					}  					else if ( UnpackHelpers.IsIEqualityComparer( parameters[ 0 ].ParameterType ) &&  							parameters[ 0 ].ParameterType == typeof( int ) )  					{  						return capacity =>  #if !UNITY  							( T )  #endif // !UNITY  							constructor.InvokePreservingExceptionType( comparer' capacity );  					}    					break;  				}  			}
Missing Default,System.Runtime.CompilerServices,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following switch statement is missing a default case: switch ( parameters.Length )  				{  					case 0:  					{  						if ( currentScore < noParameters )  						{  							constructor = candidate;  							currentScore = noParameters;  						}    						break;  					}  					case 1:  					{  						if ( currentScore < withCapacity && parameters[ 0 ].ParameterType == typeof( int ) )  						{  							constructor = candidate;  							currentScore = noParameters;  						}  						else if ( currentScore < withComparer && IsIEqualityComparer( parameters[ 0 ].ParameterType ) )  						{  							constructor = candidate;  							currentScore = noParameters;  						}  						break;  					}  					case 2:  					{  						if ( currentScore < withCapacityAndComparer && parameters[ 0 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 1 ].ParameterType ) )  						{  							constructor = candidate;  							currentScore = withCapacityAndComparer;  						}  						else if ( currentScore < withComparerAndCapacity && parameters[ 1 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 0 ].ParameterType ) )  						{  							constructor = candidate;  							currentScore = withComparerAndCapacity;  						}    						break;  					}  				}
