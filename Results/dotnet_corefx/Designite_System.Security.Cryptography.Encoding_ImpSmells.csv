Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,System.Security.Cryptography,ToBase64Transform,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Encoding\src\System\Security\Cryptography\Base64Transforms.cs,TransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Long Parameter List,System.Security.Cryptography,FromBase64Transform,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Encoding\src\System\Security\Cryptography\Base64Transforms.cs,TransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Magic Number,Internal.Cryptography,AsnFormatter,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Encoding\src\Internal\Cryptography\AsnFormatter.cs,EncodeHexString,The following statement contains a magic number: if (sArray != null)              {                  uint len = (end - start) * 2;                    if (spaceSeparated)                  {                      // There will be n-1 spaces between n bytes.                      len += (end - start - 1);                  }                    char[] hexOrder = new char[len];                    for (uint i = start' j = 0; i < end; i++)                  {                      if (spaceSeparated && i > start)                      {                          hexOrder[j++] = ' ';                      }                        uint digit = (uint)((sArray[i] & 0xf0) >> 4);                      hexOrder[j++] = s_hexValues[digit];                        digit = (uint)(sArray[i] & 0x0f);                      hexOrder[j++] = s_hexValues[digit];                  }                    result = new string(hexOrder);              }
Magic Number,Internal.Cryptography,AsnFormatter,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Encoding\src\Internal\Cryptography\AsnFormatter.cs,EncodeHexString,The following statement contains a magic number: if (sArray != null)              {                  uint len = (end - start) * 2;                    if (spaceSeparated)                  {                      // There will be n-1 spaces between n bytes.                      len += (end - start - 1);                  }                    char[] hexOrder = new char[len];                    for (uint i = start' j = 0; i < end; i++)                  {                      if (spaceSeparated && i > start)                      {                          hexOrder[j++] = ' ';                      }                        uint digit = (uint)((sArray[i] & 0xf0) >> 4);                      hexOrder[j++] = s_hexValues[digit];                        digit = (uint)(sArray[i] & 0x0f);                      hexOrder[j++] = s_hexValues[digit];                  }                    result = new string(hexOrder);              }
Magic Number,System.Security.Cryptography,ToBase64Transform,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Encoding\src\System\Security\Cryptography\Base64Transforms.cs,TransformBlock,The following statement contains a magic number: byte[] tempBytes = ConvertToBase64(inputBuffer' inputOffset' 3);
Magic Number,System.Security.Cryptography,ToBase64Transform,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Encoding\src\System\Security\Cryptography\Base64Transforms.cs,ConvertToBase64,The following statement contains a magic number: char[] temp = new char[4];
Magic Number,System.Security.Cryptography,ToBase64Transform,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Encoding\src\System\Security\Cryptography\Base64Transforms.cs,ConvertToBase64,The following statement contains a magic number: if (tempBytes.Length != 4)                  throw new CryptographicException(SR.Cryptography_SSE_InvalidDataSize);
Magic Number,System.Security.Cryptography,FromBase64Transform,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Encoding\src\System\Security\Cryptography\Base64Transforms.cs,TransformBlock,The following statement contains a magic number: if (effectiveCount + _inputIndex < 4)              {                  Buffer.BlockCopy(temp' 0' _inputBuffer' _inputIndex' effectiveCount);                  _inputIndex += effectiveCount;                  return 0;              }
Magic Number,System.Security.Cryptography,FromBase64Transform,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Encoding\src\System\Security\Cryptography\Base64Transforms.cs,TransformFinalBlock,The following statement contains a magic number: if (effectiveCount + _inputIndex < 4)              {                  Reset();                  return Array.Empty<byte>();              }
Magic Number,System.Security.Cryptography,FromBase64Transform,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Encoding\src\System\Security\Cryptography\Base64Transforms.cs,ConvertFromBase64,The following statement contains a magic number: int numBlocks = (effectiveCount + _inputIndex) / 4;
Magic Number,System.Security.Cryptography,FromBase64Transform,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Encoding\src\System\Security\Cryptography\Base64Transforms.cs,ConvertFromBase64,The following statement contains a magic number: _inputIndex = (effectiveCount + _inputIndex) % 4;
Magic Number,System.Security.Cryptography,FromBase64Transform,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Encoding\src\System\Security\Cryptography\Base64Transforms.cs,ConvertFromBase64,The following statement contains a magic number: char[] tempChar = Encoding.ASCII.GetChars(transformBuffer' 0' 4 * numBlocks);
Magic Number,System.Security.Cryptography,FromBase64Transform,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Encoding\src\System\Security\Cryptography\Base64Transforms.cs,ConvertFromBase64,The following statement contains a magic number: byte[] tempBytes = Convert.FromBase64CharArray(tempChar' 0' 4 * numBlocks);
