Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,Invoke,The method has 157 lines of code.
Long Method,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForWorker,The method has 208 lines of code.
Long Method,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForWorker64,The method has 211 lines of code.
Long Method,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,PartitionerForEachWorker,The method has 254 lines of code.
Complex Method,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,Invoke,Cyclomatic complexity of the method is 9
Long Parameter List,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,For,The method has 5 parameters. Parameters: fromInclusive' toExclusive' localInit' body' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,For,The method has 5 parameters. Parameters: fromInclusive' toExclusive' localInit' body' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,For,The method has 6 parameters. Parameters: fromInclusive' toExclusive' parallelOptions' localInit' body' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,For,The method has 6 parameters. Parameters: fromInclusive' toExclusive' parallelOptions' localInit' body' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForWorker,The method has 8 parameters. Parameters: fromInclusive' toExclusive' parallelOptions' body' bodyWithState' bodyWithLocal' localInit' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForWorker64,The method has 8 parameters. Parameters: fromInclusive' toExclusive' parallelOptions' body' bodyWithState' bodyWithLocal' localInit' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForEach,The method has 5 parameters. Parameters: source' parallelOptions' localInit' body' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForEach,The method has 5 parameters. Parameters: source' parallelOptions' localInit' body' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForEachWorker,The method has 9 parameters. Parameters: source' parallelOptions' body' bodyWithState' bodyWithStateAndIndex' bodyWithStateAndLocal' bodyWithEverything' localInit' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForEachWorker,The method has 9 parameters. Parameters: array' parallelOptions' body' bodyWithState' bodyWithStateAndIndex' bodyWithStateAndLocal' bodyWithEverything' localInit' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForEachWorker,The method has 9 parameters. Parameters: list' parallelOptions' body' bodyWithState' bodyWithStateAndIndex' bodyWithStateAndLocal' bodyWithEverything' localInit' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForEach,The method has 5 parameters. Parameters: source' parallelOptions' localInit' body' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForEach,The method has 5 parameters. Parameters: source' parallelOptions' localInit' body' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,PartitionerForEachWorker,The method has 9 parameters. Parameters: source' parallelOptions' simpleBody' bodyWithState' bodyWithStateAndIndex' bodyWithStateAndLocal' bodyWithEverything' localInit' localFinally
Long Parameter List,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelLoopBegin,The method has 6 parameters. Parameters: OriginatingTaskSchedulerID' OriginatingTaskID' ForkJoinContextID' OperationType' InclusiveFrom' ExclusiveTo
Long Parameter List,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelInvokeBegin,The method has 5 parameters. Parameters: OriginatingTaskSchedulerID' OriginatingTaskID' ForkJoinContextID' OperationType' ActionCount
Long Identifier,System.Threading,PlatformHelper,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\PlatformHelper.cs,,The length of the parameter PROCESSOR_COUNT_REFRESH_INTERVAL_MS is 35.
Long Identifier,System.Threading,PlatformHelper,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\PlatformHelper.cs,,The length of the parameter s_lastProcessorCountRefreshTicks is 32.
Long Identifier,System.Threading.Tasks,TaskReplicator,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\TaskReplicator.cs,,The length of the parameter CooperativeMultitaskingTaskTimeout_Min is 38.
Long Identifier,System.Threading.Tasks,TaskReplicator,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\TaskReplicator.cs,,The length of the parameter CooperativeMultitaskingTaskTimeout_Increment is 44.
Long Identifier,System.Threading.Tasks,TaskReplicator,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\TaskReplicator.cs,,The length of the parameter CooperativeMultitaskingTaskTimeout_RootTask is 43.
Long Identifier,System.Threading.Tasks,Replica,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\TaskReplicator.cs,Execute,The length of the parameter userActionYieldedBeforeCompletion is 33.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,Invoke,The length of the statement  "                                        LazyInitializer.EnsureInitialized<ConcurrentQueue<Exception>>(ref exceptionQ' () => { return new ConcurrentQueue<Exception>(); }); " is 130.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,Invoke,The length of the statement  "                        LazyInitializer.EnsureInitialized<ConcurrentQueue<Exception>>(ref exceptionQ' () => { return new ConcurrentQueue<Exception>(); }); " is 130.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForWorker,The length of the statement  "                            bool bLocalValueInitialized = false; // Tracks whether localInit ran without exceptions' so that we can skip localFinally if it wasn't " is 134.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForWorker,The length of the statement  "                                             j < nToExclusiveLocal && (sharedPStateFlags.LoopStateFlags == ParallelLoopStateFlags.ParallelLoopStateNone  // fast path check as SEL() doesn't inline " is 150.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForWorker,The length of the statement  "                                            j < nToExclusiveLocal && (sharedPStateFlags.LoopStateFlags == ParallelLoopStateFlags.ParallelLoopStateNone  // fast path check as SEL() doesn't inline " is 150.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForWorker,The length of the statement  "                                            j < nToExclusiveLocal && (sharedPStateFlags.LoopStateFlags == ParallelLoopStateFlags.ParallelLoopStateNone  // fast path check as SEL() doesn't inline " is 150.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForWorker,The length of the statement  "                    ParallelEtwProvider.Log.ParallelLoopEnd(TaskScheduler.Current.Id' Task.CurrentId ?? 0' forkJoinContextID' nTotalIterations); " is 124.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForWorker64,The length of the statement  "                            bool bLocalValueInitialized = false; // Tracks whether localInit ran without exceptions' so that we can skip localFinally if it wasn't " is 134.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForWorker64,The length of the statement  "                                             j < nToExclusiveLocal && (sharedPStateFlags.LoopStateFlags == ParallelLoopStateFlags.ParallelLoopStateNone  // fast path check as SEL() doesn't inline " is 150.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForWorker64,The length of the statement  "                                             j < nToExclusiveLocal && (sharedPStateFlags.LoopStateFlags == ParallelLoopStateFlags.ParallelLoopStateNone  // fast path check as SEL() doesn't inline " is 150.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForWorker64,The length of the statement  "                                             j < nToExclusiveLocal && (sharedPStateFlags.LoopStateFlags == ParallelLoopStateFlags.ParallelLoopStateNone  // fast path check as SEL() doesn't inline " is 150.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForWorker64,The length of the statement  "                    ParallelEtwProvider.Log.ParallelLoopEnd(TaskScheduler.Current.Id' Task.CurrentId ?? 0' forkJoinContextID' nTotalIterations); " is 124.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForEachWorker,The length of the statement  "                (bodyWithStateAndIndex == null ? 0 : 1) + (bodyWithStateAndLocal == null ? 0 : 1) + (bodyWithEverything == null ? 0 : 1)) == 1' " is 127.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForEachWorker,The length of the statement  "            Debug.Assert((bodyWithStateAndLocal != null) || (bodyWithEverything != null) || (localInit == null && localFinally == null)' " is 124.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForEachWorker,The length of the statement  "                    from' to' parallelOptions' null' null' (i' state' local) => bodyWithStateAndLocal(array[i]' state' local)' localInit' localFinally); " is 132.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForEachWorker,The length of the statement  "                    from' to' parallelOptions' null' null' (i' state' local) => bodyWithEverything(array[i]' state' i' local)' localInit' localFinally); " is 132.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForEachWorker,The length of the statement  "                    0' list.Count' parallelOptions' null' null' (i' state' local) => bodyWithStateAndLocal(list[i]' state' local)' localInit' localFinally); " is 136.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForEachWorker,The length of the statement  "                    0' list.Count' parallelOptions' null' null' (i' state' local) => bodyWithEverything(list[i]' state' i' local)' localInit' localFinally); " is 136.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForEach,The length of the statement  "            return PartitionerForEachWorker<TSource' object>(source' s_defaultParallelOptions' body' null' null' null' null' null' null); " is 125.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForEach,The length of the statement  "            return PartitionerForEachWorker<TSource' object>(source' s_defaultParallelOptions' null' body' null' null' null' null' null); " is 125.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForEach,The length of the statement  "            return PartitionerForEachWorker<TSource' object>(source' s_defaultParallelOptions' null' null' body' null' null' null' null); " is 125.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForEach,The length of the statement  "            return PartitionerForEachWorker<TSource' TLocal>(source' s_defaultParallelOptions' null' null' null' body' null' localInit' localFinally); " is 138.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForEach,The length of the statement  "            return PartitionerForEachWorker<TSource' TLocal>(source' s_defaultParallelOptions' null' null' null' null' body' localInit' localFinally); " is 138.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForEach,The length of the statement  "            return PartitionerForEachWorker<TSource' TLocal>(source' parallelOptions' null' null' null' body' null' localInit' localFinally); " is 129.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,ForEach,The length of the statement  "            return PartitionerForEachWorker<TSource' TLocal>(source' parallelOptions' null' null' null' null' body' localInit' localFinally); " is 129.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,PartitionerForEachWorker,The length of the statement  "                (bodyWithStateAndIndex == null ? 0 : 1) + (bodyWithStateAndLocal == null ? 0 : 1) + (bodyWithEverything == null ? 0 : 1)) == 1' " is 127.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,PartitionerForEachWorker,The length of the statement  "            Debug.Assert((bodyWithStateAndLocal != null) || (bodyWithEverything != null) || (localInit == null && localFinally == null)' " is 124.
Long Statement,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,PartitionerForEachWorker,The length of the statement  "                            bool bLocalValueInitialized = false; // Tracks whether localInit ran without exceptions' so that we can skip localFinally if it wasn't " is 134.
Long Statement,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelLoopEnd,The length of the statement  "                // Therefore calling WriteEvent() would hit the "params" overload' which leads to an object allocation every time this event is fired. " is 134.
Long Statement,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelLoopEnd,The length of the statement  "                // To prevent that problem we will call WriteEventCore()' which works with a stack based EventData array populated with the event fields " is 136.
Long Statement,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelInvokeBegin,The length of the statement  "                // Therefore calling WriteEvent() would hit the "params" overload' which leads to an object allocation every time this event is fired. " is 134.
Long Statement,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelInvokeBegin,The length of the statement  "                // To prevent that problem we will call WriteEventCore()' which works with a stack based EventData array populated with the event fields " is 136.
Long Statement,System.Threading.Tasks,ParallelLoopState,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelLoopState.cs,Break,The length of the statement  "                                             ParallelLoopStateFlags.ParallelLoopStateStopped | ParallelLoopStateFlags.ParallelLoopStateExceptional | ParallelLoopStateFlags.ParallelLoopStateCanceled' " is 153.
Long Statement,System.Threading.Tasks,ParallelLoopState,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelLoopState.cs,Break,The length of the statement  "                                             ParallelLoopStateFlags.ParallelLoopStateStopped | ParallelLoopStateFlags.ParallelLoopStateExceptional | ParallelLoopStateFlags.ParallelLoopStateCanceled' " is 153.
Long Statement,System.Threading.Tasks,ParallelLoopStateFlags32,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelLoopState.cs,ShouldExitLoop,The length of the statement  "            return ((flags != ParallelLoopStateNone) && ((flags & (ParallelLoopStateExceptional | ParallelLoopStateCanceled)) != 0)); " is 121.
Long Statement,System.Threading.Tasks,ParallelLoopStateFlags64,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelLoopState.cs,ShouldExitLoop,The length of the statement  "            return ((flags != ParallelLoopStateNone) && ((flags & (ParallelLoopStateExceptional | ParallelLoopStateCanceled)) != 0)); " is 121.
Long Statement,System.Threading.Tasks,RangeWorker,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelRangeManager.cs,FindNewWork,The length of the statement  "                        nMyOffset = Interlocked.Add(ref _indexRanges[_nCurrentIndexRange]._nSharedCurrentIndexOffset.Value' _nIncrementValue) - _nIncrementValue; " is 137.
Long Statement,System.Threading.Tasks,TaskReplicator,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\TaskReplicator.cs,Run,The length of the statement  "            int maxConcurrencyLevel = (options.EffectiveMaxConcurrencyLevel > 0) ? options.EffectiveMaxConcurrencyLevel : int.MaxValue; " is 123.
Long Statement,System.Threading.Tasks,TaskReplicator,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\TaskReplicator.cs,GenerateCooperativeMultitaskingTaskTimeout,The length of the statement  "            // Otherwise all worker will try to timeout at precisely the same point' which is bad if the work is just about to finish. " is 122.
Long Statement,System.Threading.Tasks,Replica<TState>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\TaskReplicator.cs,CreateNewReplica,The length of the statement  "                Replica<TState> newReplica = new Replica<TState>(_replicator' _remainingConcurrency' GenerateCooperativeMultitaskingTaskTimeout()' _action); " is 140.
Magic Number,System.Threading.Tasks,Parallel,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\Parallel.cs,Invoke,The following statement contains a magic number: const int SMALL_ACTIONCOUNT_LIMIT = 10;
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelLoopBegin,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields. Therefore calling                  // WriteEvent() would hit the "params" overload' which leads to an object allocation every time                   // this event is fired. To prevent that problem we will call WriteEventCore()' which works with                   // a stack based EventData array populated with the event fields.                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[6];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int32);                      eventPayload[3].DataPointer = ((IntPtr)(&OperationType));                      eventPayload[4].Size = sizeof(Int64);                      eventPayload[4].DataPointer = ((IntPtr)(&InclusiveFrom));                      eventPayload[5].Size = sizeof(Int64);                      eventPayload[5].DataPointer = ((IntPtr)(&ExclusiveTo));                        WriteEventCore(PARALLELLOOPBEGIN_ID' 6' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelLoopBegin,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields. Therefore calling                  // WriteEvent() would hit the "params" overload' which leads to an object allocation every time                   // this event is fired. To prevent that problem we will call WriteEventCore()' which works with                   // a stack based EventData array populated with the event fields.                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[6];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int32);                      eventPayload[3].DataPointer = ((IntPtr)(&OperationType));                      eventPayload[4].Size = sizeof(Int64);                      eventPayload[4].DataPointer = ((IntPtr)(&InclusiveFrom));                      eventPayload[5].Size = sizeof(Int64);                      eventPayload[5].DataPointer = ((IntPtr)(&ExclusiveTo));                        WriteEventCore(PARALLELLOOPBEGIN_ID' 6' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelLoopBegin,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields. Therefore calling                  // WriteEvent() would hit the "params" overload' which leads to an object allocation every time                   // this event is fired. To prevent that problem we will call WriteEventCore()' which works with                   // a stack based EventData array populated with the event fields.                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[6];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int32);                      eventPayload[3].DataPointer = ((IntPtr)(&OperationType));                      eventPayload[4].Size = sizeof(Int64);                      eventPayload[4].DataPointer = ((IntPtr)(&InclusiveFrom));                      eventPayload[5].Size = sizeof(Int64);                      eventPayload[5].DataPointer = ((IntPtr)(&ExclusiveTo));                        WriteEventCore(PARALLELLOOPBEGIN_ID' 6' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelLoopBegin,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields. Therefore calling                  // WriteEvent() would hit the "params" overload' which leads to an object allocation every time                   // this event is fired. To prevent that problem we will call WriteEventCore()' which works with                   // a stack based EventData array populated with the event fields.                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[6];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int32);                      eventPayload[3].DataPointer = ((IntPtr)(&OperationType));                      eventPayload[4].Size = sizeof(Int64);                      eventPayload[4].DataPointer = ((IntPtr)(&InclusiveFrom));                      eventPayload[5].Size = sizeof(Int64);                      eventPayload[5].DataPointer = ((IntPtr)(&ExclusiveTo));                        WriteEventCore(PARALLELLOOPBEGIN_ID' 6' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelLoopBegin,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields. Therefore calling                  // WriteEvent() would hit the "params" overload' which leads to an object allocation every time                   // this event is fired. To prevent that problem we will call WriteEventCore()' which works with                   // a stack based EventData array populated with the event fields.                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[6];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int32);                      eventPayload[3].DataPointer = ((IntPtr)(&OperationType));                      eventPayload[4].Size = sizeof(Int64);                      eventPayload[4].DataPointer = ((IntPtr)(&InclusiveFrom));                      eventPayload[5].Size = sizeof(Int64);                      eventPayload[5].DataPointer = ((IntPtr)(&ExclusiveTo));                        WriteEventCore(PARALLELLOOPBEGIN_ID' 6' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelLoopBegin,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields. Therefore calling                  // WriteEvent() would hit the "params" overload' which leads to an object allocation every time                   // this event is fired. To prevent that problem we will call WriteEventCore()' which works with                   // a stack based EventData array populated with the event fields.                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[6];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int32);                      eventPayload[3].DataPointer = ((IntPtr)(&OperationType));                      eventPayload[4].Size = sizeof(Int64);                      eventPayload[4].DataPointer = ((IntPtr)(&InclusiveFrom));                      eventPayload[5].Size = sizeof(Int64);                      eventPayload[5].DataPointer = ((IntPtr)(&ExclusiveTo));                        WriteEventCore(PARALLELLOOPBEGIN_ID' 6' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelLoopBegin,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields. Therefore calling                  // WriteEvent() would hit the "params" overload' which leads to an object allocation every time                   // this event is fired. To prevent that problem we will call WriteEventCore()' which works with                   // a stack based EventData array populated with the event fields.                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[6];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int32);                      eventPayload[3].DataPointer = ((IntPtr)(&OperationType));                      eventPayload[4].Size = sizeof(Int64);                      eventPayload[4].DataPointer = ((IntPtr)(&InclusiveFrom));                      eventPayload[5].Size = sizeof(Int64);                      eventPayload[5].DataPointer = ((IntPtr)(&ExclusiveTo));                        WriteEventCore(PARALLELLOOPBEGIN_ID' 6' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelLoopBegin,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields. Therefore calling                  // WriteEvent() would hit the "params" overload' which leads to an object allocation every time                   // this event is fired. To prevent that problem we will call WriteEventCore()' which works with                   // a stack based EventData array populated with the event fields.                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[6];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int32);                      eventPayload[3].DataPointer = ((IntPtr)(&OperationType));                      eventPayload[4].Size = sizeof(Int64);                      eventPayload[4].DataPointer = ((IntPtr)(&InclusiveFrom));                      eventPayload[5].Size = sizeof(Int64);                      eventPayload[5].DataPointer = ((IntPtr)(&ExclusiveTo));                        WriteEventCore(PARALLELLOOPBEGIN_ID' 6' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelLoopBegin,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields. Therefore calling                  // WriteEvent() would hit the "params" overload' which leads to an object allocation every time                   // this event is fired. To prevent that problem we will call WriteEventCore()' which works with                   // a stack based EventData array populated with the event fields.                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[6];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int32);                      eventPayload[3].DataPointer = ((IntPtr)(&OperationType));                      eventPayload[4].Size = sizeof(Int64);                      eventPayload[4].DataPointer = ((IntPtr)(&InclusiveFrom));                      eventPayload[5].Size = sizeof(Int64);                      eventPayload[5].DataPointer = ((IntPtr)(&ExclusiveTo));                        WriteEventCore(PARALLELLOOPBEGIN_ID' 6' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelLoopBegin,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields. Therefore calling                  // WriteEvent() would hit the "params" overload' which leads to an object allocation every time                   // this event is fired. To prevent that problem we will call WriteEventCore()' which works with                   // a stack based EventData array populated with the event fields.                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[6];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int32);                      eventPayload[3].DataPointer = ((IntPtr)(&OperationType));                      eventPayload[4].Size = sizeof(Int64);                      eventPayload[4].DataPointer = ((IntPtr)(&InclusiveFrom));                      eventPayload[5].Size = sizeof(Int64);                      eventPayload[5].DataPointer = ((IntPtr)(&ExclusiveTo));                        WriteEventCore(PARALLELLOOPBEGIN_ID' 6' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelLoopEnd,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields.                  // Therefore calling WriteEvent() would hit the "params" overload' which leads to an object allocation every time this event is fired.                  // To prevent that problem we will call WriteEventCore()' which works with a stack based EventData array populated with the event fields                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[4];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int64);                      eventPayload[3].DataPointer = ((IntPtr)(&TotalIterations));                        WriteEventCore(PARALLELLOOPEND_ID' 4' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelLoopEnd,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields.                  // Therefore calling WriteEvent() would hit the "params" overload' which leads to an object allocation every time this event is fired.                  // To prevent that problem we will call WriteEventCore()' which works with a stack based EventData array populated with the event fields                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[4];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int64);                      eventPayload[3].DataPointer = ((IntPtr)(&TotalIterations));                        WriteEventCore(PARALLELLOOPEND_ID' 4' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelLoopEnd,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields.                  // Therefore calling WriteEvent() would hit the "params" overload' which leads to an object allocation every time this event is fired.                  // To prevent that problem we will call WriteEventCore()' which works with a stack based EventData array populated with the event fields                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[4];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int64);                      eventPayload[3].DataPointer = ((IntPtr)(&TotalIterations));                        WriteEventCore(PARALLELLOOPEND_ID' 4' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelLoopEnd,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields.                  // Therefore calling WriteEvent() would hit the "params" overload' which leads to an object allocation every time this event is fired.                  // To prevent that problem we will call WriteEventCore()' which works with a stack based EventData array populated with the event fields                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[4];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int64);                      eventPayload[3].DataPointer = ((IntPtr)(&TotalIterations));                        WriteEventCore(PARALLELLOOPEND_ID' 4' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelLoopEnd,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields.                  // Therefore calling WriteEvent() would hit the "params" overload' which leads to an object allocation every time this event is fired.                  // To prevent that problem we will call WriteEventCore()' which works with a stack based EventData array populated with the event fields                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[4];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int64);                      eventPayload[3].DataPointer = ((IntPtr)(&TotalIterations));                        WriteEventCore(PARALLELLOOPEND_ID' 4' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelLoopEnd,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields.                  // Therefore calling WriteEvent() would hit the "params" overload' which leads to an object allocation every time this event is fired.                  // To prevent that problem we will call WriteEventCore()' which works with a stack based EventData array populated with the event fields                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[4];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int64);                      eventPayload[3].DataPointer = ((IntPtr)(&TotalIterations));                        WriteEventCore(PARALLELLOOPEND_ID' 4' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelInvokeBegin,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields.                  // Therefore calling WriteEvent() would hit the "params" overload' which leads to an object allocation every time this event is fired.                  // To prevent that problem we will call WriteEventCore()' which works with a stack based EventData array populated with the event fields                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[5];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int32);                      eventPayload[3].DataPointer = ((IntPtr)(&OperationType));                      eventPayload[4].Size = sizeof(Int32);                      eventPayload[4].DataPointer = ((IntPtr)(&ActionCount));                        WriteEventCore(PARALLELINVOKEBEGIN_ID' 5' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelInvokeBegin,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields.                  // Therefore calling WriteEvent() would hit the "params" overload' which leads to an object allocation every time this event is fired.                  // To prevent that problem we will call WriteEventCore()' which works with a stack based EventData array populated with the event fields                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[5];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int32);                      eventPayload[3].DataPointer = ((IntPtr)(&OperationType));                      eventPayload[4].Size = sizeof(Int32);                      eventPayload[4].DataPointer = ((IntPtr)(&ActionCount));                        WriteEventCore(PARALLELINVOKEBEGIN_ID' 5' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelInvokeBegin,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields.                  // Therefore calling WriteEvent() would hit the "params" overload' which leads to an object allocation every time this event is fired.                  // To prevent that problem we will call WriteEventCore()' which works with a stack based EventData array populated with the event fields                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[5];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int32);                      eventPayload[3].DataPointer = ((IntPtr)(&OperationType));                      eventPayload[4].Size = sizeof(Int32);                      eventPayload[4].DataPointer = ((IntPtr)(&ActionCount));                        WriteEventCore(PARALLELINVOKEBEGIN_ID' 5' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelInvokeBegin,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields.                  // Therefore calling WriteEvent() would hit the "params" overload' which leads to an object allocation every time this event is fired.                  // To prevent that problem we will call WriteEventCore()' which works with a stack based EventData array populated with the event fields                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[5];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int32);                      eventPayload[3].DataPointer = ((IntPtr)(&OperationType));                      eventPayload[4].Size = sizeof(Int32);                      eventPayload[4].DataPointer = ((IntPtr)(&ActionCount));                        WriteEventCore(PARALLELINVOKEBEGIN_ID' 5' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelInvokeBegin,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields.                  // Therefore calling WriteEvent() would hit the "params" overload' which leads to an object allocation every time this event is fired.                  // To prevent that problem we will call WriteEventCore()' which works with a stack based EventData array populated with the event fields                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[5];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int32);                      eventPayload[3].DataPointer = ((IntPtr)(&OperationType));                      eventPayload[4].Size = sizeof(Int32);                      eventPayload[4].DataPointer = ((IntPtr)(&ActionCount));                        WriteEventCore(PARALLELINVOKEBEGIN_ID' 5' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelInvokeBegin,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields.                  // Therefore calling WriteEvent() would hit the "params" overload' which leads to an object allocation every time this event is fired.                  // To prevent that problem we will call WriteEventCore()' which works with a stack based EventData array populated with the event fields                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[5];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int32);                      eventPayload[3].DataPointer = ((IntPtr)(&OperationType));                      eventPayload[4].Size = sizeof(Int32);                      eventPayload[4].DataPointer = ((IntPtr)(&ActionCount));                        WriteEventCore(PARALLELINVOKEBEGIN_ID' 5' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelInvokeBegin,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields.                  // Therefore calling WriteEvent() would hit the "params" overload' which leads to an object allocation every time this event is fired.                  // To prevent that problem we will call WriteEventCore()' which works with a stack based EventData array populated with the event fields                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[5];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int32);                      eventPayload[3].DataPointer = ((IntPtr)(&OperationType));                      eventPayload[4].Size = sizeof(Int32);                      eventPayload[4].DataPointer = ((IntPtr)(&ActionCount));                        WriteEventCore(PARALLELINVOKEBEGIN_ID' 5' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,ParallelEtwProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelETWProvider.cs,ParallelInvokeBegin,The following statement contains a magic number: if (IsEnabled(EventLevel.Informational' ALL_KEYWORDS))              {                  // There is no explicit WriteEvent() overload matching this event's fields.                  // Therefore calling WriteEvent() would hit the "params" overload' which leads to an object allocation every time this event is fired.                  // To prevent that problem we will call WriteEventCore()' which works with a stack based EventData array populated with the event fields                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[5];                        eventPayload[0].Size = sizeof(Int32);                      eventPayload[0].DataPointer = ((IntPtr)(&OriginatingTaskSchedulerID));                      eventPayload[1].Size = sizeof(Int32);                      eventPayload[1].DataPointer = ((IntPtr)(&OriginatingTaskID));                      eventPayload[2].Size = sizeof(Int32);                      eventPayload[2].DataPointer = ((IntPtr)(&ForkJoinContextID));                      eventPayload[3].Size = sizeof(Int32);                      eventPayload[3].DataPointer = ((IntPtr)(&OperationType));                      eventPayload[4].Size = sizeof(Int32);                      eventPayload[4].DataPointer = ((IntPtr)(&ActionCount));                        WriteEventCore(PARALLELINVOKEBEGIN_ID' 5' eventPayload);                  }              }
Magic Number,System.Threading.Tasks,RangeWorker,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelRangeManager.cs,FindNewWork,The following statement contains a magic number: do              {                  // local snap to save array access bounds checks in places where we only read fields                  IndexRange currentRange = _indexRanges[_nCurrentIndexRange];                    if (currentRange._bRangeFinished == 0)                  {                      if (_indexRanges[_nCurrentIndexRange]._nSharedCurrentIndexOffset == null)                      {                          Interlocked.CompareExchange(ref _indexRanges[_nCurrentIndexRange]._nSharedCurrentIndexOffset' new Box<long>(0)' null);                      }                        long nMyOffset;                      if (IntPtr.Size == 4 && _use32BitCurrentIndex)                      {                          // In 32-bit processes' we prefer to use 32-bit interlocked operations' to avoid the possibility of doing                          // a 64-bit interlocked when the target value crosses a cache line' as that can be super expensive.                          // We use the first 32 bits of the Int64 index in such cases.                          unsafe                          {                              fixed (long* indexPtr = &_indexRanges[_nCurrentIndexRange]._nSharedCurrentIndexOffset.Value)                              {                                  nMyOffset = Interlocked.Add(ref *(int*)indexPtr' (int)_nIncrementValue) - _nIncrementValue;                              }                          }                      }                      else                      {                          nMyOffset = Interlocked.Add(ref _indexRanges[_nCurrentIndexRange]._nSharedCurrentIndexOffset.Value' _nIncrementValue) - _nIncrementValue;                      }                        if (currentRange._nToExclusive - currentRange._nFromInclusive > nMyOffset)                      {                          // we found work                            nFromInclusiveLocal = currentRange._nFromInclusive + nMyOffset;                          nToExclusiveLocal = unchecked(nFromInclusiveLocal + _nIncrementValue);                            // Check for going past end of range' or wrapping                          if ((nToExclusiveLocal > currentRange._nToExclusive) || (nToExclusiveLocal < currentRange._nFromInclusive))                          {                              nToExclusiveLocal = currentRange._nToExclusive;                          }                            // We will double our unit of increment until it reaches the maximum.                          if (_nIncrementValue < _nMaxIncrementValue)                          {                              _nIncrementValue *= 2;                              if (_nIncrementValue > _nMaxIncrementValue)                              {                                  _nIncrementValue = _nMaxIncrementValue;                              }                          }                            return true;                      }                      else                      {                          // this index range is completed' mark it so that others can skip it quickly                          Interlocked.Exchange(ref _indexRanges[_nCurrentIndexRange]._bRangeFinished' 1);                      }                  }                    // move on to the next index range' in circular order.                  _nCurrentIndexRange = (_nCurrentIndexRange + 1) % _indexRanges.Length;                  numIndexRangesToVisit--;              } while (numIndexRangesToVisit > 0);
Magic Number,System.Threading.Tasks,RangeWorker,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelRangeManager.cs,FindNewWork,The following statement contains a magic number: do              {                  // local snap to save array access bounds checks in places where we only read fields                  IndexRange currentRange = _indexRanges[_nCurrentIndexRange];                    if (currentRange._bRangeFinished == 0)                  {                      if (_indexRanges[_nCurrentIndexRange]._nSharedCurrentIndexOffset == null)                      {                          Interlocked.CompareExchange(ref _indexRanges[_nCurrentIndexRange]._nSharedCurrentIndexOffset' new Box<long>(0)' null);                      }                        long nMyOffset;                      if (IntPtr.Size == 4 && _use32BitCurrentIndex)                      {                          // In 32-bit processes' we prefer to use 32-bit interlocked operations' to avoid the possibility of doing                          // a 64-bit interlocked when the target value crosses a cache line' as that can be super expensive.                          // We use the first 32 bits of the Int64 index in such cases.                          unsafe                          {                              fixed (long* indexPtr = &_indexRanges[_nCurrentIndexRange]._nSharedCurrentIndexOffset.Value)                              {                                  nMyOffset = Interlocked.Add(ref *(int*)indexPtr' (int)_nIncrementValue) - _nIncrementValue;                              }                          }                      }                      else                      {                          nMyOffset = Interlocked.Add(ref _indexRanges[_nCurrentIndexRange]._nSharedCurrentIndexOffset.Value' _nIncrementValue) - _nIncrementValue;                      }                        if (currentRange._nToExclusive - currentRange._nFromInclusive > nMyOffset)                      {                          // we found work                            nFromInclusiveLocal = currentRange._nFromInclusive + nMyOffset;                          nToExclusiveLocal = unchecked(nFromInclusiveLocal + _nIncrementValue);                            // Check for going past end of range' or wrapping                          if ((nToExclusiveLocal > currentRange._nToExclusive) || (nToExclusiveLocal < currentRange._nFromInclusive))                          {                              nToExclusiveLocal = currentRange._nToExclusive;                          }                            // We will double our unit of increment until it reaches the maximum.                          if (_nIncrementValue < _nMaxIncrementValue)                          {                              _nIncrementValue *= 2;                              if (_nIncrementValue > _nMaxIncrementValue)                              {                                  _nIncrementValue = _nMaxIncrementValue;                              }                          }                            return true;                      }                      else                      {                          // this index range is completed' mark it so that others can skip it quickly                          Interlocked.Exchange(ref _indexRanges[_nCurrentIndexRange]._bRangeFinished' 1);                      }                  }                    // move on to the next index range' in circular order.                  _nCurrentIndexRange = (_nCurrentIndexRange + 1) % _indexRanges.Length;                  numIndexRangesToVisit--;              } while (numIndexRangesToVisit > 0);
Magic Number,System.Threading.Tasks,RangeManager,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelRangeManager.cs,RangeManager,The following statement contains a magic number: if (nNumExpectedWorkers == 1)                  nNumExpectedWorkers = 2;
Magic Number,System.Threading.Tasks,RangeManager,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Parallel\src\System\Threading\Tasks\ParallelRangeManager.cs,RangeManager,The following statement contains a magic number: _use32BitCurrentIndex = IntPtr.Size == 4 && nRangeSize <= int.MaxValue;
