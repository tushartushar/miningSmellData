Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Collections.Concurrent,BlockingCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\BlockingCollection.cs,TryAddWithNoTimeValidation,The method has 120 lines of code.
Long Method,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The method has 114 lines of code.
Complex Method,System.Collections.Concurrent,BlockingCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\BlockingCollection.cs,TryAddWithNoTimeValidation,Cyclomatic complexity of the method is 11
Complex Method,System.Collections.Concurrent,BlockingCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\BlockingCollection.cs,CompleteAdding,Cyclomatic complexity of the method is 8
Complex Method,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentDictionary.cs,TryAddInternal,Cyclomatic complexity of the method is 10
Complex Method,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentDictionary.cs,CopyTo,Cyclomatic complexity of the method is 8
Complex Method,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,Cyclomatic complexity of the method is 10
Complex Method,System.Collections.Concurrent,ConcurrentQueue<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentQueue.cs,Enumerate,Cyclomatic complexity of the method is 8
Complex Method,System.Collections.Concurrent,ConcurrentStack<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentStack.cs,TryPopCore,Cyclomatic complexity of the method is 10
Long Parameter List,System.Collections.Concurrent,BlockingCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\BlockingCollection.cs,TryTakeFromAnyCore,The method has 5 parameters. Parameters: collections' item' millisecondsTimeout' isTakeOperation' externalCancellationToken
Long Parameter List,System.Collections.Concurrent,BlockingCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\BlockingCollection.cs,TryTakeFromAnyCoreSlow,The method has 5 parameters. Parameters: collections' item' millisecondsTimeout' isTakeOperation' externalCancellationToken
Long Parameter List,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentDictionary.cs,TryAddInternal,The method has 6 parameters. Parameters: key' hashcode' value' updateIfExists' acquireLock' resultingValue
Long Parameter List,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentDictionary.cs,GetBucketAndLockNo,The method has 5 parameters. Parameters: hashcode' bucketNo' lockNo' bucketCount' lockCount
Long Parameter List,System.Collections.Concurrent,InternalPartitionEnumerator,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\PartitionerStatic.cs,InternalPartitionEnumerator,The method has 6 parameters. Parameters: sharedReader' sharedIndex' hasNoElementsLeft' activePartitionCount' enumerable' useSingleChunking
Long Identifier,System.Collections.Concurrent,BlockingCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\BlockingCollection.cs,UpdateTimeOut,The length of the parameter originalWaitMillisecondsTimeout is 31.
Long Identifier,System.Collections.Concurrent,BlockingCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\BlockingCollection.cs,,The length of the parameter _consumersCancellationTokenSource is 33.
Long Identifier,System.Collections.Concurrent,BlockingCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\BlockingCollection.cs,,The length of the parameter _producersCancellationTokenSource is 33.
Long Identifier,System.Collections.Concurrent,CDSCollectionETWBCLProvider,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\CDSCollectionETWBCLProvider.cs,,The length of the parameter CONCURRENTSTACK_FASTPUSHFAILED_ID is 33.
Long Identifier,System.Collections.Concurrent,CDSCollectionETWBCLProvider,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\CDSCollectionETWBCLProvider.cs,,The length of the parameter CONCURRENTSTACK_FASTPOPFAILED_ID is 32.
Long Identifier,System.Collections.Concurrent,CDSCollectionETWBCLProvider,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\CDSCollectionETWBCLProvider.cs,,The length of the parameter CONCURRENTDICTIONARY_ACQUIRINGALLLOCKS_ID is 41.
Long Identifier,System.Collections.Concurrent,CDSCollectionETWBCLProvider,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\CDSCollectionETWBCLProvider.cs,,The length of the parameter CONCURRENTBAG_TRYTAKESTEALS_ID is 30.
Long Identifier,System.Collections.Concurrent,CDSCollectionETWBCLProvider,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\CDSCollectionETWBCLProvider.cs,,The length of the parameter CONCURRENTBAG_TRYPEEKSTEALS_ID is 30.
Long Identifier,System.Threading,PlatformHelper,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\PlatformHelper.cs,,The length of the parameter PROCESSOR_COUNT_REFRESH_INTERVAL_MS is 35.
Long Identifier,System.Threading,PlatformHelper,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\PlatformHelper.cs,,The length of the parameter s_lastProcessorCountRefreshTicks is 32.
Long Statement,System.Collections.Concurrent,BlockingCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\BlockingCollection.cs,TryAddWithNoTimeValidation,The length of the statement  "                // The idea behind to spin until all adders finish' is to avoid to return to the caller with IOE while there are still some adders have " is 135.
Long Statement,System.Collections.Concurrent,BlockingCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\BlockingCollection.cs,TryAddWithNoTimeValidation,The length of the statement  "                        Debug.Assert((observedAdders + 1) <= (~COMPLETE_ADDING_ON_MASK)' "The number of concurrent adders thread exceeded the maximum limit."); " is 135.
Long Statement,System.Collections.Concurrent,BlockingCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\BlockingCollection.cs,TryAddWithNoTimeValidation,The length of the statement  "                // This outer try/finally to workaround of repeating the decrement adders code 3 times' because we should decrement the adders if: " is 130.
Long Statement,System.Collections.Concurrent,BlockingCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\BlockingCollection.cs,TryAddWithNoTimeValidation,The length of the statement  "                        //The token may have been canceled before the collection had space available' so we need a check after the wait has completed. " is 126.
Long Statement,System.Collections.Concurrent,BlockingCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\BlockingCollection.cs,TryTakeWithNoTimeValidation,The length of the statement  "                // only dispose the combined token source if we created it here' otherwise the caller (GetConsumingEnumerable) is responsible for disposing it " is 142.
Long Statement,System.Collections.Concurrent,BlockingCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\BlockingCollection.cs,TryAddToAnyCore,The length of the statement  "                using (CancellationTokenSource linkedTokenSource = CancellationTokenSource.CreateLinkedTokenSource(collatedCancellationTokens)) " is 127.
Long Statement,System.Collections.Concurrent,BlockingCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\BlockingCollection.cs,GetHandles,The length of the statement  "            List<WaitHandle> handlesList = new List<WaitHandle>(collections.Length + 1); // + 1 for the external token handle to be added " is 125.
Long Statement,System.Collections.Concurrent,BlockingCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\BlockingCollection.cs,TryTakeFromAnyCoreSlow,The length of the statement  "                using (CancellationTokenSource linkedTokenSource = CancellationTokenSource.CreateLinkedTokenSource(collatedCancellationTokens)) " is 127.
Long Statement,System.Collections.Concurrent,BlockingCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\BlockingCollection.cs,CompleteAdding,The length of the statement  "                if (Interlocked.CompareExchange(ref _currentAdders' observedAdders | COMPLETE_ADDING_ON_MASK' observedAdders) == observedAdders) " is 128.
Long Statement,System.Collections.Concurrent,BlockingCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\BlockingCollection.cs,GetConsumingEnumerable,The length of the statement  "                linkedTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken' _consumersCancellationTokenSource.Token); " is 128.
Long Statement,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentDictionary.cs,Remove,The length of the statement  "            if (keyValuePair.Key == null) throw new ArgumentNullException(nameof(keyValuePair)' SR.ConcurrentDictionary_ItemKeyIsNull); " is 123.
Long Statement,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The length of the statement  "                // Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by " is 123.
Long Statement,System.Collections.Concurrent,Partitioner,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\PartitionerStatic.cs,Create,The length of the statement  "            return Partitioner.Create(CreateRanges(fromInclusive' toExclusive' rangeSize)' EnumerablePartitionerOptions.NoBuffering); // chunk one range at a time " is 150.
Long Statement,System.Collections.Concurrent,Partitioner,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\PartitionerStatic.cs,Create,The length of the statement  "            return Partitioner.Create(CreateRanges(fromInclusive' toExclusive' rangeSize)' EnumerablePartitionerOptions.NoBuffering); // chunk one range at a time " is 150.
Long Statement,System.Collections.Concurrent,Partitioner,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\PartitionerStatic.cs,Create,The length of the statement  "            return Partitioner.Create(CreateRanges(fromInclusive' toExclusive' rangeSize)' EnumerablePartitionerOptions.NoBuffering); // chunk one range at a time " is 150.
Long Statement,System.Collections.Concurrent,Partitioner,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\PartitionerStatic.cs,Create,The length of the statement  "            return Partitioner.Create(CreateRanges(fromInclusive' toExclusive' rangeSize)' EnumerablePartitionerOptions.NoBuffering); // chunk one range at a time " is 150.
Long Statement,System.Collections.Concurrent,DynamicPartitionerForIEnumerable<TSource>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\PartitionerStatic.cs,GetOrderablePartitions,The length of the statement  "                IEnumerable<KeyValuePair<long' TSource>> partitionEnumerable = new InternalPartitionEnumerable(_source.GetEnumerator()' _useSingleChunking' true); " is 146.
Long Statement,System.Collections.Concurrent,InternalPartitionEnumerable,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\PartitionerStatic.cs,GrabChunk_Single,The length of the statement  "                    Debug.Assert(requestedChunkSize == 1' "Got requested chunk size of " + requestedChunkSize + " when single-chunking was on"); " is 124.
Long Statement,System.Collections.Concurrent,InternalPartitionEnumerable,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\PartitionerStatic.cs,GrabChunk_Single,The length of the statement  "                    Debug.Assert(actualNumElementsGrabbed == 0' "Expected actualNumElementsGrabbed == 0' instead it is " + actualNumElementsGrabbed); " is 129.
Complex Conditional,System.Collections.Concurrent,BlockingCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\BlockingCollection.cs,ValidateCollectionsArray,The conditional expression  "(!IsSTAThread && collections.Length > 63) || (IsSTAThread && collections.Length > 62)"  is complex.
Magic Number,System.Collections.Concurrent,BlockingCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\BlockingCollection.cs,ValidateCollectionsArray,The following statement contains a magic number: if (collections == null)              {                  throw new ArgumentNullException(nameof(collections));              }              else if (collections.Length < 1)              {                  throw new ArgumentException(                      SR.BlockingCollection_ValidateCollectionsArray_ZeroSize' nameof(collections));              }              else if ((!IsSTAThread && collections.Length > 63) || (IsSTAThread && collections.Length > 62))              //The number of WaitHandles must be <= 64 for MTA' and <=63 for STA' and we reserve one for CancellationToken                              {                  throw new ArgumentOutOfRangeException(  nameof(collections)' SR.BlockingCollection_ValidateCollectionsArray_LargeSize);              }
Magic Number,System.Collections.Concurrent,BlockingCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\BlockingCollection.cs,ValidateCollectionsArray,The following statement contains a magic number: if (collections == null)              {                  throw new ArgumentNullException(nameof(collections));              }              else if (collections.Length < 1)              {                  throw new ArgumentException(                      SR.BlockingCollection_ValidateCollectionsArray_ZeroSize' nameof(collections));              }              else if ((!IsSTAThread && collections.Length > 63) || (IsSTAThread && collections.Length > 62))              //The number of WaitHandles must be <= 64 for MTA' and <=63 for STA' and we reserve one for CancellationToken                              {                  throw new ArgumentOutOfRangeException(  nameof(collections)' SR.BlockingCollection_ValidateCollectionsArray_LargeSize);              }
Magic Number,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentDictionary.cs,IsValueWriteAtomic,The following statement contains a magic number: switch (Type.GetTypeCode(valueType))              {                  case TypeCode.Boolean:                  case TypeCode.Byte:                  case TypeCode.Char:                  case TypeCode.Int16:                  case TypeCode.Int32:                  case TypeCode.SByte:                  case TypeCode.Single:                  case TypeCode.UInt16:                  case TypeCode.UInt32:                      return true;                  case TypeCode.Int64:                  case TypeCode.Double:                  case TypeCode.UInt64:                      return IntPtr.Size == 8;                  default:                      return false;              }
Magic Number,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try              {                  // The thread that first obtains _locks[0] will be the one doing the resize operation                  AcquireLocks(0' 1' ref locksAcquired);                    // Make sure nobody resized the table while we were waiting for lock 0:                  if (tables != _tables)                  {                      // We assume that since the table reference is different' it was already resized (or the budget                      // was adjusted). If we ever decide to do table shrinking' or replace the table for other reasons'                      // we will have to revisit this logic.                      return;                  }                    // Compute the (approx.) total size. Use an Int64 accumulation variable to avoid an overflow.                  long approxCount = 0;                  for (int i = 0; i < tables._countPerLock.Length; i++)                  {                      approxCount += tables._countPerLock[i];                  }                    //                  // If the bucket array is too empty' double the budget instead of resizing the table                  //                  if (approxCount < tables._buckets.Length / 4)                  {                      _budget = 2 * _budget;                      if (_budget < 0)                      {                          _budget = int.MaxValue;                      }                      return;                  }                      // Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by                  // 2'3'5 or 7. We can consider a different table-sizing policy in the future.                  int newLength = 0;                  bool maximizeTableSize = false;                  try                  {                      checked                      {                          // Double the size of the buckets table and add one' so that we have an odd integer.                          newLength = tables._buckets.Length * 2 + 1;                            // Now' we only need to check odd integers' and find the first that is not divisible                          // by 3' 5 or 7.                          while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0)                          {                              newLength += 2;                          }                            Debug.Assert(newLength % 2 != 0);                            if (newLength > MaxArrayLength)                          {                              maximizeTableSize = true;                          }                      }                  }                  catch (OverflowException)                  {                      maximizeTableSize = true;                  }                    if (maximizeTableSize)                  {                      newLength = MaxArrayLength;                        // We want to make sure that GrowTable will not be called again' since table is at the maximum size.                      // To achieve that' we set the budget to int.MaxValue.                      //                      // (There is one special case that would allow GrowTable() to be called in the future:                       // calling Clear() on the ConcurrentDictionary will shrink the table and lower the budget.)                      _budget = int.MaxValue;                  }                    // Now acquire all other locks for the table                  AcquireLocks(1' tables._locks.Length' ref locksAcquired);                    object[] newLocks = tables._locks;                    // Add more locks                  if (_growLockArray && tables._locks.Length < MaxLockNumber)                  {                      newLocks = new object[tables._locks.Length * 2];                      Array.Copy(tables._locks' 0' newLocks' 0' tables._locks.Length);                      for (int i = tables._locks.Length; i < newLocks.Length; i++)                      {                          newLocks[i] = new object();                      }                  }                    Node[] newBuckets = new Node[newLength];                  int[] newCountPerLock = new int[newLocks.Length];                    // Copy all data into a new table' creating new nodes for all elements                  for (int i = 0; i < tables._buckets.Length; i++)                  {                      Node current = tables._buckets[i];                      while (current != null)                      {                          Node next = current._next;                          int newBucketNo' newLockNo;                          GetBucketAndLockNo(current._hashcode' out newBucketNo' out newLockNo' newBuckets.Length' newLocks.Length);                            newBuckets[newBucketNo] = new Node(current._key' current._value' current._hashcode' newBuckets[newBucketNo]);                            checked                          {                              newCountPerLock[newLockNo]++;                          }                            current = next;                      }                  }                    // Adjust the budget                  _budget = Math.Max(1' newBuckets.Length / newLocks.Length);                    // Replace tables with the new versions                  _tables = new Tables(newBuckets' newLocks' newCountPerLock);              }              finally              {                  // Release all locks that we took earlier                  ReleaseLocks(0' locksAcquired);              }
Magic Number,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try              {                  // The thread that first obtains _locks[0] will be the one doing the resize operation                  AcquireLocks(0' 1' ref locksAcquired);                    // Make sure nobody resized the table while we were waiting for lock 0:                  if (tables != _tables)                  {                      // We assume that since the table reference is different' it was already resized (or the budget                      // was adjusted). If we ever decide to do table shrinking' or replace the table for other reasons'                      // we will have to revisit this logic.                      return;                  }                    // Compute the (approx.) total size. Use an Int64 accumulation variable to avoid an overflow.                  long approxCount = 0;                  for (int i = 0; i < tables._countPerLock.Length; i++)                  {                      approxCount += tables._countPerLock[i];                  }                    //                  // If the bucket array is too empty' double the budget instead of resizing the table                  //                  if (approxCount < tables._buckets.Length / 4)                  {                      _budget = 2 * _budget;                      if (_budget < 0)                      {                          _budget = int.MaxValue;                      }                      return;                  }                      // Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by                  // 2'3'5 or 7. We can consider a different table-sizing policy in the future.                  int newLength = 0;                  bool maximizeTableSize = false;                  try                  {                      checked                      {                          // Double the size of the buckets table and add one' so that we have an odd integer.                          newLength = tables._buckets.Length * 2 + 1;                            // Now' we only need to check odd integers' and find the first that is not divisible                          // by 3' 5 or 7.                          while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0)                          {                              newLength += 2;                          }                            Debug.Assert(newLength % 2 != 0);                            if (newLength > MaxArrayLength)                          {                              maximizeTableSize = true;                          }                      }                  }                  catch (OverflowException)                  {                      maximizeTableSize = true;                  }                    if (maximizeTableSize)                  {                      newLength = MaxArrayLength;                        // We want to make sure that GrowTable will not be called again' since table is at the maximum size.                      // To achieve that' we set the budget to int.MaxValue.                      //                      // (There is one special case that would allow GrowTable() to be called in the future:                       // calling Clear() on the ConcurrentDictionary will shrink the table and lower the budget.)                      _budget = int.MaxValue;                  }                    // Now acquire all other locks for the table                  AcquireLocks(1' tables._locks.Length' ref locksAcquired);                    object[] newLocks = tables._locks;                    // Add more locks                  if (_growLockArray && tables._locks.Length < MaxLockNumber)                  {                      newLocks = new object[tables._locks.Length * 2];                      Array.Copy(tables._locks' 0' newLocks' 0' tables._locks.Length);                      for (int i = tables._locks.Length; i < newLocks.Length; i++)                      {                          newLocks[i] = new object();                      }                  }                    Node[] newBuckets = new Node[newLength];                  int[] newCountPerLock = new int[newLocks.Length];                    // Copy all data into a new table' creating new nodes for all elements                  for (int i = 0; i < tables._buckets.Length; i++)                  {                      Node current = tables._buckets[i];                      while (current != null)                      {                          Node next = current._next;                          int newBucketNo' newLockNo;                          GetBucketAndLockNo(current._hashcode' out newBucketNo' out newLockNo' newBuckets.Length' newLocks.Length);                            newBuckets[newBucketNo] = new Node(current._key' current._value' current._hashcode' newBuckets[newBucketNo]);                            checked                          {                              newCountPerLock[newLockNo]++;                          }                            current = next;                      }                  }                    // Adjust the budget                  _budget = Math.Max(1' newBuckets.Length / newLocks.Length);                    // Replace tables with the new versions                  _tables = new Tables(newBuckets' newLocks' newCountPerLock);              }              finally              {                  // Release all locks that we took earlier                  ReleaseLocks(0' locksAcquired);              }
Magic Number,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try              {                  // The thread that first obtains _locks[0] will be the one doing the resize operation                  AcquireLocks(0' 1' ref locksAcquired);                    // Make sure nobody resized the table while we were waiting for lock 0:                  if (tables != _tables)                  {                      // We assume that since the table reference is different' it was already resized (or the budget                      // was adjusted). If we ever decide to do table shrinking' or replace the table for other reasons'                      // we will have to revisit this logic.                      return;                  }                    // Compute the (approx.) total size. Use an Int64 accumulation variable to avoid an overflow.                  long approxCount = 0;                  for (int i = 0; i < tables._countPerLock.Length; i++)                  {                      approxCount += tables._countPerLock[i];                  }                    //                  // If the bucket array is too empty' double the budget instead of resizing the table                  //                  if (approxCount < tables._buckets.Length / 4)                  {                      _budget = 2 * _budget;                      if (_budget < 0)                      {                          _budget = int.MaxValue;                      }                      return;                  }                      // Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by                  // 2'3'5 or 7. We can consider a different table-sizing policy in the future.                  int newLength = 0;                  bool maximizeTableSize = false;                  try                  {                      checked                      {                          // Double the size of the buckets table and add one' so that we have an odd integer.                          newLength = tables._buckets.Length * 2 + 1;                            // Now' we only need to check odd integers' and find the first that is not divisible                          // by 3' 5 or 7.                          while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0)                          {                              newLength += 2;                          }                            Debug.Assert(newLength % 2 != 0);                            if (newLength > MaxArrayLength)                          {                              maximizeTableSize = true;                          }                      }                  }                  catch (OverflowException)                  {                      maximizeTableSize = true;                  }                    if (maximizeTableSize)                  {                      newLength = MaxArrayLength;                        // We want to make sure that GrowTable will not be called again' since table is at the maximum size.                      // To achieve that' we set the budget to int.MaxValue.                      //                      // (There is one special case that would allow GrowTable() to be called in the future:                       // calling Clear() on the ConcurrentDictionary will shrink the table and lower the budget.)                      _budget = int.MaxValue;                  }                    // Now acquire all other locks for the table                  AcquireLocks(1' tables._locks.Length' ref locksAcquired);                    object[] newLocks = tables._locks;                    // Add more locks                  if (_growLockArray && tables._locks.Length < MaxLockNumber)                  {                      newLocks = new object[tables._locks.Length * 2];                      Array.Copy(tables._locks' 0' newLocks' 0' tables._locks.Length);                      for (int i = tables._locks.Length; i < newLocks.Length; i++)                      {                          newLocks[i] = new object();                      }                  }                    Node[] newBuckets = new Node[newLength];                  int[] newCountPerLock = new int[newLocks.Length];                    // Copy all data into a new table' creating new nodes for all elements                  for (int i = 0; i < tables._buckets.Length; i++)                  {                      Node current = tables._buckets[i];                      while (current != null)                      {                          Node next = current._next;                          int newBucketNo' newLockNo;                          GetBucketAndLockNo(current._hashcode' out newBucketNo' out newLockNo' newBuckets.Length' newLocks.Length);                            newBuckets[newBucketNo] = new Node(current._key' current._value' current._hashcode' newBuckets[newBucketNo]);                            checked                          {                              newCountPerLock[newLockNo]++;                          }                            current = next;                      }                  }                    // Adjust the budget                  _budget = Math.Max(1' newBuckets.Length / newLocks.Length);                    // Replace tables with the new versions                  _tables = new Tables(newBuckets' newLocks' newCountPerLock);              }              finally              {                  // Release all locks that we took earlier                  ReleaseLocks(0' locksAcquired);              }
Magic Number,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try              {                  // The thread that first obtains _locks[0] will be the one doing the resize operation                  AcquireLocks(0' 1' ref locksAcquired);                    // Make sure nobody resized the table while we were waiting for lock 0:                  if (tables != _tables)                  {                      // We assume that since the table reference is different' it was already resized (or the budget                      // was adjusted). If we ever decide to do table shrinking' or replace the table for other reasons'                      // we will have to revisit this logic.                      return;                  }                    // Compute the (approx.) total size. Use an Int64 accumulation variable to avoid an overflow.                  long approxCount = 0;                  for (int i = 0; i < tables._countPerLock.Length; i++)                  {                      approxCount += tables._countPerLock[i];                  }                    //                  // If the bucket array is too empty' double the budget instead of resizing the table                  //                  if (approxCount < tables._buckets.Length / 4)                  {                      _budget = 2 * _budget;                      if (_budget < 0)                      {                          _budget = int.MaxValue;                      }                      return;                  }                      // Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by                  // 2'3'5 or 7. We can consider a different table-sizing policy in the future.                  int newLength = 0;                  bool maximizeTableSize = false;                  try                  {                      checked                      {                          // Double the size of the buckets table and add one' so that we have an odd integer.                          newLength = tables._buckets.Length * 2 + 1;                            // Now' we only need to check odd integers' and find the first that is not divisible                          // by 3' 5 or 7.                          while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0)                          {                              newLength += 2;                          }                            Debug.Assert(newLength % 2 != 0);                            if (newLength > MaxArrayLength)                          {                              maximizeTableSize = true;                          }                      }                  }                  catch (OverflowException)                  {                      maximizeTableSize = true;                  }                    if (maximizeTableSize)                  {                      newLength = MaxArrayLength;                        // We want to make sure that GrowTable will not be called again' since table is at the maximum size.                      // To achieve that' we set the budget to int.MaxValue.                      //                      // (There is one special case that would allow GrowTable() to be called in the future:                       // calling Clear() on the ConcurrentDictionary will shrink the table and lower the budget.)                      _budget = int.MaxValue;                  }                    // Now acquire all other locks for the table                  AcquireLocks(1' tables._locks.Length' ref locksAcquired);                    object[] newLocks = tables._locks;                    // Add more locks                  if (_growLockArray && tables._locks.Length < MaxLockNumber)                  {                      newLocks = new object[tables._locks.Length * 2];                      Array.Copy(tables._locks' 0' newLocks' 0' tables._locks.Length);                      for (int i = tables._locks.Length; i < newLocks.Length; i++)                      {                          newLocks[i] = new object();                      }                  }                    Node[] newBuckets = new Node[newLength];                  int[] newCountPerLock = new int[newLocks.Length];                    // Copy all data into a new table' creating new nodes for all elements                  for (int i = 0; i < tables._buckets.Length; i++)                  {                      Node current = tables._buckets[i];                      while (current != null)                      {                          Node next = current._next;                          int newBucketNo' newLockNo;                          GetBucketAndLockNo(current._hashcode' out newBucketNo' out newLockNo' newBuckets.Length' newLocks.Length);                            newBuckets[newBucketNo] = new Node(current._key' current._value' current._hashcode' newBuckets[newBucketNo]);                            checked                          {                              newCountPerLock[newLockNo]++;                          }                            current = next;                      }                  }                    // Adjust the budget                  _budget = Math.Max(1' newBuckets.Length / newLocks.Length);                    // Replace tables with the new versions                  _tables = new Tables(newBuckets' newLocks' newCountPerLock);              }              finally              {                  // Release all locks that we took earlier                  ReleaseLocks(0' locksAcquired);              }
Magic Number,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try              {                  // The thread that first obtains _locks[0] will be the one doing the resize operation                  AcquireLocks(0' 1' ref locksAcquired);                    // Make sure nobody resized the table while we were waiting for lock 0:                  if (tables != _tables)                  {                      // We assume that since the table reference is different' it was already resized (or the budget                      // was adjusted). If we ever decide to do table shrinking' or replace the table for other reasons'                      // we will have to revisit this logic.                      return;                  }                    // Compute the (approx.) total size. Use an Int64 accumulation variable to avoid an overflow.                  long approxCount = 0;                  for (int i = 0; i < tables._countPerLock.Length; i++)                  {                      approxCount += tables._countPerLock[i];                  }                    //                  // If the bucket array is too empty' double the budget instead of resizing the table                  //                  if (approxCount < tables._buckets.Length / 4)                  {                      _budget = 2 * _budget;                      if (_budget < 0)                      {                          _budget = int.MaxValue;                      }                      return;                  }                      // Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by                  // 2'3'5 or 7. We can consider a different table-sizing policy in the future.                  int newLength = 0;                  bool maximizeTableSize = false;                  try                  {                      checked                      {                          // Double the size of the buckets table and add one' so that we have an odd integer.                          newLength = tables._buckets.Length * 2 + 1;                            // Now' we only need to check odd integers' and find the first that is not divisible                          // by 3' 5 or 7.                          while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0)                          {                              newLength += 2;                          }                            Debug.Assert(newLength % 2 != 0);                            if (newLength > MaxArrayLength)                          {                              maximizeTableSize = true;                          }                      }                  }                  catch (OverflowException)                  {                      maximizeTableSize = true;                  }                    if (maximizeTableSize)                  {                      newLength = MaxArrayLength;                        // We want to make sure that GrowTable will not be called again' since table is at the maximum size.                      // To achieve that' we set the budget to int.MaxValue.                      //                      // (There is one special case that would allow GrowTable() to be called in the future:                       // calling Clear() on the ConcurrentDictionary will shrink the table and lower the budget.)                      _budget = int.MaxValue;                  }                    // Now acquire all other locks for the table                  AcquireLocks(1' tables._locks.Length' ref locksAcquired);                    object[] newLocks = tables._locks;                    // Add more locks                  if (_growLockArray && tables._locks.Length < MaxLockNumber)                  {                      newLocks = new object[tables._locks.Length * 2];                      Array.Copy(tables._locks' 0' newLocks' 0' tables._locks.Length);                      for (int i = tables._locks.Length; i < newLocks.Length; i++)                      {                          newLocks[i] = new object();                      }                  }                    Node[] newBuckets = new Node[newLength];                  int[] newCountPerLock = new int[newLocks.Length];                    // Copy all data into a new table' creating new nodes for all elements                  for (int i = 0; i < tables._buckets.Length; i++)                  {                      Node current = tables._buckets[i];                      while (current != null)                      {                          Node next = current._next;                          int newBucketNo' newLockNo;                          GetBucketAndLockNo(current._hashcode' out newBucketNo' out newLockNo' newBuckets.Length' newLocks.Length);                            newBuckets[newBucketNo] = new Node(current._key' current._value' current._hashcode' newBuckets[newBucketNo]);                            checked                          {                              newCountPerLock[newLockNo]++;                          }                            current = next;                      }                  }                    // Adjust the budget                  _budget = Math.Max(1' newBuckets.Length / newLocks.Length);                    // Replace tables with the new versions                  _tables = new Tables(newBuckets' newLocks' newCountPerLock);              }              finally              {                  // Release all locks that we took earlier                  ReleaseLocks(0' locksAcquired);              }
Magic Number,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try              {                  // The thread that first obtains _locks[0] will be the one doing the resize operation                  AcquireLocks(0' 1' ref locksAcquired);                    // Make sure nobody resized the table while we were waiting for lock 0:                  if (tables != _tables)                  {                      // We assume that since the table reference is different' it was already resized (or the budget                      // was adjusted). If we ever decide to do table shrinking' or replace the table for other reasons'                      // we will have to revisit this logic.                      return;                  }                    // Compute the (approx.) total size. Use an Int64 accumulation variable to avoid an overflow.                  long approxCount = 0;                  for (int i = 0; i < tables._countPerLock.Length; i++)                  {                      approxCount += tables._countPerLock[i];                  }                    //                  // If the bucket array is too empty' double the budget instead of resizing the table                  //                  if (approxCount < tables._buckets.Length / 4)                  {                      _budget = 2 * _budget;                      if (_budget < 0)                      {                          _budget = int.MaxValue;                      }                      return;                  }                      // Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by                  // 2'3'5 or 7. We can consider a different table-sizing policy in the future.                  int newLength = 0;                  bool maximizeTableSize = false;                  try                  {                      checked                      {                          // Double the size of the buckets table and add one' so that we have an odd integer.                          newLength = tables._buckets.Length * 2 + 1;                            // Now' we only need to check odd integers' and find the first that is not divisible                          // by 3' 5 or 7.                          while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0)                          {                              newLength += 2;                          }                            Debug.Assert(newLength % 2 != 0);                            if (newLength > MaxArrayLength)                          {                              maximizeTableSize = true;                          }                      }                  }                  catch (OverflowException)                  {                      maximizeTableSize = true;                  }                    if (maximizeTableSize)                  {                      newLength = MaxArrayLength;                        // We want to make sure that GrowTable will not be called again' since table is at the maximum size.                      // To achieve that' we set the budget to int.MaxValue.                      //                      // (There is one special case that would allow GrowTable() to be called in the future:                       // calling Clear() on the ConcurrentDictionary will shrink the table and lower the budget.)                      _budget = int.MaxValue;                  }                    // Now acquire all other locks for the table                  AcquireLocks(1' tables._locks.Length' ref locksAcquired);                    object[] newLocks = tables._locks;                    // Add more locks                  if (_growLockArray && tables._locks.Length < MaxLockNumber)                  {                      newLocks = new object[tables._locks.Length * 2];                      Array.Copy(tables._locks' 0' newLocks' 0' tables._locks.Length);                      for (int i = tables._locks.Length; i < newLocks.Length; i++)                      {                          newLocks[i] = new object();                      }                  }                    Node[] newBuckets = new Node[newLength];                  int[] newCountPerLock = new int[newLocks.Length];                    // Copy all data into a new table' creating new nodes for all elements                  for (int i = 0; i < tables._buckets.Length; i++)                  {                      Node current = tables._buckets[i];                      while (current != null)                      {                          Node next = current._next;                          int newBucketNo' newLockNo;                          GetBucketAndLockNo(current._hashcode' out newBucketNo' out newLockNo' newBuckets.Length' newLocks.Length);                            newBuckets[newBucketNo] = new Node(current._key' current._value' current._hashcode' newBuckets[newBucketNo]);                            checked                          {                              newCountPerLock[newLockNo]++;                          }                            current = next;                      }                  }                    // Adjust the budget                  _budget = Math.Max(1' newBuckets.Length / newLocks.Length);                    // Replace tables with the new versions                  _tables = new Tables(newBuckets' newLocks' newCountPerLock);              }              finally              {                  // Release all locks that we took earlier                  ReleaseLocks(0' locksAcquired);              }
Magic Number,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try              {                  // The thread that first obtains _locks[0] will be the one doing the resize operation                  AcquireLocks(0' 1' ref locksAcquired);                    // Make sure nobody resized the table while we were waiting for lock 0:                  if (tables != _tables)                  {                      // We assume that since the table reference is different' it was already resized (or the budget                      // was adjusted). If we ever decide to do table shrinking' or replace the table for other reasons'                      // we will have to revisit this logic.                      return;                  }                    // Compute the (approx.) total size. Use an Int64 accumulation variable to avoid an overflow.                  long approxCount = 0;                  for (int i = 0; i < tables._countPerLock.Length; i++)                  {                      approxCount += tables._countPerLock[i];                  }                    //                  // If the bucket array is too empty' double the budget instead of resizing the table                  //                  if (approxCount < tables._buckets.Length / 4)                  {                      _budget = 2 * _budget;                      if (_budget < 0)                      {                          _budget = int.MaxValue;                      }                      return;                  }                      // Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by                  // 2'3'5 or 7. We can consider a different table-sizing policy in the future.                  int newLength = 0;                  bool maximizeTableSize = false;                  try                  {                      checked                      {                          // Double the size of the buckets table and add one' so that we have an odd integer.                          newLength = tables._buckets.Length * 2 + 1;                            // Now' we only need to check odd integers' and find the first that is not divisible                          // by 3' 5 or 7.                          while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0)                          {                              newLength += 2;                          }                            Debug.Assert(newLength % 2 != 0);                            if (newLength > MaxArrayLength)                          {                              maximizeTableSize = true;                          }                      }                  }                  catch (OverflowException)                  {                      maximizeTableSize = true;                  }                    if (maximizeTableSize)                  {                      newLength = MaxArrayLength;                        // We want to make sure that GrowTable will not be called again' since table is at the maximum size.                      // To achieve that' we set the budget to int.MaxValue.                      //                      // (There is one special case that would allow GrowTable() to be called in the future:                       // calling Clear() on the ConcurrentDictionary will shrink the table and lower the budget.)                      _budget = int.MaxValue;                  }                    // Now acquire all other locks for the table                  AcquireLocks(1' tables._locks.Length' ref locksAcquired);                    object[] newLocks = tables._locks;                    // Add more locks                  if (_growLockArray && tables._locks.Length < MaxLockNumber)                  {                      newLocks = new object[tables._locks.Length * 2];                      Array.Copy(tables._locks' 0' newLocks' 0' tables._locks.Length);                      for (int i = tables._locks.Length; i < newLocks.Length; i++)                      {                          newLocks[i] = new object();                      }                  }                    Node[] newBuckets = new Node[newLength];                  int[] newCountPerLock = new int[newLocks.Length];                    // Copy all data into a new table' creating new nodes for all elements                  for (int i = 0; i < tables._buckets.Length; i++)                  {                      Node current = tables._buckets[i];                      while (current != null)                      {                          Node next = current._next;                          int newBucketNo' newLockNo;                          GetBucketAndLockNo(current._hashcode' out newBucketNo' out newLockNo' newBuckets.Length' newLocks.Length);                            newBuckets[newBucketNo] = new Node(current._key' current._value' current._hashcode' newBuckets[newBucketNo]);                            checked                          {                              newCountPerLock[newLockNo]++;                          }                            current = next;                      }                  }                    // Adjust the budget                  _budget = Math.Max(1' newBuckets.Length / newLocks.Length);                    // Replace tables with the new versions                  _tables = new Tables(newBuckets' newLocks' newCountPerLock);              }              finally              {                  // Release all locks that we took earlier                  ReleaseLocks(0' locksAcquired);              }
Magic Number,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try              {                  // The thread that first obtains _locks[0] will be the one doing the resize operation                  AcquireLocks(0' 1' ref locksAcquired);                    // Make sure nobody resized the table while we were waiting for lock 0:                  if (tables != _tables)                  {                      // We assume that since the table reference is different' it was already resized (or the budget                      // was adjusted). If we ever decide to do table shrinking' or replace the table for other reasons'                      // we will have to revisit this logic.                      return;                  }                    // Compute the (approx.) total size. Use an Int64 accumulation variable to avoid an overflow.                  long approxCount = 0;                  for (int i = 0; i < tables._countPerLock.Length; i++)                  {                      approxCount += tables._countPerLock[i];                  }                    //                  // If the bucket array is too empty' double the budget instead of resizing the table                  //                  if (approxCount < tables._buckets.Length / 4)                  {                      _budget = 2 * _budget;                      if (_budget < 0)                      {                          _budget = int.MaxValue;                      }                      return;                  }                      // Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by                  // 2'3'5 or 7. We can consider a different table-sizing policy in the future.                  int newLength = 0;                  bool maximizeTableSize = false;                  try                  {                      checked                      {                          // Double the size of the buckets table and add one' so that we have an odd integer.                          newLength = tables._buckets.Length * 2 + 1;                            // Now' we only need to check odd integers' and find the first that is not divisible                          // by 3' 5 or 7.                          while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0)                          {                              newLength += 2;                          }                            Debug.Assert(newLength % 2 != 0);                            if (newLength > MaxArrayLength)                          {                              maximizeTableSize = true;                          }                      }                  }                  catch (OverflowException)                  {                      maximizeTableSize = true;                  }                    if (maximizeTableSize)                  {                      newLength = MaxArrayLength;                        // We want to make sure that GrowTable will not be called again' since table is at the maximum size.                      // To achieve that' we set the budget to int.MaxValue.                      //                      // (There is one special case that would allow GrowTable() to be called in the future:                       // calling Clear() on the ConcurrentDictionary will shrink the table and lower the budget.)                      _budget = int.MaxValue;                  }                    // Now acquire all other locks for the table                  AcquireLocks(1' tables._locks.Length' ref locksAcquired);                    object[] newLocks = tables._locks;                    // Add more locks                  if (_growLockArray && tables._locks.Length < MaxLockNumber)                  {                      newLocks = new object[tables._locks.Length * 2];                      Array.Copy(tables._locks' 0' newLocks' 0' tables._locks.Length);                      for (int i = tables._locks.Length; i < newLocks.Length; i++)                      {                          newLocks[i] = new object();                      }                  }                    Node[] newBuckets = new Node[newLength];                  int[] newCountPerLock = new int[newLocks.Length];                    // Copy all data into a new table' creating new nodes for all elements                  for (int i = 0; i < tables._buckets.Length; i++)                  {                      Node current = tables._buckets[i];                      while (current != null)                      {                          Node next = current._next;                          int newBucketNo' newLockNo;                          GetBucketAndLockNo(current._hashcode' out newBucketNo' out newLockNo' newBuckets.Length' newLocks.Length);                            newBuckets[newBucketNo] = new Node(current._key' current._value' current._hashcode' newBuckets[newBucketNo]);                            checked                          {                              newCountPerLock[newLockNo]++;                          }                            current = next;                      }                  }                    // Adjust the budget                  _budget = Math.Max(1' newBuckets.Length / newLocks.Length);                    // Replace tables with the new versions                  _tables = new Tables(newBuckets' newLocks' newCountPerLock);              }              finally              {                  // Release all locks that we took earlier                  ReleaseLocks(0' locksAcquired);              }
Magic Number,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try              {                  // The thread that first obtains _locks[0] will be the one doing the resize operation                  AcquireLocks(0' 1' ref locksAcquired);                    // Make sure nobody resized the table while we were waiting for lock 0:                  if (tables != _tables)                  {                      // We assume that since the table reference is different' it was already resized (or the budget                      // was adjusted). If we ever decide to do table shrinking' or replace the table for other reasons'                      // we will have to revisit this logic.                      return;                  }                    // Compute the (approx.) total size. Use an Int64 accumulation variable to avoid an overflow.                  long approxCount = 0;                  for (int i = 0; i < tables._countPerLock.Length; i++)                  {                      approxCount += tables._countPerLock[i];                  }                    //                  // If the bucket array is too empty' double the budget instead of resizing the table                  //                  if (approxCount < tables._buckets.Length / 4)                  {                      _budget = 2 * _budget;                      if (_budget < 0)                      {                          _budget = int.MaxValue;                      }                      return;                  }                      // Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by                  // 2'3'5 or 7. We can consider a different table-sizing policy in the future.                  int newLength = 0;                  bool maximizeTableSize = false;                  try                  {                      checked                      {                          // Double the size of the buckets table and add one' so that we have an odd integer.                          newLength = tables._buckets.Length * 2 + 1;                            // Now' we only need to check odd integers' and find the first that is not divisible                          // by 3' 5 or 7.                          while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0)                          {                              newLength += 2;                          }                            Debug.Assert(newLength % 2 != 0);                            if (newLength > MaxArrayLength)                          {                              maximizeTableSize = true;                          }                      }                  }                  catch (OverflowException)                  {                      maximizeTableSize = true;                  }                    if (maximizeTableSize)                  {                      newLength = MaxArrayLength;                        // We want to make sure that GrowTable will not be called again' since table is at the maximum size.                      // To achieve that' we set the budget to int.MaxValue.                      //                      // (There is one special case that would allow GrowTable() to be called in the future:                       // calling Clear() on the ConcurrentDictionary will shrink the table and lower the budget.)                      _budget = int.MaxValue;                  }                    // Now acquire all other locks for the table                  AcquireLocks(1' tables._locks.Length' ref locksAcquired);                    object[] newLocks = tables._locks;                    // Add more locks                  if (_growLockArray && tables._locks.Length < MaxLockNumber)                  {                      newLocks = new object[tables._locks.Length * 2];                      Array.Copy(tables._locks' 0' newLocks' 0' tables._locks.Length);                      for (int i = tables._locks.Length; i < newLocks.Length; i++)                      {                          newLocks[i] = new object();                      }                  }                    Node[] newBuckets = new Node[newLength];                  int[] newCountPerLock = new int[newLocks.Length];                    // Copy all data into a new table' creating new nodes for all elements                  for (int i = 0; i < tables._buckets.Length; i++)                  {                      Node current = tables._buckets[i];                      while (current != null)                      {                          Node next = current._next;                          int newBucketNo' newLockNo;                          GetBucketAndLockNo(current._hashcode' out newBucketNo' out newLockNo' newBuckets.Length' newLocks.Length);                            newBuckets[newBucketNo] = new Node(current._key' current._value' current._hashcode' newBuckets[newBucketNo]);                            checked                          {                              newCountPerLock[newLockNo]++;                          }                            current = next;                      }                  }                    // Adjust the budget                  _budget = Math.Max(1' newBuckets.Length / newLocks.Length);                    // Replace tables with the new versions                  _tables = new Tables(newBuckets' newLocks' newCountPerLock);              }              finally              {                  // Release all locks that we took earlier                  ReleaseLocks(0' locksAcquired);              }
Magic Number,System.Collections.Concurrent,ConcurrentQueue<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentQueue.cs,RoundUpToPowerOf2,The following statement contains a magic number: i |= i >> 2;
Magic Number,System.Collections.Concurrent,ConcurrentQueue<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentQueue.cs,RoundUpToPowerOf2,The following statement contains a magic number: i |= i >> 4;
Magic Number,System.Collections.Concurrent,ConcurrentQueue<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentQueue.cs,RoundUpToPowerOf2,The following statement contains a magic number: i |= i >> 8;
Magic Number,System.Collections.Concurrent,ConcurrentQueue<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentQueue.cs,RoundUpToPowerOf2,The following statement contains a magic number: i |= i >> 16;
Magic Number,System.Collections.Concurrent,ConcurrentQueue<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentQueue.cs,EnqueueSlow,The following statement contains a magic number: while (true)              {                  Segment tail = _tail;                    // Try to append to the existing tail.                  if (tail.TryEnqueue(item))                  {                      return;                  }                    // If we were unsuccessful' take the lock so that we can compare and manipulate                  // the tail.  Assuming another enqueuer hasn't already added a new segment'                  // do so' then loop around to try enqueueing again.                  lock (_crossSegmentLock)                  {                      if (tail == _tail)                      {                          // Make sure no one else can enqueue to this segment.                          tail.EnsureFrozenForEnqueues();                            // We determine the new segment's length based on the old length.                          // In general' we double the size of the segment' to make it less likely                          // that we'll need to grow again.  However' if the tail segment is marked                          // as preserved for observation' something caused us to avoid reusing this                          // segment' and if that happens a lot and we grow' we'll end up allocating                          // lots of wasted space.  As such' in such situations we reset back to the                          // initial segment length; if these observations are happening frequently'                          // this will help to avoid wasted memory' and if they're not' we'll                          // relatively quickly grow again to a larger size.                          int nextSize = tail._preservedForObservation ? InitialSegmentLength : Math.Min(tail.Capacity * 2' MaxSegmentLength);                          var newTail = new Segment(nextSize);                            // Hook up the new tail.                          tail._nextSegment = newTail;                          _tail = newTail;                      }                  }              }
Magic Number,System.Collections.Concurrent,Segment,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentQueue.cs,Segment,The following statement contains a magic number: Debug.Assert(boundedLength >= 2' $"Must be >= 2' got {boundedLength}");
Magic Number,System.Collections.Concurrent,ConcurrentStack<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentStack.cs,TryPopCore,The following statement contains a magic number: while (true)              {                  head = _head;                  // Is the stack empty?                  if (head == null)                  {                      if (count == 1 && CDSCollectionETWBCLProvider.Log.IsEnabled())                      {                          CDSCollectionETWBCLProvider.Log.ConcurrentStack_FastPopFailed(spin.Count);                      }                        poppedHead = null;                      return 0;                  }                  next = head;                  int nodesCount = 1;                  for (; nodesCount < count && next._next != null; nodesCount++)                  {                      next = next._next;                  }                    // Try to swap the new head.  If we succeed' break out of the loop.                  if (Interlocked.CompareExchange(ref _head' next._next' head) == head)                  {                      if (count == 1 && CDSCollectionETWBCLProvider.Log.IsEnabled())                      {                          CDSCollectionETWBCLProvider.Log.ConcurrentStack_FastPopFailed(spin.Count);                      }                        // Return the popped Node.                      poppedHead = head;                      return nodesCount;                  }                    // We failed to CAS the new head.  Spin briefly and retry.                  for (int i = 0; i < backoff; i++)                  {                      spin.SpinOnce();                  }                    if (spin.NextSpinWillYield)                  {                      if (r == null)                      {                          r = new Random();                      }                      backoff = r.Next(1' BACKOFF_MAX_YIELDS);                  }                  else                  {                      backoff *= 2;                  }              }
Magic Number,System.Collections.Concurrent,Partitioner,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\PartitionerStatic.cs,Create,The following statement contains a magic number: int coreOversubscriptionRate = 3;
Magic Number,System.Collections.Concurrent,Partitioner,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\PartitionerStatic.cs,Create,The following statement contains a magic number: int coreOversubscriptionRate = 3;
Magic Number,System.Collections.Concurrent,DynamicPartitionEnumerator_Abstract<TSource;TSourceReader>,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\PartitionerStatic.cs,MoveNext,The following statement contains a magic number: if (_localOffset.Value < _currentChunkSize.Value - 1)                  //attempt to grab the next element from the local chunk                  {                      _localOffset.Value++;                      return true;                  }                  else                  //otherwise it means we exhausted the local chunk                  //grab a new chunk from the source enumerator                  {                      // The second part of the || condition is necessary to handle the case when MoveNext() is called                      // after a previous MoveNext call returned false.                      Debug.Assert(_localOffset.Value == _currentChunkSize.Value - 1 || _currentChunkSize.Value == 0);                        //set the requested chunk size to a proper value                      int requestedChunkSize;                      if (_currentChunkSize.Value == 0) //first time grabbing from source enumerator                      {                          requestedChunkSize = 1;                      }                      else if (_doublingCountdown > 0)                      {                          requestedChunkSize = _currentChunkSize.Value;                      }                      else                      {                          requestedChunkSize = Math.Min(_currentChunkSize.Value * 2' _maxChunkSize);                          _doublingCountdown = CHUNK_DOUBLING_RATE; // reset                      }                        // Decrement your doubling countdown                      _doublingCountdown--;                        Debug.Assert(requestedChunkSize > 0 && requestedChunkSize <= _maxChunkSize);                      //GrabNextChunk will update the value of _currentChunkSize                      if (GrabNextChunk(requestedChunkSize))                      {                          Debug.Assert(_currentChunkSize.Value <= requestedChunkSize && _currentChunkSize.Value > 0);                          _localOffset.Value = 0;                          return true;                      }                      else                      {                          return false;                      }                  }
Magic Number,System.Collections.Concurrent,InternalPartitionEnumerable,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\PartitionerStatic.cs,InternalPartitionEnumerable,The following statement contains a magic number: if (!_useSingleChunking)                      {                          // Time to allocate the fill buffer which is used to reduce the contention on the shared lock.                          // First pick the buffer size multiplier. We use 4 for when there are more than 4 cores' and just 1 for below. This is based on empirical evidence.                          int fillBufferMultiplier = (PlatformHelper.ProcessorCount > 4) ? 4 : 1;                            // and allocate the fill buffer using these two numbers                          _fillBuffer = new KeyValuePair<long' TSource>[fillBufferMultiplier * Partitioner.GetDefaultChunkSize<TSource>()];                      }
Magic Number,System.Collections.Concurrent,InternalPartitionEnumerable,C:\selectedRepos\dotnet_corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\PartitionerStatic.cs,InternalPartitionEnumerable,The following statement contains a magic number: if (!_useSingleChunking)                      {                          // Time to allocate the fill buffer which is used to reduce the contention on the shared lock.                          // First pick the buffer size multiplier. We use 4 for when there are more than 4 cores' and just 1 for below. This is based on empirical evidence.                          int fillBufferMultiplier = (PlatformHelper.ProcessorCount > 4) ? 4 : 1;                            // and allocate the fill buffer using these two numbers                          _fillBuffer = new KeyValuePair<long' TSource>[fillBufferMultiplier * Partitioner.GetDefaultChunkSize<TSource>()];                      }
