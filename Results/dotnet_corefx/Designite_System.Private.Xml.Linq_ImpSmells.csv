Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Xml.Linq,ContentReader,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XContainer.cs,ReadContentFrom,The method has 111 lines of code.
Complex Method,System.Xml.Linq,Extensions,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\Extensions.cs,GetDescendants,Cyclomatic complexity of the method is 8
Complex Method,System.Xml.Linq,XContainer,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XContainer.cs,Add,Cyclomatic complexity of the method is 11
Complex Method,System.Xml.Linq,XContainer,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XContainer.cs,RemoveNodes,Cyclomatic complexity of the method is 8
Complex Method,System.Xml.Linq,XContainer,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XContainer.cs,AddContentSkipNotify,Cyclomatic complexity of the method is 10
Complex Method,System.Xml.Linq,XContainer,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XContainer.cs,ContentsEqual,Cyclomatic complexity of the method is 8
Complex Method,System.Xml.Linq,XHashtableState,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XHashtable.cs,Resize,Cyclomatic complexity of the method is 10
Complex Method,System.Xml.Linq,Inserter,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XLinq.cs,AddContent,Cyclomatic complexity of the method is 10
Complex Method,System.Xml.Linq,StreamingElementWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XLinq.cs,Write,Cyclomatic complexity of the method is 10
Complex Method,System.Xml.Linq,XNode,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XNode.cs,CompareDocumentOrder,Cyclomatic complexity of the method is 14
Complex Method,System.Xml.Linq,XNodeReader,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XNodeReader.cs,MoveToNextAttribute,Cyclomatic complexity of the method is 12
Complex Method,System.Xml.Schema,XmlSchemaInfoEqualityComparer,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Schema\XNodeValidator.cs,GetHashCode,Cyclomatic complexity of the method is 8
Long Parameter List,System.Xml.Linq,XHashtableState,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XHashtable.cs,FindEntry,The method has 5 parameters. Parameters: hashCode' key' index' count' entryIndex
Long Parameter List,System.Xml.Schema,Extensions,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Schema\XNodeValidator.cs,Validate,The method has 5 parameters. Parameters: source' partialValidationType' schemas' validationEventHandler' addSchemaInfo
Long Parameter List,System.Xml.Schema,Extensions,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Schema\XNodeValidator.cs,Validate,The method has 5 parameters. Parameters: source' partialValidationType' schemas' validationEventHandler' addSchemaInfo
Long Statement,System.Xml.Linq,ContentReader,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XContainer.cs,ReadContentFrom,The length of the statement  "                                e.AppendAttributeSkipNotify(new XAttribute(_aCache.Get(r.Prefix.Length == 0 ? string.Empty : r.NamespaceURI).GetName(r.LocalName)' r.Value)); " is 141.
Long Statement,System.Xml.Linq,ContentReader,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XContainer.cs,ReadContentFrom,The length of the statement  "                        _currentContainer.AddNodeSkipNotify(new XDocumentType(r.LocalName' r.GetAttribute("PUBLIC")' r.GetAttribute("SYSTEM")' r.Value)); " is 129.
Long Statement,System.Xml.Linq,ContentReader,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XContainer.cs,ReadContentFrom,The length of the statement  "                                XAttribute a = new XAttribute(_aCache.Get(r.Prefix.Length == 0 ? string.Empty : r.NamespaceURI).GetName(r.LocalName)' r.Value); " is 127.
Long Statement,System.Xml.Linq,XElement,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XElement.cs,Load,The length of the statement  "            if (reader.MoveToContent() != XmlNodeType.Element) throw new InvalidOperationException(SR.Format(SR.InvalidOperation_ExpectedNodeType' XmlNodeType.Element' reader.NodeType)); " is 174.
Long Statement,System.Xml.Linq,XElement,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XElement.cs,LoadAsyncInternal,The length of the statement  "            if (await reader.MoveToContentAsync().ConfigureAwait(false) != XmlNodeType.Element) throw new InvalidOperationException(SR.Format(SR.InvalidOperation_ExpectedNodeType' XmlNodeType.Element' reader.NodeType)); " is 207.
Long Statement,System.Xml.Linq,XElement,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XElement.cs,ReadXml,The length of the statement  "            if (parent != null || annotations != null || content != null || lastAttr != null) throw new InvalidOperationException(SR.InvalidOperation_DeserializeInstance); " is 159.
Long Statement,System.Xml.Linq,XElement,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XElement.cs,ReadXml,The length of the statement  "            if (reader.MoveToContent() != XmlNodeType.Element) throw new InvalidOperationException(SR.Format(SR.InvalidOperation_ExpectedNodeType' XmlNodeType.Element' reader.NodeType)); " is 174.
Long Statement,System.Xml.Linq,XElement,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XElement.cs,ReadElementFromImpl,The length of the statement  "                    XAttribute a = new XAttribute(XNamespace.Get(r.Prefix.Length == 0 ? string.Empty : r.NamespaceURI).GetName(r.LocalName)' r.Value); " is 130.
Long Statement,System.Xml.Linq,ElementWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XLinq.cs,WriteStartElement,The length of the statement  "                    _writer.WriteAttributeString(GetPrefixOfNamespace(ns' false)' localName' namespaceName.Length == 0 && localName == "xmlns" ? XNamespace.xmlnsPrefixNamespace : namespaceName' a.Value); " is 183.
Long Statement,System.Xml.Linq,ElementWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XLinq.cs,WriteStartElementAsync,The length of the statement  "            await _writer.WriteStartElementAsync(GetPrefixOfNamespace(ns' true)' e.Name.LocalName' ns.NamespaceName).ConfigureAwait(false); " is 127.
Long Statement,System.Xml.Linq,ElementWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XLinq.cs,WriteStartElementAsync,The length of the statement  "                    await _writer.WriteAttributeStringAsync(GetPrefixOfNamespace(ns' false)' localName' namespaceName.Length == 0 && localName == "xmlns" ? XNamespace.xmlnsPrefixNamespace : namespaceName' a.Value).ConfigureAwait(false); " is 216.
Long Statement,System.Xml.Linq,StreamingElementWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XLinq.cs,FlushElement,The length of the statement  "                    _writer.WriteAttributeString(GetPrefixOfNamespace(ns' false)' localName' namespaceName.Length == 0 && localName == "xmlns" ? XNamespace.xmlnsPrefixNamespace : namespaceName' a.Value); " is 183.
Long Statement,System.Xml.Linq,XName,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XName.cs,Get,The length of the statement  "                if (i <= 1 || i == expandedName.Length - 1) throw new ArgumentException(SR.Format(SR.Argument_InvalidExpandedName' expandedName)); " is 130.
Long Statement,System.Xml.Linq,XNamespace,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XNamespace.cs,Get,The length of the statement  "            Debug.Assert(count >= 0 && index + count <= namespaceName.Length' "Caller should have checked that count was in bounds"); " is 121.
Long Statement,System.Xml.Linq,XNamespace,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XNamespace.cs,Get,The length of the statement  "                Interlocked.CompareExchange(ref s_namespaces' new XHashtable<WeakReference>(ExtractNamespace' NamespacesCapacity)' null); " is 121.
Long Statement,System.Xml.Linq,XNamespace,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XNamespace.cs,Get,The length of the statement  "                    if (count == xmlPrefixNamespace.Length && string.CompareOrdinal(namespaceName' index' xmlPrefixNamespace' 0' count) == 0) return Xml; " is 133.
Long Statement,System.Xml.Linq,XNamespace,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XNamespace.cs,Get,The length of the statement  "                    if (count == xmlnsPrefixNamespace.Length && string.CompareOrdinal(namespaceName' index' xmlnsPrefixNamespace' 0' count) == 0) return Xmlns; " is 139.
Long Statement,System.Xml.Linq,XNode,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XNode.cs,ReadFrom,The length of the statement  "            if (reader.ReadState != ReadState.Interactive) throw new InvalidOperationException(SR.InvalidOperation_ExpectedInteractive); " is 124.
Long Statement,System.Xml.Linq,XNode,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XNode.cs,ReadFromAsyncInternal,The length of the statement  "            if (reader.ReadState != ReadState.Interactive) throw new InvalidOperationException(SR.InvalidOperation_ExpectedInteractive); " is 124.
Long Statement,System.Xml.Linq,XNodeDocumentOrderComparer,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XNodeDocumentOrderComparer.cs,Compare,The length of the statement  "            if (n1 == null && x != null) throw new ArgumentException(SR.Format(SR.Argument_MustBeDerivedFrom' typeof(XNode))' nameof(x)); " is 125.
Long Statement,System.Xml.Linq,XNodeDocumentOrderComparer,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XNodeDocumentOrderComparer.cs,Compare,The length of the statement  "            if (n2 == null && y != null) throw new ArgumentException(SR.Format(SR.Argument_MustBeDerivedFrom' typeof(XNode))' nameof(y)); " is 125.
Long Statement,System.Xml.Linq,XNodeEqualityComparer,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XNodeEqualityComparer.cs,Equals,The length of the statement  "            if (n1 == null && x != null) throw new ArgumentException(SR.Format(SR.Argument_MustBeDerivedFrom' typeof(XNode))' nameof(x)); " is 125.
Long Statement,System.Xml.Linq,XNodeEqualityComparer,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XNodeEqualityComparer.cs,Equals,The length of the statement  "            if (n2 == null && y != null) throw new ArgumentException(SR.Format(SR.Argument_MustBeDerivedFrom' typeof(XNode))' nameof(y)); " is 125.
Long Statement,System.Xml.Linq,XNodeEqualityComparer,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XNodeEqualityComparer.cs,GetHashCode,The length of the statement  "            if (n == null && obj != null) throw new ArgumentException(SR.Format(SR.Argument_MustBeDerivedFrom' typeof(XNode))' nameof(obj)); " is 128.
Long Statement,System.Xml.Linq,XNodeReader,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XNodeReader.cs,IsDuplicateNamespaceAttributeInner,The length of the statement  "            //    Note that if we find a namespace declaration for the same prefix but with a different URI' then we don't have a dupe! " is 123.
Long Statement,System.Xml.Linq,XNodeReader,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XNodeReader.cs,IsDuplicateNamespaceAttributeInner,The length of the statement  "                // Trick - a declaration for the same prefix will have the exact same XName - so we can do a quick ref comparison of names " is 122.
Long Statement,System.Xml.Linq,XNodeReader,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XNodeReader.cs,GetFirstNonDuplicateNamespaceAttribute,The length of the statement  "            Debug.Assert(_omitDuplicateNamespaces' "This method should only be called if we're omitting duplicate namespace attribute." + " is 125.
Long Statement,System.Xml.Linq,XProcessingInstruction,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XProcessingInstruction.cs,ValidateName,The length of the statement  "            if (string.Equals(name' "xml"' StringComparison.OrdinalIgnoreCase)) throw new ArgumentException(SR.Format(SR.Argument_InvalidPIName' name)); " is 140.
Long Statement,System.Xml.XPath,XNodeNavigator,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\XPath\XNodeNavigator.cs,GetXmlNamespaceDeclaration,The length of the statement  "                System.Threading.Interlocked.CompareExchange(ref s_XmlNamespaceDeclaration' new XAttribute(XNamespace.Xmlns.GetName("xml")' xmlPrefixNamespace)' null); " is 151.
Long Statement,System.Xml.XPath,XPathEvaluator,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\XPath\XNodeNavigator.cs,Evaluate,The length of the statement  "            if (!(result is T)) throw new InvalidOperationException(SR.Format(SR.InvalidOperation_UnexpectedEvaluation' result.GetType())); " is 127.
Long Statement,System.Xml.XPath,Extensions,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\XPath\XNodeNavigator.cs,CreateNavigator,The length of the statement  "            if (node is XDocumentType) throw new ArgumentException(SR.Format(SR.Argument_CreateNavigator' XmlNodeType.DocumentType)); " is 121.
Long Statement,System.Xml.XPath,Extensions,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\XPath\XNodeNavigator.cs,CreateNavigator,The length of the statement  "                if (text.GetParent() is XDocument) throw new ArgumentException(SR.Format(SR.Argument_CreateNavigator' XmlNodeType.Whitespace)); " is 127.
Complex Conditional,System.Xml.Linq,ContentReader,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XContainer.cs,ReadContentFrom,The conditional expression  "(_baseUri != null && _baseUri != baseUri) ||                              (_lineInfo != null && _lineInfo.HasLineInfo())"  is complex.
Complex Conditional,System.Xml.Linq,XDocument,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XDocument.cs,IsWhitespace,The conditional expression  "ch != ' ' && ch != '\t' && ch != '\r' && ch != '\n'"  is complex.
Complex Conditional,System.Xml.Linq,XElement,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XElement.cs,ReadXml,The conditional expression  "parent != null || annotations != null || content != null || lastAttr != null"  is complex.
Complex Conditional,System.Xml.Linq,NamespaceResolver,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XLinq.cs,GetPrefixOfNamespace,The conditional expression  "_rover != null && _rover.ns == ns && (allowDefaultNamespace || _rover.prefix.Length > 0)"  is complex.
Virtual Method Call from Constructor,System.Xml.Linq,XComment,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XComment.cs,XComment,The constructor "XComment" calls a virtual method "Read".
Virtual Method Call from Constructor,System.Xml.Linq,XContainer,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XContainer.cs,XContainer,The constructor "XContainer" calls a virtual method "CloneNode".
Virtual Method Call from Constructor,System.Xml.Linq,XDeclaration,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XDeclaration.cs,XDeclaration,The constructor "XDeclaration" calls a virtual method "GetAttribute".
Virtual Method Call from Constructor,System.Xml.Linq,XDeclaration,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XDeclaration.cs,XDeclaration,The constructor "XDeclaration" calls a virtual method "GetAttribute".
Virtual Method Call from Constructor,System.Xml.Linq,XDeclaration,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XDeclaration.cs,XDeclaration,The constructor "XDeclaration" calls a virtual method "GetAttribute".
Virtual Method Call from Constructor,System.Xml.Linq,XDeclaration,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XDeclaration.cs,XDeclaration,The constructor "XDeclaration" calls a virtual method "Read".
Virtual Method Call from Constructor,System.Xml.Linq,XDocumentType,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XDocumentType.cs,XDocumentType,The constructor "XDocumentType" calls a virtual method "GetAttribute".
Virtual Method Call from Constructor,System.Xml.Linq,XDocumentType,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XDocumentType.cs,XDocumentType,The constructor "XDocumentType" calls a virtual method "GetAttribute".
Virtual Method Call from Constructor,System.Xml.Linq,XDocumentType,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XDocumentType.cs,XDocumentType,The constructor "XDocumentType" calls a virtual method "Read".
Virtual Method Call from Constructor,System.Xml.Linq,XProcessingInstruction,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XProcessingInstruction.cs,XProcessingInstruction,The constructor "XProcessingInstruction" calls a virtual method "Read".
Virtual Method Call from Constructor,System.Xml.Linq,XText,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XText.cs,XText,The constructor "XText" calls a virtual method "Read".
Empty Catch Block,System.Xml.Linq,XDocument,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XDocument.cs,Save,The method has an empty catch block.
Empty Catch Block,System.Xml.Linq,XDocument,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XDocument.cs,SaveAsync,The method has an empty catch block.
Empty Catch Block,System.Xml.Linq,XDocument,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XDocument.cs,Save,The method has an empty catch block.
Empty Catch Block,System.Xml.Schema,XNodeValidator,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Schema\XNodeValidator.cs,GetDefaultAttributeSchemaInfo,The method has an empty catch block.
Magic Number,System.Collections.Generic,ArrayBuilder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\ArrayBuilder.cs,EnsureCapacity,The following statement contains a magic number: int nextCapacity = capacity == 0 ? DefaultCapacity : 2 * capacity;
Magic Number,System.Collections.Generic,EnumerableHelpers,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\EnumerableHelpers.cs,ToArray,The following statement contains a magic number: if (source is ICollection<T> ic)              {                  int count = ic.Count;                  if (count != 0)                  {                      // Allocate an array of the desired size' then copy the elements into it. Note that this has the same                      // issue regarding concurrency as other existing collections like List<T>. If the collection size                      // concurrently changes between the array allocation and the CopyTo' we could end up either getting an                      // exception from overrunning the array (if the size went up) or we could end up not filling as many                      // items as 'count' suggests (if the size went down).  This is only an issue for concurrent collections                      // that implement ICollection<T>' which as of .NET 4.6 is just ConcurrentDictionary<TKey' TValue>.                      T[] arr = new T[count];                      ic.CopyTo(arr' 0);                      length = count;                      return arr;                  }              }              else              {                  using (var en = source.GetEnumerator())                  {                      if (en.MoveNext())                      {                          const int DefaultCapacity = 4;                          T[] arr = new T[DefaultCapacity];                          arr[0] = en.Current;                          int count = 1;                            while (en.MoveNext())                          {                              if (count == arr.Length)                              {                                  // MaxArrayLength is defined in Array.MaxArrayLength and in gchelpers in CoreCLR.                                  // It represents the maximum number of elements that can be in an array where                                  // the size of the element is greater than one byte; a separate' slightly larger constant'                                  // is used when the size of the element is one.                                  const int MaxArrayLength = 0x7FEFFFFF;                                    // This is the same growth logic as in List<T>:                                  // If the array is currently empty' we make it a default size.  Otherwise' we attempt to                                  // double the size of the array.  Doubling will overflow once the size of the array reaches                                  // 2^30' since doubling to 2^31 is 1 larger than Int32.MaxValue.  In that case' we instead                                  // constrain the length to be MaxArrayLength (this overflow check works because of the                                  // cast to uint).  Because a slightly larger constant is used when T is one byte in size' we                                  // could then end up in a situation where arr.Length is MaxArrayLength or slightly larger' such                                  // that we constrain newLength to be MaxArrayLength but the needed number of elements is actually                                  // larger than that.  For that case' we then ensure that the newLength is large enough to hold                                  // the desired capacity.  This does mean that in the very rare case where we've grown to such a                                  // large size' each new element added after MaxArrayLength will end up doing a resize.                                  int newLength = count << 1;                                  if ((uint)newLength > MaxArrayLength)                                  {                                      newLength = MaxArrayLength <= count ? count + 1 : MaxArrayLength;                                  }                                    Array.Resize(ref arr' newLength);                              }                                arr[count++] = en.Current;                          }                            length = count;                          return arr;                      }                  }              }
Magic Number,System.Collections.Generic,LargeArrayBuilder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\LargeArrayBuilder.cs,GetBuffer,The following statement contains a magic number: Debug.Assert(index >= 0 && index < _buffers.Count + 2);
Magic Number,System.Collections.Generic,LargeArrayBuilder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\LargeArrayBuilder.cs,AllocateBuffer,The following statement contains a magic number: if ((uint)_count < (uint)ResizeLimit)              {                  // We haven't passed ResizeLimit. Resize _first' copying over the previous items.                  Debug.Assert(_current == _first && _count == _first.Length);                    int nextCapacity = Math.Min(_count == 0 ? StartingCapacity : _count * 2' _maxCapacity);                    _current = new T[nextCapacity];                  Array.Copy(_first' 0' _current' 0' _count);                  _first = _current;              }              else              {                  Debug.Assert(_maxCapacity > ResizeLimit);                  Debug.Assert(_count == ResizeLimit ^ _current != _first);                    int nextCapacity;                  if (_count == ResizeLimit)                  {                      nextCapacity = ResizeLimit;                  }                  else                  {                      // Example scenario: Let's say _count == 64.                      // Then our buffers look like this: | 8 | 8 | 16 | 32 |                      // As you can see' our count will be just double the last buffer.                      // Now' say _maxCapacity is 100. We will find the right amount to allocate by                      // doing min(64' 100 - 64). The lhs represents double the last buffer'                      // the rhs the limit minus the amount we've already allocated.                        Debug.Assert(_count >= ResizeLimit * 2);                      Debug.Assert(_count == _current.Length * 2);                        _buffers.Add(_current);                      nextCapacity = Math.Min(_count' _maxCapacity - _count);                  }                    _current = new T[nextCapacity];                  _index = 0;              }
Magic Number,System.Collections.Generic,LargeArrayBuilder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\LargeArrayBuilder.cs,AllocateBuffer,The following statement contains a magic number: if ((uint)_count < (uint)ResizeLimit)              {                  // We haven't passed ResizeLimit. Resize _first' copying over the previous items.                  Debug.Assert(_current == _first && _count == _first.Length);                    int nextCapacity = Math.Min(_count == 0 ? StartingCapacity : _count * 2' _maxCapacity);                    _current = new T[nextCapacity];                  Array.Copy(_first' 0' _current' 0' _count);                  _first = _current;              }              else              {                  Debug.Assert(_maxCapacity > ResizeLimit);                  Debug.Assert(_count == ResizeLimit ^ _current != _first);                    int nextCapacity;                  if (_count == ResizeLimit)                  {                      nextCapacity = ResizeLimit;                  }                  else                  {                      // Example scenario: Let's say _count == 64.                      // Then our buffers look like this: | 8 | 8 | 16 | 32 |                      // As you can see' our count will be just double the last buffer.                      // Now' say _maxCapacity is 100. We will find the right amount to allocate by                      // doing min(64' 100 - 64). The lhs represents double the last buffer'                      // the rhs the limit minus the amount we've already allocated.                        Debug.Assert(_count >= ResizeLimit * 2);                      Debug.Assert(_count == _current.Length * 2);                        _buffers.Add(_current);                      nextCapacity = Math.Min(_count' _maxCapacity - _count);                  }                    _current = new T[nextCapacity];                  _index = 0;              }
Magic Number,System.Collections.Generic,LargeArrayBuilder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\LargeArrayBuilder.cs,AllocateBuffer,The following statement contains a magic number: if ((uint)_count < (uint)ResizeLimit)              {                  // We haven't passed ResizeLimit. Resize _first' copying over the previous items.                  Debug.Assert(_current == _first && _count == _first.Length);                    int nextCapacity = Math.Min(_count == 0 ? StartingCapacity : _count * 2' _maxCapacity);                    _current = new T[nextCapacity];                  Array.Copy(_first' 0' _current' 0' _count);                  _first = _current;              }              else              {                  Debug.Assert(_maxCapacity > ResizeLimit);                  Debug.Assert(_count == ResizeLimit ^ _current != _first);                    int nextCapacity;                  if (_count == ResizeLimit)                  {                      nextCapacity = ResizeLimit;                  }                  else                  {                      // Example scenario: Let's say _count == 64.                      // Then our buffers look like this: | 8 | 8 | 16 | 32 |                      // As you can see' our count will be just double the last buffer.                      // Now' say _maxCapacity is 100. We will find the right amount to allocate by                      // doing min(64' 100 - 64). The lhs represents double the last buffer'                      // the rhs the limit minus the amount we've already allocated.                        Debug.Assert(_count >= ResizeLimit * 2);                      Debug.Assert(_count == _current.Length * 2);                        _buffers.Add(_current);                      nextCapacity = Math.Min(_count' _maxCapacity - _count);                  }                    _current = new T[nextCapacity];                  _index = 0;              }
Magic Number,System.Xml.Linq,XHashtableState,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XHashtable.cs,Resize,The following statement contains a magic number: if (newSize < _buckets.Length / 2)                  {                      newSize = _buckets.Length;                  }                  else                  {                      newSize = _buckets.Length * 2;                        if (newSize < 0)                          throw new OverflowException();                  }
Magic Number,System.Xml.Linq,XHashtableState,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XHashtable.cs,Resize,The following statement contains a magic number: if (newSize < _buckets.Length / 2)                  {                      newSize = _buckets.Length;                  }                  else                  {                      newSize = _buckets.Length * 2;                        if (newSize < 0)                          throw new OverflowException();                  }
Magic Number,System.Xml.Linq,XHashtableState,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XHashtable.cs,ComputeHashCode,The following statement contains a magic number: for (int i = index; i < end; i++)                      unchecked                      {                          hashCode += (hashCode << 7) ^ key[i];                      }
Magic Number,System.Xml.Linq,XHashtableState,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XHashtable.cs,ComputeHashCode,The following statement contains a magic number: hashCode -= hashCode >> 17;
Magic Number,System.Xml.Linq,XHashtableState,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XHashtable.cs,ComputeHashCode,The following statement contains a magic number: hashCode -= hashCode >> 11;
Magic Number,System.Xml.Linq,XHashtableState,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XHashtable.cs,ComputeHashCode,The following statement contains a magic number: hashCode -= hashCode >> 5;
Magic Number,System.Xml.Linq,XNode,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XNode.cs,GetXmlReaderSettings,The following statement contains a magic number: rs.DtdProcessing = (DtdProcessing)2;
Magic Number,System.Xml.Linq,XNode,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XNode.cs,GetXmlReaderSettings,The following statement contains a magic number: rs.MaxCharactersFromEntities = (long)1e7;
Magic Number,System.Xml.Linq,XObject,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XObject.cs,AddAnnotation,The following statement contains a magic number: if (annotations == null)              {                  annotations = annotation is object[] ? new object[] { annotation } : annotation;              }              else              {                  object[] a = annotations as object[];                  if (a == null)                  {                      annotations = new object[] { annotations' annotation };                  }                  else                  {                      int i = 0;                      while (i < a.Length && a[i] != null) i++;                      if (i == a.Length)                      {                          Array.Resize(ref a' i * 2);                          annotations = a;                      }                      a[i] = annotation;                  }              }
Missing Default,System.Xml.Linq,XDocument,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XDocument.cs,ValidateNode,The following switch statement is missing a default case: switch (node.NodeType)              {                  case XmlNodeType.Text:                      ValidateString(((XText)node).Value);                      break;                  case XmlNodeType.Element:                      ValidateDocument(previous' XmlNodeType.DocumentType' XmlNodeType.None);                      break;                  case XmlNodeType.DocumentType:                      ValidateDocument(previous' XmlNodeType.None' XmlNodeType.Element);                      break;                  case XmlNodeType.CDATA:                      throw new ArgumentException(SR.Format(SR.Argument_AddNode' XmlNodeType.CDATA));                  case XmlNodeType.Document:                      throw new ArgumentException(SR.Format(SR.Argument_AddNode' XmlNodeType.Document));              }
Missing Default,System.Xml.Linq,XNodeReader,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\Linq\XNodeReader.cs,GetAttribute,The following switch statement is missing a default case: switch (name)                  {                      case "PUBLIC":                          return n.PublicId;                      case "SYSTEM":                          return n.SystemId;                  }
Missing Default,System.Xml.XPath,XNodeNavigator,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\XPath\XNodeNavigator.cs,MoveToFirstNamespace,The following switch statement is missing a default case: switch (scope)                  {                      case XPathNamespaceScope.Local:                          a = GetFirstNamespaceDeclarationLocal(e);                          break;                      case XPathNamespaceScope.ExcludeXml:                          a = GetFirstNamespaceDeclarationGlobal(e);                          while (a != null && a.Name.LocalName == "xml")                          {                              a = GetNextNamespaceDeclarationGlobal(a);                          }                          break;                      case XPathNamespaceScope.All:                          a = GetFirstNamespaceDeclarationGlobal(e);                          if (a == null)                          {                              a = GetXmlNamespaceDeclaration();                          }                          break;                  }
Missing Default,System.Xml.XPath,XNodeNavigator,C:\selectedRepos\dotnet_corefx\src\System.Private.Xml.Linq\src\System\Xml\XPath\XNodeNavigator.cs,MoveToNextNamespace,The following switch statement is missing a default case: switch (scope)                  {                      case XPathNamespaceScope.Local:                          if (a.GetParent() != _parent)                          {                              return false;                          }                          a = GetNextNamespaceDeclarationLocal(a);                          break;                      case XPathNamespaceScope.ExcludeXml:                          do                          {                              a = GetNextNamespaceDeclarationGlobal(a);                          } while (a != null &&                                   (a.Name.LocalName == "xml" ||                                    HasNamespaceDeclarationInScope(a' _parent)));                          break;                      case XPathNamespaceScope.All:                          do                          {                              a = GetNextNamespaceDeclarationGlobal(a);                          } while (a != null &&                                   HasNamespaceDeclarationInScope(a' _parent));                          if (a == null &&                              !HasNamespaceDeclarationInScope(GetXmlNamespaceDeclaration()' _parent))                          {                              a = GetXmlNamespaceDeclaration();                          }                          break;                  }
