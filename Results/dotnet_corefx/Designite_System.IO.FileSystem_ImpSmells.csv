Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.IO,DosMatcher,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\DosMatcher.cs,MatchPattern,The method has 199 lines of code.
Complex Method,System.IO,DosMatcher,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\DosMatcher.cs,MatchPattern,Cyclomatic complexity of the method is 13
Complex Method,System.IO,Directory,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\Directory.cs,Move,Cyclomatic complexity of the method is 9
Complex Method,System.IO,DirectoryInfo,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\DirectoryInfo.cs,MoveTo,Cyclomatic complexity of the method is 9
Long Parameter List,System.IO,Directory,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\Directory.cs,InternalGetFileDirectoryNames,The method has 6 parameters. Parameters: path' userPathOriginal' searchPattern' includeFiles' includeDirs' searchOption
Long Parameter List,System.IO,Directory,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\Directory.cs,EnumerateFileSystemNames,The method has 5 parameters. Parameters: path' searchPattern' searchOption' includeFiles' includeDirs
Long Identifier,System.IO,Directory,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\Directory.cs,EnsureTrailingDirectorySeparator,The length of the parameter fullPathWithTrailingDirectorySeparator is 38.
Long Identifier,System.IO,PathHelpers,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\PathHelpers.cs,,The length of the parameter DirectorySeparatorCharAsString is 30.
Long Statement,System.IO,DirectoryInfo,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\DirectoryInfo.cs,InternalGetFiles,The length of the statement  "            IEnumerable<FileInfo> enumerable = (IEnumerable<FileInfo>)FileSystem.Current.EnumerateFileSystemInfos(FullPath' searchPattern' searchOption' SearchTarget.Files); " is 161.
Long Statement,System.IO,DirectoryInfo,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\DirectoryInfo.cs,InternalGetFileSystemInfos,The length of the statement  "            IEnumerable<FileSystemInfo> enumerable = FileSystem.Current.EnumerateFileSystemInfos(FullPath' searchPattern' searchOption' SearchTarget.Both); " is 143.
Long Statement,System.IO,DirectoryInfo,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\DirectoryInfo.cs,InternalGetDirectories,The length of the statement  "            IEnumerable<DirectoryInfo> enumerable = (IEnumerable<DirectoryInfo>)FileSystem.Current.EnumerateFileSystemInfos(FullPath' searchPattern' searchOption' SearchTarget.Directories); " is 177.
Long Statement,System.IO,DirectoryInfo,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\DirectoryInfo.cs,InternalEnumerateDirectories,The length of the statement  "            return (IEnumerable<DirectoryInfo>)FileSystem.Current.EnumerateFileSystemInfos(FullPath' searchPattern' searchOption' SearchTarget.Directories); " is 144.
Long Statement,System.IO,DirectoryInfo,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\DirectoryInfo.cs,InternalEnumerateFiles,The length of the statement  "            return (IEnumerable<FileInfo>)FileSystem.Current.EnumerateFileSystemInfos(FullPath' searchPattern' searchOption' SearchTarget.Files); " is 133.
Long Statement,System.IO,File,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\File.cs,InternalWriteAllBytesAsync,The length of the statement  "            using (FileStream fs = new FileStream(path' FileMode.Create' FileAccess.Write' FileShare.Read' DefaultBufferSize' FileOptions.Asynchronous | FileOptions.SequentialScan)) " is 169.
Long Statement,System.IO,PathHelpers,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\PathHelpers.cs,CombineNoChecksInternal,The length of the statement  "                    (First: (IntPtr)f' FirstLength: first.Length' Second: (IntPtr)s' SecondLength: second.Length' HasSeparator: hasSeparator)' " is 122.
Long Statement,System.IO,PathHelpers,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\PathHelpers.cs,CombineNoChecksInternal,The length of the statement  "                        new Span<char>((char*)state.Second' state.SecondLength).CopyTo(destination.Slice(state.FirstLength + (state.HasSeparator ? 0 : 1))); " is 132.
Long Statement,System.IO,PathHelpers,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\PathHelpers.cs,CombineNoChecksInternal,The length of the statement  "            fixed (char* f = &first.DangerousGetPinnableReference()' s = &second.DangerousGetPinnableReference()' t = &third.DangerousGetPinnableReference()) " is 145.
Long Statement,System.IO,PathHelpers,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\PathHelpers.cs,CombineNoChecksInternal,The length of the statement  "                        Third: (IntPtr)t' ThirdLength: third.Length' FirstHasSeparator: firstHasSeparator' ThirdHasSeparator: thirdHasSeparator)' " is 121.
Long Statement,System.IO,PathHelpers,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\PathHelpers.cs,CombineNoChecksInternal,The length of the statement  "                        new Span<char>((char*)state.Second' state.SecondLength).CopyTo(destination.Slice(state.FirstLength + (state.FirstHasSeparator ? 0 : 1))); " is 137.
Long Statement,System.IO,PathHelpers,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\PathHelpers.cs,CombineNoChecksInternal,The length of the statement  "                        new Span<char>((char*)state.Third' state.ThirdLength).CopyTo(destination.Slice(destination.Length - state.ThirdLength)); " is 120.
Long Statement,System.IO,PathInternal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\IO\PathInternal.cs,GetIsCaseSensitive,The length of the statement  "                using (new FileStream(pathWithUpperCase' FileMode.CreateNew' FileAccess.ReadWrite' FileShare.None' 0x1000' FileOptions.DeleteOnClose)) " is 134.
Long Statement,System.Text,ValueStringBuilder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Text\ValueStringBuilder.cs,Append,The length of the statement  "            if (s.Length == 1 && pos < _chars.Length) // very common case' e.g. appending strings from NumberFormatInfo like separators' percent symbols' etc. " is 146.
Long Statement,System.Threading.Tasks,TaskToApm,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Threading\Tasks\TaskToApm.cs,Begin,The length of the statement  "                asyncResult = task.AsyncState == state ? (IAsyncResult)task : new TaskWrapperAsyncResult(task' state' completedSynchronously: false); " is 133.
Complex Conditional,System.IO,PathInternal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\IO\PathInternal.cs,EqualStartingCharacterCount,The conditional expression  "l != leftEnd && r != rightEnd                      && (*l == *r || (ignoreCase && char.ToUpperInvariant((*l)) == char.ToUpperInvariant((*r))))"  is complex.
Empty Catch Block,System.IO,Directory,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\Directory.cs,Exists,The method has an empty catch block.
Empty Catch Block,System.IO,Directory,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\Directory.cs,Exists,The method has an empty catch block.
Empty Catch Block,System.IO,Directory,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\Directory.cs,Exists,The method has an empty catch block.
Empty Catch Block,System.IO,Directory,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\Directory.cs,Exists,The method has an empty catch block.
Empty Catch Block,System.IO,Directory,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\Directory.cs,Exists,The method has an empty catch block.
Empty Catch Block,System.IO,File,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\File.cs,Exists,The method has an empty catch block.
Empty Catch Block,System.IO,File,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\File.cs,Exists,The method has an empty catch block.
Empty Catch Block,System.IO,File,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\File.cs,Exists,The method has an empty catch block.
Empty Catch Block,System.IO,File,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\File.cs,Exists,The method has an empty catch block.
Empty Catch Block,System.IO,File,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\File.cs,Exists,The method has an empty catch block.
Magic Number,System.IO,DosMatcher,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\DosMatcher.cs,MatchPattern,The following statement contains a magic number: Span<int> priorMatches = stackalloc int[16];
Magic Number,System.IO,DosMatcher,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\DosMatcher.cs,MatchPattern,The following statement contains a magic number: Span<int> currentMatches = stackalloc int[16];
Magic Number,System.IO,DosMatcher,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\DosMatcher.cs,MatchPattern,The following statement contains a magic number: int maxState = expression.Length * 2;
Magic Number,System.IO,DosMatcher,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\DosMatcher.cs,MatchPattern,The following statement contains a magic number: while (!nameFinished)              {                  if (nameOffset < name.Length)                  {                      // Not at the end of the name. Grab the current character and move the offset forward.                      nameChar = name[nameOffset++];                  }                  else                  {                      // At the end of the name. If the expression is exhausted' exit.                      if (priorMatches[matchCount - 1] == maxState)                          break;                        nameFinished = true;                  }                    // Now' for each of the previous stored expression matches' see what                  // we can do with this name character.                  priorMatch = 0;                  currentMatch = 0;                  priorMatchCount = 0;                    while (priorMatch < matchCount)                  {                      // We have to carry on our expression analysis as far as possible for each                      // character of name' so we loop here until the expression stops matching.                        expressionOffset = (priorMatches[priorMatch++] + 1) / 2;                        while (expressionOffset < expression.Length)                      {                          currentState = expressionOffset * 2;                          expressionChar = expression[expressionOffset];                            // We may be about to exhaust the local space for matches'                          // so we have to reallocate if this is the case.                          if (currentMatch >= currentMatches.Length - 2)                          {                              int newSize = currentMatches.Length * 2;                              temp = new int[newSize];                              currentMatches.CopyTo(temp);                              currentMatches = temp;                                temp = new int[newSize];                              priorMatches.CopyTo(temp);                              priorMatches = temp;                          }                            if (expressionChar == '*')                          {                              // '*' matches any character zero or more times.                              goto MatchZeroOrMore;                          }                          else if (expressionChar == '<')                          {                              // '<' (DOS_STAR) matches any character except '.' zero or more times.                                // If we are at a period' determine if we are allowed to                              // consume it' i.e. make sure it is not the last one.                                bool notLastPeriod = false;                              if (!nameFinished && nameChar == '.')                              {                                  for (int offset = nameOffset; offset < name.Length; offset++)                                  {                                      if (name[offset] == '.')                                      {                                          notLastPeriod = true;                                          break;                                      }                                  }                              }                                if (nameFinished || nameChar != '.' || notLastPeriod)                              {                                  goto MatchZeroOrMore;                              }                              else                              {                                  // We are at a period.  We can only match zero                                  // characters (i.e. the epsilon transition).                                  goto MatchZero;                              }                          }                          else                          {                              // The following expression characters all match by consuming                              // a character' thus force the expression' and thus state forward.                              currentState += 2;                                if (expressionChar == '>')                              {                                  // '>' (DOS_QM) is the most complicated. If the name is finished'                                  // we can match zero characters. If this name is a '.'' we                                  // don't match' but look at the next expression.  Otherwise                                  // we match a single character.                                  if (nameFinished || nameChar == '.')                                      goto NextExpressionCharacter;                                    currentMatches[currentMatch++] = currentState;                                  goto ExpressionFinished;                              }                              else if (expressionChar == '"')                              {                                  // A '"' (DOS_DOT) can match either a period' or zero characters                                  // beyond the end of name.                                  if (nameFinished)                                  {                                      goto NextExpressionCharacter;                                  }                                  else if (nameChar == '.')                                  {                                      currentMatches[currentMatch++] = currentState;                                  }                                  goto ExpressionFinished;                              }                              else                              {                                  // From this point on a name character is required to even                                  // continue' let alone make a match.                                  if (nameFinished) goto ExpressionFinished;                                    if (expressionChar == '?')                                  {                                      // If this expression was a '?' we can match it once.                                      currentMatches[currentMatch++] = currentState;                                  }                                  else if (ignoreCase                                      ? char.ToUpperInvariant(expressionChar) == char.ToUpperInvariant(nameChar)                                      : expressionChar == nameChar)                                  {                                      // Matched a non-wildcard character                                      currentMatches[currentMatch++] = currentState;                                  }                                    // The expression didn't match so move to the next prior match.                                  goto ExpressionFinished;                              }                          }                            MatchZeroOrMore:                              currentMatches[currentMatch++] = currentState;                          MatchZero:                              currentMatches[currentMatch++] = currentState + 1;                          NextExpressionCharacter:                              if (++expressionOffset == expression.Length)                                  currentMatches[currentMatch++] = maxState;                      } // while (expressionOffset < expression.Length)                        ExpressionFinished:                        // Prevent duplication in the destination array.                      //                      // Each of the arrays is monotonically increasing and non-duplicating' thus we skip                      // over any source element in the source array if we just added the same element to                      // the destination array. This guarantees non-duplication in the destination array.                        if ((priorMatch < matchCount) && (priorMatchCount < currentMatch))                      {                          while (priorMatchCount < currentMatch)                          {                              int previousLength = priorMatches.Length;                              while ((priorMatch < previousLength) && (priorMatches[priorMatch] < currentMatches[priorMatchCount]))                              {                                  priorMatch++;                              }                              priorMatchCount++;                          }                      }                  } // while (sourceCount < matchesCount)                    // If we found no matches in the just finished iteration it's time to bail.                  if (currentMatch == 0)                      return false;                    // Swap the meaning the two arrays                  temp = priorMatches;                  priorMatches = currentMatches;                  currentMatches = temp;                    matchCount = currentMatch;              }
Magic Number,System.IO,DosMatcher,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\DosMatcher.cs,MatchPattern,The following statement contains a magic number: while (!nameFinished)              {                  if (nameOffset < name.Length)                  {                      // Not at the end of the name. Grab the current character and move the offset forward.                      nameChar = name[nameOffset++];                  }                  else                  {                      // At the end of the name. If the expression is exhausted' exit.                      if (priorMatches[matchCount - 1] == maxState)                          break;                        nameFinished = true;                  }                    // Now' for each of the previous stored expression matches' see what                  // we can do with this name character.                  priorMatch = 0;                  currentMatch = 0;                  priorMatchCount = 0;                    while (priorMatch < matchCount)                  {                      // We have to carry on our expression analysis as far as possible for each                      // character of name' so we loop here until the expression stops matching.                        expressionOffset = (priorMatches[priorMatch++] + 1) / 2;                        while (expressionOffset < expression.Length)                      {                          currentState = expressionOffset * 2;                          expressionChar = expression[expressionOffset];                            // We may be about to exhaust the local space for matches'                          // so we have to reallocate if this is the case.                          if (currentMatch >= currentMatches.Length - 2)                          {                              int newSize = currentMatches.Length * 2;                              temp = new int[newSize];                              currentMatches.CopyTo(temp);                              currentMatches = temp;                                temp = new int[newSize];                              priorMatches.CopyTo(temp);                              priorMatches = temp;                          }                            if (expressionChar == '*')                          {                              // '*' matches any character zero or more times.                              goto MatchZeroOrMore;                          }                          else if (expressionChar == '<')                          {                              // '<' (DOS_STAR) matches any character except '.' zero or more times.                                // If we are at a period' determine if we are allowed to                              // consume it' i.e. make sure it is not the last one.                                bool notLastPeriod = false;                              if (!nameFinished && nameChar == '.')                              {                                  for (int offset = nameOffset; offset < name.Length; offset++)                                  {                                      if (name[offset] == '.')                                      {                                          notLastPeriod = true;                                          break;                                      }                                  }                              }                                if (nameFinished || nameChar != '.' || notLastPeriod)                              {                                  goto MatchZeroOrMore;                              }                              else                              {                                  // We are at a period.  We can only match zero                                  // characters (i.e. the epsilon transition).                                  goto MatchZero;                              }                          }                          else                          {                              // The following expression characters all match by consuming                              // a character' thus force the expression' and thus state forward.                              currentState += 2;                                if (expressionChar == '>')                              {                                  // '>' (DOS_QM) is the most complicated. If the name is finished'                                  // we can match zero characters. If this name is a '.'' we                                  // don't match' but look at the next expression.  Otherwise                                  // we match a single character.                                  if (nameFinished || nameChar == '.')                                      goto NextExpressionCharacter;                                    currentMatches[currentMatch++] = currentState;                                  goto ExpressionFinished;                              }                              else if (expressionChar == '"')                              {                                  // A '"' (DOS_DOT) can match either a period' or zero characters                                  // beyond the end of name.                                  if (nameFinished)                                  {                                      goto NextExpressionCharacter;                                  }                                  else if (nameChar == '.')                                  {                                      currentMatches[currentMatch++] = currentState;                                  }                                  goto ExpressionFinished;                              }                              else                              {                                  // From this point on a name character is required to even                                  // continue' let alone make a match.                                  if (nameFinished) goto ExpressionFinished;                                    if (expressionChar == '?')                                  {                                      // If this expression was a '?' we can match it once.                                      currentMatches[currentMatch++] = currentState;                                  }                                  else if (ignoreCase                                      ? char.ToUpperInvariant(expressionChar) == char.ToUpperInvariant(nameChar)                                      : expressionChar == nameChar)                                  {                                      // Matched a non-wildcard character                                      currentMatches[currentMatch++] = currentState;                                  }                                    // The expression didn't match so move to the next prior match.                                  goto ExpressionFinished;                              }                          }                            MatchZeroOrMore:                              currentMatches[currentMatch++] = currentState;                          MatchZero:                              currentMatches[currentMatch++] = currentState + 1;                          NextExpressionCharacter:                              if (++expressionOffset == expression.Length)                                  currentMatches[currentMatch++] = maxState;                      } // while (expressionOffset < expression.Length)                        ExpressionFinished:                        // Prevent duplication in the destination array.                      //                      // Each of the arrays is monotonically increasing and non-duplicating' thus we skip                      // over any source element in the source array if we just added the same element to                      // the destination array. This guarantees non-duplication in the destination array.                        if ((priorMatch < matchCount) && (priorMatchCount < currentMatch))                      {                          while (priorMatchCount < currentMatch)                          {                              int previousLength = priorMatches.Length;                              while ((priorMatch < previousLength) && (priorMatches[priorMatch] < currentMatches[priorMatchCount]))                              {                                  priorMatch++;                              }                              priorMatchCount++;                          }                      }                  } // while (sourceCount < matchesCount)                    // If we found no matches in the just finished iteration it's time to bail.                  if (currentMatch == 0)                      return false;                    // Swap the meaning the two arrays                  temp = priorMatches;                  priorMatches = currentMatches;                  currentMatches = temp;                    matchCount = currentMatch;              }
Magic Number,System.IO,DosMatcher,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\DosMatcher.cs,MatchPattern,The following statement contains a magic number: while (!nameFinished)              {                  if (nameOffset < name.Length)                  {                      // Not at the end of the name. Grab the current character and move the offset forward.                      nameChar = name[nameOffset++];                  }                  else                  {                      // At the end of the name. If the expression is exhausted' exit.                      if (priorMatches[matchCount - 1] == maxState)                          break;                        nameFinished = true;                  }                    // Now' for each of the previous stored expression matches' see what                  // we can do with this name character.                  priorMatch = 0;                  currentMatch = 0;                  priorMatchCount = 0;                    while (priorMatch < matchCount)                  {                      // We have to carry on our expression analysis as far as possible for each                      // character of name' so we loop here until the expression stops matching.                        expressionOffset = (priorMatches[priorMatch++] + 1) / 2;                        while (expressionOffset < expression.Length)                      {                          currentState = expressionOffset * 2;                          expressionChar = expression[expressionOffset];                            // We may be about to exhaust the local space for matches'                          // so we have to reallocate if this is the case.                          if (currentMatch >= currentMatches.Length - 2)                          {                              int newSize = currentMatches.Length * 2;                              temp = new int[newSize];                              currentMatches.CopyTo(temp);                              currentMatches = temp;                                temp = new int[newSize];                              priorMatches.CopyTo(temp);                              priorMatches = temp;                          }                            if (expressionChar == '*')                          {                              // '*' matches any character zero or more times.                              goto MatchZeroOrMore;                          }                          else if (expressionChar == '<')                          {                              // '<' (DOS_STAR) matches any character except '.' zero or more times.                                // If we are at a period' determine if we are allowed to                              // consume it' i.e. make sure it is not the last one.                                bool notLastPeriod = false;                              if (!nameFinished && nameChar == '.')                              {                                  for (int offset = nameOffset; offset < name.Length; offset++)                                  {                                      if (name[offset] == '.')                                      {                                          notLastPeriod = true;                                          break;                                      }                                  }                              }                                if (nameFinished || nameChar != '.' || notLastPeriod)                              {                                  goto MatchZeroOrMore;                              }                              else                              {                                  // We are at a period.  We can only match zero                                  // characters (i.e. the epsilon transition).                                  goto MatchZero;                              }                          }                          else                          {                              // The following expression characters all match by consuming                              // a character' thus force the expression' and thus state forward.                              currentState += 2;                                if (expressionChar == '>')                              {                                  // '>' (DOS_QM) is the most complicated. If the name is finished'                                  // we can match zero characters. If this name is a '.'' we                                  // don't match' but look at the next expression.  Otherwise                                  // we match a single character.                                  if (nameFinished || nameChar == '.')                                      goto NextExpressionCharacter;                                    currentMatches[currentMatch++] = currentState;                                  goto ExpressionFinished;                              }                              else if (expressionChar == '"')                              {                                  // A '"' (DOS_DOT) can match either a period' or zero characters                                  // beyond the end of name.                                  if (nameFinished)                                  {                                      goto NextExpressionCharacter;                                  }                                  else if (nameChar == '.')                                  {                                      currentMatches[currentMatch++] = currentState;                                  }                                  goto ExpressionFinished;                              }                              else                              {                                  // From this point on a name character is required to even                                  // continue' let alone make a match.                                  if (nameFinished) goto ExpressionFinished;                                    if (expressionChar == '?')                                  {                                      // If this expression was a '?' we can match it once.                                      currentMatches[currentMatch++] = currentState;                                  }                                  else if (ignoreCase                                      ? char.ToUpperInvariant(expressionChar) == char.ToUpperInvariant(nameChar)                                      : expressionChar == nameChar)                                  {                                      // Matched a non-wildcard character                                      currentMatches[currentMatch++] = currentState;                                  }                                    // The expression didn't match so move to the next prior match.                                  goto ExpressionFinished;                              }                          }                            MatchZeroOrMore:                              currentMatches[currentMatch++] = currentState;                          MatchZero:                              currentMatches[currentMatch++] = currentState + 1;                          NextExpressionCharacter:                              if (++expressionOffset == expression.Length)                                  currentMatches[currentMatch++] = maxState;                      } // while (expressionOffset < expression.Length)                        ExpressionFinished:                        // Prevent duplication in the destination array.                      //                      // Each of the arrays is monotonically increasing and non-duplicating' thus we skip                      // over any source element in the source array if we just added the same element to                      // the destination array. This guarantees non-duplication in the destination array.                        if ((priorMatch < matchCount) && (priorMatchCount < currentMatch))                      {                          while (priorMatchCount < currentMatch)                          {                              int previousLength = priorMatches.Length;                              while ((priorMatch < previousLength) && (priorMatches[priorMatch] < currentMatches[priorMatchCount]))                              {                                  priorMatch++;                              }                              priorMatchCount++;                          }                      }                  } // while (sourceCount < matchesCount)                    // If we found no matches in the just finished iteration it's time to bail.                  if (currentMatch == 0)                      return false;                    // Swap the meaning the two arrays                  temp = priorMatches;                  priorMatches = currentMatches;                  currentMatches = temp;                    matchCount = currentMatch;              }
Magic Number,System.IO,DosMatcher,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\DosMatcher.cs,MatchPattern,The following statement contains a magic number: while (!nameFinished)              {                  if (nameOffset < name.Length)                  {                      // Not at the end of the name. Grab the current character and move the offset forward.                      nameChar = name[nameOffset++];                  }                  else                  {                      // At the end of the name. If the expression is exhausted' exit.                      if (priorMatches[matchCount - 1] == maxState)                          break;                        nameFinished = true;                  }                    // Now' for each of the previous stored expression matches' see what                  // we can do with this name character.                  priorMatch = 0;                  currentMatch = 0;                  priorMatchCount = 0;                    while (priorMatch < matchCount)                  {                      // We have to carry on our expression analysis as far as possible for each                      // character of name' so we loop here until the expression stops matching.                        expressionOffset = (priorMatches[priorMatch++] + 1) / 2;                        while (expressionOffset < expression.Length)                      {                          currentState = expressionOffset * 2;                          expressionChar = expression[expressionOffset];                            // We may be about to exhaust the local space for matches'                          // so we have to reallocate if this is the case.                          if (currentMatch >= currentMatches.Length - 2)                          {                              int newSize = currentMatches.Length * 2;                              temp = new int[newSize];                              currentMatches.CopyTo(temp);                              currentMatches = temp;                                temp = new int[newSize];                              priorMatches.CopyTo(temp);                              priorMatches = temp;                          }                            if (expressionChar == '*')                          {                              // '*' matches any character zero or more times.                              goto MatchZeroOrMore;                          }                          else if (expressionChar == '<')                          {                              // '<' (DOS_STAR) matches any character except '.' zero or more times.                                // If we are at a period' determine if we are allowed to                              // consume it' i.e. make sure it is not the last one.                                bool notLastPeriod = false;                              if (!nameFinished && nameChar == '.')                              {                                  for (int offset = nameOffset; offset < name.Length; offset++)                                  {                                      if (name[offset] == '.')                                      {                                          notLastPeriod = true;                                          break;                                      }                                  }                              }                                if (nameFinished || nameChar != '.' || notLastPeriod)                              {                                  goto MatchZeroOrMore;                              }                              else                              {                                  // We are at a period.  We can only match zero                                  // characters (i.e. the epsilon transition).                                  goto MatchZero;                              }                          }                          else                          {                              // The following expression characters all match by consuming                              // a character' thus force the expression' and thus state forward.                              currentState += 2;                                if (expressionChar == '>')                              {                                  // '>' (DOS_QM) is the most complicated. If the name is finished'                                  // we can match zero characters. If this name is a '.'' we                                  // don't match' but look at the next expression.  Otherwise                                  // we match a single character.                                  if (nameFinished || nameChar == '.')                                      goto NextExpressionCharacter;                                    currentMatches[currentMatch++] = currentState;                                  goto ExpressionFinished;                              }                              else if (expressionChar == '"')                              {                                  // A '"' (DOS_DOT) can match either a period' or zero characters                                  // beyond the end of name.                                  if (nameFinished)                                  {                                      goto NextExpressionCharacter;                                  }                                  else if (nameChar == '.')                                  {                                      currentMatches[currentMatch++] = currentState;                                  }                                  goto ExpressionFinished;                              }                              else                              {                                  // From this point on a name character is required to even                                  // continue' let alone make a match.                                  if (nameFinished) goto ExpressionFinished;                                    if (expressionChar == '?')                                  {                                      // If this expression was a '?' we can match it once.                                      currentMatches[currentMatch++] = currentState;                                  }                                  else if (ignoreCase                                      ? char.ToUpperInvariant(expressionChar) == char.ToUpperInvariant(nameChar)                                      : expressionChar == nameChar)                                  {                                      // Matched a non-wildcard character                                      currentMatches[currentMatch++] = currentState;                                  }                                    // The expression didn't match so move to the next prior match.                                  goto ExpressionFinished;                              }                          }                            MatchZeroOrMore:                              currentMatches[currentMatch++] = currentState;                          MatchZero:                              currentMatches[currentMatch++] = currentState + 1;                          NextExpressionCharacter:                              if (++expressionOffset == expression.Length)                                  currentMatches[currentMatch++] = maxState;                      } // while (expressionOffset < expression.Length)                        ExpressionFinished:                        // Prevent duplication in the destination array.                      //                      // Each of the arrays is monotonically increasing and non-duplicating' thus we skip                      // over any source element in the source array if we just added the same element to                      // the destination array. This guarantees non-duplication in the destination array.                        if ((priorMatch < matchCount) && (priorMatchCount < currentMatch))                      {                          while (priorMatchCount < currentMatch)                          {                              int previousLength = priorMatches.Length;                              while ((priorMatch < previousLength) && (priorMatches[priorMatch] < currentMatches[priorMatchCount]))                              {                                  priorMatch++;                              }                              priorMatchCount++;                          }                      }                  } // while (sourceCount < matchesCount)                    // If we found no matches in the just finished iteration it's time to bail.                  if (currentMatch == 0)                      return false;                    // Swap the meaning the two arrays                  temp = priorMatches;                  priorMatches = currentMatches;                  currentMatches = temp;                    matchCount = currentMatch;              }
Magic Number,System.IO,DosMatcher,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\DosMatcher.cs,MatchPattern,The following statement contains a magic number: while (!nameFinished)              {                  if (nameOffset < name.Length)                  {                      // Not at the end of the name. Grab the current character and move the offset forward.                      nameChar = name[nameOffset++];                  }                  else                  {                      // At the end of the name. If the expression is exhausted' exit.                      if (priorMatches[matchCount - 1] == maxState)                          break;                        nameFinished = true;                  }                    // Now' for each of the previous stored expression matches' see what                  // we can do with this name character.                  priorMatch = 0;                  currentMatch = 0;                  priorMatchCount = 0;                    while (priorMatch < matchCount)                  {                      // We have to carry on our expression analysis as far as possible for each                      // character of name' so we loop here until the expression stops matching.                        expressionOffset = (priorMatches[priorMatch++] + 1) / 2;                        while (expressionOffset < expression.Length)                      {                          currentState = expressionOffset * 2;                          expressionChar = expression[expressionOffset];                            // We may be about to exhaust the local space for matches'                          // so we have to reallocate if this is the case.                          if (currentMatch >= currentMatches.Length - 2)                          {                              int newSize = currentMatches.Length * 2;                              temp = new int[newSize];                              currentMatches.CopyTo(temp);                              currentMatches = temp;                                temp = new int[newSize];                              priorMatches.CopyTo(temp);                              priorMatches = temp;                          }                            if (expressionChar == '*')                          {                              // '*' matches any character zero or more times.                              goto MatchZeroOrMore;                          }                          else if (expressionChar == '<')                          {                              // '<' (DOS_STAR) matches any character except '.' zero or more times.                                // If we are at a period' determine if we are allowed to                              // consume it' i.e. make sure it is not the last one.                                bool notLastPeriod = false;                              if (!nameFinished && nameChar == '.')                              {                                  for (int offset = nameOffset; offset < name.Length; offset++)                                  {                                      if (name[offset] == '.')                                      {                                          notLastPeriod = true;                                          break;                                      }                                  }                              }                                if (nameFinished || nameChar != '.' || notLastPeriod)                              {                                  goto MatchZeroOrMore;                              }                              else                              {                                  // We are at a period.  We can only match zero                                  // characters (i.e. the epsilon transition).                                  goto MatchZero;                              }                          }                          else                          {                              // The following expression characters all match by consuming                              // a character' thus force the expression' and thus state forward.                              currentState += 2;                                if (expressionChar == '>')                              {                                  // '>' (DOS_QM) is the most complicated. If the name is finished'                                  // we can match zero characters. If this name is a '.'' we                                  // don't match' but look at the next expression.  Otherwise                                  // we match a single character.                                  if (nameFinished || nameChar == '.')                                      goto NextExpressionCharacter;                                    currentMatches[currentMatch++] = currentState;                                  goto ExpressionFinished;                              }                              else if (expressionChar == '"')                              {                                  // A '"' (DOS_DOT) can match either a period' or zero characters                                  // beyond the end of name.                                  if (nameFinished)                                  {                                      goto NextExpressionCharacter;                                  }                                  else if (nameChar == '.')                                  {                                      currentMatches[currentMatch++] = currentState;                                  }                                  goto ExpressionFinished;                              }                              else                              {                                  // From this point on a name character is required to even                                  // continue' let alone make a match.                                  if (nameFinished) goto ExpressionFinished;                                    if (expressionChar == '?')                                  {                                      // If this expression was a '?' we can match it once.                                      currentMatches[currentMatch++] = currentState;                                  }                                  else if (ignoreCase                                      ? char.ToUpperInvariant(expressionChar) == char.ToUpperInvariant(nameChar)                                      : expressionChar == nameChar)                                  {                                      // Matched a non-wildcard character                                      currentMatches[currentMatch++] = currentState;                                  }                                    // The expression didn't match so move to the next prior match.                                  goto ExpressionFinished;                              }                          }                            MatchZeroOrMore:                              currentMatches[currentMatch++] = currentState;                          MatchZero:                              currentMatches[currentMatch++] = currentState + 1;                          NextExpressionCharacter:                              if (++expressionOffset == expression.Length)                                  currentMatches[currentMatch++] = maxState;                      } // while (expressionOffset < expression.Length)                        ExpressionFinished:                        // Prevent duplication in the destination array.                      //                      // Each of the arrays is monotonically increasing and non-duplicating' thus we skip                      // over any source element in the source array if we just added the same element to                      // the destination array. This guarantees non-duplication in the destination array.                        if ((priorMatch < matchCount) && (priorMatchCount < currentMatch))                      {                          while (priorMatchCount < currentMatch)                          {                              int previousLength = priorMatches.Length;                              while ((priorMatch < previousLength) && (priorMatches[priorMatch] < currentMatches[priorMatchCount]))                              {                                  priorMatch++;                              }                              priorMatchCount++;                          }                      }                  } // while (sourceCount < matchesCount)                    // If we found no matches in the just finished iteration it's time to bail.                  if (currentMatch == 0)                      return false;                    // Swap the meaning the two arrays                  temp = priorMatches;                  priorMatches = currentMatches;                  currentMatches = temp;                    matchCount = currentMatch;              }
Magic Number,System.IO,FileInfo,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\FileInfo.cs,OpenRead,The following statement contains a magic number: return new FileStream(FullPath' FileMode.Open' FileAccess.Read'                                    FileShare.Read' 4096' false);
Magic Number,System.IO,PathHelpers,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\PathHelpers.cs,IsDotOrDotDot,The following statement contains a magic number: return !(fileName.Length > 2                  || fileName[0] != '.'                  || (fileName.Length == 2 && fileName[1] != '.'));
Magic Number,System.IO,PathHelpers,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem\src\System\IO\PathHelpers.cs,IsDotOrDotDot,The following statement contains a magic number: return !(fileName.Length > 2                  || fileName[0] != '.'                  || (fileName.Length == 2 && fileName[1] != '.'));
Magic Number,System.Collections.Generic,ArrayBuilder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\ArrayBuilder.cs,EnsureCapacity,The following statement contains a magic number: int nextCapacity = capacity == 0 ? DefaultCapacity : 2 * capacity;
Magic Number,System.Collections.Generic,EnumerableHelpers,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\EnumerableHelpers.cs,ToArray,The following statement contains a magic number: if (source is ICollection<T> ic)              {                  int count = ic.Count;                  if (count != 0)                  {                      // Allocate an array of the desired size' then copy the elements into it. Note that this has the same                      // issue regarding concurrency as other existing collections like List<T>. If the collection size                      // concurrently changes between the array allocation and the CopyTo' we could end up either getting an                      // exception from overrunning the array (if the size went up) or we could end up not filling as many                      // items as 'count' suggests (if the size went down).  This is only an issue for concurrent collections                      // that implement ICollection<T>' which as of .NET 4.6 is just ConcurrentDictionary<TKey' TValue>.                      T[] arr = new T[count];                      ic.CopyTo(arr' 0);                      length = count;                      return arr;                  }              }              else              {                  using (var en = source.GetEnumerator())                  {                      if (en.MoveNext())                      {                          const int DefaultCapacity = 4;                          T[] arr = new T[DefaultCapacity];                          arr[0] = en.Current;                          int count = 1;                            while (en.MoveNext())                          {                              if (count == arr.Length)                              {                                  // MaxArrayLength is defined in Array.MaxArrayLength and in gchelpers in CoreCLR.                                  // It represents the maximum number of elements that can be in an array where                                  // the size of the element is greater than one byte; a separate' slightly larger constant'                                  // is used when the size of the element is one.                                  const int MaxArrayLength = 0x7FEFFFFF;                                    // This is the same growth logic as in List<T>:                                  // If the array is currently empty' we make it a default size.  Otherwise' we attempt to                                  // double the size of the array.  Doubling will overflow once the size of the array reaches                                  // 2^30' since doubling to 2^31 is 1 larger than Int32.MaxValue.  In that case' we instead                                  // constrain the length to be MaxArrayLength (this overflow check works because of the                                  // cast to uint).  Because a slightly larger constant is used when T is one byte in size' we                                  // could then end up in a situation where arr.Length is MaxArrayLength or slightly larger' such                                  // that we constrain newLength to be MaxArrayLength but the needed number of elements is actually                                  // larger than that.  For that case' we then ensure that the newLength is large enough to hold                                  // the desired capacity.  This does mean that in the very rare case where we've grown to such a                                  // large size' each new element added after MaxArrayLength will end up doing a resize.                                  int newLength = count << 1;                                  if ((uint)newLength > MaxArrayLength)                                  {                                      newLength = MaxArrayLength <= count ? count + 1 : MaxArrayLength;                                  }                                    Array.Resize(ref arr' newLength);                              }                                arr[count++] = en.Current;                          }                            length = count;                          return arr;                      }                  }              }
Magic Number,System.Collections.Generic,LargeArrayBuilder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\LargeArrayBuilder.cs,GetBuffer,The following statement contains a magic number: Debug.Assert(index >= 0 && index < _buffers.Count + 2);
Magic Number,System.Collections.Generic,LargeArrayBuilder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\LargeArrayBuilder.cs,AllocateBuffer,The following statement contains a magic number: if ((uint)_count < (uint)ResizeLimit)              {                  // We haven't passed ResizeLimit. Resize _first' copying over the previous items.                  Debug.Assert(_current == _first && _count == _first.Length);                    int nextCapacity = Math.Min(_count == 0 ? StartingCapacity : _count * 2' _maxCapacity);                    _current = new T[nextCapacity];                  Array.Copy(_first' 0' _current' 0' _count);                  _first = _current;              }              else              {                  Debug.Assert(_maxCapacity > ResizeLimit);                  Debug.Assert(_count == ResizeLimit ^ _current != _first);                    int nextCapacity;                  if (_count == ResizeLimit)                  {                      nextCapacity = ResizeLimit;                  }                  else                  {                      // Example scenario: Let's say _count == 64.                      // Then our buffers look like this: | 8 | 8 | 16 | 32 |                      // As you can see' our count will be just double the last buffer.                      // Now' say _maxCapacity is 100. We will find the right amount to allocate by                      // doing min(64' 100 - 64). The lhs represents double the last buffer'                      // the rhs the limit minus the amount we've already allocated.                        Debug.Assert(_count >= ResizeLimit * 2);                      Debug.Assert(_count == _current.Length * 2);                        _buffers.Add(_current);                      nextCapacity = Math.Min(_count' _maxCapacity - _count);                  }                    _current = new T[nextCapacity];                  _index = 0;              }
Magic Number,System.Collections.Generic,LargeArrayBuilder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\LargeArrayBuilder.cs,AllocateBuffer,The following statement contains a magic number: if ((uint)_count < (uint)ResizeLimit)              {                  // We haven't passed ResizeLimit. Resize _first' copying over the previous items.                  Debug.Assert(_current == _first && _count == _first.Length);                    int nextCapacity = Math.Min(_count == 0 ? StartingCapacity : _count * 2' _maxCapacity);                    _current = new T[nextCapacity];                  Array.Copy(_first' 0' _current' 0' _count);                  _first = _current;              }              else              {                  Debug.Assert(_maxCapacity > ResizeLimit);                  Debug.Assert(_count == ResizeLimit ^ _current != _first);                    int nextCapacity;                  if (_count == ResizeLimit)                  {                      nextCapacity = ResizeLimit;                  }                  else                  {                      // Example scenario: Let's say _count == 64.                      // Then our buffers look like this: | 8 | 8 | 16 | 32 |                      // As you can see' our count will be just double the last buffer.                      // Now' say _maxCapacity is 100. We will find the right amount to allocate by                      // doing min(64' 100 - 64). The lhs represents double the last buffer'                      // the rhs the limit minus the amount we've already allocated.                        Debug.Assert(_count >= ResizeLimit * 2);                      Debug.Assert(_count == _current.Length * 2);                        _buffers.Add(_current);                      nextCapacity = Math.Min(_count' _maxCapacity - _count);                  }                    _current = new T[nextCapacity];                  _index = 0;              }
Magic Number,System.Collections.Generic,LargeArrayBuilder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\LargeArrayBuilder.cs,AllocateBuffer,The following statement contains a magic number: if ((uint)_count < (uint)ResizeLimit)              {                  // We haven't passed ResizeLimit. Resize _first' copying over the previous items.                  Debug.Assert(_current == _first && _count == _first.Length);                    int nextCapacity = Math.Min(_count == 0 ? StartingCapacity : _count * 2' _maxCapacity);                    _current = new T[nextCapacity];                  Array.Copy(_first' 0' _current' 0' _count);                  _first = _current;              }              else              {                  Debug.Assert(_maxCapacity > ResizeLimit);                  Debug.Assert(_count == ResizeLimit ^ _current != _first);                    int nextCapacity;                  if (_count == ResizeLimit)                  {                      nextCapacity = ResizeLimit;                  }                  else                  {                      // Example scenario: Let's say _count == 64.                      // Then our buffers look like this: | 8 | 8 | 16 | 32 |                      // As you can see' our count will be just double the last buffer.                      // Now' say _maxCapacity is 100. We will find the right amount to allocate by                      // doing min(64' 100 - 64). The lhs represents double the last buffer'                      // the rhs the limit minus the amount we've already allocated.                        Debug.Assert(_count >= ResizeLimit * 2);                      Debug.Assert(_count == _current.Length * 2);                        _buffers.Add(_current);                      nextCapacity = Math.Min(_count' _maxCapacity - _count);                  }                    _current = new T[nextCapacity];                  _index = 0;              }
Magic Number,System.Text,ValueStringBuilder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Text\ValueStringBuilder.cs,Grow,The following statement contains a magic number: char[] poolArray = ArrayPool<char>.Shared.Rent(Math.Max(_pos + requiredAdditionalCapacity' _chars.Length * 2));
