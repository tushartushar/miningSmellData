Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Internal.Cryptography,UniversalCryptoTransform,C:\selectedRepos\dotnet_corefx\src\Common\src\Internal\Cryptography\UniversalCryptoTransform.cs,TransformBlock,Cyclomatic complexity of the method is 10
Complex Method,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,CreateFromName,Cyclomatic complexity of the method is 14
Long Parameter List,Internal.Cryptography,BasicSymmetricCipher,C:\selectedRepos\dotnet_corefx\src\Common\src\Internal\Cryptography\BasicSymmetricCipher.cs,Transform,The method has 5 parameters. Parameters: input' inputOffset' count' output' outputOffset
Long Parameter List,Internal.Cryptography,UniversalCryptoTransform,C:\selectedRepos\dotnet_corefx\src\Common\src\Internal\Cryptography\UniversalCryptoTransform.cs,TransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Long Parameter List,Internal.Cryptography,UniversalCryptoTransform,C:\selectedRepos\dotnet_corefx\src\Common\src\Internal\Cryptography\UniversalCryptoTransform.cs,UncheckedTransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Long Parameter List,Internal.Cryptography,UniversalCryptoEncryptor,C:\selectedRepos\dotnet_corefx\src\Common\src\Internal\Cryptography\UniversalCryptoEncryptor.cs,UncheckedTransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Long Parameter List,Internal.Cryptography,UniversalCryptoDecryptor,C:\selectedRepos\dotnet_corefx\src\Common\src\Internal\Cryptography\UniversalCryptoDecryptor.cs,UncheckedTransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Long Parameter List,System.Security.Cryptography,DSA,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\DSA.cs,VerifyData,The method has 5 parameters. Parameters: data' offset' count' signature' hashAlgorithm
Long Parameter List,System.Security.Cryptography,ECDsa,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\ECDsa.cs,VerifyData,The method has 5 parameters. Parameters: data' offset' count' signature' hashAlgorithm
Long Parameter List,System.Security.Cryptography,RSA,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\RSA.cs,TrySignHash,The method has 5 parameters. Parameters: source' destination' hashAlgorithm' padding' bytesWritten
Long Parameter List,System.Security.Cryptography,RSA,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\RSA.cs,SignData,The method has 5 parameters. Parameters: data' offset' count' hashAlgorithm' padding
Long Parameter List,System.Security.Cryptography,RSA,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\RSA.cs,TrySignData,The method has 5 parameters. Parameters: source' destination' hashAlgorithm' padding' bytesWritten
Long Parameter List,System.Security.Cryptography,RSA,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\RSA.cs,VerifyData,The method has 6 parameters. Parameters: data' offset' count' signature' hashAlgorithm' padding
Long Statement,Internal.Cryptography,UniversalCryptoDecryptor,C:\selectedRepos\dotnet_corefx\src\Common\src\Internal\Cryptography\UniversalCryptoDecryptor.cs,UncheckedTransformBlock,The length of the statement  "                    int depadDecryptLength = BasicSymmetricCipher.Transform(_heldoverCipher' 0' _heldoverCipher.Length' outputBuffer' outputOffset); " is 128.
Long Statement,Internal.Cryptography,UniversalCryptoDecryptor,C:\selectedRepos\dotnet_corefx\src\Common\src\Internal\Cryptography\UniversalCryptoDecryptor.cs,UncheckedTransformFinalBlock,The length of the statement  "            // If we have postponed cipher bits from the prior round' copy that into the decryption buffer followed by the input data. " is 122.
Long Statement,Internal.Cryptography,UniversalCryptoDecryptor,C:\selectedRepos\dotnet_corefx\src\Common\src\Internal\Cryptography\UniversalCryptoDecryptor.cs,UncheckedTransformFinalBlock,The length of the statement  "            // Decrypt the data' then strip the padding to get the final decrypted data. Note that even if the cipherText length is 0' we must " is 130.
Long Statement,System.Security.Cryptography,Implementation,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\MD5.cs,Initialize,The length of the statement  "                // reality that our native crypto providers (e.g. CNG) expose hash finalization and object reinitialization as an atomic operation. " is 131.
Long Statement,System.Security.Cryptography,Implementation,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\MD5.cs,Initialize,The length of the statement  "                // reality that our native crypto providers (e.g. CNG) expose hash finalization and object reinitialization as an atomic operation. " is 131.
Long Statement,System.Security.Cryptography,Implementation,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\MD5.cs,Initialize,The length of the statement  "                // reality that our native crypto providers (e.g. CNG) expose hash finalization and object reinitialization as an atomic operation. " is 131.
Long Statement,System.Security.Cryptography,Implementation,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\MD5.cs,Initialize,The length of the statement  "                // reality that our native crypto providers (e.g. CNG) expose hash finalization and object reinitialization as an atomic operation. " is 131.
Long Statement,System.Security.Cryptography,Implementation,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\MD5.cs,Initialize,The length of the statement  "                // reality that our native crypto providers (e.g. CNG) expose hash finalization and object reinitialization as an atomic operation. " is 131.
Long Statement,System.Security.Cryptography,SHA1Managed,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\SHA1Managed.cs,Initialize,The length of the statement  "            // reality that our native crypto providers (e.g. CNG) expose hash finalization and object reinitialization as an atomic operation. " is 131.
Long Statement,System.Security.Cryptography,SHA256Managed,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\SHA256Managed.cs,Initialize,The length of the statement  "            // reality that our native crypto providers (e.g. CNG) expose hash finalization and object reinitialization as an atomic operation. " is 131.
Long Statement,System.Security.Cryptography,SHA384Managed,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\SHA384Managed.cs,Initialize,The length of the statement  "            // reality that our native crypto providers (e.g. CNG) expose hash finalization and object reinitialization as an atomic operation. " is 131.
Long Statement,System.Security.Cryptography,SHA512Managed,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\SHA512Managed.cs,Initialize,The length of the statement  "            // reality that our native crypto providers (e.g. CNG) expose hash finalization and object reinitialization as an atomic operation. " is 131.
Long Statement,System.Security.Cryptography,HMACMD5,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\HMACMD5.cs,Initialize,The length of the statement  "            // reality that our native crypto providers (e.g. CNG) expose hash finalization and object reinitialization as an atomic operation. " is 131.
Long Statement,System.Security.Cryptography,HMACSHA1,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\HMACSHA1.cs,Initialize,The length of the statement  "            // reality that our native crypto providers (e.g. CNG) expose hash finalization and object reinitialization as an atomic operation. " is 131.
Long Statement,System.Security.Cryptography,HMACSHA256,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\HMACSHA256.cs,Initialize,The length of the statement  "            // reality that our native crypto providers (e.g. CNG) expose hash finalization and object reinitialization as an atomic operation. " is 131.
Long Statement,System.Security.Cryptography,HMACSHA384,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\HMACSHA384.cs,Initialize,The length of the statement  "            // reality that our native crypto providers (e.g. CNG) expose hash finalization and object reinitialization as an atomic operation. " is 131.
Long Statement,System.Security.Cryptography,HMACSHA512,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\HMACSHA512.cs,Initialize,The length of the statement  "            // reality that our native crypto providers (e.g. CNG) expose hash finalization and object reinitialization as an atomic operation. " is 131.
Long Statement,System.Security.Cryptography,SignatureDescription,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\SignatureDescription.cs,CreateDeformatter,The length of the statement  "            AsymmetricSignatureDeformatter item = (AsymmetricSignatureDeformatter)CryptoConfig.CreateFromName(DeformatterAlgorithm); " is 120.
Long Statement,System.Security.Cryptography,TripleDES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\TripleDES.cs,IsWeakKey,The length of the statement  "                throw new CryptographicException(SR.Cryptography_InvalidKeySize);  // Desktop compat: Strange exception for a null value' but this is what we threw in classic CLR.  " is 163.
Complex Conditional,System.Security.Cryptography,DES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\DES.cs,IsWeakKey,The conditional expression  "(key == 0x0101010101010101) ||                  (key == 0xfefefefefefefefe) ||                  (key == 0x1f1f1f1f0e0e0e0e) ||                  (key == 0xe0e0e0e0f1f1f1f1)"  is complex.
Complex Conditional,System.Security.Cryptography,DES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\DES.cs,IsSemiWeakKey,The conditional expression  "(key == 0x01fe01fe01fe01fe) ||                  (key == 0xfe01fe01fe01fe01) ||                  (key == 0x1fe01fe00ef10ef1) ||                  (key == 0xe01fe01ff10ef10e) ||                  (key == 0x01e001e001f101f1) ||                  (key == 0xe001e001f101f101) ||                  (key == 0x1ffe1ffe0efe0efe) ||                  (key == 0xfe1ffe1ffe0efe0e) ||                  (key == 0x011f011f010e010e) ||                  (key == 0x1f011f010e010e01) ||                  (key == 0xe0fee0fef1fef1fe) ||                  (key == 0xfee0fee0fef1fef1)"  is complex.
Complex Conditional,System.Security.Cryptography,ECCurve,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\ECCurve.cs,Validate,The conditional expression  "A == null ||                      B == null || B.Length != A.Length ||                      G.X == null || G.X.Length != A.Length ||                      G.Y == null || G.Y.Length != A.Length ||                      Order == null || Order.Length == 0 ||                      Cofactor == null || Cofactor.Length == 0"  is complex.
Empty Catch Block,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,MapNameToOID,The method has an empty catch block.
Magic Number,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\Internal\Cryptography\Helpers.cs,WriteInt,The following statement contains a magic number: unchecked              {                  Debug.Assert(arr != null);                  Debug.Assert(arr.Length >= offset + sizeof(uint));                    arr[offset] = (byte)(i >> 24);                  arr[offset + 1] = (byte)(i >> 16);                  arr[offset + 2] = (byte)(i >> 8);                  arr[offset + 3] = (byte)i;              }
Magic Number,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\Internal\Cryptography\Helpers.cs,WriteInt,The following statement contains a magic number: unchecked              {                  Debug.Assert(arr != null);                  Debug.Assert(arr.Length >= offset + sizeof(uint));                    arr[offset] = (byte)(i >> 24);                  arr[offset + 1] = (byte)(i >> 16);                  arr[offset + 2] = (byte)(i >> 8);                  arr[offset + 3] = (byte)i;              }
Magic Number,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\Internal\Cryptography\Helpers.cs,WriteInt,The following statement contains a magic number: unchecked              {                  Debug.Assert(arr != null);                  Debug.Assert(arr.Length >= offset + sizeof(uint));                    arr[offset] = (byte)(i >> 24);                  arr[offset + 1] = (byte)(i >> 16);                  arr[offset + 2] = (byte)(i >> 8);                  arr[offset + 3] = (byte)i;              }
Magic Number,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\Internal\Cryptography\Helpers.cs,WriteInt,The following statement contains a magic number: unchecked              {                  Debug.Assert(arr != null);                  Debug.Assert(arr.Length >= offset + sizeof(uint));                    arr[offset] = (byte)(i >> 24);                  arr[offset + 1] = (byte)(i >> 16);                  arr[offset + 2] = (byte)(i >> 8);                  arr[offset + 3] = (byte)i;              }
Magic Number,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\Internal\Cryptography\Helpers.cs,WriteInt,The following statement contains a magic number: unchecked              {                  Debug.Assert(arr != null);                  Debug.Assert(arr.Length >= offset + sizeof(uint));                    arr[offset] = (byte)(i >> 24);                  arr[offset + 1] = (byte)(i >> 16);                  arr[offset + 2] = (byte)(i >> 8);                  arr[offset + 3] = (byte)i;              }
Magic Number,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\Internal\Cryptography\Helpers.cs,FixupKeyParity,The following statement contains a magic number: for (int index = 0; index < key.Length; index++)              {                  // Get the bits we are interested in                  oddParityKey[index] = (byte)(key[index] & 0xfe);                    // Get the parity of the sum of the previous bits                  byte tmp1 = (byte)((oddParityKey[index] & 0xF) ^ (oddParityKey[index] >> 4));                  byte tmp2 = (byte)((tmp1 & 0x3) ^ (tmp1 >> 2));                  byte sumBitsMod2 = (byte)((tmp2 & 0x1) ^ (tmp2 >> 1));                                    // We need to set the last bit in oddParityKey[index] to the negation                  // of the last bit in sumBitsMod2                  if (sumBitsMod2 == 0)                      oddParityKey[index] |= 1;              }
Magic Number,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\Internal\Cryptography\Helpers.cs,FixupKeyParity,The following statement contains a magic number: for (int index = 0; index < key.Length; index++)              {                  // Get the bits we are interested in                  oddParityKey[index] = (byte)(key[index] & 0xfe);                    // Get the parity of the sum of the previous bits                  byte tmp1 = (byte)((oddParityKey[index] & 0xF) ^ (oddParityKey[index] >> 4));                  byte tmp2 = (byte)((tmp1 & 0x3) ^ (tmp1 >> 2));                  byte sumBitsMod2 = (byte)((tmp2 & 0x1) ^ (tmp2 >> 1));                                    // We need to set the last bit in oddParityKey[index] to the negation                  // of the last bit in sumBitsMod2                  if (sumBitsMod2 == 0)                      oddParityKey[index] |= 1;              }
Magic Number,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\Internal\Cryptography\Helpers.cs,ConvertIntToByteArray,The following statement contains a magic number: Debug.Assert(dest.Length == 4);
Magic Number,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\Internal\Cryptography\Helpers.cs,ConvertIntToByteArray,The following statement contains a magic number: dest[0] = (byte)((value & 0xFF000000) >> 24);
Magic Number,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\Internal\Cryptography\Helpers.cs,ConvertIntToByteArray,The following statement contains a magic number: dest[1] = (byte)((value & 0xFF0000) >> 16);
Magic Number,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\Internal\Cryptography\Helpers.cs,ConvertIntToByteArray,The following statement contains a magic number: dest[2] = (byte)((value & 0xFF00) >> 8);
Magic Number,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\Internal\Cryptography\Helpers.cs,ConvertIntToByteArray,The following statement contains a magic number: dest[2] = (byte)((value & 0xFF00) >> 8);
Magic Number,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\Internal\Cryptography\Helpers.cs,ConvertIntToByteArray,The following statement contains a magic number: dest[3] = (byte)(value & 0xFF);
Magic Number,Internal.Cryptography,RijndaelImplementation,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\Internal\Cryptography\RijndaelImplementation.cs,RijndaelImplementation,The following statement contains a magic number: LegalBlockSizesValue = new KeySizes[] { new KeySizes(minSize: 128' maxSize: 128' skipSize: 0) };
Magic Number,Internal.Cryptography,RijndaelImplementation,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\Internal\Cryptography\RijndaelImplementation.cs,RijndaelImplementation,The following statement contains a magic number: LegalBlockSizesValue = new KeySizes[] { new KeySizes(minSize: 128' maxSize: 128' skipSize: 0) };
Magic Number,Internal.Cryptography,TripleDesImplementation,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\Internal\Cryptography\TripleDesImplementation.cs,CreateTransform,The following statement contains a magic number: if (rgbKey.Length == 16)              {                  // Some platforms do not support Two-Key Triple DES' so manually support it here.                  // Two-Key Triple DES contains two 8-byte keys {K1}{K2} with {K1} appended to make {K1}{K2}{K1}.                  byte[] newkey = new byte[24];                  Array.Copy(rgbKey' 0' newkey' 0' 16);                  Array.Copy(rgbKey' 0' newkey' 16' 8);                  rgbKey = newkey;              }
Magic Number,Internal.Cryptography,TripleDesImplementation,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\Internal\Cryptography\TripleDesImplementation.cs,CreateTransform,The following statement contains a magic number: if (rgbKey.Length == 16)              {                  // Some platforms do not support Two-Key Triple DES' so manually support it here.                  // Two-Key Triple DES contains two 8-byte keys {K1}{K2} with {K1} appended to make {K1}{K2}{K1}.                  byte[] newkey = new byte[24];                  Array.Copy(rgbKey' 0' newkey' 0' 16);                  Array.Copy(rgbKey' 0' newkey' 16' 8);                  rgbKey = newkey;              }
Magic Number,Internal.Cryptography,TripleDesImplementation,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\Internal\Cryptography\TripleDesImplementation.cs,CreateTransform,The following statement contains a magic number: if (rgbKey.Length == 16)              {                  // Some platforms do not support Two-Key Triple DES' so manually support it here.                  // Two-Key Triple DES contains two 8-byte keys {K1}{K2} with {K1} appended to make {K1}{K2}{K1}.                  byte[] newkey = new byte[24];                  Array.Copy(rgbKey' 0' newkey' 0' 16);                  Array.Copy(rgbKey' 0' newkey' 16' 8);                  rgbKey = newkey;              }
Magic Number,Internal.Cryptography,TripleDesImplementation,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\Internal\Cryptography\TripleDesImplementation.cs,CreateTransform,The following statement contains a magic number: if (rgbKey.Length == 16)              {                  // Some platforms do not support Two-Key Triple DES' so manually support it here.                  // Two-Key Triple DES contains two 8-byte keys {K1}{K2} with {K1} appended to make {K1}{K2}{K1}.                  byte[] newkey = new byte[24];                  Array.Copy(rgbKey' 0' newkey' 0' 16);                  Array.Copy(rgbKey' 0' newkey' 16' 8);                  rgbKey = newkey;              }
Magic Number,Internal.Cryptography,TripleDesImplementation,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\Internal\Cryptography\TripleDesImplementation.cs,CreateTransform,The following statement contains a magic number: if (rgbKey.Length == 16)              {                  // Some platforms do not support Two-Key Triple DES' so manually support it here.                  // Two-Key Triple DES contains two 8-byte keys {K1}{K2} with {K1} appended to make {K1}{K2}{K1}.                  byte[] newkey = new byte[24];                  Array.Copy(rgbKey' 0' newkey' 0' 16);                  Array.Copy(rgbKey' 0' newkey' 16' 8);                  rgbKey = newkey;              }
Magic Number,System.Security.Cryptography,Aes,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\Aes.cs,Aes,The following statement contains a magic number: BlockSizeValue = 128;
Magic Number,System.Security.Cryptography,Aes,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\Aes.cs,Aes,The following statement contains a magic number: FeedbackSizeValue = 8;
Magic Number,System.Security.Cryptography,Aes,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\Aes.cs,Aes,The following statement contains a magic number: KeySizeValue = 256;
Magic Number,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,EncodeOID,The following statement contains a magic number: if (oidNums.Length < 2)                  throw new CryptographicUnexpectedOperationException(SR.Cryptography_InvalidOID);
Magic Number,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,EncodeOID,The following statement contains a magic number: uint firstTwoOidNums = unchecked((oidNums[0] * 40) + oidNums[1]);
Magic Number,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,EncodeOID,The following statement contains a magic number: int encodedOidNumsLength = 2;
Magic Number,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,EncodeOID,The following statement contains a magic number: for (int i = 2; i < oidNums.Length; i++)              {                  EncodeSingleOidNum(oidNums[i]' null' ref encodedOidNumsLength);              }
Magic Number,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,EncodeOID,The following statement contains a magic number: int encodedOidNumsIndex = 2;
Magic Number,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,EncodeOID,The following statement contains a magic number: for (int i = 2; i < oidNums.Length; i++)              {                  EncodeSingleOidNum(oidNums[i]' encodedOidNums' ref encodedOidNumsIndex);              }
Magic Number,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,EncodeOID,The following statement contains a magic number: if (encodedOidNumsIndex - 2 > 0x7f)                  throw new CryptographicUnexpectedOperationException(SR.Cryptography_Config_EncodedOIDError);
Magic Number,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,EncodeOID,The following statement contains a magic number: encodedOidNums[1] = (byte)(encodedOidNumsIndex - 2);
Magic Number,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,EncodeSingleOidNum,The following statement contains a magic number: if (unchecked((int)value) < 0x80)              {                  if (destination != null)                  {                      destination[index++] = unchecked((byte)value);                  }                  else                  {                      index += 1;                  }              }              else if (value < 0x4000)              {                  if (destination != null)                  {                      destination[index++] = (byte)((value >> 7) | 0x80);                      destination[index++] = (byte)(value & 0x7f);                  }                  else                  {                      index += 2;                  }              }              else if (value < 0x200000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 3;                  }              }              else if (value < 0x10000000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 4;                  }              }              else              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 28) | 0x80);                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 5;                  }              }
Magic Number,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,EncodeSingleOidNum,The following statement contains a magic number: if (unchecked((int)value) < 0x80)              {                  if (destination != null)                  {                      destination[index++] = unchecked((byte)value);                  }                  else                  {                      index += 1;                  }              }              else if (value < 0x4000)              {                  if (destination != null)                  {                      destination[index++] = (byte)((value >> 7) | 0x80);                      destination[index++] = (byte)(value & 0x7f);                  }                  else                  {                      index += 2;                  }              }              else if (value < 0x200000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 3;                  }              }              else if (value < 0x10000000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 4;                  }              }              else              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 28) | 0x80);                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 5;                  }              }
Magic Number,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,EncodeSingleOidNum,The following statement contains a magic number: if (unchecked((int)value) < 0x80)              {                  if (destination != null)                  {                      destination[index++] = unchecked((byte)value);                  }                  else                  {                      index += 1;                  }              }              else if (value < 0x4000)              {                  if (destination != null)                  {                      destination[index++] = (byte)((value >> 7) | 0x80);                      destination[index++] = (byte)(value & 0x7f);                  }                  else                  {                      index += 2;                  }              }              else if (value < 0x200000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 3;                  }              }              else if (value < 0x10000000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 4;                  }              }              else              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 28) | 0x80);                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 5;                  }              }
Magic Number,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,EncodeSingleOidNum,The following statement contains a magic number: if (unchecked((int)value) < 0x80)              {                  if (destination != null)                  {                      destination[index++] = unchecked((byte)value);                  }                  else                  {                      index += 1;                  }              }              else if (value < 0x4000)              {                  if (destination != null)                  {                      destination[index++] = (byte)((value >> 7) | 0x80);                      destination[index++] = (byte)(value & 0x7f);                  }                  else                  {                      index += 2;                  }              }              else if (value < 0x200000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 3;                  }              }              else if (value < 0x10000000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 4;                  }              }              else              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 28) | 0x80);                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 5;                  }              }
Magic Number,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,EncodeSingleOidNum,The following statement contains a magic number: if (unchecked((int)value) < 0x80)              {                  if (destination != null)                  {                      destination[index++] = unchecked((byte)value);                  }                  else                  {                      index += 1;                  }              }              else if (value < 0x4000)              {                  if (destination != null)                  {                      destination[index++] = (byte)((value >> 7) | 0x80);                      destination[index++] = (byte)(value & 0x7f);                  }                  else                  {                      index += 2;                  }              }              else if (value < 0x200000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 3;                  }              }              else if (value < 0x10000000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 4;                  }              }              else              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 28) | 0x80);                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 5;                  }              }
Magic Number,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,EncodeSingleOidNum,The following statement contains a magic number: if (unchecked((int)value) < 0x80)              {                  if (destination != null)                  {                      destination[index++] = unchecked((byte)value);                  }                  else                  {                      index += 1;                  }              }              else if (value < 0x4000)              {                  if (destination != null)                  {                      destination[index++] = (byte)((value >> 7) | 0x80);                      destination[index++] = (byte)(value & 0x7f);                  }                  else                  {                      index += 2;                  }              }              else if (value < 0x200000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 3;                  }              }              else if (value < 0x10000000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 4;                  }              }              else              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 28) | 0x80);                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 5;                  }              }
Magic Number,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,EncodeSingleOidNum,The following statement contains a magic number: if (unchecked((int)value) < 0x80)              {                  if (destination != null)                  {                      destination[index++] = unchecked((byte)value);                  }                  else                  {                      index += 1;                  }              }              else if (value < 0x4000)              {                  if (destination != null)                  {                      destination[index++] = (byte)((value >> 7) | 0x80);                      destination[index++] = (byte)(value & 0x7f);                  }                  else                  {                      index += 2;                  }              }              else if (value < 0x200000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 3;                  }              }              else if (value < 0x10000000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 4;                  }              }              else              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 28) | 0x80);                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 5;                  }              }
Magic Number,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,EncodeSingleOidNum,The following statement contains a magic number: if (unchecked((int)value) < 0x80)              {                  if (destination != null)                  {                      destination[index++] = unchecked((byte)value);                  }                  else                  {                      index += 1;                  }              }              else if (value < 0x4000)              {                  if (destination != null)                  {                      destination[index++] = (byte)((value >> 7) | 0x80);                      destination[index++] = (byte)(value & 0x7f);                  }                  else                  {                      index += 2;                  }              }              else if (value < 0x200000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 3;                  }              }              else if (value < 0x10000000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 4;                  }              }              else              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 28) | 0x80);                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 5;                  }              }
Magic Number,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,EncodeSingleOidNum,The following statement contains a magic number: if (unchecked((int)value) < 0x80)              {                  if (destination != null)                  {                      destination[index++] = unchecked((byte)value);                  }                  else                  {                      index += 1;                  }              }              else if (value < 0x4000)              {                  if (destination != null)                  {                      destination[index++] = (byte)((value >> 7) | 0x80);                      destination[index++] = (byte)(value & 0x7f);                  }                  else                  {                      index += 2;                  }              }              else if (value < 0x200000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 3;                  }              }              else if (value < 0x10000000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 4;                  }              }              else              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 28) | 0x80);                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 5;                  }              }
Magic Number,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,EncodeSingleOidNum,The following statement contains a magic number: if (unchecked((int)value) < 0x80)              {                  if (destination != null)                  {                      destination[index++] = unchecked((byte)value);                  }                  else                  {                      index += 1;                  }              }              else if (value < 0x4000)              {                  if (destination != null)                  {                      destination[index++] = (byte)((value >> 7) | 0x80);                      destination[index++] = (byte)(value & 0x7f);                  }                  else                  {                      index += 2;                  }              }              else if (value < 0x200000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 3;                  }              }              else if (value < 0x10000000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 4;                  }              }              else              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 28) | 0x80);                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 5;                  }              }
Magic Number,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,EncodeSingleOidNum,The following statement contains a magic number: if (unchecked((int)value) < 0x80)              {                  if (destination != null)                  {                      destination[index++] = unchecked((byte)value);                  }                  else                  {                      index += 1;                  }              }              else if (value < 0x4000)              {                  if (destination != null)                  {                      destination[index++] = (byte)((value >> 7) | 0x80);                      destination[index++] = (byte)(value & 0x7f);                  }                  else                  {                      index += 2;                  }              }              else if (value < 0x200000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 3;                  }              }              else if (value < 0x10000000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 4;                  }              }              else              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 28) | 0x80);                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 5;                  }              }
Magic Number,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,EncodeSingleOidNum,The following statement contains a magic number: if (unchecked((int)value) < 0x80)              {                  if (destination != null)                  {                      destination[index++] = unchecked((byte)value);                  }                  else                  {                      index += 1;                  }              }              else if (value < 0x4000)              {                  if (destination != null)                  {                      destination[index++] = (byte)((value >> 7) | 0x80);                      destination[index++] = (byte)(value & 0x7f);                  }                  else                  {                      index += 2;                  }              }              else if (value < 0x200000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 3;                  }              }              else if (value < 0x10000000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 4;                  }              }              else              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 28) | 0x80);                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 5;                  }              }
Magic Number,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,EncodeSingleOidNum,The following statement contains a magic number: if (unchecked((int)value) < 0x80)              {                  if (destination != null)                  {                      destination[index++] = unchecked((byte)value);                  }                  else                  {                      index += 1;                  }              }              else if (value < 0x4000)              {                  if (destination != null)                  {                      destination[index++] = (byte)((value >> 7) | 0x80);                      destination[index++] = (byte)(value & 0x7f);                  }                  else                  {                      index += 2;                  }              }              else if (value < 0x200000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 3;                  }              }              else if (value < 0x10000000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 4;                  }              }              else              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 28) | 0x80);                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 5;                  }              }
Magic Number,System.Security.Cryptography,CryptoConfig,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\CryptoConfig.cs,EncodeSingleOidNum,The following statement contains a magic number: if (unchecked((int)value) < 0x80)              {                  if (destination != null)                  {                      destination[index++] = unchecked((byte)value);                  }                  else                  {                      index += 1;                  }              }              else if (value < 0x4000)              {                  if (destination != null)                  {                      destination[index++] = (byte)((value >> 7) | 0x80);                      destination[index++] = (byte)(value & 0x7f);                  }                  else                  {                      index += 2;                  }              }              else if (value < 0x200000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 3;                  }              }              else if (value < 0x10000000)              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 4;                  }              }              else              {                  if (destination != null)                  {                      unchecked                      {                          destination[index++] = (byte)((value >> 28) | 0x80);                          destination[index++] = (byte)((value >> 21) | 0x80);                          destination[index++] = (byte)((value >> 14) | 0x80);                          destination[index++] = (byte)((value >> 7) | 0x80);                          destination[index++] = (byte)(value & 0x7f);                      }                  }                  else                  {                      index += 5;                  }              }
Magic Number,System.Security.Cryptography,DES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\DES.cs,DES,The following statement contains a magic number: KeySizeValue = 64;
Magic Number,System.Security.Cryptography,DES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\DES.cs,DES,The following statement contains a magic number: BlockSizeValue = 64;
Magic Number,System.Security.Cryptography,DES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\DES.cs,IsLegalKeySize,The following statement contains a magic number: if (rgbKey != null && rgbKey.Length == 8)                  return true;
Magic Number,System.Security.Cryptography,DES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\DES.cs,QuadWordFromBigEndian,The following statement contains a magic number: UInt64 x = (                  (((UInt64)block[0]) << 56) | (((UInt64)block[1]) << 48) |                  (((UInt64)block[2]) << 40) | (((UInt64)block[3]) << 32) |                  (((UInt64)block[4]) << 24) | (((UInt64)block[5]) << 16) |                  (((UInt64)block[6]) << 8) | ((UInt64)block[7])                  );
Magic Number,System.Security.Cryptography,DES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\DES.cs,QuadWordFromBigEndian,The following statement contains a magic number: UInt64 x = (                  (((UInt64)block[0]) << 56) | (((UInt64)block[1]) << 48) |                  (((UInt64)block[2]) << 40) | (((UInt64)block[3]) << 32) |                  (((UInt64)block[4]) << 24) | (((UInt64)block[5]) << 16) |                  (((UInt64)block[6]) << 8) | ((UInt64)block[7])                  );
Magic Number,System.Security.Cryptography,DES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\DES.cs,QuadWordFromBigEndian,The following statement contains a magic number: UInt64 x = (                  (((UInt64)block[0]) << 56) | (((UInt64)block[1]) << 48) |                  (((UInt64)block[2]) << 40) | (((UInt64)block[3]) << 32) |                  (((UInt64)block[4]) << 24) | (((UInt64)block[5]) << 16) |                  (((UInt64)block[6]) << 8) | ((UInt64)block[7])                  );
Magic Number,System.Security.Cryptography,DES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\DES.cs,QuadWordFromBigEndian,The following statement contains a magic number: UInt64 x = (                  (((UInt64)block[0]) << 56) | (((UInt64)block[1]) << 48) |                  (((UInt64)block[2]) << 40) | (((UInt64)block[3]) << 32) |                  (((UInt64)block[4]) << 24) | (((UInt64)block[5]) << 16) |                  (((UInt64)block[6]) << 8) | ((UInt64)block[7])                  );
Magic Number,System.Security.Cryptography,DES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\DES.cs,QuadWordFromBigEndian,The following statement contains a magic number: UInt64 x = (                  (((UInt64)block[0]) << 56) | (((UInt64)block[1]) << 48) |                  (((UInt64)block[2]) << 40) | (((UInt64)block[3]) << 32) |                  (((UInt64)block[4]) << 24) | (((UInt64)block[5]) << 16) |                  (((UInt64)block[6]) << 8) | ((UInt64)block[7])                  );
Magic Number,System.Security.Cryptography,DES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\DES.cs,QuadWordFromBigEndian,The following statement contains a magic number: UInt64 x = (                  (((UInt64)block[0]) << 56) | (((UInt64)block[1]) << 48) |                  (((UInt64)block[2]) << 40) | (((UInt64)block[3]) << 32) |                  (((UInt64)block[4]) << 24) | (((UInt64)block[5]) << 16) |                  (((UInt64)block[6]) << 8) | ((UInt64)block[7])                  );
Magic Number,System.Security.Cryptography,DES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\DES.cs,QuadWordFromBigEndian,The following statement contains a magic number: UInt64 x = (                  (((UInt64)block[0]) << 56) | (((UInt64)block[1]) << 48) |                  (((UInt64)block[2]) << 40) | (((UInt64)block[3]) << 32) |                  (((UInt64)block[4]) << 24) | (((UInt64)block[5]) << 16) |                  (((UInt64)block[6]) << 8) | ((UInt64)block[7])                  );
Magic Number,System.Security.Cryptography,DES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\DES.cs,QuadWordFromBigEndian,The following statement contains a magic number: UInt64 x = (                  (((UInt64)block[0]) << 56) | (((UInt64)block[1]) << 48) |                  (((UInt64)block[2]) << 40) | (((UInt64)block[3]) << 32) |                  (((UInt64)block[4]) << 24) | (((UInt64)block[5]) << 16) |                  (((UInt64)block[6]) << 8) | ((UInt64)block[7])                  );
Magic Number,System.Security.Cryptography,DES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\DES.cs,QuadWordFromBigEndian,The following statement contains a magic number: UInt64 x = (                  (((UInt64)block[0]) << 56) | (((UInt64)block[1]) << 48) |                  (((UInt64)block[2]) << 40) | (((UInt64)block[3]) << 32) |                  (((UInt64)block[4]) << 24) | (((UInt64)block[5]) << 16) |                  (((UInt64)block[6]) << 8) | ((UInt64)block[7])                  );
Magic Number,System.Security.Cryptography,DES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\DES.cs,QuadWordFromBigEndian,The following statement contains a magic number: UInt64 x = (                  (((UInt64)block[0]) << 56) | (((UInt64)block[1]) << 48) |                  (((UInt64)block[2]) << 40) | (((UInt64)block[3]) << 32) |                  (((UInt64)block[4]) << 24) | (((UInt64)block[5]) << 16) |                  (((UInt64)block[6]) << 8) | ((UInt64)block[7])                  );
Magic Number,System.Security.Cryptography,DES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\DES.cs,QuadWordFromBigEndian,The following statement contains a magic number: UInt64 x = (                  (((UInt64)block[0]) << 56) | (((UInt64)block[1]) << 48) |                  (((UInt64)block[2]) << 40) | (((UInt64)block[3]) << 32) |                  (((UInt64)block[4]) << 24) | (((UInt64)block[5]) << 16) |                  (((UInt64)block[6]) << 8) | ((UInt64)block[7])                  );
Magic Number,System.Security.Cryptography,DES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\DES.cs,QuadWordFromBigEndian,The following statement contains a magic number: UInt64 x = (                  (((UInt64)block[0]) << 56) | (((UInt64)block[1]) << 48) |                  (((UInt64)block[2]) << 40) | (((UInt64)block[3]) << 32) |                  (((UInt64)block[4]) << 24) | (((UInt64)block[5]) << 16) |                  (((UInt64)block[6]) << 8) | ((UInt64)block[7])                  );
Magic Number,System.Security.Cryptography,DES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\DES.cs,QuadWordFromBigEndian,The following statement contains a magic number: UInt64 x = (                  (((UInt64)block[0]) << 56) | (((UInt64)block[1]) << 48) |                  (((UInt64)block[2]) << 40) | (((UInt64)block[3]) << 32) |                  (((UInt64)block[4]) << 24) | (((UInt64)block[5]) << 16) |                  (((UInt64)block[6]) << 8) | ((UInt64)block[7])                  );
Magic Number,System.Security.Cryptography,DSA,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\DSA.cs,VerifyData,The following statement contains a magic number: for (int i = 256; ; i = checked(i * 2))              {                  int hashLength = 0;                  byte[] hash = ArrayPool<byte>.Shared.Rent(i);                  try                  {                      if (TryHashData(data' hash' hashAlgorithm' out hashLength))                      {                          return VerifySignature(new ReadOnlySpan<byte>(hash' 0' hashLength)' signature);                      }                  }                  finally                  {                      Array.Clear(hash' 0' hashLength);                      ArrayPool<byte>.Shared.Return(hash);                  }              }
Magic Number,System.Security.Cryptography,DSA,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\DSA.cs,VerifyData,The following statement contains a magic number: for (int i = 256; ; i = checked(i * 2))              {                  int hashLength = 0;                  byte[] hash = ArrayPool<byte>.Shared.Rent(i);                  try                  {                      if (TryHashData(data' hash' hashAlgorithm' out hashLength))                      {                          return VerifySignature(new ReadOnlySpan<byte>(hash' 0' hashLength)' signature);                      }                  }                  finally                  {                      Array.Clear(hash' 0' hashLength);                      ArrayPool<byte>.Shared.Return(hash);                  }              }
Magic Number,System.Security.Cryptography,ECDsa,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\ECDsa.cs,VerifyData,The following statement contains a magic number: for (int i = 256; ; i = checked(i * 2))              {                  int hashLength = 0;                  byte[] hash = ArrayPool<byte>.Shared.Rent(i);                  try                  {                      if (TryHashData(data' hash' hashAlgorithm' out hashLength))                      {                          return VerifyHash(new ReadOnlySpan<byte>(hash' 0' hashLength)' signature);                      }                  }                  finally                  {                      Array.Clear(hash' 0' hashLength);                      ArrayPool<byte>.Shared.Return(hash);                  }              }
Magic Number,System.Security.Cryptography,ECDsa,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\ECDsa.cs,VerifyData,The following statement contains a magic number: for (int i = 256; ; i = checked(i * 2))              {                  int hashLength = 0;                  byte[] hash = ArrayPool<byte>.Shared.Rent(i);                  try                  {                      if (TryHashData(data' hash' hashAlgorithm' out hashLength))                      {                          return VerifyHash(new ReadOnlySpan<byte>(hash' 0' hashLength)' signature);                      }                  }                  finally                  {                      Array.Clear(hash' 0' hashLength);                      ArrayPool<byte>.Shared.Return(hash);                  }              }
Magic Number,System.Security.Cryptography,Implementation,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\MD5.cs,Implementation,The following statement contains a magic number: HashSizeValue = _hashProvider.HashSizeInBytes * 8;
Magic Number,System.Security.Cryptography,Implementation,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\MD5.cs,Implementation,The following statement contains a magic number: HashSizeValue = _hashProvider.HashSizeInBytes * 8;
Magic Number,System.Security.Cryptography,Implementation,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\MD5.cs,Implementation,The following statement contains a magic number: HashSizeValue = _hashProvider.HashSizeInBytes * 8;
Magic Number,System.Security.Cryptography,Implementation,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\MD5.cs,Implementation,The following statement contains a magic number: HashSizeValue = _hashProvider.HashSizeInBytes * 8;
Magic Number,System.Security.Cryptography,Implementation,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\MD5.cs,Implementation,The following statement contains a magic number: HashSizeValue = _hashProvider.HashSizeInBytes * 8;
Magic Number,System.Security.Cryptography,SHA1Managed,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\SHA1Managed.cs,SHA1Managed,The following statement contains a magic number: HashSizeValue = _hashProvider.HashSizeInBytes * 8;
Magic Number,System.Security.Cryptography,SHA256Managed,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\SHA256Managed.cs,SHA256Managed,The following statement contains a magic number: HashSizeValue = _hashProvider.HashSizeInBytes * 8;
Magic Number,System.Security.Cryptography,SHA384Managed,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\SHA384Managed.cs,SHA384Managed,The following statement contains a magic number: HashSizeValue = _hashProvider.HashSizeInBytes * 8;
Magic Number,System.Security.Cryptography,SHA512Managed,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\SHA512Managed.cs,SHA512Managed,The following statement contains a magic number: HashSizeValue = _hashProvider.HashSizeInBytes * 8;
Magic Number,System.Security.Cryptography,PKCS1MaskGenerationMethod,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\PKCS1MaskGenerationMethod.cs,GenerateMask,The following statement contains a magic number: using (HashAlgorithm hasher = (HashAlgorithm)CryptoConfig.CreateFromName(_hashNameValue))              {                  byte[] rgbCounter = new byte[4];                  byte[] rgbT = new byte[cbReturn];                    uint counter = 0;                  for (int ib = 0; ib < rgbT.Length;)                  {                      //  Increment counter -- up to 2^32 * sizeof(Hash)                      Helpers.ConvertIntToByteArray(counter++' rgbCounter);                      hasher.TransformBlock(rgbSeed' 0' rgbSeed.Length' rgbSeed' 0);                      hasher.TransformFinalBlock(rgbCounter' 0' 4);                      byte[] hash = hasher.Hash;                      hasher.Initialize();                      Buffer.BlockCopy(hash' 0' rgbT' ib' Math.Min(rgbT.Length - ib' hash.Length));                        ib += hasher.Hash.Length;                  }                  return rgbT;              }
Magic Number,System.Security.Cryptography,PKCS1MaskGenerationMethod,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\PKCS1MaskGenerationMethod.cs,GenerateMask,The following statement contains a magic number: using (HashAlgorithm hasher = (HashAlgorithm)CryptoConfig.CreateFromName(_hashNameValue))              {                  byte[] rgbCounter = new byte[4];                  byte[] rgbT = new byte[cbReturn];                    uint counter = 0;                  for (int ib = 0; ib < rgbT.Length;)                  {                      //  Increment counter -- up to 2^32 * sizeof(Hash)                      Helpers.ConvertIntToByteArray(counter++' rgbCounter);                      hasher.TransformBlock(rgbSeed' 0' rgbSeed.Length' rgbSeed' 0);                      hasher.TransformFinalBlock(rgbCounter' 0' 4);                      byte[] hash = hasher.Hash;                      hasher.Initialize();                      Buffer.BlockCopy(hash' 0' rgbT' ib' Math.Min(rgbT.Length - ib' hash.Length));                        ib += hasher.Hash.Length;                  }                  return rgbT;              }
Magic Number,System.Security.Cryptography,RC2,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\RC2.cs,RC2,The following statement contains a magic number: KeySizeValue = 128;
Magic Number,System.Security.Cryptography,RC2,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\RC2.cs,RC2,The following statement contains a magic number: BlockSizeValue = 64;
Magic Number,System.Security.Cryptography,Rijndael,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\Rijndael.cs,Rijndael,The following statement contains a magic number: KeySizeValue = 256;
Magic Number,System.Security.Cryptography,Rijndael,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\Rijndael.cs,Rijndael,The following statement contains a magic number: BlockSizeValue = 128;
Magic Number,System.Security.Cryptography,RijndaelManaged,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\RijndaelManaged.cs,RijndaelManaged,The following statement contains a magic number: LegalBlockSizesValue = new KeySizes[] { new KeySizes(minSize: 128' maxSize: 128' skipSize: 0) };
Magic Number,System.Security.Cryptography,RijndaelManaged,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\RijndaelManaged.cs,RijndaelManaged,The following statement contains a magic number: LegalBlockSizesValue = new KeySizes[] { new KeySizes(minSize: 128' maxSize: 128' skipSize: 0) };
Magic Number,System.Security.Cryptography,Rfc2898DeriveBytes,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\Rfc2898DeriveBytes.cs,Rfc2898DeriveBytes,The following statement contains a magic number: _blockSize = _hmac.HashSize >> 3;
Magic Number,System.Security.Cryptography,Rfc2898DeriveBytes,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\Rfc2898DeriveBytes.cs,Rfc2898DeriveBytes,The following statement contains a magic number: _blockSize = _hmac.HashSize >> 3;
Magic Number,System.Security.Cryptography,Rfc2898DeriveBytes,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\Rfc2898DeriveBytes.cs,Func,The following statement contains a magic number: try              {                  Span<byte> uiSpan = new Span<byte>(ui' 0' _blockSize);                    if (!_hmac.TryComputeHash(temp' uiSpan' out int bytesWritten) || bytesWritten != _blockSize)                      throw new CryptographicException();                    byte[] ret = new byte[_blockSize];                  uiSpan.CopyTo(ret);                    for (int i = 2; i <= _iterations; i++)                  {                      if (!_hmac.TryComputeHash(uiSpan' uiSpan' out bytesWritten) || bytesWritten != _blockSize)                          throw new CryptographicException();                        for (int j = 0; j < _blockSize; j++)                      {                          ret[j] ^= ui[j];                      }                  }                    // increment the block count.                  _block++;                  return ret;              }              finally              {                  Array.Clear(ui' 0' _blockSize);                  ArrayPool<byte>.Shared.Return(ui);              }
Magic Number,System.Security.Cryptography,RSA,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\RSA.cs,VerifyData,The following statement contains a magic number: for (int i = 256; ; i = checked(i * 2))              {                  int hashLength = 0;                  byte[] hash = ArrayPool<byte>.Shared.Rent(i);                  try                  {                      if (TryHashData(data' hash' hashAlgorithm' out hashLength))                      {                          return VerifyHash(new ReadOnlySpan<byte>(hash' 0' hashLength)' signature' hashAlgorithm' padding);                      }                  }                  finally                  {                      Array.Clear(hash' 0' hashLength);                      ArrayPool<byte>.Shared.Return(hash);                  }              }
Magic Number,System.Security.Cryptography,RSA,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\RSA.cs,VerifyData,The following statement contains a magic number: for (int i = 256; ; i = checked(i * 2))              {                  int hashLength = 0;                  byte[] hash = ArrayPool<byte>.Shared.Rent(i);                  try                  {                      if (TryHashData(data' hash' hashAlgorithm' out hashLength))                      {                          return VerifyHash(new ReadOnlySpan<byte>(hash' 0' hashLength)' signature' hashAlgorithm' padding);                      }                  }                  finally                  {                      Array.Clear(hash' 0' hashLength);                      ArrayPool<byte>.Shared.Return(hash);                  }              }
Magic Number,System.Security.Cryptography,RSAEncryptionPadding,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\RSAEncryptionPadding.cs,CombineHashCodes,The following statement contains a magic number: return (((h1 << 5) + h1) ^ h2);
Magic Number,System.Security.Cryptography,TripleDES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\TripleDES.cs,TripleDES,The following statement contains a magic number: KeySizeValue = 3*64;
Magic Number,System.Security.Cryptography,TripleDES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\TripleDES.cs,TripleDES,The following statement contains a magic number: KeySizeValue = 3*64;
Magic Number,System.Security.Cryptography,TripleDES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\TripleDES.cs,TripleDES,The following statement contains a magic number: BlockSizeValue = 64;
Magic Number,System.Security.Cryptography,TripleDES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\TripleDES.cs,IsWeakKey,The following statement contains a magic number: if (!(rgbKey.Length*8).IsLegalSize(s_legalKeySizes))                  throw new CryptographicException(SR.Cryptography_InvalidKeySize);
Magic Number,System.Security.Cryptography,TripleDES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\TripleDES.cs,IsWeakKey,The following statement contains a magic number: if (EqualBytes(rgbOddParityKey' 0' 8' 8))                  return true;
Magic Number,System.Security.Cryptography,TripleDES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\TripleDES.cs,IsWeakKey,The following statement contains a magic number: if (EqualBytes(rgbOddParityKey' 0' 8' 8))                  return true;
Magic Number,System.Security.Cryptography,TripleDES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\TripleDES.cs,IsWeakKey,The following statement contains a magic number: if ((rgbOddParityKey.Length == 24) && EqualBytes(rgbOddParityKey' 8' 16' 8))                  return true;
Magic Number,System.Security.Cryptography,TripleDES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\TripleDES.cs,IsWeakKey,The following statement contains a magic number: if ((rgbOddParityKey.Length == 24) && EqualBytes(rgbOddParityKey' 8' 16' 8))                  return true;
Magic Number,System.Security.Cryptography,TripleDES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\TripleDES.cs,IsWeakKey,The following statement contains a magic number: if ((rgbOddParityKey.Length == 24) && EqualBytes(rgbOddParityKey' 8' 16' 8))                  return true;
Magic Number,System.Security.Cryptography,TripleDES,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Algorithms\src\System\Security\Cryptography\TripleDES.cs,IsWeakKey,The following statement contains a magic number: if ((rgbOddParityKey.Length == 24) && EqualBytes(rgbOddParityKey' 8' 16' 8))                  return true;
