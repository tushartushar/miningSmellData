Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Threading.Tasks.Dataflow,ReceiveTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,CleanupAndComplete,The method has 100 lines of code.
Long Method,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,RetrievePostponedItemsNonGreedy,The method has 102 lines of code.
Long Method,System.Threading.Tasks.Dataflow.Internal,SourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\SourceCore.cs,OfferToTargets,The method has 104 lines of code.
Long Method,System.Threading.Tasks.Dataflow.Internal,TargetCore<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetCore.cs,ProcessMessagesLoopCore,The method has 108 lines of code.
Complex Method,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,Choose,Cyclomatic complexity of the method is 8
Complex Method,System.Threading.Tasks.Dataflow,SendAsyncSource<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,ReleaseReservation,Cyclomatic complexity of the method is 8
Complex Method,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,RetrievePostponedItemsNonGreedy,Cyclomatic complexity of the method is 8
Complex Method,System.Threading.Tasks.Dataflow,JoinBlockTargetSharedResources,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,RetrievePostponedItemsNonGreedy,Cyclomatic complexity of the method is 8
Complex Method,System.Threading.Tasks.Dataflow.Internal,JoinBlockTargetSharedResources,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,RetrievePostponedItemsNonGreedy,Cyclomatic complexity of the method is 8
Complex Method,System.Threading.Tasks.Dataflow.Internal,SourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\SourceCore.cs,OfferToTargets,Cyclomatic complexity of the method is 9
Long Parameter List,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,Choose,The method has 5 parameters. Parameters: source1' action1' source2' action2' dataflowBlockOptions
Long Parameter List,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,Choose,The method has 6 parameters. Parameters: source1' action1' source2' action2' source3' action3
Long Parameter List,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,Choose,The method has 7 parameters. Parameters: source1' action1' source2' action2' source3' action3' dataflowBlockOptions
Long Parameter List,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,ChooseCore,The method has 7 parameters. Parameters: source1' action1' source2' action2' source3' action3' dataflowBlockOptions
Long Parameter List,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,TryChooseFromSource,The method has 5 parameters. Parameters: source' action' branchId' scheduler' task
Long Parameter List,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,ChooseCoreByLinking,The method has 7 parameters. Parameters: source1' action1' source2' action2' source3' action3' dataflowBlockOptions
Long Parameter List,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,CreateChooseBranch,The method has 6 parameters. Parameters: boxedCompleted' cts' scheduler' branchId' source' action
Long Parameter List,System.Threading.Tasks.Dataflow,BatchedJoinBlockTargetSharedResources,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchedJoinBlock.cs,BatchedJoinBlockTargetSharedResources,The method has 6 parameters. Parameters: batchSize' dataflowBlockOptions' batchSizeReachedAction' allTargetsDecliningAction' exceptionAction' completionAction
Long Parameter List,System.Threading.Tasks.Dataflow,JoinBlockTargetSharedResources,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,JoinBlockTargetSharedResources,The method has 5 parameters. Parameters: ownerJoin' targets' joinFilledAction' exceptionAction' dataflowBlockOptions
Long Parameter List,System.Threading.Tasks.Dataflow.Internal,BatchedJoinBlockTargetSharedResources,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchedJoinBlock.cs,BatchedJoinBlockTargetSharedResources,The method has 6 parameters. Parameters: batchSize' dataflowBlockOptions' batchSizeReachedAction' allTargetsDecliningAction' exceptionAction' completionAction
Long Parameter List,System.Threading.Tasks.Dataflow.Internal,JoinBlockTargetSharedResources,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,JoinBlockTargetSharedResources,The method has 5 parameters. Parameters: ownerJoin' targets' joinFilledAction' exceptionAction' dataflowBlockOptions
Long Parameter List,System.Threading.Tasks.Dataflow.Internal,SourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\SourceCore.cs,SourceCore,The method has 5 parameters. Parameters: owningSource' dataflowBlockOptions' completeAction' itemsRemovedAction' itemCountingFunc
Long Parameter List,System.Threading.Tasks.Dataflow.Internal,TargetCore<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetCore.cs,TargetCore,The method has 5 parameters. Parameters: owningTarget' callAction' reorderingBuffer' dataflowBlockOptions' targetCoreOptions
Long Parameter List,System.Threading.Tasks.Dataflow.Internal,TargetCore<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetCore.cs,Complete,The method has 5 parameters. Parameters: exception' dropPendingMessages' storeExceptionEvenIfAlreadyCompleting' unwrapInnerExceptions' revertProcessingState
Long Identifier,System.Threading.Tasks.Dataflow,ReceiveTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,,The length of the parameter CachedLinkingCancellationCallback is 33.
Long Identifier,System.Threading.Tasks.Dataflow,ReceiveTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,,The length of the parameter _regFromExternalCancellationToken is 33.
Long Identifier,System.Threading.Tasks.Dataflow,DataflowLinkOptions,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowLinkOptions.cs,,The length of the parameter UnlinkAfterOneAndPropagateCompletion is 36.
Long Identifier,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,RetrievePostponedItemsGreedyBounded,The length of the parameter itemCountNeededToCompleteBatch is 30.
Long Identifier,System.Threading.Tasks.Dataflow,BatchedJoinBlockTargetSharedResources,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchedJoinBlock.cs,,The length of the parameter _allTargetsDecliningPermanentlyAction is 37.
Long Identifier,System.Threading.Tasks.Dataflow,BroadcastBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BroadcastBlock.cs,CompleteCore,The length of the parameter storeExceptionEvenIfAlreadyCompleting is 37.
Long Identifier,System.Threading.Tasks.Dataflow,BufferBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BufferBlock.cs,CompleteCore,The length of the parameter storeExceptionEvenIfAlreadyCompleting is 37.
Long Identifier,System.Threading.Tasks.Dataflow,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,ConsumeOnePostponedMessage,The length of the parameter hasTheHighestNumberOfMessagesAvailable is 38.
Long Identifier,System.Threading.Tasks.Dataflow,JoinBlockTargetSharedResources,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,CompleteBlockIfPossible,The length of the parameter impossibleToCompleteAnotherJoin is 31.
Long Identifier,System.Threading.Tasks.Dataflow,WriteOnceBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\WriteOnceBlock.cs,CompleteCore,The length of the parameter storeExceptionEvenIfAlreadyCompleting is 37.
Long Identifier,System.Threading.Tasks.Dataflow.Internal,BatchedJoinBlockTargetSharedResources,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchedJoinBlock.cs,,The length of the parameter _allTargetsDecliningPermanentlyAction is 37.
Long Identifier,System.Threading.Tasks.Dataflow.Internal,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,ConsumeOnePostponedMessage,The length of the parameter hasTheHighestNumberOfMessagesAvailable is 38.
Long Identifier,System.Threading.Tasks.Dataflow.Internal,JoinBlockTargetSharedResources,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,CompleteBlockIfPossible,The length of the parameter impossibleToCompleteAnotherJoin is 31.
Long Identifier,System.Threading.Tasks.Dataflow.Internal,Common,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\Common.cs,,The length of the parameter CompletedVoidResultTaskCompletionSource is 39.
Long Identifier,System.Threading.Tasks.Dataflow.Internal,Common,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\Common.cs,,The length of the parameter KEEP_ALIVE_NUMBER_OF_MESSAGES_THRESHOLD is 39.
Long Identifier,System.Threading.Tasks.Dataflow.Internal,Common,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\Common.cs,,The length of the parameter EXCEPTIONDATAKEY_DATAFLOWMESSAGEVALUE is 37.
Long Identifier,System.Threading.Tasks.Dataflow.Internal,SourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\SourceCore.cs,OfferMessagesLoopCore,The length of the parameter DEFAULT_RELEASE_LOCK_ITERATIONS is 31.
Long Identifier,System.Threading.Tasks.Dataflow.Internal,TargetCore<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetCore.cs,Complete,The length of the parameter storeExceptionEvenIfAlreadyCompleting is 37.
Long Identifier,System.Threading.Tasks.Dataflow.Internal,TargetCore<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetCore.cs,ProcessMessagesLoopCore,The length of the parameter shouldAttemptPostponedTransfer is 30.
Long Identifier,System.Threading.Tasks.Dataflow.Internal,TargetCore<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetCore.cs,ProcessMessagesLoopCore,The length of the parameter numberOfMessagesProcessedByThisTask is 35.
Long Identifier,System.Threading.Tasks.Dataflow.Internal,TargetCore<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetCore.cs,ProcessMessagesLoopCore,The length of the parameter numberOfMessagesProcessedSinceTheLastKeepAlive is 46.
Long Identifier,System.Threading.Tasks.Dataflow.Internal,TargetCore<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetCore.cs,TryConsumePostponedMessage,The length of the parameter countIncrementedExpectingToGetItem is 34.
Long Identifier,System.Threading.Tasks.Dataflow.Internal,TargetCore<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetCore.cs,,The length of the parameter _numberOfOutstandingOperations is 30.
Long Identifier,System.Threading.Tasks.Dataflow.Internal,TargetCore<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetCore.cs,,The length of the parameter _numberOfOutstandingServiceTasks is 32.
Long Statement,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,Post,The length of the statement  "            return target.OfferMessage(Common.SingleMessageHeader' item' source: null' consumeToAccept: false) == DataflowMessageStatus.Accepted; " is 133.
Long Statement,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,ReceiveAsync,The length of the statement  "            if (!Common.IsValidTimeout(timeout)) throw new ArgumentOutOfRangeException(nameof(timeout)' SR.ArgumentOutOfRange_NeedNonNegOrNegative1); " is 137.
Long Statement,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,Receive,The length of the statement  "            if (!Common.IsValidTimeout(timeout)) throw new ArgumentOutOfRangeException(nameof(timeout)' SR.ArgumentOutOfRange_NeedNonNegOrNegative1); " is 137.
Long Statement,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,ReceiveCoreByLinking,The length of the statement  "            // Keep cancellation registrations inside the try/catch in case the underlying CTS is disposed in which case an exception is thrown " is 131.
Long Statement,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,ReceiveCoreByLinking,The length of the statement  "                        ReceiveTarget<TOutput>.CachedLinkingCancellationCallback' target); // we don't have to cleanup this registration' as this cts is short-lived " is 140.
Long Statement,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,OutputAvailableAsync,The length of the statement  "                    CancellationToken.None' Common.GetContinuationOptions() | TaskContinuationOptions.NotOnCanceled' TaskScheduler.Default); " is 120.
Long Statement,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,ChooseCore,The length of the statement  "            bool hasThirdSource = source3 != null; // In the future' if we want higher arities on Choose' we can simply add more such checks on additional arguments " is 152.
Long Statement,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,ChooseCoreByLinking,The length of the statement  "            bool hasThirdSource = source3 != null; // In the future' if we want higher arities on Choose' we can simply add more such checks on additional arguments " is 152.
Long Statement,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,ChooseCoreByLinking,The length of the statement  "            CancellationTokenSource cts = CancellationTokenSource.CreateLinkedTokenSource(dataflowBlockOptions.CancellationToken' CancellationToken.None); " is 142.
Long Statement,System.Threading.Tasks.Dataflow,SendAsyncSource<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,CancellationHandler,The length of the statement  "                        Interlocked.CompareExchange(ref source._cancellationState' CANCELLATION_STATE_COMPLETING' CANCELLATION_STATE_REGISTERED) == CANCELLATION_STATE_REGISTERED) " is 154.
Long Statement,System.Threading.Tasks.Dataflow,SendAsyncSource<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,ReserveMessage,The length of the statement  "                     Interlocked.CompareExchange(ref _cancellationState' CANCELLATION_STATE_RESERVED' CANCELLATION_STATE_REGISTERED) == CANCELLATION_STATE_REGISTERED); " is 146.
Long Statement,System.Threading.Tasks.Dataflow,SendAsyncSource<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,ReleaseReservation,The length of the statement  "                    if (Interlocked.CompareExchange(ref _cancellationState' CANCELLATION_STATE_REGISTERED' CANCELLATION_STATE_RESERVED) != CANCELLATION_STATE_RESERVED) " is 147.
Long Statement,System.Threading.Tasks.Dataflow,SendAsyncSource<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,ReleaseReservation,The length of the statement  "                        CancellationHandler(new WeakReference<SendAsyncSource<TOutput>>(this)); // same code as registered with the CancellationToken " is 125.
Long Statement,System.Threading.Tasks.Dataflow,ReceiveTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,OfferMessage,The length of the statement  "                if (source == null && consumeToAccept) throw new ArgumentException(SR.Argument_CantConsumeFromANullSource' nameof(consumeToAccept)); " is 132.
Long Statement,System.Threading.Tasks.Dataflow,ChooseTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,OfferMessage,The length of the statement  "                if (source == null && consumeToAccept) throw new ArgumentException(SR.Argument_CantConsumeFromANullSource' nameof(consumeToAccept)); " is 132.
Long Statement,System.Threading.Tasks.Dataflow,ObserversState,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,NotifyObserversOfCompletion,The length of the statement  "                    Debug.Assert(Target.Completion.IsCompleted' "The target must have already completed in order to notify of completion."); " is 120.
Long Statement,System.Threading.Tasks.Dataflow,ActionBlock<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\ActionBlock.cs,ProcessMessageWithTask,The length of the statement  "                    _defaultTarget.Complete(caughtException' dropPendingMessages: true' storeExceptionEvenIfAlreadyCompleting: true' unwrapInnerExceptions: false); " is 143.
Long Statement,System.Threading.Tasks.Dataflow,ActionBlock<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\ActionBlock.cs,ProcessMessageWithTask,The length of the statement  "                }' this' CancellationToken.None' Common.GetContinuationOptions(TaskContinuationOptions.ExecuteSynchronously)' TaskScheduler.Default); " is 133.
Long Statement,System.Threading.Tasks.Dataflow,ActionBlock<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\ActionBlock.cs,AsyncCompleteProcessMessageWithTask,The length of the statement  "                _defaultTarget.Complete(completed.Exception' dropPendingMessages: true' storeExceptionEvenIfAlreadyCompleting: true' unwrapInnerExceptions: true); " is 146.
Long Statement,System.Threading.Tasks.Dataflow,ActionBlock<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\ActionBlock.cs,ToString,The length of the statement  "            return Common.GetNameForDebugger(this' _defaultTarget != null ? _defaultTarget.DataflowBlockOptions : _spscTarget.DataflowBlockOptions); " is 136.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,OfferMessage,The length of the statement  "                if (source == null && consumeToAccept) throw new ArgumentException(SR.Argument_CantConsumeFromANullSource' nameof(consumeToAccept)); " is 132.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,OfferMessage,The length of the statement  "                    //      2) we are being greedy AND we are bounding AND there is room available AND there are no postponed messages AND we are not currently processing.  " is 151.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,OfferMessage,The length of the statement  "                    // (We should also postpone if we are currently processing' because there may be a race between consuming postponed messages and " is 128.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,OfferMessage,The length of the statement  "                             (_boundingState.CountIsLessThanBound && _nonGreedyState.PostponedMessages.Count == 0 && _nonGreedyState.TaskForInputProcessing == null))) " is 137.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,OfferMessage,The length of the statement  "                        Debug.Assert(_nonGreedyState != null' "_nonGreedyState must have been initialized during construction in non-greedy mode."); " is 124.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,CompleteBlockIfPossible,The length of the statement  "                        // If we still have straggling items remaining' make them into their own batch even though there are fewer than batchSize " is 121.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,ProcessAsyncIfNecessary_Slow,The length of the statement  "                _nonGreedyState.TaskForInputProcessing = new Task(thisBatchTarget => ((BatchBlockTargetCore)thisBatchTarget).ProcessMessagesLoopCore()' this' " is 141.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,ProcessAsyncIfNecessary_Slow,The length of the statement  "                Exception exception = Common.StartTaskSafe(_nonGreedyState.TaskForInputProcessing' _dataflowBlockOptions.TaskScheduler); " is 120.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,ProcessAsyncIfNecessary_Slow,The length of the statement  "                    Task.Factory.StartNew(exc => Complete(exception: (Exception)exc' dropPendingMessages: true' releaseReservedMessages: true' revertProcessingState: true)' " is 152.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,RetrievePostponedItemsNonGreedy,The length of the statement  "                List<KeyValuePair<ISourceBlock<T>' KeyValuePair<DataflowMessageHeader'T>>> reserved = _nonGreedyState.ReservedSourcesTemp; " is 122.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,RetrievePostponedItemsNonGreedy,The length of the statement  "                        var reservedSourceAndMessage = new KeyValuePair<ISourceBlock<T>' KeyValuePair<DataflowMessageHeader' T>>(sourceAndMessage.Key' reservedMessage); " is 144.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,RetrievePostponedItemsNonGreedy,The length of the statement  "                Array.Clear(postponedTemp' 0' postponedTemp.Length); // clear out the temp array so as not to hold onto messages too long " is 121.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,RetrievePostponedItemsNonGreedy,The length of the statement  "                        var reservedSourceAndMessage = new KeyValuePair<ISourceBlock<T>' KeyValuePair<DataflowMessageHeader' T>>(sourceAndMessage.Key' reservedMessage); " is 144.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,RetrievePostponedItemsNonGreedy,The length of the statement  "                Debug.Assert(reserved.Count <= _batchSize' "Expected the number of reserved sources to be <= the number needed for a batch."); " is 126.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,RetrievePostponedItemsGreedyBounded,The length of the statement  "                List<KeyValuePair<ISourceBlock<T>' KeyValuePair<DataflowMessageHeader' T>>> reserved = _nonGreedyState.ReservedSourcesTemp; " is 123.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,RetrievePostponedItemsGreedyBounded,The length of the statement  "                    if (boundedCapacityAvailable < itemCountNeededToCompleteBatch) itemCountNeededToCompleteBatch = boundedCapacityAvailable; " is 121.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,RetrievePostponedItemsGreedyBounded,The length of the statement  "                    var reservedSourceAndMessage = new KeyValuePair<ISourceBlock<T>' KeyValuePair<DataflowMessageHeader' T>>(sourceAndMessage.Key' reservedMessage); " is 144.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,RetrievePostponedItemsGreedyBounded,The length of the statement  "                Array.Clear(postponedTemp' 0' postponedTemp.Length); // clear out the temp array so as not to hold onto messages too long " is 121.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,RetrievePostponedItemsGreedyBounded,The length of the statement  "                    var reservedSourceAndMessage = new KeyValuePair<ISourceBlock<T>' KeyValuePair<DataflowMessageHeader' T>>(sourceAndMessage.Key' reservedMessage); " is 144.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,RetrievePostponedItemsGreedyBounded,The length of the statement  "                Debug.Assert(reserved.Count <= itemCountNeededToCompleteBatch' "Expected the number of reserved sources to be <= the number needed for a batch."); " is 146.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,ConsumeReservedMessagesNonGreedy,The length of the statement  "                List<KeyValuePair<ISourceBlock<T>' KeyValuePair<DataflowMessageHeader' T>>> reserved = _nonGreedyState.ReservedSourcesTemp; " is 123.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,ConsumeReservedMessagesNonGreedy,The length of the statement  "                    reserved[i] = default(KeyValuePair<ISourceBlock<T>' KeyValuePair<DataflowMessageHeader' T>>); // in case of exception from ConsumeMessage " is 137.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,ConsumeReservedMessagesNonGreedy,The length of the statement  "                        for (int prev = 0; prev < i; prev++) reserved[prev] = default(KeyValuePair<ISourceBlock<T>' KeyValuePair<DataflowMessageHeader' T>>); " is 133.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,ConsumeReservedMessagesNonGreedy,The length of the statement  "                    var consumedSourceAndMessage = new KeyValuePair<ISourceBlock<T>' KeyValuePair<DataflowMessageHeader' T>>(sourceAndMessage.Key' consumedMessage); " is 144.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,ConsumeReservedMessagesGreedyBounded,The length of the statement  "                List<KeyValuePair<ISourceBlock<T>' KeyValuePair<DataflowMessageHeader' T>>> reserved = _nonGreedyState.ReservedSourcesTemp; " is 123.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,ConsumeReservedMessagesGreedyBounded,The length of the statement  "                    reserved[i] = default(KeyValuePair<ISourceBlock<T>' KeyValuePair<DataflowMessageHeader' T>>); // in case of exception from ConsumeMessage " is 137.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,ConsumeReservedMessagesGreedyBounded,The length of the statement  "                        var consumedSourceAndMessage = new KeyValuePair<ISourceBlock<T>' KeyValuePair<DataflowMessageHeader' T>>(sourceAndMessage.Key' consumedMessage); " is 144.
Long Statement,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,ReleaseReservedMessages,The length of the statement  "                List<KeyValuePair<ISourceBlock<T>' KeyValuePair<DataflowMessageHeader' T>>> reserved = _nonGreedyState.ReservedSourcesTemp; " is 123.
Long Statement,System.Threading.Tasks.Dataflow,BatchedJoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchedJoinBlock.cs,OfferMessage,The length of the statement  "            if (source == null && consumeToAccept) throw new ArgumentException(SR.Argument_CantConsumeFromANullSource' nameof(consumeToAccept)); " is 132.
Long Statement,System.Threading.Tasks.Dataflow,BroadcastBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BroadcastBlock.cs,OfferMessage,The length of the statement  "            if (source == null && consumeToAccept) throw new ArgumentException(SR.Argument_CantConsumeFromANullSource' nameof(consumeToAccept)); " is 132.
Long Statement,System.Threading.Tasks.Dataflow,BroadcastBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BroadcastBlock.cs,OfferMessage,The length of the statement  "                //      2) we are bounding AND there is room available AND there are no postponed messages AND we are not currently processing.  " is 127.
Long Statement,System.Threading.Tasks.Dataflow,BroadcastBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BroadcastBlock.cs,OfferMessage,The length of the statement  "                // (We should also postpone if we are currently processing' because there may be a race between consuming postponed messages and " is 128.
Long Statement,System.Threading.Tasks.Dataflow,BroadcastBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BroadcastBlock.cs,OfferMessage,The length of the statement  "                    (_boundingState.CountIsLessThanBound && _boundingState.PostponedMessages.Count == 0 && _boundingState.TaskForInputProcessing == null)) " is 134.
Long Statement,System.Threading.Tasks.Dataflow,BroadcastBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BroadcastBlock.cs,ConsumeAsyncIfNecessary,The length of the statement  "                Exception exception = Common.StartTaskSafe(_boundingState.TaskForInputProcessing' _source.DataflowBlockOptions.TaskScheduler); " is 126.
Long Statement,System.Threading.Tasks.Dataflow,BroadcastBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BroadcastBlock.cs,ConsumeAsyncIfNecessary,The length of the statement  "                    Task.Factory.StartNew(exc => CompleteCore(exception: (Exception)exc' storeExceptionEvenIfAlreadyCompleting: true' revertProcessingState: true)' " is 143.
Long Statement,System.Threading.Tasks.Dataflow,BroadcastingSourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BroadcastBlock.cs,OfferCurrentMessageToNewTarget,The length of the statement  "                DataflowMessageStatus result = target.OfferMessage(new DataflowMessageHeader(_nextMessageId)' currentMessage' _owningSource' consumeToAccept: useCloning); " is 154.
Long Statement,System.Threading.Tasks.Dataflow,BroadcastingSourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BroadcastBlock.cs,OfferAsyncIfNecessary,The length of the statement  "                    _taskForOutputProcessing = new Task(thisSourceCore => ((BroadcastingSourceCore<TOutput>)thisSourceCore).OfferMessagesLoopCore()' this' " is 134.
Long Statement,System.Threading.Tasks.Dataflow,BroadcastingSourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BroadcastBlock.cs,OfferAsyncIfNecessary,The length of the statement  "                            _owningSource' _taskForOutputProcessing' DataflowEtwProvider.TaskLaunchedReason.OfferingOutputMessages' _messages.Count); " is 121.
Long Statement,System.Threading.Tasks.Dataflow,BroadcastingSourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BroadcastBlock.cs,ReleaseReservation,The length of the statement  "                    if (_nextMessageReservedFor != target) throw new InvalidOperationException(SR.InvalidOperation_MessageNotReservedByTarget); " is 123.
Long Statement,System.Threading.Tasks.Dataflow,BroadcastingSourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BroadcastBlock.cs,ReleaseReservation,The length of the statement  "                        if (messageHeader.Id != _nextMessageId) throw new InvalidOperationException(SR.InvalidOperation_MessageNotReservedByTarget); " is 124.
Long Statement,System.Threading.Tasks.Dataflow,BroadcastingSourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BroadcastBlock.cs,AddException,The length of the statement  "                Debug.Assert(!Completion.IsCompleted || Completion.IsFaulted' "The block must either not be completed or be faulted if we're still storing exceptions."); " is 153.
Long Statement,System.Threading.Tasks.Dataflow,BroadcastingSourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BroadcastBlock.cs,AddExceptions,The length of the statement  "                Debug.Assert(!Completion.IsCompleted || Completion.IsFaulted' "The block must either not be completed or be faulted if we're still storing exceptions."); " is 153.
Long Statement,System.Threading.Tasks.Dataflow,BufferBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BufferBlock.cs,OfferMessage,The length of the statement  "            if (source == null && consumeToAccept) throw new ArgumentException(SR.Argument_CantConsumeFromANullSource' nameof(consumeToAccept)); " is 132.
Long Statement,System.Threading.Tasks.Dataflow,BufferBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BufferBlock.cs,OfferMessage,The length of the statement  "                //      2) we are bounding AND there is room available AND there are no postponed messages AND we are not currently processing.  " is 127.
Long Statement,System.Threading.Tasks.Dataflow,BufferBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BufferBlock.cs,OfferMessage,The length of the statement  "                // (We should also postpone if we are currently processing' because there may be a race between consuming postponed messages and " is 128.
Long Statement,System.Threading.Tasks.Dataflow,BufferBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BufferBlock.cs,OfferMessage,The length of the statement  "                    (_boundingState.CountIsLessThanBound && _boundingState.PostponedMessages.Count == 0 && _boundingState.TaskForInputProcessing == null)) " is 134.
Long Statement,System.Threading.Tasks.Dataflow,BufferBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BufferBlock.cs,ConsumeAsyncIfNecessary,The length of the statement  "                Exception exception = Common.StartTaskSafe(_boundingState.TaskForInputProcessing' _source.DataflowBlockOptions.TaskScheduler); " is 126.
Long Statement,System.Threading.Tasks.Dataflow,BufferBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BufferBlock.cs,ConsumeAsyncIfNecessary,The length of the statement  "                    Task.Factory.StartNew(exc => CompleteCore(exception: (Exception)exc' storeExceptionEvenIfAlreadyCompleting: true' revertProcessingState: true)' " is 143.
Long Statement,System.Threading.Tasks.Dataflow,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,ConsumeOnePostponedMessage,The length of the statement  "                    bool boundingCapacityAvailable = _sharedResources._boundingState.CountIsLessThanBound || !hasTheHighestNumberOfMessagesAvailable; " is 129.
Long Statement,System.Threading.Tasks.Dataflow,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,ConsumeOnePostponedMessage,The length of the statement  "                        // The ranking in highest number of available messages cannot have changed because this task is causing OfferMessage to postpone  " is 128.
Long Statement,System.Threading.Tasks.Dataflow,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,ConsumeOnePostponedMessage,The length of the statement  "                        if (hasTheHighestNumberOfMessagesAvailable) _sharedResources._boundingState.CurrentCount += 1; // track this new item against our bound " is 135.
Long Statement,System.Threading.Tasks.Dataflow,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,OfferMessage,The length of the statement  "            if (source == null && consumeToAccept) throw new ArgumentException(SR.Argument_CantConsumeFromANullSource' nameof(consumeToAccept)); " is 132.
Long Statement,System.Threading.Tasks.Dataflow,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,OfferMessage,The length of the statement  "                //      2) we are being greedy AND we are bounding AND there is room available AND there are no postponed messages AND we are not currently processing.  " is 151.
Long Statement,System.Threading.Tasks.Dataflow,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,OfferMessage,The length of the statement  "                // (We should also postpone if we are currently processing' because there may be a race between consuming postponed messages and " is 128.
Long Statement,System.Threading.Tasks.Dataflow,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,OfferMessage,The length of the statement  "                    if (_sharedResources._boundingState != null && HasTheHighestNumberOfMessagesAvailable) _sharedResources._boundingState.CurrentCount += 1; // track this new item against our bound " is 178.
Long Statement,System.Threading.Tasks.Dataflow,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,CompleteCore,The length of the statement  "                if (exception != null && ((!_decliningPermanently && !_sharedResources._decliningPermanently) || releaseReservedMessages)) " is 122.
Long Statement,System.Threading.Tasks.Dataflow,JoinBlockTargetSharedResources,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,ProcessAsyncIfNecessary_Slow,The length of the statement  "            _taskForInputProcessing = new Task(thisSharedResources => ((JoinBlockTargetSharedResources)thisSharedResources).ProcessMessagesLoopCore()' this' " is 144.
Long Statement,System.Threading.Tasks.Dataflow,JoinBlockTargetSharedResources,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,ProcessMessagesLoopCore,The length of the statement  "            Debug.Assert(!_dataflowBlockOptions.Greedy || _boundingState != null' "This only makes sense in non-greedy or bounding mode"); " is 126.
Long Statement,System.Threading.Tasks.Dataflow,TransformBlock<TInput;TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\TransformBlock.cs,ProcessMessageWithTask,The length of the statement  "                    _target.Complete(caughtException' dropPendingMessages: true' storeExceptionEvenIfAlreadyCompleting: true' unwrapInnerExceptions: false); " is 136.
Long Statement,System.Threading.Tasks.Dataflow,TransformBlock<TInput;TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\TransformBlock.cs,AsyncCompleteProcessMessageWithTask,The length of the statement  "                    _target.Complete(aggregate' dropPendingMessages: true' storeExceptionEvenIfAlreadyCompleting: true' unwrapInnerExceptions: true); " is 129.
Long Statement,System.Threading.Tasks.Dataflow,TransformManyBlock<TInput;TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\TransformManyBlock.cs,ProcessMessageWithTask,The length of the statement  "                    _target.Complete(caughtException' dropPendingMessages: true' storeExceptionEvenIfAlreadyCompleting: true' unwrapInnerExceptions: false); " is 136.
Long Statement,System.Threading.Tasks.Dataflow,TransformManyBlock<TInput;TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\TransformManyBlock.cs,AsyncCompleteProcessMessageWithTask,The length of the statement  "                            _target.Complete(exc' dropPendingMessages: true' storeExceptionEvenIfAlreadyCompleting: true' unwrapInnerExceptions: false); " is 124.
Long Statement,System.Threading.Tasks.Dataflow,TransformManyBlock<TInput;TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\TransformManyBlock.cs,AsyncCompleteProcessMessageWithTask,The length of the statement  "                    _target.Complete(aggregate' dropPendingMessages: true' storeExceptionEvenIfAlreadyCompleting: true' unwrapInnerExceptions: true); " is 129.
Long Statement,System.Threading.Tasks.Dataflow,TransformManyBlock<TInput;TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\TransformManyBlock.cs,StoreOutputItemsNonReorderedAtomic,The length of the statement  "            Debug.Assert(outputItems is TOutput[] || outputItems is List<TOutput>' "outputItems must be a list we've already vetted as trusted"); " is 133.
Long Statement,System.Threading.Tasks.Dataflow,WriteOnceBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\WriteOnceBlock.cs,CompleteBlock,The length of the statement  "            Debug.Assert(_lazyCompletionTaskSource == null || !_lazyCompletionTaskSource.Task.IsCompleted' "The task completion source must not be completed. This must be the only thread that ever completes the block."); " is 208.
Long Statement,System.Threading.Tasks.Dataflow,WriteOnceBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\WriteOnceBlock.cs,CompleteBlock,The length of the statement  "                if (Interlocked.CompareExchange(ref _lazyCompletionTaskSource' Common.CompletedVoidResultTaskCompletionSource' null) != null) " is 125.
Long Statement,System.Threading.Tasks.Dataflow,WriteOnceBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\WriteOnceBlock.cs,CompleteCore,The length of the statement  "                if (!_completionReserved || storeExceptionEvenIfAlreadyCompleting) thisThreadReservedCompletion = _completionReserved = true; " is 125.
Long Statement,System.Threading.Tasks.Dataflow,WriteOnceBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\WriteOnceBlock.cs,OfferMessage,The length of the statement  "            if (source == null && consumeToAccept) throw new ArgumentException(SR.Argument_CantConsumeFromANullSource' nameof(consumeToAccept)); " is 132.
Long Statement,System.Threading.Tasks.Dataflow,WriteOnceBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\WriteOnceBlock.cs,ReleaseReservation,The length of the statement  "            if (_header.Id != messageHeader.Id) throw new InvalidOperationException(SR.InvalidOperation_MessageNotReservedByTarget); " is 120.
Long Statement,System.Threading.Tasks.Dataflow.Internal,BatchedJoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchedJoinBlock.cs,OfferMessage,The length of the statement  "            if (source == null && consumeToAccept) throw new ArgumentException(SR.Argument_CantConsumeFromANullSource' nameof(consumeToAccept)); " is 132.
Long Statement,System.Threading.Tasks.Dataflow.Internal,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,ConsumeOnePostponedMessage,The length of the statement  "                    bool boundingCapacityAvailable = _sharedResources._boundingState.CountIsLessThanBound || !hasTheHighestNumberOfMessagesAvailable; " is 129.
Long Statement,System.Threading.Tasks.Dataflow.Internal,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,ConsumeOnePostponedMessage,The length of the statement  "                        // The ranking in highest number of available messages cannot have changed because this task is causing OfferMessage to postpone  " is 128.
Long Statement,System.Threading.Tasks.Dataflow.Internal,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,ConsumeOnePostponedMessage,The length of the statement  "                        if (hasTheHighestNumberOfMessagesAvailable) _sharedResources._boundingState.CurrentCount += 1; // track this new item against our bound " is 135.
Long Statement,System.Threading.Tasks.Dataflow.Internal,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,OfferMessage,The length of the statement  "            if (source == null && consumeToAccept) throw new ArgumentException(SR.Argument_CantConsumeFromANullSource' nameof(consumeToAccept)); " is 132.
Long Statement,System.Threading.Tasks.Dataflow.Internal,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,OfferMessage,The length of the statement  "                //      2) we are being greedy AND we are bounding AND there is room available AND there are no postponed messages AND we are not currently processing.  " is 151.
Long Statement,System.Threading.Tasks.Dataflow.Internal,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,OfferMessage,The length of the statement  "                // (We should also postpone if we are currently processing' because there may be a race between consuming postponed messages and " is 128.
Long Statement,System.Threading.Tasks.Dataflow.Internal,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,OfferMessage,The length of the statement  "                    if (_sharedResources._boundingState != null && HasTheHighestNumberOfMessagesAvailable) _sharedResources._boundingState.CurrentCount += 1; // track this new item against our bound " is 178.
Long Statement,System.Threading.Tasks.Dataflow.Internal,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,CompleteCore,The length of the statement  "                if (exception != null && ((!_decliningPermanently && !_sharedResources._decliningPermanently) || releaseReservedMessages)) " is 122.
Long Statement,System.Threading.Tasks.Dataflow.Internal,JoinBlockTargetSharedResources,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,ProcessAsyncIfNecessary_Slow,The length of the statement  "            _taskForInputProcessing = new Task(thisSharedResources => ((JoinBlockTargetSharedResources)thisSharedResources).ProcessMessagesLoopCore()' this' " is 144.
Long Statement,System.Threading.Tasks.Dataflow.Internal,JoinBlockTargetSharedResources,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,ProcessMessagesLoopCore,The length of the statement  "            Debug.Assert(!_dataflowBlockOptions.Greedy || _boundingState != null' "This only makes sense in non-greedy or bounding mode"); " is 126.
Long Statement,System.Threading.Tasks.Dataflow.Internal,Common,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\Common.cs,IsCooperativeCancellation,The length of the statement  "            // to cancel an individual operation which must return a TOutput value' simply by throwing an OperationCanceledException. " is 121.
Long Statement,System.Threading.Tasks.Dataflow.Internal,Common,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\Common.cs,PropagateCompletion,The length of the statement  "            Debug.Assert(sourceCompletionTask.IsCompleted' "sourceCompletionTask must be completed in order to propagate its completion."); " is 127.
Long Statement,System.Threading.Tasks.Dataflow.Internal,Common,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\Common.cs,PropagateCompletionAsContinuation,The length of the statement  "            sourceCompletionTask.ContinueWith((task' state) => Common.PropagateCompletion(task' (IDataflowBlock)state' AsyncExceptionHandler)' " is 130.
Long Statement,System.Threading.Tasks.Dataflow.Internal,SourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\SourceCore.cs,ReleaseReservation,The length of the statement  "                if (_nextMessageReservedFor != target) throw new InvalidOperationException(SR.InvalidOperation_MessageNotReservedByTarget); " is 123.
Long Statement,System.Threading.Tasks.Dataflow.Internal,SourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\SourceCore.cs,ReleaseReservation,The length of the statement  "                    if (messageHeader.Id != _nextMessageId.Value || _messages.IsEmpty) throw new InvalidOperationException(SR.InvalidOperation_MessageNotReservedByTarget); " is 151.
Long Statement,System.Threading.Tasks.Dataflow.Internal,SourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\SourceCore.cs,AddMessage,The length of the statement  "            Interlocked.MemoryBarrier(); // ensure the read of _taskForOutputProcessing doesn't move up before the writes in Enqueue " is 120.
Long Statement,System.Threading.Tasks.Dataflow.Internal,SourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\SourceCore.cs,AddMessages,The length of the statement  "            Interlocked.MemoryBarrier(); // ensure the read of _taskForOutputProcessing doesn't move up before the writes in Enqueue " is 120.
Long Statement,System.Threading.Tasks.Dataflow.Internal,SourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\SourceCore.cs,AddException,The length of the statement  "            Debug.Assert(!Completion.IsCompleted || Completion.IsFaulted' "The block must either not be completed or be faulted if we're still storing exceptions."); " is 153.
Long Statement,System.Threading.Tasks.Dataflow.Internal,SourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\SourceCore.cs,AddExceptions,The length of the statement  "            Debug.Assert(!Completion.IsCompleted || Completion.IsFaulted' "The block must either not be completed or be faulted if we're still storing exceptions."); " is 153.
Long Statement,System.Threading.Tasks.Dataflow.Internal,SourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\SourceCore.cs,AddAndUnwrapAggregateException,The length of the statement  "            Debug.Assert(aggregateException != null && aggregateException.InnerExceptions.Count > 0' "Aggregate must be valid and contain inner exceptions to unwrap."); " is 156.
Long Statement,System.Threading.Tasks.Dataflow.Internal,SourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\SourceCore.cs,AddAndUnwrapAggregateException,The length of the statement  "            Debug.Assert(!Completion.IsCompleted || Completion.IsFaulted' "The block must either not be completed or be faulted if we're still storing exceptions."); " is 153.
Long Statement,System.Threading.Tasks.Dataflow.Internal,SourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\SourceCore.cs,OfferMessageToTarget,The length of the statement  "            Debug.Assert(result != DataflowMessageStatus.NotAvailable' "Messages are not being offered concurrently' so nothing should be missed."); " is 136.
Long Statement,System.Threading.Tasks.Dataflow.Internal,SourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\SourceCore.cs,OfferAsyncIfNecessary_Slow,The length of the statement  "                _taskForOutputProcessing = new Task(thisSourceCore => ((SourceCore<TOutput>)thisSourceCore).OfferMessagesLoopCore()' this' " is 122.
Long Statement,System.Threading.Tasks.Dataflow.Internal,SourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\SourceCore.cs,OfferAsyncIfNecessary_Slow,The length of the statement  "                        _owningSource' _taskForOutputProcessing' DataflowEtwProvider.TaskLaunchedReason.OfferingOutputMessages' _messages.Count); " is 121.
Long Statement,System.Threading.Tasks.Dataflow.Internal,TargetCore<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetCore.cs,OfferMessage,The length of the statement  "            if (source == null && consumeToAccept) throw new ArgumentException(SR.Argument_CantConsumeFromANullSource' nameof(consumeToAccept)); " is 132.
Long Statement,System.Threading.Tasks.Dataflow.Internal,TargetCore<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetCore.cs,OfferMessage,The length of the statement  "                //      2) we are bounding AND there is room available AND there are no postponed messages AND no messages are currently being transfered to the input queue. " is 157.
Long Statement,System.Threading.Tasks.Dataflow.Internal,TargetCore<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetCore.cs,OfferMessage,The length of the statement  "                    (_boundingState.OutstandingTransfers == 0 && _boundingState.CountIsLessThanBound && _boundingState.PostponedMessages.Count == 0)) " is 129.
Long Statement,System.Threading.Tasks.Dataflow.Internal,TargetCore<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetCore.cs,ProcessAsyncIfNecessary_Slow,The length of the statement  "                (!_decliningPermanently && _boundingState != null && _boundingState.CountIsLessThanBound && _boundingState.PostponedMessages.Count > 0); " is 136.
Long Statement,System.Threading.Tasks.Dataflow.Internal,TargetCore<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetCore.cs,ProcessAsyncIfNecessary_Slow,The length of the statement  "                var taskForInputProcessing = new Task(thisTargetCore => ((TargetCore<TInput>)thisTargetCore).ProcessMessagesLoopCore()' this' " is 125.
Long Statement,System.Threading.Tasks.Dataflow.Internal,TargetCore<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetCore.cs,ProcessAsyncIfNecessary_Slow,The length of the statement  "                    Task.Factory.StartNew(exc => Complete(exception: (Exception)exc' dropPendingMessages: true' storeExceptionEvenIfAlreadyCompleting: true' " is 136.
Long Statement,System.Threading.Tasks.Dataflow.Internal,TargetCore<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetCore.cs,ProcessMessagesLoopCore,The length of the statement  "                    Debug.Assert(_numberOfOutstandingOperations > 0' "Expected a positive number of outstanding operations' since we're completing one here."); " is 139.
Long Statement,System.Threading.Tasks.Dataflow.Internal,TargetCore<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetCore.cs,ProcessMessagesLoopCore,The length of the statement  "                        Debug.Assert(_numberOfOutstandingServiceTasks > 0' "Expected a positive number of outstanding service tasks' since we're completing one here."); " is 144.
Long Statement,System.Threading.Tasks.Dataflow.Internal,TargetCore<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetCore.cs,TryGetNextAvailableOrPostponedMessage,The length of the statement  "            else if (_boundingState != null && TryConsumePostponedMessage(forPostponementTransfer: false' result: out messageWithId)) " is 121.
Long Statement,System.Threading.Tasks.Dataflow.Internal,TargetRegistry<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetRegistry.cs,Remove_Slow,The length of the statement  "            Debug.Assert(!onlyIfReachedMaxMessages || _linksWithRemainingMessages > 0' "We shouldn't have ended on the slow path."); " is 120.
Long Statement,System.Threading.Tasks.Dataflow.Internal,TargetRegistry<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetRegistry.cs,Remove_Slow,The length of the statement  "                    Debug.Assert(node.RemainingMessages > 1' "The target should have been removed' because there are no remaining messages."); " is 122.
Long Statement,System.Threading.Tasks.Dataflow.Internal,TargetRegistry<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetRegistry.cs,PropagateCompletion,The length of the statement  "            Debug.Assert(_owningSource.Completion.IsCompleted' "The owning source must have completed before propagating completion."); " is 123.
Long Statement,System.Threading.Tasks.Dataflow.Internal,TargetRegistry<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetRegistry.cs,PropagateCompletion,The length of the statement  "                if (node.PropagateCompletion) Common.PropagateCompletion(owningSourceCompletion' node.Target' Common.AsyncExceptionHandler); " is 124.
Long Statement,System.Threading.Tasks.Dataflow.Internal,TargetRegistry<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetRegistry.cs,AddToList,The length of the statement  "            Debug.Assert(_firstTarget != null && _lastTarget != null' "Both first and last node must be non-null after AddToList."); " is 120.
Long Statement,System.Threading.Tasks.Dataflow.Internal,TargetRegistry<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetRegistry.cs,RemoveFromList,The length of the statement  "            Debug.Assert(_firstTarget != null && _lastTarget != null' "Both first and last node must be non-null before RemoveFromList."); " is 126.
Long Statement,System.Threading.Tasks.Dataflow.Internal,TargetRegistry<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetRegistry.cs,RemoveFromList,The length of the statement  "            Debug.Assert((_firstTarget != null) == (_lastTarget != null)' "Both first and last node must either be null or non-null after RemoveFromList."); " is 144.
Complex Conditional,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,ChooseCore,The conditional expression  "TryChooseFromSource(source1' action1' 0' scheduler' out resultTask) ||                      TryChooseFromSource(source2' action2' 1' scheduler' out resultTask) ||                      (hasThirdSource && TryChooseFromSource(source3' action3' 2' scheduler' out resultTask))"  is complex.
Complex Conditional,System.Threading.Tasks.Dataflow,ActionBlock<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\ActionBlock.cs,ActionBlock,The conditional expression  "syncAction != null &&                  dataflowBlockOptions.SingleProducerConstrained &&                  dataflowBlockOptions.MaxDegreeOfParallelism == 1 &&                  !dataflowBlockOptions.CancellationToken.CanBeCanceled &&                  dataflowBlockOptions.BoundedCapacity == DataflowBlockOptions.Unbounded"  is complex.
Complex Conditional,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,OfferMessage,The conditional expression  "_dataflowBlockOptions.Greedy &&                              (_boundingState == null                                  ||                               (_boundingState.CountIsLessThanBound && _nonGreedyState.PostponedMessages.Count == 0 && _nonGreedyState.TaskForInputProcessing == null))"  is complex.
Complex Conditional,System.Threading.Tasks.Dataflow,BatchBlockTargetCore,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BatchBlock.cs,RetrievePostponedItemsNonGreedy,The conditional expression  "_decliningPermanently ||                          postponed.Count == 0 ||                          boundedCapacityAvailable <= 0 ||                          (!allowFewerThanBatchSize && (postponed.Count < _batchSize || boundedCapacityAvailable < _batchSize))"  is complex.
Complex Conditional,System.Threading.Tasks.Dataflow,BroadcastBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BroadcastBlock.cs,OfferMessage,The conditional expression  "_boundingState == null                          ||                      (_boundingState.CountIsLessThanBound && _boundingState.PostponedMessages.Count == 0 && _boundingState.TaskForInputProcessing == null)"  is complex.
Complex Conditional,System.Threading.Tasks.Dataflow,BroadcastBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BroadcastBlock.cs,ConsumeAsyncIfNecessary,The conditional expression  "!_decliningPermanently &&                  _boundingState.TaskForInputProcessing == null &&                  _boundingState.PostponedMessages.Count > 0 &&                  _boundingState.CountIsLessThanBound"  is complex.
Complex Conditional,System.Threading.Tasks.Dataflow,BroadcastBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BroadcastBlock.cs,CompleteTargetIfPossible,The conditional expression  "_decliningPermanently &&                  !_completionReserved &&                  (_boundingState == null || _boundingState.TaskForInputProcessing == null)"  is complex.
Complex Conditional,System.Threading.Tasks.Dataflow,BufferBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BufferBlock.cs,OfferMessage,The conditional expression  "_boundingState == null                          ||                      (_boundingState.CountIsLessThanBound && _boundingState.PostponedMessages.Count == 0 && _boundingState.TaskForInputProcessing == null)"  is complex.
Complex Conditional,System.Threading.Tasks.Dataflow,BufferBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BufferBlock.cs,ConsumeAsyncIfNecessary,The conditional expression  "!_targetDecliningPermanently &&                  _boundingState.TaskForInputProcessing == null &&                  _boundingState.PostponedMessages.Count > 0 &&                  _boundingState.CountIsLessThanBound"  is complex.
Complex Conditional,System.Threading.Tasks.Dataflow,BufferBlock<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BufferBlock.cs,CompleteTargetIfPossible,The conditional expression  "_targetDecliningPermanently &&                  !_targetCompletionReserved &&                  (_boundingState == null || _boundingState.TaskForInputProcessing == null)"  is complex.
Complex Conditional,System.Threading.Tasks.Dataflow,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,ConsumeOnePostponedMessage,The conditional expression  "_decliningPermanently || _sharedResources._decliningPermanently ||                          !boundingCapacityAvailable || !_nonGreedy.PostponedMessages.TryPop(out next)"  is complex.
Complex Conditional,System.Threading.Tasks.Dataflow,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,OfferMessage,The conditional expression  "_sharedResources._dataflowBlockOptions.Greedy &&                          (_sharedResources._boundingState == null                              ||                           ((_sharedResources._boundingState.CountIsLessThanBound || !HasTheHighestNumberOfMessagesAvailable) &&                            _nonGreedy.PostponedMessages.Count == 0 && _sharedResources._taskForInputProcessing == null))"  is complex.
Complex Conditional,System.Threading.Tasks.Dataflow,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,CompleteCore,The conditional expression  "exception != null && ((!_decliningPermanently && !_sharedResources._decliningPermanently) || releaseReservedMessages)"  is complex.
Complex Conditional,System.Threading.Tasks.Dataflow.Internal,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,ConsumeOnePostponedMessage,The conditional expression  "_decliningPermanently || _sharedResources._decliningPermanently ||                          !boundingCapacityAvailable || !_nonGreedy.PostponedMessages.TryPop(out next)"  is complex.
Complex Conditional,System.Threading.Tasks.Dataflow.Internal,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,OfferMessage,The conditional expression  "_sharedResources._dataflowBlockOptions.Greedy &&                          (_sharedResources._boundingState == null                              ||                           ((_sharedResources._boundingState.CountIsLessThanBound || !HasTheHighestNumberOfMessagesAvailable) &&                            _nonGreedy.PostponedMessages.Count == 0 && _sharedResources._taskForInputProcessing == null))"  is complex.
Complex Conditional,System.Threading.Tasks.Dataflow.Internal,JoinBlockTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,CompleteCore,The conditional expression  "exception != null && ((!_decliningPermanently && !_sharedResources._decliningPermanently) || releaseReservedMessages)"  is complex.
Complex Conditional,System.Threading.Tasks.Dataflow.Internal,Common,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\Common.cs,StoreStringIntoExceptionData,The conditional expression  "data != null && !data.IsFixedSize && !data.IsReadOnly && data[key] == null"  is complex.
Complex Conditional,System.Threading.Tasks.Dataflow.Internal,SpscTargetCore<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\SpscTargetCore.cs,ProcessMessagesLoopCore,The conditional expression  "!_messages.IsEmpty || // messages to be processed                                  (!wasDecliningPermanently && _decliningPermanently) || // potentially completion to be processed                                  _exceptions != null"  is complex.
Complex Conditional,System.Threading.Tasks.Dataflow.Internal,TargetCore<TInput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\TargetCore.cs,OfferMessage,The conditional expression  "_boundingState == null ||                      (_boundingState.OutstandingTransfers == 0 && _boundingState.CountIsLessThanBound && _boundingState.PostponedMessages.Count == 0)"  is complex.
Empty Catch Block,System.Threading.Tasks.Dataflow,SendAsyncSource<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,CompleteAsAccepted,The method has an empty catch block.
Empty Catch Block,System.Threading.Tasks.Dataflow,SendAsyncSource<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,CompleteAsDeclined,The method has an empty catch block.
Empty Catch Block,System.Threading.Tasks.Dataflow,SendAsyncSource<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,CompleteAsFaulted,The method has an empty catch block.
Empty Catch Block,System.Threading.Tasks.Dataflow,SendAsyncSource<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,CompleteAsCanceled,The method has an empty catch block.
Empty Catch Block,System.Threading.Tasks.Dataflow,ReceiveTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,CleanupAndComplete,The method has an empty catch block.
Empty Catch Block,System.Threading.Tasks.Dataflow,ReceiveTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,CleanupAndComplete,The method has an empty catch block.
Empty Catch Block,System.Threading.Tasks.Dataflow,ReceiveTarget<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,CleanupAndComplete,The method has an empty catch block.
Empty Catch Block,System.Threading.Tasks.Dataflow.Internal,Common,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\Common.cs,StoreDataflowMessageValueIntoExceptionData,The method has an empty catch block.
Empty Catch Block,System.Threading.Tasks.Dataflow.Internal,Common,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\Common.cs,StoreStringIntoExceptionData,The method has an empty catch block.
Empty Catch Block,System.Threading.Tasks.Dataflow.Internal,Common,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\Common.cs,GetPotentiallyNotSupportedCompletionTask,The method has an empty catch block.
Empty Catch Block,System.Threading.Tasks.Dataflow.Internal,Common,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\Common.cs,GetPotentiallyNotSupportedCompletionTask,The method has an empty catch block.
Magic Number,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,ChooseCore,The following statement contains a magic number: try              {                  TaskScheduler scheduler = dataflowBlockOptions.TaskScheduler;                  if (TryChooseFromSource(source1' action1' 0' scheduler' out resultTask) ||                      TryChooseFromSource(source2' action2' 1' scheduler' out resultTask) ||                      (hasThirdSource && TryChooseFromSource(source3' action3' 2' scheduler' out resultTask)))                  {                      return resultTask;                  }              }              catch (Exception exc)              {                  // In case TryReceive in TryChooseFromSource erroneously throws                  return Common.CreateTaskFromException<int>(exc);              }
Magic Number,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,ChooseCoreByLinking,The following statement contains a magic number: var branchTasks = new Task<int>[hasThirdSource ? 3 : 2];
Magic Number,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,ChooseCoreByLinking,The following statement contains a magic number: var branchTasks = new Task<int>[hasThirdSource ? 3 : 2];
Magic Number,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,ChooseCoreByLinking,The following statement contains a magic number: if (hasThirdSource)              {                  branchTasks[2] = CreateChooseBranch(boxedCompleted' cts' scheduler' 2' source3' action3);              }
Magic Number,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,ChooseCoreByLinking,The following statement contains a magic number: if (hasThirdSource)              {                  branchTasks[2] = CreateChooseBranch(boxedCompleted' cts' scheduler' 2' source3' action3);              }
Magic Number,System.Threading.Tasks.Dataflow,JoinBlock<T1;T2>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,JoinBlock,The following statement contains a magic number: var targets = new JoinBlockTargetBase[2];
Magic Number,System.Threading.Tasks.Dataflow,JoinBlock<T1;T2;T3>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,JoinBlock,The following statement contains a magic number: var targets = new JoinBlockTargetBase[3];
Magic Number,System.Threading.Tasks.Dataflow,JoinBlock<T1;T2;T3>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,JoinBlock,The following statement contains a magic number: targets[2] = _target3 = new JoinBlockTarget<T3>(_sharedResources);
Magic Number,System.Threading.Tasks.Dataflow.Internal,JoinBlock<T1;T2>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,JoinBlock,The following statement contains a magic number: var targets = new JoinBlockTargetBase[2];
Magic Number,System.Threading.Tasks.Dataflow.Internal,JoinBlock<T1;T2;T3>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,JoinBlock,The following statement contains a magic number: var targets = new JoinBlockTargetBase[3];
Magic Number,System.Threading.Tasks.Dataflow.Internal,JoinBlock<T1;T2;T3>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\JoinBlock.cs,JoinBlock,The following statement contains a magic number: targets[2] = _target3 = new JoinBlockTarget<T3>(_sharedResources);
Magic Number,System.Threading.Tasks.Dataflow.Internal,Common,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\Common.cs,TryKeepAliveUntil,The following statement contains a magic number: const int ITERATION_LIMIT = 16;
Magic Number,System.Threading.Tasks.Dataflow.Internal,SourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\SourceCore.cs,OfferMessagesLoopCore,The following statement contains a magic number: try              {                  int maxMessagesPerTask = _dataflowBlockOptions.ActualMaxMessagesPerTask;                    // We need to hold the outgoing lock while offering messages.  We can either                  // lock and unlock for each individual offering' or we can lock around multiple or all                  // possible offerings.  The former ensures that other operations don't get starved'                  // while the latter is much more efficient (not continually acquiring and releasing                  // the lock).  For blocks that aren't linked to any targets' this won't matter                  // (no offering is done)' and for blocks that are only linked to targets' this shouldn't                   // matter (no one is contending for the lock)' thus                  // the only case it would matter is when a block both has targets and is being                  // explicitly received from' which is an uncommon scenario.  Thus' we want to lock                  // around the whole thing to improve performance' but just in case we do hit                  // an uncommon scenario' in the default case we release the lock every now and again.                    // If a developer wants to control this' they can limit the duration of the                   // lock by using MaxMessagesPerTask.                    const int DEFAULT_RELEASE_LOCK_ITERATIONS = 10; // Dialable                  int releaseLockIterations =                      _dataflowBlockOptions.MaxMessagesPerTask == DataflowBlockOptions.Unbounded ?                          DEFAULT_RELEASE_LOCK_ITERATIONS : maxMessagesPerTask;                    for (int messageCounter = 0;                      messageCounter < maxMessagesPerTask && !CanceledOrFaulted;)                  {                      lock (OutgoingLock)                      {                          // While there are more messages to process' offer each in turn                          // to the targets.  If we're unable to propagate a particular message'                          // stop trying until something changes in the future.                          for (                              int lockReleaseCounter = 0;                              messageCounter < maxMessagesPerTask && lockReleaseCounter < releaseLockIterations && !CanceledOrFaulted;                              ++messageCounter' ++lockReleaseCounter)                          {                              if (!OfferToTargets()) return;                          }                      }                  }              }              catch (Exception exc)              {                  // Record the exception                  AddException(exc);                    // Notify the owning block it should stop accepting new messages                  _completeAction(_owningSource);              }              finally              {                  lock (OutgoingLock)                  {                      lock (ValueLock)                      {                          // We're no longer processing' so null out the processing task                          Debug.Assert(_taskForOutputProcessing != null && _taskForOutputProcessing.Id == Task.CurrentId'                              "Must be part of the current processing task.");                          _taskForOutputProcessing = null;                          Interlocked.MemoryBarrier(); // synchronize with AddMessage(s) and its read of _taskForOutputProcessing                            // However' we may have given up early because we hit our own configured                          // processing limits rather than because we ran out of work to do.  If that's                          // the case' make sure we spin up another task to keep going.                          OfferAsyncIfNecessary(isReplacementReplica: true' outgoingLockKnownAcquired: true);                            // If' however' we stopped because we ran out of work to do and we                          // know we'll never get more' then complete.                          CompleteBlockIfPossible();                      }                  }              }
Magic Number,System.Threading.Tasks,SingleProducerSingleConsumerQueue<T>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Internal\ProducerConsumerQueues.cs,SingleProducerSingleConsumerQueue,The following statement contains a magic number: Debug.Assert(MAX_SEGMENT_SIZE < Int32.MaxValue / 2' "Max segment size * 2 must be < Int32.MaxValue' or else overflow could occur.");
Missing Default,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,SendAsync,The following switch statement is missing a default case: switch (target.OfferMessage(Common.SingleMessageHeader' item' source: null' consumeToAccept: false))                  {                      // If the message is immediately accepted' return a cached completed task with a true result                      case DataflowMessageStatus.Accepted:                          return Common.CompletedTaskWithTrueResult;                        // If the target is declining permanently' return a cached completed task with a false result                      case DataflowMessageStatus.DecliningPermanently:                          return Common.CompletedTaskWithFalseResult;    #if DEBUG                      case DataflowMessageStatus.Postponed:                          Debug.Assert(false' "A message should never be postponed when no source has been provided");                          break;                        case DataflowMessageStatus.NotAvailable:                          Debug.Assert(false' "The message should never be missed' as it's offered to only this one target");                          break;  #endif                  }
Missing Default,System.Threading.Tasks.Dataflow,DataflowBlock,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,ChooseCoreByLinking,The following switch statement is missing a default case: switch (task.Status)                      {                          case TaskStatus.Faulted:                              Common.AddException(ref exceptions' task.Exception' unwrapInnerExceptions: true);                              break;                          case TaskStatus.RanToCompletion:                              int resultBranchId = task.Result;                              if (resultBranchId >= 0)                              {                                  Debug.Assert(resultBranchId < tasks.Length' "Expected a valid branch ID");                                  Debug.Assert(successfulBranchId == -1' "There should be at most one successful branch.");                                  successfulBranchId = resultBranchId;                              }                              else Debug.Assert(resultBranchId == -1' "Expected -1 as a signal of a non-successful branch");                              break;                      }
Missing Default,System.Threading.Tasks.Dataflow,SendAsyncSource<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Base\DataflowBlock.cs,OfferToTarget,The following switch statement is missing a default case: switch (_target.OfferMessage(                          Common.SingleMessageHeader' _messageValue' this' consumeToAccept: consumeToAccept))                      {                          // If the message is immediately accepted' complete the task as accepted                          case DataflowMessageStatus.Accepted:                              if (!consumeToAccept)                              {                                  // Cancellation wasn't in use' and the target accepted the message directly'                                  // so complete the task as accepted.                                  CompleteAsAccepted(runAsync: false);                              }                              else                              {                                  // If cancellation is in use' then since the target accepted'                                  // our state better reflect that we're completing.                                  Debug.Assert(_cancellationState == CANCELLATION_STATE_COMPLETING'                                      "The message was accepted' so we should have started completion.");                              }                              break;                            // If the message is immediately declined' complete the task as declined                          case DataflowMessageStatus.Declined:                          case DataflowMessageStatus.DecliningPermanently:                              CompleteAsDeclined(runAsync: false);                              break;  #if DEBUG                          case DataflowMessageStatus.NotAvailable:                              Debug.Assert(false' "The message should never be missed' as it's offered to only this one target");                              break;                              // If the message was postponed' the source may or may not be complete yet.  Nothing to validate.                              // Treat an improper DataflowMessageStatus as postponed and do nothing.  #endif                      }
Missing Default,System.Threading.Tasks.Dataflow,BroadcastingSourceCore<TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\BroadcastBlock.cs,OfferMessageToTarget,The following switch statement is missing a default case: switch (target.OfferMessage(header' message' _owningSource' consumeToAccept: useCloning))                  {                      case DataflowMessageStatus.Accepted:                          if (!useCloning)                          {                              // If accepted and the target was linked as "once"' mark it for removal.                              // If we were forcing consumption' this removal would have already                              // happened in ConsumeMessage.                              _targetRegistry.Remove(target' onlyIfReachedMaxMessages: true);                          }                          break;                        case DataflowMessageStatus.DecliningPermanently:                          // If declined permanently' mark the target for removal                          _targetRegistry.Remove(target);                          break;                        case DataflowMessageStatus.NotAvailable:                          Debug.Assert(false' "Messages from a Broadcast should never be missed.");                          break;                          // No action required for Postponed or Declined                  }
Missing Default,System.Threading.Tasks.Dataflow,TransformBlock<TInput;TOutput>,C:\selectedRepos\dotnet_corefx\src\System.Threading.Tasks.Dataflow\src\Blocks\TransformBlock.cs,AsyncCompleteProcessMessageWithTask,The following switch statement is missing a default case: switch (completed.Status)              {                  case TaskStatus.RanToCompletion:                      outputItem = completed.Result;                      gotOutputItem = true;                      break;                    case TaskStatus.Faulted:                      // We must add the exception before declining and signaling completion' as the exception                       // is part of the operation' and the completion conditions depend on this.                      AggregateException aggregate = completed.Exception;                      Common.StoreDataflowMessageValueIntoExceptionData(aggregate' messageWithId.Key' targetInnerExceptions: true);                      _target.Complete(aggregate' dropPendingMessages: true' storeExceptionEvenIfAlreadyCompleting: true' unwrapInnerExceptions: true);                      break;                      // Nothing special to do for cancellation              }
