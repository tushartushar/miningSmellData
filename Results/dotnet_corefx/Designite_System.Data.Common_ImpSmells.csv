Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Data.Common,UInt64Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\UInt64Storage.cs,Aggregate,The method has 122 lines of code.
Long Method,System.Data.Common,ByteStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\ByteStorage.cs,Aggregate,The method has 117 lines of code.
Long Method,System.Data.Common,DbCommandBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DBCommandBuilder.cs,BuildInformation,The method has 126 lines of code.
Long Method,System.Data.Common,DbCommandBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DBCommandBuilder.cs,BuildWhereClause,The method has 108 lines of code.
Long Method,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,GetKeyValuePair,The method has 179 lines of code.
Long Method,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,Update,The method has 355 lines of code.
Long Method,System.Data.Common,DecimalStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DecimalStorage.cs,Aggregate,The method has 122 lines of code.
Long Method,System.Data.Common,DoubleStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DoubleStorage.cs,Aggregate,The method has 117 lines of code.
Long Method,System.Data.Common,Int16Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\Int16Storage.cs,Aggregate,The method has 131 lines of code.
Long Method,System.Data.Common,Int32Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\Int32Storage.cs,Aggregate,The method has 130 lines of code.
Long Method,System.Data.Common,Int64Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\Int64Storage.cs,Aggregate,The method has 122 lines of code.
Long Method,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The method has 214 lines of code.
Long Method,System.Data.Common,SByteStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SByteStorage.cs,Aggregate,The method has 117 lines of code.
Long Method,System.Data.Common,SingleStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SingleStorage.cs,Aggregate,The method has 118 lines of code.
Long Method,System.Data.Common,SqlConvert,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLConvert.cs,ChangeType2,The method has 196 lines of code.
Long Method,System.Data.Common,SqlConvert,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLConvert.cs,ChangeTypeForXML,The method has 183 lines of code.
Long Method,System.Data.Common,TimeSpanStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\TimeSpanStorage.cs,Aggregate,The method has 116 lines of code.
Long Method,System.Data.Common,UInt16Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\UInt16Storage.cs,Aggregate,The method has 130 lines of code.
Long Method,System.Data.Common,UInt32Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\UInt32Storage.cs,Aggregate,The method has 128 lines of code.
Long Method,System.Data.Common,SqlDecimalStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLDecimalStorage.cs,Aggregate,The method has 125 lines of code.
Long Method,System.Data.Common,SqlDoubleStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLDoubleStorage.cs,Aggregate,The method has 125 lines of code.
Long Method,System.Data.Common,SqlInt16Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLInt16Storage.cs,Aggregate,The method has 125 lines of code.
Long Method,System.Data.Common,SqlInt32Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLInt32Storage.cs,Aggregate,The method has 125 lines of code.
Long Method,System.Data.Common,SqlInt64Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLInt64Storage.cs,Aggregate,The method has 125 lines of code.
Long Method,System.Data.Common,SqlMoneyStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLMoneyStorage.cs,Aggregate,The method has 125 lines of code.
Long Method,System.Data.Common,SqlSingleStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLSingleStorage.cs,Aggregate,The method has 119 lines of code.
Long Method,System.Data.Common,SqlByteStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLByteStorage.cs,Aggregate,The method has 125 lines of code.
Long Method,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,OnColumnValueChanged,The method has 168 lines of code.
Long Method,System.Xml,XPathNodePointer,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XPathNodePointer.cs,ComparePosition,The method has 133 lines of code.
Long Method,System.Data,XDRSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XDRSchema.cs,HandleColumn,The method has 131 lines of code.
Long Method,System.Data,XmlDataLoader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XmlDataLoader.cs,LoadRowData,The method has 110 lines of code.
Long Method,System.Data,XmlDataLoader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XmlDataLoader.cs,LoadTopMostTable,The method has 147 lines of code.
Long Method,System.Data,XmlDataLoader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XmlDataLoader.cs,LoadTable,The method has 232 lines of code.
Long Method,System.Data,XmlDataLoader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XmlDataLoader.cs,LoadColumn,The method has 201 lines of code.
Long Method,System.Data,XMLDiffLoader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLDiffLoader.cs,ReadOldRowData,The method has 145 lines of code.
Long Method,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,SchemaTree,The method has 348 lines of code.
Long Method,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleColumn,The method has 107 lines of code.
Long Method,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleTable,The method has 402 lines of code.
Long Method,System.Data,NewDiffgramGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,GenerateColumn,The method has 108 lines of code.
Long Method,System.Data,XmlDataTreeWriter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,XmlDataRowWriter,The method has 150 lines of code.
Long Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,LoadSchema,The method has 182 lines of code.
Long Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,InstantiateTable,The method has 184 lines of code.
Long Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleSimpleTypeSimpleContentColumn,The method has 120 lines of code.
Long Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleAttributeColumn,The method has 145 lines of code.
Long Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleElementColumn,The method has 181 lines of code.
Long Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleDataSet,The method has 149 lines of code.
Long Method,System.Data,DataColumnCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataColumnCollection.cs,CanRemove,The method has 108 lines of code.
Long Method,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXml,The method has 248 lines of code.
Long Method,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXmlDiffgram,The method has 115 lines of code.
Long Method,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXml,The method has 221 lines of code.
Long Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,MergeRow,The method has 110 lines of code.
Long Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,CloneTo,The method has 113 lines of code.
Long Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SetNewRecordWorker,The method has 191 lines of code.
Long Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SetDataRowWithLoadOption,The method has 196 lines of code.
Long Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ReadXml,The method has 214 lines of code.
Long Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ReadXml,The method has 266 lines of code.
Long Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ReadXmlSchema,The method has 165 lines of code.
Long Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,EvaluateDependentExpressions,The method has 145 lines of code.
Long Method,System.Data,DataTableReader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableReader.cs,GetSchemaTableFromDataTable,The method has 124 lines of code.
Long Method,System.Data,Merger,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Merger.cs,MergeSchema,The method has 122 lines of code.
Long Method,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,RBInsert,The method has 212 lines of code.
Long Method,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,RBDeleteX,The method has 197 lines of code.
Long Method,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,RBDeleteFixup,The method has 117 lines of code.
Long Method,System.Data,Select,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Select.cs,AnalyzeExpression,The method has 113 lines of code.
Long Method,System.Data,Select,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Select.cs,CreateIndex,The method has 130 lines of code.
Long Method,System.Data,ExpressionParser,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\ExpressionParser.cs,Parse,The method has 327 lines of code.
Long Method,System.Data,ExpressionParser,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\ExpressionParser.cs,Scan,The method has 169 lines of code.
Long Method,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The method has 200 lines of code.
Long Method,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,BinaryCompare,The method has 114 lines of code.
Long Method,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The method has 799 lines of code.
Long Method,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,SchemaMapping,The method has 107 lines of code.
Long Method,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,SetupSchemaWithoutKeyInfo,The method has 175 lines of code.
Long Method,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,SetupSchemaWithKeyInfo,The method has 378 lines of code.
Long Method,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,CalculatePrecision,The method has 102 lines of code.
Long Method,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The method has 100 lines of code.
Long Method,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,Parse,The method has 107 lines of code.
Long Method,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,MpDiv,The method has 139 lines of code.
Complex Method,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,RemoveStringQuotes,Cyclomatic complexity of the method is 8
Complex Method,System.Data.Common,DataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataAdapter.cs,Fill,Cyclomatic complexity of the method is 12
Complex Method,System.Data.Common,DataColumnMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataColumnMapping.cs,GetDataColumnBySchemaAction,Cyclomatic complexity of the method is 10
Complex Method,System.Data.Common,DbCommandBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DBCommandBuilder.cs,BuildCache,Cyclomatic complexity of the method is 11
Complex Method,System.Data.Common,DbCommandBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DBCommandBuilder.cs,BuildInformation,Cyclomatic complexity of the method is 23
Complex Method,System.Data.Common,DbCommandBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DBCommandBuilder.cs,BuildInsertCommand,Cyclomatic complexity of the method is 8
Complex Method,System.Data.Common,DbCommandBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DBCommandBuilder.cs,BuildUpdateCommand,Cyclomatic complexity of the method is 8
Complex Method,System.Data.Common,DbCommandBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DBCommandBuilder.cs,BuildWhereClause,Cyclomatic complexity of the method is 9
Complex Method,System.Data.Common,DbCommandBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DBCommandBuilder.cs,RefreshSchema,Cyclomatic complexity of the method is 8
Complex Method,System.Data.Common,DbCommandBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DBCommandBuilder.cs,RowUpdatingHandler,Cyclomatic complexity of the method is 9
Complex Method,System.Data.Common,ParameterNames,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DBCommandBuilder.cs,ParameterNames,Cyclomatic complexity of the method is 15
Complex Method,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,AppendKeyValuePairBuilder,Cyclomatic complexity of the method is 8
Complex Method,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,SplitConnectionString,Cyclomatic complexity of the method is 9
Complex Method,System.Data.Common,DbConnectionStringBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionStringBuilder.cs,GetProperties,Cyclomatic complexity of the method is 11
Complex Method,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,Update,Cyclomatic complexity of the method is 26
Complex Method,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,UpdateBatchExecute,Cyclomatic complexity of the method is 13
Complex Method,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,UpdatedRowStatusErrors,Cyclomatic complexity of the method is 8
Complex Method,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,Cyclomatic complexity of the method is 8
Complex Method,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,CreateElement,Cyclomatic complexity of the method is 8
Complex Method,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,GetColumnInsertAfterLocation,Cyclomatic complexity of the method is 9
Complex Method,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,OnColumnValueChanged,Cyclomatic complexity of the method is 13
Complex Method,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,SynchronizeRowFromRowElementEx,Cyclomatic complexity of the method is 16
Complex Method,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,OrderTables,Cyclomatic complexity of the method is 11
Complex Method,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,IsSelfRelatedDataTable,Cyclomatic complexity of the method is 8
Complex Method,System.Xml,XPathNodePointer,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XPathNodePointer.cs,MoveToNextAttribute,Cyclomatic complexity of the method is 9
Complex Method,System.Xml,XPathNodePointer,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XPathNodePointer.cs,MoveToFirst,Cyclomatic complexity of the method is 8
Complex Method,System.Xml,XPathNodePointer,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XPathNodePointer.cs,MoveToFirstChild,Cyclomatic complexity of the method is 10
Complex Method,System.Xml,XPathNodePointer,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XPathNodePointer.cs,ComparePosition,Cyclomatic complexity of the method is 13
Complex Method,System.Xml,XPathNodePointer,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XPathNodePointer.cs,GetNamespace,Cyclomatic complexity of the method is 9
Complex Method,System.Xml,XPathNodePointer,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XPathNodePointer.cs,MoveToNamespace,Cyclomatic complexity of the method is 8
Complex Method,System.Xml,XPathNodePointer,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XPathNodePointer.cs,MoveToNextNamespace,Cyclomatic complexity of the method is 8
Complex Method,System.Xml,XPathNodePointer,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XPathNodePointer.cs,MoveToNextNamespace,Cyclomatic complexity of the method is 9
Complex Method,System.Xml,DataSetMapper,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\DataSetMappper.cs,SearchMatchingTableSchema,Cyclomatic complexity of the method is 11
Complex Method,System.Xml,DataSetMapper,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\DataSetMappper.cs,IsRegionRadical,Cyclomatic complexity of the method is 17
Complex Method,System.Data,XDRSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XDRSchema.cs,FindTypeNode,Cyclomatic complexity of the method is 8
Complex Method,System.Data,XDRSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XDRSchema.cs,HandleColumn,Cyclomatic complexity of the method is 14
Complex Method,System.Data,XDRSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XDRSchema.cs,InstantiateTable,Cyclomatic complexity of the method is 11
Complex Method,System.Data,XmlDataLoader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XmlDataLoader.cs,LoadRowData,Cyclomatic complexity of the method is 22
Complex Method,System.Data,XmlDataLoader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XmlDataLoader.cs,LoadRows,Cyclomatic complexity of the method is 8
Complex Method,System.Data,XmlDataLoader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XmlDataLoader.cs,LoadData,Cyclomatic complexity of the method is 12
Complex Method,System.Data,XmlDataLoader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XmlDataLoader.cs,LoadTopMostTable,Cyclomatic complexity of the method is 10
Complex Method,System.Data,XmlDataLoader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XmlDataLoader.cs,LoadTable,Cyclomatic complexity of the method is 16
Complex Method,System.Data,XmlDataLoader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XmlDataLoader.cs,LoadColumn,Cyclomatic complexity of the method is 10
Complex Method,System.Data,XMLDiffLoader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLDiffLoader.cs,ProcessErrors,Cyclomatic complexity of the method is 10
Complex Method,System.Data,XMLDiffLoader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLDiffLoader.cs,ReadOldRowData,Cyclomatic complexity of the method is 13
Complex Method,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,AddXdoProperty,Cyclomatic complexity of the method is 11
Complex Method,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,XmlDataTypeName,Cyclomatic complexity of the method is 23
Complex Method,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,GenerateConstraintNames,Cyclomatic complexity of the method is 8
Complex Method,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HaveExtendedProperties,Cyclomatic complexity of the method is 8
Complex Method,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,SchemaTree,Cyclomatic complexity of the method is 51
Complex Method,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleRelation,Cyclomatic complexity of the method is 8
Complex Method,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleColumnType,Cyclomatic complexity of the method is 10
Complex Method,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,AddColumnProperties,Cyclomatic complexity of the method is 11
Complex Method,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleColumn,Cyclomatic complexity of the method is 15
Complex Method,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,AutoGenerated,Cyclomatic complexity of the method is 10
Complex Method,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,AutoGenerated,Cyclomatic complexity of the method is 10
Complex Method,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleTable,Cyclomatic complexity of the method is 54
Complex Method,System.Data,NewDiffgramGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,Save,Cyclomatic complexity of the method is 9
Complex Method,System.Data,NewDiffgramGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,GenerateTableErrors,Cyclomatic complexity of the method is 11
Complex Method,System.Data,NewDiffgramGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,GenerateRow,Cyclomatic complexity of the method is 11
Complex Method,System.Data,XmlDataTreeWriter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,Save,Cyclomatic complexity of the method is 14
Complex Method,System.Data,XmlDataTreeWriter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,XmlDataRowWriter,Cyclomatic complexity of the method is 24
Complex Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,CollectElementsAnnotations,Cyclomatic complexity of the method is 16
Complex Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,SetProperties,Cyclomatic complexity of the method is 10
Complex Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,SetExtProperties,Cyclomatic complexity of the method is 8
Complex Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleRelation,Cyclomatic complexity of the method is 14
Complex Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,IsDatasetParticle,Cyclomatic complexity of the method is 10
Complex Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,FindDatasetElement,Cyclomatic complexity of the method is 14
Complex Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,LoadSchema,Cyclomatic complexity of the method is 35
Complex Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleParticle,Cyclomatic complexity of the method is 9
Complex Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleComplexType,Cyclomatic complexity of the method is 9
Complex Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleKeyref,Cyclomatic complexity of the method is 12
Complex Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleConstraint,Cyclomatic complexity of the method is 8
Complex Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,InstantiateSimpleTable,Cyclomatic complexity of the method is 13
Complex Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,InstantiateTable,Cyclomatic complexity of the method is 39
Complex Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleSimpleTypeSimpleContentColumn,Cyclomatic complexity of the method is 19
Complex Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleSimpleContentColumn,Cyclomatic complexity of the method is 18
Complex Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleAttributeColumn,Cyclomatic complexity of the method is 16
Complex Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleElementColumn,Cyclomatic complexity of the method is 17
Complex Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleDataSet,Cyclomatic complexity of the method is 21
Complex Method,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,IsTable,Cyclomatic complexity of the method is 8
Complex Method,System.Data,XmlToDatasetMap,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XmlToDatasetMap.cs,BuildIdentityMap,Cyclomatic complexity of the method is 10
Complex Method,System.Data,XmlToDatasetMap,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XmlToDatasetMap.cs,BuildIdentityMap,Cyclomatic complexity of the method is 9
Complex Method,System.Data,ColumnTypeConverter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ColumnTypeConverter.cs,ConvertTo,Cyclomatic complexity of the method is 9
Complex Method,System.Data,ConstraintCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ConstraintCollection.cs,Add,Cyclomatic complexity of the method is 10
Complex Method,System.Data,ConstraintCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ConstraintCollection.cs,BaseGroupSwitch,Cyclomatic complexity of the method is 8
Complex Method,System.Data,ConstraintCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ConstraintCollection.cs,FinishInitConstraints,Cyclomatic complexity of the method is 11
Complex Method,System.Data,DataColumnCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataColumnCollection.cs,BaseAdd,Cyclomatic complexity of the method is 10
Complex Method,System.Data,DataColumnCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataColumnCollection.cs,BaseGroupSwitch,Cyclomatic complexity of the method is 9
Complex Method,System.Data,DataColumnCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataColumnCollection.cs,CanRemove,Cyclomatic complexity of the method is 27
Complex Method,System.Data,DataKey,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataKey.cs,DataKey,Cyclomatic complexity of the method is 11
Complex Method,System.Data,DataRelation,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRelation.cs,ValidateMultipleNestedRelations,Cyclomatic complexity of the method is 8
Complex Method,System.Data,DataSetRelationCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRelationCollection.cs,AddCore,Cyclomatic complexity of the method is 10
Complex Method,System.Data,DataRow,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRow.cs,RejectChanges,Cyclomatic complexity of the method is 12
Complex Method,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,SerializeDataSet,Cyclomatic complexity of the method is 9
Complex Method,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,Clone,Cyclomatic complexity of the method is 14
Complex Method,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,GetChanges,Cyclomatic complexity of the method is 9
Complex Method,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXmlSchema,Cyclomatic complexity of the method is 15
Complex Method,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXml,Cyclomatic complexity of the method is 30
Complex Method,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXmlDiffgram,Cyclomatic complexity of the method is 21
Complex Method,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXml,Cyclomatic complexity of the method is 20
Complex Method,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXmlSerializable,Cyclomatic complexity of the method is 8
Complex Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,GetInheritedNamespace,Cyclomatic complexity of the method is 8
Complex Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,CloneTo,Cyclomatic complexity of the method is 17
Complex Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,InsertRow,Cyclomatic complexity of the method is 10
Complex Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,Clear,Cyclomatic complexity of the method is 8
Complex Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,Compare,Cyclomatic complexity of the method is 8
Complex Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ImportRow,Cyclomatic complexity of the method is 8
Complex Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,InsertRow,Cyclomatic complexity of the method is 11
Complex Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,RaiseRowChanging,Cyclomatic complexity of the method is 8
Complex Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SetNewRecordWorker,Cyclomatic complexity of the method is 22
Complex Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,LoadRow,Cyclomatic complexity of the method is 14
Complex Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SetDataRowWithLoadOption,Cyclomatic complexity of the method is 14
Complex Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ReadXml,Cyclomatic complexity of the method is 28
Complex Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ReadXml,Cyclomatic complexity of the method is 26
Complex Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ReadXmlDiffgram,Cyclomatic complexity of the method is 16
Complex Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ReadXmlSchema,Cyclomatic complexity of the method is 10
Complex Method,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,EvaluateDependentExpressions,Cyclomatic complexity of the method is 28
Complex Method,System.Data,DataTableCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableCollection.cs,BaseGroupSwitch,Cyclomatic complexity of the method is 9
Complex Method,System.Data,DataTableCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableCollection.cs,CanRemove,Cyclomatic complexity of the method is 13
Complex Method,System.Data,DataTableReader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableReader.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,System.Data,DataTableReader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableReader.cs,GetSchemaTableFromDataTable,Cyclomatic complexity of the method is 12
Complex Method,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,ApplySort,Cyclomatic complexity of the method is 8
Complex Method,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,UpdateIndex,Cyclomatic complexity of the method is 9
Complex Method,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,ToTable,Cyclomatic complexity of the method is 9
Complex Method,System.Data,ForeignKeyConstraint,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ForeignKeyConstraint.cs,CascadeCommit,Cyclomatic complexity of the method is 8
Complex Method,System.Data,ForeignKeyConstraint,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ForeignKeyConstraint.cs,CheckConstraint,Cyclomatic complexity of the method is 11
Complex Method,System.Data,ForeignKeyConstraint,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ForeignKeyConstraint.cs,Clone,Cyclomatic complexity of the method is 9
Complex Method,System.Data,Merger,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Merger.cs,MergeDataSet,Cyclomatic complexity of the method is 15
Complex Method,System.Data,Merger,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Merger.cs,MergeTable,Cyclomatic complexity of the method is 8
Complex Method,System.Data,Merger,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Merger.cs,MergeRows,Cyclomatic complexity of the method is 14
Complex Method,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetIndexOfPageWithFreeSlot,Cyclomatic complexity of the method is 8
Complex Method,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,RBInsert,Cyclomatic complexity of the method is 10
Complex Method,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,RBDeleteX,Cyclomatic complexity of the method is 31
Complex Method,System.Data,Select,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Select.cs,SelectRows,Cyclomatic complexity of the method is 10
Complex Method,System.Data,Select,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Select.cs,Eval,Cyclomatic complexity of the method is 12
Complex Method,System.Data,SimpleType,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SimpleType.cs,LoadTypeValues,Cyclomatic complexity of the method is 19
Complex Method,System.Data,SimpleType,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SimpleType.cs,ToNode,Cyclomatic complexity of the method is 9
Complex Method,System.Data,ExpressionParser,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\ExpressionParser.cs,ScanNumeric,Cyclomatic complexity of the method is 8
Complex Method,System.Data,LookupNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\LookupNode.cs,Bind,Cyclomatic complexity of the method is 9
Complex Method,System.Data,AggregateNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\AggregateNode.cs,Eval,Cyclomatic complexity of the method is 8
Complex Method,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,Optimize,Cyclomatic complexity of the method is 10
Complex Method,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,ResultType,Cyclomatic complexity of the method is 20
Complex Method,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,ResultSqlType,Cyclomatic complexity of the method is 28
Complex Method,System.Data,LikeNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,Eval,Cyclomatic complexity of the method is 9
Complex Method,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,SchemaMapping,Cyclomatic complexity of the method is 9
Complex Method,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,GetMappedValues,Cyclomatic complexity of the method is 9
Complex Method,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,SetupSchemaWithoutKeyInfo,Cyclomatic complexity of the method is 19
Complex Method,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,SetupSchemaWithKeyInfo,Cyclomatic complexity of the method is 38
Complex Method,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,AddAdditionalProperties,Cyclomatic complexity of the method is 12
Complex Method,System.Data.SqlTypes,SqlChars,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLChars.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,CalculatePrecision,Cyclomatic complexity of the method is 9
Complex Method,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,Cyclomatic complexity of the method is 12
Complex Method,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,Parse,Cyclomatic complexity of the method is 17
Complex Method,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,Round,Cyclomatic complexity of the method is 10
Complex Method,System.Data.SqlTypes,SqlBytes,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLBytes.cs,Read,Cyclomatic complexity of the method is 9
Long Parameter List,System.Data.Common,DataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataAdapter.cs,FillSchemaFromReader,The method has 5 parameters. Parameters: dataset' datatable' schemaType' srcTable' dataReader
Long Parameter List,System.Data.Common,DataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataAdapter.cs,Fill,The method has 5 parameters. Parameters: dataSet' srcTable' dataReader' startRecord' maxRecords
Long Parameter List,System.Data.Common,DataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataAdapter.cs,FillFromReader,The method has 8 parameters. Parameters: dataset' datatable' srcTable' dataReader' startRecord' maxRecords' parentChapterColumn' parentChapterValue
Long Parameter List,System.Data.Common,DataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataAdapter.cs,FillMappingInternal,The method has 7 parameters. Parameters: dataset' datatable' srcTable' dataReader' schemaCount' parentChapterColumn' parentChapterValue
Long Parameter List,System.Data.Common,DataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataAdapter.cs,FillMapping,The method has 7 parameters. Parameters: dataset' datatable' srcTable' dataReader' schemaCount' parentChapterColumn' parentChapterValue
Long Parameter List,System.Data.Common,DataColumnMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataColumnMapping.cs,GetDataColumnBySchemaAction,The method has 5 parameters. Parameters: sourceColumn' dataSetColumn' dataTable' dataType' schemaAction
Long Parameter List,System.Data.Common,DataColumnMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataColumnMapping.cs,CreateDataColumnBySchemaAction,The method has 5 parameters. Parameters: sourceColumn' dataSetColumn' dataTable' dataType' schemaAction
Long Parameter List,System.Data.Common,DataColumnMappingCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataColumnMappingCollection.cs,GetDataColumn,The method has 6 parameters. Parameters: columnMappings' sourceColumn' dataType' dataTable' mappingAction' schemaAction
Long Parameter List,System.Data.Common,DataRecordInternal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataRecordInternal.cs,GetBytes,The method has 5 parameters. Parameters: i' dataIndex' buffer' bufferIndex' length
Long Parameter List,System.Data.Common,DataRecordInternal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataRecordInternal.cs,GetChars,The method has 5 parameters. Parameters: i' dataIndex' buffer' bufferIndex' length
Long Parameter List,System.Data.Common,DataStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataStorage.cs,DataStorage,The method has 5 parameters. Parameters: column' type' defaultValue' nullValue' storageType
Long Parameter List,System.Data.Common,DataStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataStorage.cs,DataStorage,The method has 6 parameters. Parameters: column' type' defaultValue' nullValue' isICloneable' storageType
Long Parameter List,System.Data.Common,DataStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataStorage.cs,ImplementsInterfaces,The method has 7 parameters. Parameters: typeCode' dataType' sqlType' nullable' xmlSerializable' changeTracking' revertibleChangeTracking
Long Parameter List,System.Data.Common,DataTableMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataTableMapping.cs,GetDataColumn,The method has 5 parameters. Parameters: sourceColumn' dataType' dataTable' mappingAction' schemaAction
Long Parameter List,System.Data.Common,DbCommandBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DBCommandBuilder.cs,BuildWhereClause,The method has 6 parameters. Parameters: mappings' dataRow' builder' command' parameterCount' isUpdate
Long Parameter List,System.Data.Common,DbCommandBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DBCommandBuilder.cs,CreateParameterForNullTest,The method has 9 parameters. Parameters: command' parameterName' sourceColumn' version' parameterCount' value' row' statementType' whereClause
Long Parameter List,System.Data.Common,DbCommandBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DBCommandBuilder.cs,CreateParameterForValue,The method has 9 parameters. Parameters: command' parameterName' sourceColumn' version' parameterCount' value' row' statementType' whereClause
Long Parameter List,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,GetKeyValuePair,The method has 6 parameters. Parameters: connectionString' currentPosition' buffer' useOdbcRules' keyname' keyvalue
Long Parameter List,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,ParseComparison,The method has 5 parameters. Parameters: parsetable' connectionString' synonyms' firstKey' e
Long Parameter List,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,ParseInternal,The method has 5 parameters. Parameters: parsetable' connectionString' buildChain' synonyms' firstKey
Long Parameter List,System.Data.Common,DbConnectionStringBuilderDescriptor,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionStringBuilderDescriptor.cs,DbConnectionStringBuilderDescriptor,The method has 5 parameters. Parameters: propertyName' componentType' propertyType' isReadOnly' attributes
Long Parameter List,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,FillSchema,The method has 5 parameters. Parameters: dataSet' schemaType' command' srcTable' behavior
Long Parameter List,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,FillSchemaInternal,The method has 6 parameters. Parameters: dataset' datatable' schemaType' command' srcTable' behavior
Long Parameter List,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,Fill,The method has 6 parameters. Parameters: dataSet' startRecord' maxRecords' srcTable' command' behavior
Long Parameter List,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,Fill,The method has 5 parameters. Parameters: dataTables' startRecord' maxRecords' command' behavior
Long Parameter List,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,FillInternal,The method has 7 parameters. Parameters: dataset' datatables' startRecord' maxRecords' srcTable' command' behavior
Long Parameter List,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,ParameterOutput,The method has 5 parameters. Parameters: parameter' row' mappings' missingMapping' missingSchema
Long Parameter List,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,UpdateConnectionOpen,The method has 5 parameters. Parameters: connection' statementType' connections' connectionStates' useSelectConnectionState
Long Parameter List,System.Data.Common,DbDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataReader.cs,GetBytes,The method has 5 parameters. Parameters: ordinal' dataOffset' buffer' bufferOffset' length
Long Parameter List,System.Data.Common,DbDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataReader.cs,GetChars,The method has 5 parameters. Parameters: ordinal' dataOffset' buffer' bufferOffset' length
Long Parameter List,System.Data.Common,DbDataRecord,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataRecord.cs,GetBytes,The method has 5 parameters. Parameters: i' dataIndex' buffer' bufferIndex' length
Long Parameter List,System.Data.Common,DbDataRecord,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataRecord.cs,GetChars,The method has 5 parameters. Parameters: i' dataIndex' buffer' bufferIndex' length
Long Parameter List,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The method has 5 parameters. Parameters: name' leftQuote' rightQuote' property' ThrowOnEmptyMultipartName
Long Parameter List,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The method has 8 parameters. Parameters: name' leftQuote' rightQuote' separator' limit' removequotes' property' ThrowOnEmptyMultipartName
Long Parameter List,System.Xml,XPathNodePointer,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XPathNodePointer.cs,XPathNodePointer,The method has 6 parameters. Parameters: owner' doc' node' c' bOnValue' parentOfNS
Long Parameter List,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,SchemaTree,The method has 5 parameters. Parameters: xd' xmlWriter' ds' dt' writeHierarchy
Long Parameter List,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,Save,The method has 5 parameters. Parameters: ds' dt' xw' writeHierarchy' multipleTargetConverter
Long Parameter List,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleSimpleTypeSimpleContentColumn,The method has 6 parameters. Parameters: typeNode' strType' table' isBase' attrs' isNillable
Long Parameter List,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleSimpleContentColumn,The method has 5 parameters. Parameters: strType' table' isBase' attrs' isNillable
Long Parameter List,System.Data,DataRelation,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRelation.cs,DataRelation,The method has 6 parameters. Parameters: relationName' parentTableName' childTableName' parentColumnNames' childColumnNames' nested
Long Parameter List,System.Data,DataRelation,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRelation.cs,DataRelation,The method has 8 parameters. Parameters: relationName' parentTableName' parentTableNamespace' childTableName' childTableNamespace' parentColumnNames' childColumnNames' nested
Long Parameter List,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,RecordStateChanged,The method has 6 parameters. Parameters: record1' oldState1' newState1' record2' oldState2' newState2
Long Parameter List,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SetNewRecord,The method has 6 parameters. Parameters: row' proposedRecord' action' isInMerge' fireEvent' suppressEnsurePropertyChanged
Long Parameter List,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SetNewRecordWorker,The method has 8 parameters. Parameters: row' proposedRecord' action' isInMerge' suppressEnsurePropertyChanged' position' fireEvent' deferredException
Long Parameter List,System.Data,DataTableReader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableReader.cs,GetBytes,The method has 5 parameters. Parameters: ordinal' dataIndex' buffer' bufferIndex' length
Long Parameter List,System.Data,DataTableReader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableReader.cs,GetChars,The method has 5 parameters. Parameters: ordinal' dataIndex' buffer' bufferIndex' length
Long Parameter List,System.Data,ForeignKeyConstraint,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ForeignKeyConstraint.cs,ForeignKeyConstraint,The method has 7 parameters. Parameters: constraintName' parentTableName' parentColumnNames' childColumnNames' acceptRejectRule' deleteRule' updateRule
Long Parameter List,System.Data,ForeignKeyConstraint,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ForeignKeyConstraint.cs,ForeignKeyConstraint,The method has 8 parameters. Parameters: constraintName' parentTableName' parentTableNamespace' parentColumnNames' childColumnNames' acceptRejectRule' deleteRule' updateRule
Long Parameter List,System.Data,IDataRecord,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\IDataRecord.cs,GetBytes,The method has 5 parameters. Parameters: i' fieldOffset' buffer' bufferoffset' length
Long Parameter List,System.Data,IDataRecord,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\IDataRecord.cs,GetChars,The method has 5 parameters. Parameters: i' fieldoffset' buffer' bufferoffset' length
Long Parameter List,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,RBInsert,The method has 5 parameters. Parameters: root_id' x_id' mainTreeNodeID' position' append
Long Parameter List,System.Data,Index,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Selection.cs,Index,The method has 5 parameters. Parameters: table' indexFields' comparison' recordStates' rowFilter
Long Parameter List,System.Data,Index,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Selection.cs,RecordStateChanged,The method has 6 parameters. Parameters: oldRecord' oldOldState' oldNewState' newRecord' newOldState' newNewState
Long Parameter List,System.Data,DataCommonEventSource,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataCommonEventSource.cs,Trace,The method has 5 parameters. Parameters: format' arg0' arg1' arg2' arg3
Long Parameter List,System.Data,DataCommonEventSource,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataCommonEventSource.cs,Trace,The method has 6 parameters. Parameters: format' arg0' arg1' arg2' arg3' arg4
Long Parameter List,System.Data,DataCommonEventSource,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataCommonEventSource.cs,Trace,The method has 8 parameters. Parameters: format' arg0' arg1' arg2' arg3' arg4' arg5' arg6
Long Parameter List,System.Data,DataCommonEventSource,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataCommonEventSource.cs,EnterScope,The method has 5 parameters. Parameters: format' arg1' arg2' arg3' arg4
Long Parameter List,System.Data,Function,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,Function,The method has 9 parameters. Parameters: name' id' result' IsValidateArguments' IsVariantArgumentList' argumentCount' a1' a2' a3
Long Parameter List,System.Data,AggregateNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\AggregateNode.cs,AggregateNode,The method has 5 parameters. Parameters: table' aggregateType' columnName' local' relationName
Long Parameter List,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,BinaryCompare,The method has 5 parameters. Parameters: vLeft' vRight' resultType' op' comparer
Long Parameter List,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The method has 6 parameters. Parameters: op' left' right' row' version' recordNos
Long Parameter List,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,ResultType,The method has 5 parameters. Parameters: left' right' lc' rc' op
Long Parameter List,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,ResultSqlType,The method has 5 parameters. Parameters: left' right' lc' rc' op
Long Parameter List,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,SchemaMapping,The method has 10 parameters. Parameters: adapter' dataset' datatable' dataReader' keyInfo' schemaType' sourceTableName' gettingData' parentChapterColumn' parentChapterValue
Long Parameter List,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,SetupSchemaWithoutKeyInfo,The method has 5 parameters. Parameters: mappingAction' schemaAction' gettingData' parentChapterColumn' chapterValue
Long Parameter List,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,SetupSchemaWithKeyInfo,The method has 5 parameters. Parameters: mappingAction' schemaAction' gettingData' parentChapterColumn' chapterValue
Long Parameter List,System.Data.SqlTypes,SqlDateTime,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDateTime.cs,SqlDateTime,The method has 6 parameters. Parameters: year' month' day' hour' minute' second
Long Parameter List,System.Data.SqlTypes,SqlDateTime,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDateTime.cs,SqlDateTime,The method has 7 parameters. Parameters: year' month' day' hour' minute' second' millisecond
Long Parameter List,System.Data.SqlTypes,SqlDateTime,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDateTime.cs,SqlDateTime,The method has 7 parameters. Parameters: year' month' day' hour' minute' second' bilisecond
Long Parameter List,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The method has 7 parameters. Parameters: bPrecision' bScale' fPositive' data1' data2' data3' data4
Long Parameter List,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The method has 5 parameters. Parameters: rglData' bLen' bPrec' bScale' fPositive
Long Parameter List,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,MpDiv,The method has 8 parameters. Parameters: rgulU' ciulU' rgulD' ciulD' rgulQ' ciulQ' rgulR' ciulR
Long Parameter List,System.Data.SqlTypes,SqlGuid,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLGuid.cs,SqlGuid,The method has 11 parameters. Parameters: a' b' c' d' e' f' g' h' i' j' k
Long Parameter List,System.Data.SqlTypes,SqlString,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLString.cs,SqlString,The method has 6 parameters. Parameters: lcid' compareOptions' data' index' count' fUnicode
Long Parameter List,System.Data.SqlTypes,SqlString,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLString.cs,SqlString,The method has 5 parameters. Parameters: lcid' compareOptions' data' index' count
Long Identifier,System.Data.Common,DataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataAdapter.cs,,The length of the parameter _acceptChangesDuringUpdateAfterInsert is 37.
Long Identifier,System.Data.Common,DataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataAdapter.cs,,The length of the parameter _debugHookNonEmptySelectCommand is 31.
Long Identifier,System.Data.Common,ParameterNames,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DBCommandBuilder.cs,,The length of the parameter _adjustedParameterNameMaxLength is 31.
Long Identifier,System.Data.Common,DbConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnection.cs,,The length of the parameter _suppressStateChangeForReconnection is 35.
Long Identifier,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,ParseComparison,The length of the parameter KeywordNotSupportedMessagePrefix is 32.
Long Identifier,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,,The length of the parameter ConnectionStringValidKeyPattern is 31.
Long Identifier,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,,The length of the parameter ConnectionStringValidValuePattern is 33.
Long Identifier,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,,The length of the parameter ConnectionStringQuoteValuePattern is 33.
Long Identifier,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,,The length of the parameter ConnectionStringQuoteOdbcValuePattern is 37.
Long Identifier,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,,The length of the parameter s_connectionStringValidKeyRegex is 31.
Long Identifier,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,,The length of the parameter s_connectionStringValidValueRegex is 33.
Long Identifier,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,,The length of the parameter s_connectionStringQuoteValueRegex is 33.
Long Identifier,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,,The length of the parameter s_connectionStringQuoteOdbcValueRegex is 37.
Long Identifier,System.Data.Common,DbMetaDataColumnNames,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbMetaDataColumnNames.cs,,The length of the parameter CompositeIdentifierSeparatorPattern is 35.
Long Identifier,System.Data.Common,DbMetaDataColumnNames,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbMetaDataColumnNames.cs,,The length of the parameter DataSourceProductVersionNormalized is 34.
Long Identifier,System.Data.Common,DbProviderFactories,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbProviderFactories.cs,RegisterFactory,The length of the parameter factoryTypeAssemblyQualifiedName is 32.
Long Identifier,System.Data.Common,DbProviderFactories,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbProviderFactories.cs,,The length of the parameter AssemblyQualifiedNameColumnName is 31.
Long Identifier,System.Data.Common,ProviderRegistration,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbProviderFactories.cs,ProviderRegistration,The length of the parameter factoryTypeAssemblyQualifiedName is 32.
Long Identifier,System.Data.Common,DbProviderSpecificTypePropertyAttribute,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbProviderSpecificTypePropertyAttribute.cs,DbProviderSpecificTypePropertyAttribute,The length of the parameter isProviderSpecificTypeProperty is 30.
Long Identifier,System.Data.Common,ObjectStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\ObjectStorage.cs,ConvertXmlToObject,The length of the parameter deserializerWithOutRootAttribute is 32.
Long Identifier,System.Data.Common,ObjectStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\ObjectStorage.cs,ConvertObjectToXml,The length of the parameter serializerWithOutRootAttribute is 30.
Long Identifier,System.Data.Common,SqlUdtStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SqlUDTStorage.cs,ConvertXmlToObject,The length of the parameter deserializerWithOutRootAttribute is 32.
Long Identifier,System.Data.Common,SqlUdtStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SqlUDTStorage.cs,ConvertObjectToXml,The length of the parameter serializerWithOutRootAttribute is 30.
Long Identifier,System.Xml,XPathNodePointer,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XPathNodePointer.cs,,The length of the parameter s_xmlNodeType_To_XpathNodeType_Map is 34.
Long Identifier,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,SchemaTree,The length of the parameter isMultipleNamespaceAndStreamingWriter is 37.
Long Identifier,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleDataSet,The length of the parameter isComplexTypeOrValidElementType is 31.
Long Identifier,System.Data,ConstraintCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ConstraintCollection.cs,,The length of the parameter _fLoadForeignKeyConstraintsOnly is 31.
Long Identifier,System.Data,DataColumn,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataColumn.cs,,The length of the parameter _implementsIRevertibleChangeTracking is 36.
Long Identifier,System.Data,DataColumnCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataColumnCollection.cs,,The length of the parameter _columnsImplementingIChangeTracking is 35.
Long Identifier,System.Data,DataColumnCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataColumnCollection.cs,,The length of the parameter _nColumnsImplementingIChangeTracking is 36.
Long Identifier,System.Data,DataColumnCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataColumnCollection.cs,,The length of the parameter _nColumnsImplementingIRevertibleChangeTracking is 46.
Long Identifier,System.Data,DataRowView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRowView.cs,,The length of the parameter s_zeroPropertyDescriptorCollection is 34.
Long Identifier,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,,The length of the parameter _propertyDescriptorCollectionCache is 34.
Long Identifier,System.Data.SqlTypes,SqlXml,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SqlXml.cs,CreateSqlXmlReader,The length of the parameter throwTargetInvocationExceptions is 31.
Long Identifier,System.Data.SqlTypes,SqlXml,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SqlXml.cs,,The length of the parameter s_defaultXmlReaderSettingsCloseInput is 36.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,ColumnSchemaMismatch,The length of the statement  "            return DataMapping(SR.Format(SR.ADP_ColumnSchemaMismatch' srcColumn' srcType.Name' column.ColumnName' column.DataType.Name)); " is 125.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,ColumnsDataSetColumn,The length of the statement  "            return CollectionIndexString(typeof(DataColumnMapping)' ADP.DataSetColumn' cacheColumn' typeof(DataColumnMappingCollection)); " is 125.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,ColumnsIndexSource,The length of the statement  "            return CollectionIndexString(typeof(DataColumnMapping)' ADP.SourceColumn' srcColumn' typeof(DataColumnMappingCollection)); " is 122.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,TablesDataSetTable,The length of the statement  "            return CollectionIndexString(typeof(DataTableMapping)' ADP.DataSetTable' cacheTable' typeof(DataTableMappingCollection)); " is 121.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,UpdateConcurrencyViolation,The length of the statement  "            DBConcurrencyException exception = new DBConcurrencyException(SR.Format(resource' affected.ToString(CultureInfo.InvariantCulture)' expected.ToString(CultureInfo.InvariantCulture))' null' dataRows); " is 197.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,RemoveStringQuotes,The length of the statement  "                unquotedString = quotedString.Substring(prefixLength' quotedStringLength - (prefixLength + suffixLength)).Replace(quoteSuffix + quoteSuffix' quoteSuffix); " is 154.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,InvalidEnumerationValue,The length of the statement  "            return ArgumentOutOfRange(SR.Format(SR.ADP_InvalidEnumerationValue' type.Name' value.ToString(CultureInfo.InvariantCulture))' type.Name); " is 137.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,CollectionIndexInt32,The length of the statement  "            return IndexOutOfRange(SR.Format(SR.ADP_CollectionIndexInt32' index.ToString(CultureInfo.InvariantCulture)' collection.Name' count.ToString(CultureInfo.InvariantCulture))); " is 172.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,CollectionIndexString,The length of the statement  "            return IndexOutOfRange(SR.Format(SR.ADP_CollectionIndexString' itemType.Name' propertyName' propertyValue' collection.Name)); " is 125.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,CollectionInvalidType,The length of the statement  "            return InvalidCast(SR.Format(SR.ADP_CollectionInvalidType' collection.Name' itemType.Name' invalidValue.GetType().Name)); " is 121.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,InvalidSourceBufferIndex,The length of the statement  "            return ArgumentOutOfRange(SR.Format(SR.ADP_InvalidSourceBufferIndex' maxLen.ToString(CultureInfo.InvariantCulture)' srcOffset.ToString(CultureInfo.InvariantCulture))' parameterName); " is 182.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,InvalidDestinationBufferIndex,The length of the statement  "            return ArgumentOutOfRange(SR.Format(SR.ADP_InvalidDestinationBufferIndex' maxLen.ToString(CultureInfo.InvariantCulture)' dstOffset.ToString(CultureInfo.InvariantCulture))' parameterName); " is 187.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,InvalidBufferSizeOrIndex,The length of the statement  "            return IndexOutOfRange(SR.Format(SR.SQL_InvalidBufferSizeOrIndex' numBytes.ToString(CultureInfo.InvariantCulture)' bufferIndex.ToString(CultureInfo.InvariantCulture))); " is 168.
Long Statement,System.Data.Common,CharStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\CharStorage.cs,Set,The length of the statement  "                if ((ch >= (char)0xd800 && ch <= (char)0xdfff) || (ch < (char)0x21 && (ch == (char)0x9 || ch == (char)0xa || ch == (char)0xd))) " is 127.
Long Statement,System.Data.Common,DataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataAdapter.cs,AssertReaderHandleFieldCount,The length of the statement  "            Debug.Assert(!_debugHookNonEmptySelectCommand || readerHandler.FieldCount > 0' "Scenario expects non-empty results but no fields reported by reader"); " is 150.
Long Statement,System.Data.Common,DataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataAdapter.cs,AssertSchemaMapping,The length of the statement  "                Debug.Assert(mapping != null && mapping.DataValues != null && mapping.DataTable != null' "Debug hook specifies that non-empty results are not expected"); " is 153.
Long Statement,System.Data.Common,DataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataAdapter.cs,CloneInternals,The length of the statement  "            DataAdapter clone = (DataAdapter)Activator.CreateInstance(GetType()' System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance' null' null' CultureInfo.InvariantCulture' null); " is 198.
Long Statement,System.Data.Common,DataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataAdapter.cs,FillSchema,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<comm.DataAdapter.FillSchema|API> {0}' dataSet' schemaType={1}' srcTable' dataReader"' ObjectID' schemaType); " is 165.
Long Statement,System.Data.Common,DataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataAdapter.cs,FillSchema,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<comm.DataAdapter.FillSchema|API> {0}' dataTable' schemaType' dataReader"' ObjectID); " is 141.
Long Statement,System.Data.Common,DataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataAdapter.cs,FillSchemaFromReader,The length of the statement  "                SchemaMapping mapping = new SchemaMapping(this' dataset' datatable' readerHandler' true' schemaType' tmp' false' null' null); " is 125.
Long Statement,System.Data.Common,DataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataAdapter.cs,Fill,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<comm.DataAdapter.Fill|API> {0}' dataSet' srcTable' dataReader' startRecord' maxRecords"' ObjectID); " is 156.
Long Statement,System.Data.Common,DataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataAdapter.cs,Fill,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<comm.DataAdapter.Fill|API> {0}' dataTables[]' dataReader' startRecord' maxRecords"' ObjectID); " is 151.
Long Statement,System.Data.Common,DataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataAdapter.cs,FillFromReader,The length of the statement  "                SchemaMapping mapping = FillMapping(dataset' datatable' srcTable' dataReader' schemaCount' parentChapterColumn' parentChapterValue); " is 132.
Long Statement,System.Data.Common,DataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataAdapter.cs,FillMappingInternal,The length of the statement  "            return new SchemaMapping(this' dataset' datatable' dataReader' withKeyInfo' SchemaType.Mapped' tmp' true' parentChapterColumn' parentChapterValue); " is 147.
Long Statement,System.Data.Common,DataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataAdapter.cs,FillMapping,The length of the statement  "                    mapping = FillMappingInternal(dataset' datatable' srcTable' dataReader' schemaCount' parentChapterColumn' parentChapterValue); " is 126.
Long Statement,System.Data.Common,DataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataAdapter.cs,FillMapping,The length of the statement  "                mapping = FillMappingInternal(dataset' datatable' srcTable' dataReader' schemaCount' parentChapterColumn' parentChapterValue); " is 126.
Long Statement,System.Data.Common,DataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataAdapter.cs,GetTableMappingBySchemaAction,The length of the statement  "            return DataTableMappingCollection.GetTableMappingBySchemaAction(_tableMappings' sourceTableName' dataSetTableName' mappingAction); " is 130.
Long Statement,System.Data.Common,DataColumnMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataColumnMapping.cs,GetDataColumnBySchemaAction,The length of the statement  "                    Debug.WriteLine("schema mismatch on DataColumn \"" + dataSetColumn + "\" " + dataType.Name + " != " + dataColumn.DataType.Name); " is 128.
Long Statement,System.Data.Common,DataColumnMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataColumnMapping.cs,CreateDataColumnBySchemaAction,The length of the statement  "                        Debug.WriteLine("schema add of DataColumn \"" + dataSetColumn + "\" <" + Convert.ToString(dataType' CultureInfo.InvariantCulture) + ">"); " is 137.
Long Statement,System.Data.Common,DataColumnMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataColumnMapping.cs,CreateDataColumnBySchemaAction,The length of the statement  "                        Debug.WriteLine("schema filter of DataColumn \"" + dataSetColumn + "\" <" + Convert.ToString(dataType' CultureInfo.InvariantCulture) + ">"); " is 140.
Long Statement,System.Data.Common,DataColumnMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataColumnMapping.cs,CreateDataColumnBySchemaAction,The length of the statement  "                        Debug.WriteLine("schema error on DataColumn \"" + dataSetColumn + "\" <" + Convert.ToString(dataType' CultureInfo.InvariantCulture) + ">"); " is 139.
Long Statement,System.Data.Common,DataStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataStorage.cs,ImplementsInterfaces,The length of the statement  "            Debug.Assert(changeTracking == typeof(System.ComponentModel.IChangeTracking).IsAssignableFrom(dataType)' "IChangeTracking"); " is 124.
Long Statement,System.Data.Common,DataStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataStorage.cs,ImplementsInterfaces,The length of the statement  "            Debug.Assert(revertibleChangeTracking == typeof(System.ComponentModel.IRevertibleChangeTracking).IsAssignableFrom(dataType)' "IRevertibleChangeTracking"); " is 154.
Long Statement,System.Data.Common,DataStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataStorage.cs,ImplementsINullableValue,The length of the statement  "            return ((StorageType.Empty == typeCode) && dataType.IsGenericType && (dataType.GetGenericTypeDefinition() == typeof(System.Nullable<>))); " is 137.
Long Statement,System.Data.Common,DataTableMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataTableMapping.cs,GetDataColumn,The length of the statement  "            return DataColumnMappingCollection.GetDataColumn(_columnMappings' sourceColumn' dataType' dataTable' mappingAction' schemaAction); " is 130.
Long Statement,System.Data.Common,DateTimeStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DateTimeStorage.cs,SetStorage,The length of the statement  "                        _values[i] = DateTime.SpecifyKind(_values[i].ToLocalTime()' DateTimeKind.Unspecified); //Strip the kind for UnspecifiedLocal. " is 125.
Long Statement,System.Data.Common,DbCommandBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DBCommandBuilder.cs,CreateParameterForNullTest,The length of the statement  "                Debug.Assert(null != _parameterMarkerFormat' "How can we have a _parameterNames collection but no _parameterMarkerFormat?"); " is 124.
Long Statement,System.Data.Common,DbCommandBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DBCommandBuilder.cs,CreateParameterForValue,The length of the statement  "                Debug.Assert(null != _parameterMarkerFormat' "How can we have a _parameterNames collection but no _parameterMarkerFormat?"); " is 124.
Long Statement,System.Data.Common,DbCommandBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DBCommandBuilder.cs,RowUpdatingHandlerBuilder,The length of the statement  "            // the Update method will close the connection if command was null and returned command.Connection is same as SelectCommand.Connection " is 134.
Long Statement,System.Data.Common,ParameterNames,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DBCommandBuilder.cs,EliminateConflictingNames,The length of the statement  "                                Debug.Assert(_isMutatedName[iMutatedName]' string.Format(CultureInfo.InvariantCulture' "{0} expected to be a mutated name"' _baseParameterNames[iMutatedName])); " is 160.
Long Statement,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,AppendKeyValuePairBuilder,The length of the statement  "                        (('{' == keyValue[0]) || (0 <= keyValue.IndexOf(';')) || (0 == string.Compare(DbConnectionStringKeywords.Driver' keyName' StringComparison.OrdinalIgnoreCase))) && " is 162.
Long Statement,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,DebugTraceKeyValuePair,The length of the statement  "                    DataCommonEventSource.Log.Trace("<comm.DbConnectionOptions|INFO|ADV> KeyName='{0}'' KeyValue='{1}'"' keyname' keyvalue); " is 120.
Long Statement,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,IsKeyNameValid,The length of the statement  "                Debug.Assert(((0 < keyname.Length) && (';' != keyname[0]) && !Char.IsWhiteSpace(keyname[0]) && (-1 == keyname.IndexOf('\u0000'))) == compValue' "IsValueValid mismatch with regex"); " is 180.
Long Statement,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,IsKeyNameValid,The length of the statement  "                return ((0 < keyname.Length) && (';' != keyname[0]) && !Char.IsWhiteSpace(keyname[0]) && (-1 == keyname.IndexOf('\u0000'))); " is 124.
Long Statement,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,ParseComparison,The length of the statement  "                            if (msg1.StartsWith(KeywordNotSupportedMessagePrefix' StringComparison.Ordinal) || msg1.StartsWith(WrongFormatMessagePrefix' StringComparison.Ordinal)) " is 151.
Long Statement,System.Data.Common,DbConnectionStringBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionStringBuilder.cs,EquivalentTo,The length of the statement  "            DataCommonEventSource.Log.Trace("<comm.DbConnectionStringBuilder.EquivalentTo|API> {0}' connectionStringBuilder={1}"' ObjectID' connectionStringBuilder.ObjectID); " is 162.
Long Statement,System.Data.Common,DbConnectionStringBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionStringBuilder.cs,EquivalentTo,The length of the statement  "            if ((GetType() != connectionStringBuilder.GetType()) || (CurrentValues.Count != connectionStringBuilder.CurrentValues.Count)) " is 125.
Long Statement,System.Data.Common,DbConnectionStringBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionStringBuilder.cs,GetProperties,The length of the statement  "                long logScopeId = DataCommonEventSource.Log.EnterScope("<comm.DbConnectionStringBuilder.GetProperties|INFO> {0}"' ObjectID); " is 124.
Long Statement,System.Data.Common,DbConnectionStringBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionStringBuilder.cs,GetProperties,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<comm.DbConnectionStringBuilder.GetProperties|API> {0}"' ObjectID); " is 123.
Long Statement,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,FillSchema,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<comm.DbDataAdapter.FillSchema|API> {0}' dataTable' schemaType={1}"' ObjectID' schemaType); " is 147.
Long Statement,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,FillSchema,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<comm.DbDataAdapter.FillSchema|API> {0}' dataSet' schemaType={1}"' ObjectID' schemaType); " is 145.
Long Statement,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,FillSchema,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<comm.DbDataAdapter.FillSchema|API> {0}' dataSet' schemaType={1}' srcTable={2}"' ObjectID' (int)schemaType' srcTable); " is 174.
Long Statement,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,FillSchema,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<comm.DbDataAdapter.FillSchema|API> {0}' dataSet' schemaType' command' srcTable' behavior={1}"' ObjectID' behavior); " is 172.
Long Statement,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,FillSchema,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<comm.DbDataAdapter.FillSchema|API> {0}' dataTable' schemaType' command' behavior={1}"' ObjectID' behavior); " is 164.
Long Statement,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,FillSchema,The length of the statement  "                return (DataTable)FillSchemaInternal(null' dataTable' schemaType' command' srcTableName' behavior | CommandBehavior.SingleResult); " is 130.
Long Statement,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,Fill,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<comm.DbDataAdapter.Fill|API> {0}' dataSet' srcTable='{1}'"' ObjectID' srcTable); " is 137.
Long Statement,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,Fill,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<comm.DbDataAdapter.Fill|API> {0}' dataSet' startRecord={1}' maxRecords={2}' srcTable='{3}'"' ObjectID' startRecord' maxRecords' srcTable); " is 195.
Long Statement,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,Fill,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<comm.DbDataAdapter.Fill|API> {0}' dataSet' startRecord' maxRecords' srcTable' command' behavior={1}"' ObjectID' behavior); " is 179.
Long Statement,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,Fill,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<comm.DbDataAdapter.Fill|API> {0}' startRecord={1}' maxRecords={2}' dataTable[]"' ObjectID' startRecord' maxRecords); " is 173.
Long Statement,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,Fill,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<comm.DbDataAdapter.Fill|API> {0}' dataTable' command' behavior={1}"' ObjectID' behavior); " is 146.
Long Statement,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,Fill,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<comm.DbDataAdapter.Fill|API> {0}' dataTables[]' startRecord' maxRecords' command' behavior={1}"' ObjectID' behavior); " is 174.
Long Statement,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,Update,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<comm.DbDataAdapter.Update|API> {0}' dataSet' srcTable='{1}'"' ObjectID' srcTable); " is 139.
Long Statement,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,Update,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<comm.DbDataAdapter.Update|API> {0}' dataRows[]' tableMapping"' ObjectID); " is 130.
Long Statement,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,Update,The length of the statement  "                                    ConnectionState state = UpdateConnectionOpen(connection' StatementType.Batch' connections' connectionStates' useSelectConnectionState); " is 135.
Long Statement,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,Update,The length of the statement  "                                    ConnectionState state = UpdateConnectionOpen(connection' statementType' connections' connectionStates' useSelectConnectionState); " is 129.
Long Statement,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,Update,The length of the statement  "                                ConnectionState state = UpdateConnectionOpen(connection' StatementType.Batch' connections' connectionStates' useSelectConnectionState); " is 135.
Long Statement,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,UpdateBatchExecute,The length of the statement  "                            batchCommands[bc]._errors = ADP.UpdateConcurrencyViolation(batchCommands[bc]._statementType' 0' 1' new DataRow[] { rowUpdatedEvent.Rows[bc] }); " is 143.
Long Statement,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,UpdateBatchExecute,The length of the statement  "                        rowUpdatedEvent.Errors = ADP.UpdateConcurrencyViolation(StatementType.Batch' commandCount - rowsInError.Length' commandCount' rowsInError); " is 139.
Long Statement,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,UpdateRowExecute,The length of the statement  "                            SchemaMapping mapping = new SchemaMapping(this' null' rowUpdatedEvent.Row.Table' readerHandler' false' SchemaType.Mapped' rowUpdatedEvent.TableMapping.SourceTable' true' null' null); " is 182.
Long Statement,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,UpdateRowExecute,The length of the statement  "                                rowUpdatedEvent.Errors = ADP.UpdateConcurrencyViolation(cmdIndex' rowUpdatedEvent.RecordsAffected' 1' new DataRow[] { rowUpdatedEvent.Row }); " is 141.
Long Statement,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,UpdatedRowStatusContinue,The length of the statement  "                if ((null == batchCommands[i]._errors) && batchCommands[i]._recordsAffected.HasValue && (0 != batchCommands[i]._recordsAffected.Value)) " is 135.
Long Statement,System.Data.Common,DbProviderFactories,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbProviderFactories.cs,GetFactoryClasses,The length of the statement  "            DataColumn assemblyQualifiedNameColumn = new DataColumn(AssemblyQualifiedNameColumnName' typeof(string)) { ReadOnly = true }; " is 125.
Long Statement,System.Data.Common,DbProviderFactories,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbProviderFactories.cs,RegisterFactory,The length of the statement  "            // this method performs a deferred registration: the type name specified is checked when the factory is requested for the first time.  " is 133.
Long Statement,System.Data.Common,DbProviderFactories,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbProviderFactories.cs,RegisterFactory,The length of the statement  "            _registeredFactories[providerInvariantName] = new ProviderRegistration(factory.GetType().AssemblyQualifiedName' factory); " is 121.
Long Statement,System.Data.Common,DbProviderFactories,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbProviderFactories.cs,UnregisterFactory,The length of the statement  "            return !string.IsNullOrWhiteSpace(providerInvariantName) && _registeredFactories.TryRemove(providerInvariantName' out _); " is 121.
Long Statement,System.Data.Common,DbProviderFactories,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbProviderFactories.cs,GetFactory,The length of the statement  "                return throwOnError ? throw ADP.Argument(SR.Format(SR.ADP_DbProviderFactories_InvariantNameNotFound' providerInvariantName)) : (DbProviderFactory)null; " is 151.
Long Statement,System.Data.Common,DbProviderFactories,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbProviderFactories.cs,GetFactory,The length of the statement  "                // Even in the case of throwOnError being false' this will throw when an exception occurs checking the registered type as the user has to be notified the  " is 153.
Long Statement,System.Data.Common,DbProviderFactories,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbProviderFactories.cs,GetFactoryInstance,The length of the statement  "            FieldInfo providerInstance = providerFactoryClass.GetField(InstanceFieldName' BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Static); " is 149.
Long Statement,System.Data.Common,DbSchemaRow,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DBSchemaRow.cs,GetSortedSchemaRows,The length of the statement  "            const DataViewRowState rowStates = DataViewRowState.Unchanged | DataViewRowState.Added | DataViewRowState.ModifiedCurrent; " is 122.
Long Statement,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The length of the statement  "            StringBuilder sb = new StringBuilder(name.Length); // String buffer to hold the string being currently built' init the string builder so it will never be resized " is 161.
Long Statement,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The length of the statement  "            StringBuilder whitespaceSB = null;                  // String buffer to hold whitespace used when parsing nonquoted strings  'a b .  c d' = 'a b' and 'c d' " is 155.
Long Statement,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The length of the statement  "            char rightQuoteChar = ' ';                          // Right quote character to use given the left quote character found. " is 121.
Long Statement,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The length of the statement  "                            {  // If we found a separator' no string was found' initialize the string we are parsing to Empty and the next one to Empty. " is 124.
Long Statement,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The length of the statement  "                               // This is NOT a redundant setting of string.Empty it solves the case where we are parsing ".foo" and we should be returning null' null' empty' foo " is 147.
Long Statement,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The length of the statement  "                                whitespaceSB.Append(testchar);  // start to record the whitespace' if we are parsing a name like "foo bar" we should return "foo bar" " is 133.
Long Statement,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The length of the statement  "                            {                          // It is a whitespace character so the following char should be whitespace' separator' or end of string anything else is bad " is 151.
Long Statement,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The length of the statement  "                // Shuffle the parsed name' from left justification to right justification' i.e. [a][b][null][null] goes to [null][null][a][b] " is 126.
Long Statement,System.Data.Common,ObjectStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\ObjectStorage.cs,ConvertObjectToXml,The length of the statement  "            if ((value == null) || (value == _nullValue))// this case won't happen'  this is added in case if code in xml saver changes " is 123.
Long Statement,System.Data.Common,SqlUdtStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SqlUDTStorage.cs,GetStaticNullForUdtType,The length of the statement  "                System.Reflection.PropertyInfo propInfo = type.GetProperty("Null"' System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static); " is 146.
Long Statement,System.Data.Common,SqlUdtStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SqlUDTStorage.cs,GetStaticNullForUdtType,The length of the statement  "                    System.Reflection.FieldInfo fieldInfo = type.GetField("Null"' System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static); " is 141.
Long Statement,System.Data.Common,SqlStringStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLStringStorage.cs,ConvertObjectToXml,The length of the statement  "            StringWriter strwriter = new StringWriter(FormatProvider); // consider passing cultureinfo with CultureInfo.InvariantCulture " is 124.
Long Statement,System.Xml,TreeIterator,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\TreeIterator.cs,NextRight,The length of the statement  "            // Make sure we do not get past the nodeTop if we call NextRight on a just initialized iterator and nodeTop has no children " is 123.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,Bind,The length of the statement  "            // Do the mapping. This could be a successive mapping in case of this scenario: xd = XmlDataDocument( emptyDataSet ); xd.Load( "file.xml" ); " is 140.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,CreateElement,The length of the statement  "            //  - special listeners ON' no permananent listeners: this is when the data doc was created w/o any dataset' and the 1st time a new row/element " is 143.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,CreateElement,The length of the statement  "            //  - special listeners OFF' permanent listeners ON: this is when the data doc is loaded (from dataset or XML file) and synchronization takes place. " is 148.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,CreateElement,The length of the statement  "            //  - special listeners OFF' permanent listeners OFF: this is then the data doc is LOADING (from dataset or XML file) - the synchronization is done by code' " is 156.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,CreateElement,The length of the statement  "                // Loading state: create just the XmlBoundElement: the LoadTreeFromDataSet/LoadDataSetFromTree will take care of synchronization " is 128.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,CreateElement,The length of the statement  "            // This is the 1st time an element is beeing created on an empty XmlDataDocument - unbind special listeners' bind permanent ones and then go on w/ " is 146.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,FixNestedChildren,The length of the statement  "                    // childElem can be null when we create XML from DataSet (XmlDataDocument( DataSet ) is called) and we insert rowElem of the parentRow before " is 141.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,Foliate,The length of the statement  "            // If we want to strong foliate one of the non-row-elem in a region' then the region MUST be strong-foliated (or there must be no region) " is 137.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,GetTextOnlyColumn,The length of the statement  "                // Make sure there is at most only one text column' and the text column (if present) is the one reported by row.Table.XmlText " is 125.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,HasPointers,The length of the statement  "                    // This can happens only when some threads are creating navigators (thus modifying this.pointers) while other threads are in the foreach loop. " is 142.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,CloneTree,The length of the statement  "            // Caller should ensure that the EnforceConstraints == false. See 60486 for more info about why this was changed from DataSet.EnforceConstraints = false to an assert. " is 166.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,LoadTreeFromDataSet,The length of the statement  "            // won't be in the same sequence as in XML' we may end up with having a child table' before its parent (which is not doable " is 123.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,LoadTreeFromDataSet,The length of the statement  "            // so to fix it in general' we try to iterate over ordered tables instead of going over all tables in DataTableCollection with their own sequence " is 145.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,OnColumnValueChanged,The length of the statement  "                            // We may get an exception if we are in foreach and a new pointer has been added to this.pointers. When this happens' we will skip this check and ignore the exceptions " is 167.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,OnColumnValuesChanged,The length of the statement  "            // If user has cascading relationships' then columnChangeList will contains the changed columns only for the last row beeing cascaded " is 133.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,OnFoliated,The length of the statement  "                    // This can happens only when some threads are creating navigators (thus modifying this.pointers) while other threads are in the foreach loop. " is 142.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,OnNestedParentChange,The length of the statement  "            // This function is (and s/b) called as a result of ROM changes' therefore XML changes done here should not be sync-ed to ROM " is 125.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,OnNestedParentChange,The length of the statement  "                    // no parent? Maybe the parentRow is during changing or childCol is the ID is set to null ( detached from the parent row ). " is 123.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,OnNestedParentChange,The length of the statement  "            // We should not have changed the connected/disconnected state of the node (since the row state did not change) -- IOW if the original childElem was in dis-connected " is 165.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,OnNestedParentChange,The length of the statement  "            // state and corresponded to a detached/deleted row' by adding it to the main tree we become inconsistent (since we have now a deleted/detached row in the main tree) " is 165.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,OnNestedParentChange,The length of the statement  "            // Same goes when we remove a node from connected tree to make it a child of a row-node corresponding to a non-live row. " is 120.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,OnNodeInserted,The length of the statement  "                // The code bellow assumes a move operation is fired by DOM in 2 steps: a Remvoe followed by an Insert - this is the 2nd part' the Insert. " is 138.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,OnTableColumnsChanging,The length of the statement  "            // args.Element is one of either the column (for Add and Remove actions or null' if the entire colection of columns is changing) " is 128.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,OnTableColumnsChanging,The length of the statement  "            // Disallow changing the columns collection (since we are subscribed only in populated mode' we allow changes in any state but non-populated mode) " is 146.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,OnDataSetTablesChanging,The length of the statement  "            // Disallow changing the tables collection (since we are subscribed only in populated mode' we allow changes in any state but non-populated mode) " is 145.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,OnDataSetRelationsChanging,The length of the statement  "            // Disallow changing the tables collection if there is data loaded and there are nested relationship that are added/refreshed " is 125.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,OnDataSetRelationsChanging,The length of the statement  "            Debug.Assert(!(args.Action == CollectionChangeAction.Add || args.Action == CollectionChangeAction.Remove) || rel.Nested == false); " is 130.
Long Statement,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,OrderTables,The length of the statement  "                {//there will not be  any in case just if we have circular relation dependency' just copy as they are in tablecollection use CopyTo of the collection " is 149.
Long Statement,System.Xml,XPathNodePointer,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XPathNodePointer.cs,NextColumn,The length of the statement  "                if (!_doc.IsNotMapped(c) && (c.ColumnMapping == MappingType.Attribute) == fAttribute && !Convert.IsDBNull(row[c' rowVersion])) " is 126.
Long Statement,System.Xml,XPathNodePointer,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XPathNodePointer.cs,PreviousColumn,The length of the statement  "                if (!_doc.IsNotMapped(c) && (c.ColumnMapping == MappingType.Attribute) == fAttribute && !Convert.IsDBNull(row[c' rowVersion])) " is 126.
Long Statement,System.Xml,XPathNodePointer,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XPathNodePointer.cs,GetRoot,The length of the statement  "            XmlNode parent = ((curNode.NodeType == XmlNodeType.Attribute) ? (((XmlAttribute)curNode).OwnerElement) : (curNode.ParentNode)); " is 127.
Long Statement,System.Xml,XPathNodePointer,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XPathNodePointer.cs,GetRoot,The length of the statement  "                parent = curNode.ParentNode; // no need to check for attribute since navigator can't be built on its children or navigate to its children  " is 137.
Long Statement,System.Xml,XPathNodePointer,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XPathNodePointer.cs,ComparePosition,The length of the statement  "                    curNode1 = ((curNode1.NodeType == XmlNodeType.Attribute) ? (((XmlAttribute)curNode1).OwnerElement) : (curNode1.ParentNode)); " is 124.
Long Statement,System.Xml,XPathNodePointer,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XPathNodePointer.cs,ComparePosition,The length of the statement  "                    curNode2 = ((curNode2.NodeType == XmlNodeType.Attribute) ? (((XmlAttribute)curNode2).OwnerElement) : (curNode2.ParentNode)); " is 124.
Long Statement,System.Xml,XPathNodePointer,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XPathNodePointer.cs,GetNamespace,The length of the statement  "                        DataRowVersion rowVersion = (curRow.RowState == DataRowState.Detached) ? DataRowVersion.Proposed : DataRowVersion.Current; " is 122.
Long Statement,System.Xml,XPathNodePointer,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XPathNodePointer.cs,MoveToNextNamespace,The length of the statement  "            // till now' node should be the next ancestor (bound) element of the element parent of current namespace node (attribute or data column) " is 136.
Long Statement,System.Xml,DataPointer,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\DataPointer.cs,NextColumn,The length of the statement  "                if (!_doc.IsNotMapped(c) && (c.ColumnMapping == MappingType.Attribute) == fAttribute && (fNulls || !Convert.IsDBNull(row[c' rowVersion]))) " is 138.
Long Statement,System.Xml,DataSetMapper,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\DataSetMappper.cs,SearchMatchingTableSchema,The length of the statement  "                // Some sanity check to catch errors like namespace attributes have the right localName/namespace value' but a wrong atomized namespace value " is 141.
Long Statement,System.Xml,RegionIterator,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\RegionIterator.cs,NextRight,The length of the statement  "            // Make sure we do not get past the rowElement if we call NextRight on a just initialized iterator and rowElement has no children " is 129.
Long Statement,System.Xml,RegionIterator,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\RegionIterator.cs,NextInitialTextLikeNodes,The length of the statement  "            // It's not OK to try to read the initial text value for sub-regions' because we do not know how to revert their initial state " is 126.
Long Statement,System.Data,XDRSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XDRSchema.cs,InstantiateTable,The length of the statement  "            // fxcop: new DataTable should inherit the CaseSensitive' Locale from DataSet and possibly updating during SetProperties " is 120.
Long Statement,System.Data,XMLDiffLoader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLDiffLoader.cs,ReadOldRowData,The length of the statement  "                        bool isPolymorphism = (column.DataType == typeof(object) || (row.GetAttribute(Keywords.MSD_INSTANCETYPE' Keywords.MSDNS) != null) || " is 132.
Long Statement,System.Data,XMLDiffLoader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLDiffLoader.cs,ReadOldRowData,The length of the statement  "                            if (row.NodeType == XmlNodeType.Text || row.NodeType == XmlNodeType.Whitespace || row.NodeType == XmlNodeType.SignificantWhitespace) " is 132.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,AddExtendedProperties,The length of the statement  "                        v = (string)BigIntegerStorage.ConvertFromBigInteger((System.Numerics.BigInteger)entry.Value' typeof(string)' CultureInfo.InvariantCulture); " is 139.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,AddXdoProperty,The length of the statement  "            if ((!pd.ShouldSerializeValue(instance) || !pd.Attributes.Contains(DesignerSerializationVisibilityAttribute.Visible)) && (bIsSqlType == false)) " is 143.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,AddXdoProperty,The length of the statement  "                    else if ((dt.Length == 0) || bImplementsInullable || ((dt == Keywords.XSD_ANYTYPE) && (col.XmlDataType != Keywords.XSD_ANYTYPE)) || (col.DataType == typeof(DateTimeOffset))) " is 173.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,XmlDataTypeName,The length of the statement  "            // but I can not make Sql Types that will map to string be unmapped' because in schema ' I will miss the second part and won't " is 126.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,SetupAutoGenerated,The length of the statement  "                        UniqueConstraint _constraint = (UniqueConstraint)fk.RelatedTable.Constraints.FindConstraint(new UniqueConstraint("TEMP"' fk.RelatedColumnsReference)); " is 150.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,SchemaTree,The length of the statement  "            if (top.Length == 0 || _schFormat == SchemaFormat.WebServiceSkipSchema || _schFormat == SchemaFormat.RemotingSkipSchema) " is 120.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,SchemaTree,The length of the statement  "                if (((_ds != null) && (_ds.Namespace == top[i].Namespace)) || string.IsNullOrEmpty(top[i].Namespace) || (_schFormat == SchemaFormat.Remoting)) " is 142.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,SchemaTree,The length of the statement  "                        if ((_ds != null && _ds.Namespace == top[i].Namespace) || string.IsNullOrEmpty(top[i].Namespace) || (_schFormat == SchemaFormat.Remoting)) " is 138.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,SchemaTree,The length of the statement  "                    rootSchema.SetAttribute(Keywords.MSD_FRAGMENTCOUNT' Keywords.MSDNS' _namespaces.Count.ToString(CultureInfo.InvariantCulture)); " is 126.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,SchemaTree,The length of the statement  "                                    _import2.SetAttribute(Keywords.XSD_SCHEMALOCATION' _fileName + _fileExt); // for the dataset namespace don't append anything " is 124.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,FillDataSetElement,The length of the statement  "                    _dsElement.SetAttribute(Keywords.MSD_MAINDATATABLE' Keywords.MSDNS' XmlConvert.EncodeLocalName(((dt.Namespace.Length == 0) ? dt.TableName : (dt.Namespace + ":" + dt.TableName)))); " is 179.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,FillDataSetElement,The length of the statement  "                    _dsElement.SetAttribute(Keywords.MSD_MAINDATATABLE' Keywords.MSDNS' XmlConvert.EncodeLocalName(((dt.Namespace.Length == 0) ? dt.TableName : (dt.Namespace + ":" + dt.TableName)))); " is 179.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,Save,The length of the statement  "                xw.WriteAttributeString(Keywords.MSD' Keywords.MSD_SCHEMASERIALIZATIONMODE' Keywords.MSDNS' Keywords.MSD_EXCLUDESCHEMA); " is 120.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleColumnType,The length of the statement  "                        // for remoting we need to use columns NS' for other cases it is wrong to get Columns NS' we need to take type's namespace " is 122.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleColumnType,The length of the statement  "                        if (stNode.BaseSimpleType != null && stNode.BaseSimpleType.Namespace != null && stNode.BaseSimpleType.Namespace.Length > 0) " is 123.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleColumnType,The length of the statement  "                                    root.SetAttribute(keyword' (prefix + ":" + name)); // look at below'this loop assumes we would be here just oen time: Its Wrong " is 127.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleColumnType,The length of the statement  "                            //                        Debug.Assert(col.SimpleType.IsEqual(new SimpleType(elmSimpeType))' "simpleTypes with the same name have to be the same: "+name); " is 154.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleColumnType,The length of the statement  "                        if (stNode.BaseSimpleType != null && stNode.BaseSimpleType.Namespace != null && stNode.BaseSimpleType.Namespace.Length > 0) " is 123.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,AddColumnProperties,The length of the statement  "                if ((col.IsSqlType && ((dt.Length == 0) || col.ImplementsINullable)) || (typeof(SqlXml) == col.DataType) || col.DataType == typeof(DateTimeOffset) || col.DataType == typeof(System.Numerics.BigInteger)) " is 201.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,AddColumnProperties,The length of the statement  "                else if ((dt.Length == 0) || col.ImplementsINullable || ((dt == Keywords.XSD_ANYTYPE) && (col.XmlDataType != Keywords.XSD_ANYTYPE))) " is 132.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleColumn,The length of the statement  "                        root.SetAttribute(Keywords.MSD_DEFAULTVALUE' Keywords.MSDNS' (bool)(col.DefaultValue) ? Keywords.TRUE : Keywords.FALSE); " is 120.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleColumn,The length of the statement  "                        root.SetAttribute(Keywords.MSD_DEFAULTVALUE' Keywords.MSDNS' (bool)(col.DefaultValue) ? Keywords.TRUE : Keywords.FALSE); " is 120.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleColumn,The length of the statement  "                if ((col.Namespace != (col.Table.TypeName.IsEmpty ? col.Table.Namespace : col.Table.TypeName.Namespace)) && (col.Namespace.Length != 0)) " is 136.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleTable,The length of the statement  "            if (((table.DataSet == null) || (_ds != null && table.Namespace != _ds.Namespace)) && (_schFormat == SchemaFormat.Remoting)) " is 124.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleTable,The length of the statement  "                            if (childRelations[j].Nested && childRelations[j].ParentKey.ColumnsReference.Length == 1 && childRelations[j].ParentKey.ColumnsReference[0] == col) " is 147.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleTable,The length of the statement  "                    root.SetAttribute(Keywords.TYPE' NewDiffgramGen.QualifiedName((string)_prefixes[table.TypeName.Namespace]' table.TypeName.Name)); " is 129.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleTable,The length of the statement  "                if (col.ColumnMapping == MappingType.Attribute || col.ColumnMapping == MappingType.Element || col.ColumnMapping == MappingType.Hidden) " is 134.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleTable,The length of the statement  "                    if ((childTable.Namespace == table.Namespace) || (childTable.Namespace.Length == 0) || _schFormat == SchemaFormat.Remoting) " is 123.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleTable,The length of the statement  "                    UniqueConstraint _constraint = (UniqueConstraint)foreign.RelatedTable.Constraints.FindConstraint(new UniqueConstraint("TEMP"' fields)); " is 135.
Long Statement,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleTable,The length of the statement  "                    if ((_ds == null) || (_ds.Tables.InternalIndexOf(foreign.RelatedTable.TableName) == -3)) // if there is a conflicting name/namespace only " is 137.
Long Statement,System.Data,NewDiffgramGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,GenerateTableErrors,The length of the statement  "                    _xmlw.WriteAttributeString(Keywords.DFF' Keywords.DIFFID' Keywords.DFFNS' row.Table.TableName + row.rowID.ToString(CultureInfo.InvariantCulture)); " is 146.
Long Statement,System.Data,NewDiffgramGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,GenerateTableErrors,The length of the statement  "                        _xmlw.WriteAttributeString(Keywords.DFF' Keywords.DIFFID' Keywords.DFFNS' row.Table.TableName + row.rowID.ToString(CultureInfo.InvariantCulture)); " is 146.
Long Statement,System.Data,NewDiffgramGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,GenerateColumn,The length of the statement  "                    if (!col.IsCustomType || !col.IsValueCustomTypeInstance(columnValue) || (typeof(IXmlSerializable).IsAssignableFrom(columnValue.GetType()))) " is 139.
Long Statement,System.Data,NewDiffgramGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,GenerateColumn,The length of the statement  "                                    _xmlw.WriteAttributeString(Keywords.MSD' Keywords.MSD_INSTANCETYPE' Keywords.MSDNS' DataStorage.GetQualifiedName(valuesType)); " is 126.
Long Statement,System.Data,XmlDataTreeWriter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,SaveDiffgramData,The length of the statement  "            string prefix = (_ds != null) ? ((_ds.Namespace.Length == 0) ? "" : _ds.Prefix) : ((_dt.Namespace.Length == 0) ? "" : _dt.Prefix); " is 130.
Long Statement,System.Data,XmlDataTreeWriter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,SaveDiffgramData,The length of the statement  "                        throw ExceptionBuilder.MultipleParentRows(tempTable.Namespace.Length == 0 ? tempTable.TableName : tempTable.Namespace + tempTable.TableName); " is 141.
Long Statement,System.Data,XmlDataTreeWriter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,Save,The length of the statement  "            string prefix = (_ds != null) ? ((_ds.Namespace.Length == 0) ? "" : _ds.Prefix) : ((_dt.Namespace.Length == 0) ? "" : _dt.Prefix); " is 130.
Long Statement,System.Data,XmlDataTreeWriter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,XmlDataRowWriter,The length of the statement  "                _xmlw.WriteAttributeString(Keywords.DFF' Keywords.DIFFID' Keywords.DFFNS' row.Table.TableName + row.rowID.ToString(CultureInfo.InvariantCulture)); " is 146.
Long Statement,System.Data,XmlDataTreeWriter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,XmlDataRowWriter,The length of the statement  "                        _xmlw.WriteAttributeString(Keywords.MSD' "hidden" + col.EncodedColumnName' Keywords.MSDNS' col.ConvertObjectToXml(value)); " is 122.
Long Statement,System.Data,XmlDataTreeWriter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,XmlDataRowWriter,The length of the statement  "                    if (((value == DBNull.Value) || (col.ImplementsINullable && DataStorage.IsObjectSqlNull(value))) && (col.ColumnMapping == MappingType.SimpleContent)) " is 149.
Long Statement,System.Data,XmlDataTreeWriter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,XmlDataRowWriter,The length of the statement  "                    if (((value != DBNull.Value) && (!col.ImplementsINullable || !DataStorage.IsObjectSqlNull(value))) && (col._columnMapping != MappingType.Attribute)) " is 148.
Long Statement,System.Data,XmlDataTreeWriter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,XmlDataRowWriter,The length of the statement  "                            if (!col.IsCustomType || !col.IsValueCustomTypeInstance(value) || (typeof(IXmlSerializable).IsAssignableFrom(value.GetType()))) " is 127.
Long Statement,System.Data,XmlDataTreeWriter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,XmlDataRowWriter,The length of the statement  "                                    _xmlw.WriteAttributeString(Keywords.MSD' Keywords.MSD_INSTANCETYPE' Keywords.MSDNS' DataStorage.GetQualifiedName(valuesType)); " is 126.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,CollectElementsAnnotations,The length of the statement  "                        // Assumption is that our simple type qualified name ihas the same output as XmlSchemaSimpleType type.QualifiedName.ToString() " is 126.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,IsDatasetParticle,The length of the statement  "            bool isChoice = FromInference && (pt is XmlSchemaChoice);// currently we add this support for choice' just for inference " is 120.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,IsDatasetParticle,The length of the statement  "                    if (isChoice && pt.MaxOccurs > decimal.One && (((XmlSchemaElement)el).SchemaType is XmlSchemaComplexType)) // we know frominference condition " is 141.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,IsDatasetParticle,The length of the statement  "                        if (!FromInference || (((XmlSchemaElement)el).MaxOccurs != decimal.One && !(((XmlSchemaElement)el).SchemaType is XmlSchemaComplexType))) " is 136.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,LoadSchema,The length of the statement  "            if (tmpTable != null) // this fix is done to support round-trip problem in case if there is one table with same name and NS " is 123.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleAttributeGroup,The length of the statement  "                    if (attributeGroup.RedefinedAttributeGroup != null && attributeGroupRef.RefName == new XmlQualifiedName(attributeGroup.Name' attributeGroupRef.RefName.Namespace)) " is 162.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleComplexType,The length of the statement  "                                HandleSimpleContentColumn(ccExtension.BaseTypeName.ToString()' table' isBase' ct.ContentModel.UnhandledAttributes' isNillable); " is 127.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleComplexType,The length of the statement  "                                HandleSimpleContentColumn(ccExtension.BaseTypeName.Name' table' isBase' ct.ContentModel.UnhandledAttributes' isNillable); " is 121.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleComplexType,The length of the statement  "                            HandleSimpleTypeSimpleContentColumn((XmlSchemaSimpleType)ct.BaseXmlSchemaType' ccExtension.BaseTypeName.Name' table' isBase' ct.ContentModel.UnhandledAttributes' isNillable); " is 174.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,InstantiateSimpleTable,The length of the statement  "            bool isSimpleContent = ((node.ElementSchemaType.BaseXmlSchemaType != null) || (ct != null && ct.ContentModel is XmlSchemaSimpleContent)); " is 137.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,GetInstanceName,The length of the statement  "            Debug.Assert((node is XmlSchemaElement) || (node is XmlSchemaAttribute)' "GetInstanceName should only be called on attribute or elements"); " is 139.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,GetInstanceName,The length of the statement  "            Debug.Assert((instanceName != null) && (instanceName.Length != 0)' "instanceName cannot be null or empty. There's an error in the XSD compiler"); " is 145.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,InstantiateTable,The length of the statement  "            //            if (table == null && node.RefName.IsEmpty && !IsTopLevelElement(node) && _TableUri != null && _TableUri.Length > 0) {  " is 131.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,XsdtoClr,The length of the statement  "                Debug.Assert((s_mapNameTypeXsd[i - 1].CompareTo(s_mapNameTypeXsd[i].name)) < 0' "incorrect sorting " + s_mapNameTypeXsd[i].name); " is 129.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,FindNameType,The length of the statement  "                Debug.Assert((s_mapNameTypeXsd[i - 1].CompareTo(s_mapNameTypeXsd[i].name)) < 0' "incorrect sorting " + s_mapNameTypeXsd[i].name); " is 129.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,IsXsdType,The length of the statement  "                Debug.Assert((s_mapNameTypeXsd[i - 1].CompareTo(s_mapNameTypeXsd[i].name)) < 0' "incorrect sorting " + s_mapNameTypeXsd[i].name); " is 129.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,FindTypeNode,The length of the statement  "                    typeNode = isAttr ? FindTypeNode((XmlSchemaAnnotated)_attributes[attr.RefName]) : FindTypeNode((XmlSchemaAnnotated)_elementsTable[el.RefName]); " is 143.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,FindTypeNode,The length of the statement  "                typeNode = (XmlSchemaAnnotated)_schemaTypes[isAttr ? ((XmlSchemaAttribute)node).SchemaTypeName : ((XmlSchemaElement)node).SchemaTypeName]; " is 138.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleSimpleTypeSimpleContentColumn,The length of the statement  "            if (typeNode.QualifiedName.Name != null && typeNode.QualifiedName.Name.Length != 0 && typeNode.QualifiedName.Namespace != Keywords.XSDNS) " is 137.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleSimpleTypeSimpleContentColumn,The length of the statement  "            // Update XSD type to point to simple types actual namespace instead of normalized default namespace in case of remoting " is 120.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleAttributeColumn,The length of the statement  "                if (node.QualifiedName.Name != null && node.QualifiedName.Name.Length != 0 && node.QualifiedName.Namespace != Keywords.XSDNS) " is 125.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleAttributeColumn,The length of the statement  "                    if ((string.IsNullOrEmpty(attrib.QualifiedName.Namespace) && string.IsNullOrEmpty(column._columnUri)) || // backward compatability :SQL BU DT 310912 " is 148.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleAttributeColumn,The length of the statement  "                    column = new DataColumn(columnName' type' null' MappingType.Attribute); // this is to fix issue with Exception we used to throw for old inference engine if column " is 162.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleAttributeColumn,The length of the statement  "            string strDefault = (attrib.Use == XmlSchemaUse.Required) ? GetMsdataAttribute(attr' Keywords.MSD_DEFAULTVALUE) : attr.DefaultValue; " is 132.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleElementColumn,The length of the statement  "                // ((XmlSchemaSimpleType)typeNode).Name != null && ((XmlSchemaSimpleType)typeNode).Name.Length != 0 check is for annonymos simple type'  " is 135.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleElementColumn,The length of the statement  "                if (((XmlSchemaSimpleType)typeNode).Name != null && ((XmlSchemaSimpleType)typeNode).Name.Length != 0 && ((XmlSchemaSimpleType)typeNode).QualifiedName.Namespace != Keywords.XSDNS) " is 178.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleElementColumn,The length of the statement  "                    if ((string.IsNullOrEmpty(elem.QualifiedName.Namespace) && string.IsNullOrEmpty(column._columnUri)) || // backward compatability :SQL BU DT 310912 " is 146.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleElementColumn,The length of the statement  "                    column = new DataColumn(columnName' type' null' MappingType.Element);// this is to fix issue with Exception we used to throw for old inference engine if column " is 159.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleElementColumn,The length of the statement  "            // Update XSD type to point to simple types actual namespace instead of normalized default namespace in case of remoting " is 120.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleElementColumn,The length of the statement  "            { // it is local' hence check for 'form' on local element' if not specified' check for 'elemenfformdefault' on schema element " is 125.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleDataSet,The length of the statement  "                                DataTable tempTable = _ds.Tables.GetTable(XmlConvert.DecodeName(GetInstanceName((XmlSchemaElement)el))' node.QualifiedName.Namespace); " is 134.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleDataSet,The length of the statement  "                                //                          bool isComplexTypeOrValidElementType = (node.ElementType != null || !(((XmlSchemaElement)el).SchemaType is XmlSchemaComplexType)); " is 158.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleDataSet,The length of the statement  "                                if (((XmlSchemaParticle)el).MaxOccurs > decimal.One && (((XmlSchemaElement)choiceEl).SchemaType is XmlSchemaComplexType)) // amir " is 129.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleDataSet,The length of the statement  "                                if ((((XmlSchemaElement)choiceEl).RefName.Name.Length != 0) && (!FromInference && ((XmlSchemaElement)choiceEl).MaxOccurs != decimal.One && !(((XmlSchemaElement)choiceEl).SchemaType is XmlSchemaComplexType))) " is 207.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleDataSet,The length of the statement  "                _ds.Tables.ReplaceFromInference(_tableList); // replace the list with the one in correct order: BackWard compatability for inference " is 132.
Long Statement,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleTable,The length of the statement  "            DataTable table = InstantiateTable(node' (XmlSchemaComplexType)typeNode' (node.RefName != null)); // this is wrong ' correct check should be node.RefName.IsEmpty " is 161.
Long Statement,System.Data,XmlToDatasetMap,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XmlToDatasetMap.cs,GetColumnSchema,The length of the statement  "                tableSchemaInfo = (TableSchemaInfo)(fIgnoreNamespace ? _tableSchemaMap[nodeRegion.LocalName] : _tableSchemaMap[nodeRegion]); " is 124.
Long Statement,System.Data,XmlToDatasetMap,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XmlToDatasetMap.cs,GetColumnSchema,The length of the statement  "                _lastTableSchemaInfo = (TableSchemaInfo)(fIgnoreNamespace ? _tableSchemaMap[table.EncodedTableName] : _tableSchemaMap[table]); " is 126.
Long Statement,System.Data,XmlToDatasetMap,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XmlToDatasetMap.cs,GetTableForNode,The length of the statement  "            TableSchemaInfo tableSchemaInfo = (TableSchemaInfo)(fIgnoreNamespace ? _tableSchemaMap[node.LocalName] : _tableSchemaMap[node]); " is 128.
Long Statement,System.Data,XmlToDatasetMap,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XmlToDatasetMap.cs,HandleSpecialColumn,The length of the statement  "            Debug.Assert(col.ColumnName.StartsWith("xml"' StringComparison.OrdinalIgnoreCase)' "column name should start with xml"); " is 120.
Long Statement,System.Data,InternalDataCollectionBase,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\BaseCollection.cs,NamesEqual,The length of the statement  "            if (locale.CompareInfo.Compare(s1' s2' CompareOptions.IgnoreCase | CompareOptions.IgnoreKanaType | CompareOptions.IgnoreWidth) == 0) " is 132.
Long Statement,System.Data,ConstraintCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ConstraintCollection.cs,FindKeyConstraint,The length of the statement  "                if ((null != constraint) && (constraint.Key.ColumnsReference.Length == 1) && (constraint.Key.ColumnsReference[0] == column)) " is 124.
Long Statement,System.Data,ConstraintCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ConstraintCollection.cs,FinishInitConstraints,The length of the statement  "                            parents[j] = _table.DataSet.Tables[constr._parentTableName' constr._parentTableNamespace].Columns[constr._parentColumnNames[j]]; " is 128.
Long Statement,System.Data,ConstraintConverter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ConstraintConverter.cs,ConvertTo,The length of the statement  "                    Reflection.ConstructorInfo ctor = typeof(UniqueConstraint).GetConstructor(new Type[] { typeof(string)' typeof(string[])' typeof(bool) }); " is 137.
Long Statement,System.Data,ConstraintConverter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ConstraintConverter.cs,ConvertTo,The length of the statement  "                        return new InstanceDescriptor(ctor' new object[] { constr.ConstraintName' constr.ParentKey.Table.TableName' constr.ParentColumnNames' " is 133.
Long Statement,System.Data,DataColumn,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataColumn.cs,SetTable,The length of the statement  "                    if ((table == null) || (!table.fInitInProgress && ((table.DataSet == null) || (!table.DataSet._fIsSchemaLoading && !table.DataSet._fInitInProgress)))) " is 150.
Long Statement,System.Data,DataColumn,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataColumn.cs,SetValue,The length of the statement  "            {  // at initialization time (datatable.NewRow()' we would fill the storage with default value' but at that time we won't have datarow) " is 135.
Long Statement,System.Data,DataColumn,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataColumn.cs,Clone,The length of the statement  "            clone._defaultValueIsNull = ((_defaultValue == DBNull.Value) || (clone.ImplementsINullable && DataStorage.IsObjectSqlNull(_defaultValue))) ? true : false; " is 154.
Long Statement,System.Data,AutoIncrementValue,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataColumn.cs,Clone,The length of the statement  "            AutoIncrementValue clone = (this is AutoIncrementInt64) ? new AutoIncrementInt64() : (AutoIncrementValue)new AutoIncrementBigInteger(); " is 135.
Long Statement,System.Data,AutoIncrementInt64,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataColumn.cs,SetCurrentAndIncrement,The length of the statement  "            Debug.Assert(null != value && DataColumn.IsAutoIncrementType(value.GetType()) && !(value is BigInteger)' "unexpected value for autoincrement"); " is 143.
Long Statement,System.Data,DataColumnCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataColumnCollection.cs,CanRemove,The length of the statement  "                        throw ExceptionBuilder.CannotRemoveConstraint(_table.Constraints[i].ConstraintName' _table.Constraints[i].Table.TableName); " is 123.
Long Statement,System.Data,DataColumnCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataColumnCollection.cs,CanRemove,The length of the statement  "                for (ParentForeignKeyConstraintEnumerator en = new ParentForeignKeyConstraintEnumerator(_table.DataSet' _table); en.GetNext();) " is 127.
Long Statement,System.Data,DataColumnCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataColumnCollection.cs,RegisterColumnName,The length of the statement  "            // If we're adding a child table' then update defaultNameIndex to avoid colisions between the child table and auto-generated column names " is 137.
Long Statement,System.Data,DataRelation,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRelation.cs,GetChildRows,The length of the statement  "            Index index = childKey.GetSortIndex((version == DataRowVersion.Original) ? DataViewRowState.OriginalRows : DataViewRowState.CurrentRows); " is 137.
Long Statement,System.Data,DataRelation,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRelation.cs,GetParentRows,The length of the statement  "            Index index = parentKey.GetSortIndex((version == DataRowVersion.Original) ? DataViewRowState.OriginalRows : DataViewRowState.CurrentRows); " is 138.
Long Statement,System.Data,DataRelation,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRelation.cs,GetParentRow,The length of the statement  "            Index index = parentKey.GetSortIndex((version == DataRowVersion.Original) ? DataViewRowState.OriginalRows : DataViewRowState.CurrentRows); " is 138.
Long Statement,System.Data,DataRelation,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRelation.cs,CheckState,The length of the statement  "                        ((_parentKey.ColumnsReference[i].DateTimeMode & _childKey.ColumnsReference[i].DateTimeMode) != DataSetDateTime.Unspecified))) " is 125.
Long Statement,System.Data,DataRelation,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRelation.cs,Create,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataRelation.Create|INFO> {0}' relationName='{1}'' createConstraints={2}"' ObjectID' relationName' createConstraints); " is 178.
Long Statement,System.Data,DataRelation,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRelation.cs,Clone,The length of the statement  "            DataCommonEventSource.Log.Trace("<ds.DataRelation.Clone|INFO> {0}' destination={1}"' ObjectID' (destination != null) ? destination.ObjectID : 0); " is 145.
Long Statement,System.Data,DataRelationCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRelationCollection.cs,Add,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataRelationCollection.Add|API> {0}' relation={1}"' ObjectID' (relation != null) ? relation.ObjectID : 0); " is 166.
Long Statement,System.Data,DataRelationCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRelationCollection.cs,AddCore,The length of the statement  "            DataCommonEventSource.Log.Trace("<ds.DataRelationCollection.AddCore|INFO> {0}' relation={1}"' ObjectID' (relation != null) ? relation.ObjectID : 0); " is 148.
Long Statement,System.Data,DataRelationCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRelationCollection.cs,Remove,The length of the statement  "            DataCommonEventSource.Log.Trace("<ds.DataRelationCollection.Remove|API> {0}' relation={1}"' ObjectID' (relation != null) ? relation.ObjectID : 0); " is 146.
Long Statement,System.Data,DataRelationCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRelationCollection.cs,RemoveCore,The length of the statement  "            DataCommonEventSource.Log.Trace("<ds.DataRelationCollection.RemoveCore|INFO> {0}' relation={1}"' ObjectID' (relation != null) ? relation.ObjectID : 0); " is 151.
Long Statement,System.Data,DataSetRelationCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRelationCollection.cs,AddCore,The length of the statement  "                ((DataTableRelationCollection)(relation.ParentTable.ChildRelations)).Add(relation); // Caching in ParentTable -> ChildRelations " is 127.
Long Statement,System.Data,DataSetRelationCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRelationCollection.cs,AddCore,The length of the statement  "                ((DataTableRelationCollection)(relation.ChildTable.ParentRelations)).Add(relation); // Caching in ChildTable -> ParentRelations " is 127.
Long Statement,System.Data,DataSetRelationCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRelationCollection.cs,AddCore,The length of the statement  "                ForeignKeyConstraint foreignKey = relation.ChildTable.Constraints.FindForeignKeyConstraint(relation.ParentColumnsReference' relation.ChildColumnsReference); " is 156.
Long Statement,System.Data,DataSetRelationCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRelationCollection.cs,AddCore,The length of the statement  "                        relation.ChildTable.Constraints.Add(foreignKey = new ForeignKeyConstraint(relation.ParentColumnsReference' relation.ChildColumnsReference)); " is 140.
Long Statement,System.Data,DataSetRelationCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRelationCollection.cs,RemoveCore,The length of the statement  "                        ((DataTableRelationCollection)(relation.ParentTable.ChildRelations)).Remove(relation); // Remove Cache from ParentTable -> ChildRelations " is 137.
Long Statement,System.Data,DataSetRelationCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRelationCollection.cs,RemoveCore,The length of the statement  "                        ((DataTableRelationCollection)(relation.ChildTable.ParentRelations)).Remove(relation); // Removing Cache from ChildTable -> ParentRelations " is 139.
Long Statement,System.Data,DataRow,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRow.cs,SetColumnError,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataRow.SetColumnError|API> {0}' column={1}' error='{2}'"' _objectID' column.ObjectID' error); " is 154.
Long Statement,System.Data,DataRow,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRow.cs,GetDefaultRowVersion,The length of the statement  "                Debug.Assert(_action == DataRowAction.Rollback || 0 != (DataViewRowState.Deleted & viewState)' "not DataViewRowState.Deleted"); " is 127.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,DeserializeDataSetSchema,The length of the statement  "                        byte[] buffer = (byte[])info.GetValue(string.Format(CultureInfo.InvariantCulture' "DataSet.Tables_{0}"' i)' typeof(byte[])); " is 124.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,GetChanges,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataSet.GetChanges|API> {0}' rowStates={1}"' ObjectID' rowStates); " is 126.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,HasChanges,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataSet.HasChanges|API> {0}' rowStates={1}"' ObjectID' (int)rowStates); " is 131.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,HasChanges,The length of the statement  "                const DataRowState allRowStates = DataRowState.Detached | DataRowState.Unchanged | DataRowState.Added | DataRowState.Deleted | DataRowState.Modified; " is 149.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXmlSchema,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataSet.ReadXmlSchema|INFO> {0}' reader' denyResolving={1}"' ObjectID' denyResolving); " is 146.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXmlSchema,The length of the statement  "                    if (reader.LocalName == Keywords.XSD_SCHEMA && reader.NamespaceURI.StartsWith(Keywords.XSD_NS_START' StringComparison.Ordinal)) " is 127.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXmlSchema,The length of the statement  "                        if (reader.LocalName == Keywords.XSD_SCHEMA && reader.NamespaceURI.StartsWith(Keywords.XSD_NS_START' StringComparison.Ordinal)) " is 127.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,MoveToElement,The length of the statement  "            while (!reader.EOF && reader.NodeType != XmlNodeType.EndElement && reader.NodeType != XmlNodeType.Element && reader.Depth > depth) " is 130.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXSDSchema,The length of the statement  "                    string attribValue = reader.GetAttribute(Keywords.MSD_FRAGMENTCOUNT' Keywords.MSDNS); // this must not move the position " is 120.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,WriteXmlSchema,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataSet.WriteXmlSchema|INFO> {0}' schemaFormat={1}"' ObjectID' schemaFormat); " is 137.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXml,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataSet.ReadXml|INFO> {0}' denyResolving={1}"' ObjectID' denyResolving); " is 132.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXml,The length of the statement  "                        if (reader.LocalName == Keywords.XSD_SCHEMA && reader.NamespaceURI.StartsWith(Keywords.XSD_NS_START' StringComparison.Ordinal)) " is 127.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXml,The length of the statement  "                            if (reader.LocalName == Keywords.XSD_SCHEMA && reader.NamespaceURI.StartsWith(Keywords.XSD_NS_START' StringComparison.Ordinal)) " is 127.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXml,The length of the statement  "                            if (root.ChildNodes.Count == 0 || ((root.ChildNodes.Count == 1) && root.FirstChild.GetType() == typeof(System.Xml.XmlText))) " is 124.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXml,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataSet.ReadXml|INFO> {0}' mode={1}' denyResolving={2}"' ObjectID' mode' denyResolving); " is 148.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXml,The length of the statement  "                            if (reader.LocalName == Keywords.XSD_SCHEMA && reader.NamespaceURI.StartsWith(Keywords.XSD_NS_START' StringComparison.Ordinal)) " is 127.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXml,The length of the statement  "                            if (reader.LocalName == Keywords.XSD_SCHEMA && reader.NamespaceURI.StartsWith(Keywords.XSD_NS_START' StringComparison.Ordinal)) " is 127.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXml,The length of the statement  "            XmlTextReader reader = (mode == XmlReadMode.Fragment) ? new XmlTextReader(stream' XmlNodeType.Element' null) : new XmlTextReader(stream); " is 137.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXml,The length of the statement  "            XmlTextReader xmlreader = (mode == XmlReadMode.Fragment) ? new XmlTextReader(reader.ReadToEnd()' XmlNodeType.Element' null) : new XmlTextReader(reader); " is 152.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,WriteXml,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataSet.WriteXml|API> {0}' fileName='{1}'' mode={2}"' ObjectID' fileName' (int)mode); " is 145.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,Merge,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataSet.Merge|API> {0}' dataSet={1}"' ObjectID' (dataSet != null) ? dataSet.ObjectID : 0); " is 150.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,Merge,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataSet.Merge|API> {0}' dataSet={1}' preserveChanges={2}"' ObjectID' (dataSet != null) ? dataSet.ObjectID : 0' preserveChanges); " is 188.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,Merge,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataSet.Merge|API> {0}' dataSet={1}' preserveChanges={2}' missingSchemaAction={3}"' ObjectID' (dataSet != null) ? dataSet.ObjectID : 0' preserveChanges' missingSchemaAction); " is 234.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,Merge,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataSet.Merge|API> {0}' table={1}"' ObjectID' (table != null) ? table.ObjectID : 0); " is 144.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,Merge,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataSet.Merge|API> {0}' table={1}' preserveChanges={2}' missingSchemaAction={3}"' ObjectID' (table != null) ? table.ObjectID : 0' preserveChanges' missingSchemaAction); " is 228.
Long Statement,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,Merge,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataSet.Merge|API> {0}' preserveChanges={1}' missingSchemaAction={2}"' ObjectID' preserveChanges' missingSchemaAction); " is 179.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SerializeTableSchema,The length of the statement  "                info.AddValue(string.Format(formatProvider' "DataTable.DataColumn_{0}.AutoIncrementStep"' i)' Columns[i].AutoIncrementStep); " is 124.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SerializeTableSchema,The length of the statement  "                info.AddValue(string.Format(formatProvider' "DataTable.DataColumn_{0}.AutoIncrementSeed"' i)' Columns[i].AutoIncrementSeed); " is 124.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SerializeTableSchema,The length of the statement  "                info.AddValue(string.Format(formatProvider' "DataTable.DataColumn_{0}.AutoIncrementCurrent"' i)' Columns[i].AutoIncrementCurrent); " is 130.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SerializeTableSchema,The length of the statement  "                info.AddValue(string.Format(formatProvider' "DataTable.DataColumn_{0}.ExtendedProperties"' i)' Columns[i]._extendedProperties); " is 127.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeTableSchema,The length of the statement  "                dc.XmlDataType = (string)info.GetValue(string.Format(formatProvider' "DataTable.DataColumn_{0}.XmlDataType"' i)' typeof(string)); " is 129.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeTableSchema,The length of the statement  "                dc.SimpleType = (SimpleType)info.GetValue(string.Format(formatProvider' "DataTable.DataColumn_{0}.SimpleType"' i)' typeof(SimpleType)); " is 135.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeTableSchema,The length of the statement  "                dc.ColumnMapping = (MappingType)info.GetValue(string.Format(formatProvider' "DataTable.DataColumn_{0}.ColumnMapping"' i)' typeof(MappingType)); " is 143.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeTableSchema,The length of the statement  "                dc.DateTimeMode = (DataSetDateTime)info.GetValue(string.Format(formatProvider' "DataTable.DataColumn_{0}.DateTimeMode"' i)' typeof(DataSetDateTime)); " is 149.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeTableSchema,The length of the statement  "                dc.DefaultValue = info.GetValue(string.Format(formatProvider' "DataTable.DataColumn_{0}.DefaultValue"' i)' typeof(object)); " is 123.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeTableSchema,The length of the statement  "                dc.AutoIncrementCurrent = info.GetValue(string.Format(formatProvider' "DataTable.DataColumn_{0}.AutoIncrementCurrent"' i)' typeof(object)); " is 139.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeTableSchema,The length of the statement  "                dc._extendedProperties = (PropertyCollection)info.GetValue(string.Format(formatProvider' "DataTable.DataColumn_{0}.ExtendedProperties"' i)' typeof(PropertyCollection)); " is 168.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeTableSchema,The length of the statement  "                DeserializeConstraints(info' context' /*table index */ 0' /* serialize all constraints */false);// since single table' send table index as 0' meanwhile passing " is 159.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SerializeConstraints,The length of the statement  "                        childInfo[0] = allConstraints ? DataSet.Tables.IndexOf(fk.Table) : 0;   //Since the constraint is on the current table' this is the child table. " is 144.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeConstraints,The length of the statement  "            ArrayList constraintList = (ArrayList)info.GetValue(string.Format(CultureInfo.InvariantCulture' "DataTable_{0}.Constraints"' serIndex)' typeof(ArrayList)); " is 155.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SerializeExpressionColumns,The length of the statement  "                info.AddValue(string.Format(CultureInfo.InvariantCulture' "DataTable_{0}.DataColumn_{1}.Expression"' serIndex' i)' Columns[i].Expression); " is 138.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeExpressionColumns,The length of the statement  "                string expr = info.GetString(string.Format(CultureInfo.InvariantCulture' "DataTable_{0}.DataColumn_{1}.Expression"' serIndex' i)); " is 130.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SerializeTableData,The length of the statement  "            BitArray rowStates = new BitArray(rowCount * 3' false); //All bit flags are set to false on initialization of the BitArray. " is 123.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeTableData,The length of the statement  "                BitArray rowStates = (BitArray)info.GetValue(string.Format(formatProvider' "DataTable_{0}.RowStates"' serIndex)' typeof(BitArray)); " is 131.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeTableData,The length of the statement  "                ArrayList storeList = (ArrayList)info.GetValue(string.Format(formatProvider' "DataTable_{0}.Records"' serIndex)' typeof(ArrayList)); " is 132.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeTableData,The length of the statement  "                ArrayList nullbitList = (ArrayList)info.GetValue(string.Format(formatProvider' "DataTable_{0}.NullBits"' serIndex)' typeof(ArrayList)); " is 135.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeTableData,The length of the statement  "                Hashtable rowErrors = (Hashtable)info.GetValue(string.Format(formatProvider' "DataTable_{0}.RowErrors"' serIndex)' typeof(Hashtable)); " is 134.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeTableData,The length of the statement  "                rowErrors.OnDeserialization(this);//OnDeSerialization must be called since the hashtable gets deserialized after the whole graph gets deserialized " is 146.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeTableData,The length of the statement  "                Hashtable colErrors = (Hashtable)info.GetValue(string.Format(formatProvider' "DataTable_{0}.ColumnErrors"' serIndex)' typeof(Hashtable)); " is 137.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeTableData,The length of the statement  "                colErrors.OnDeserialization(this);//OnDeSerialization must be called since the hashtable gets deserialized after the whole graph gets deserialized " is 146.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,GetInheritedNamespace,The length of the statement  "                while (j < nestedRelations.Length && ((nestedRelations[j].ParentTable == this) || (visitedTables.Contains(nestedRelations[j].ParentTable)))) " is 140.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,MergeRow,The length of the statement  "                            newRecord = (targetRow.RowState == DataRowState.Unchanged) ? _recordManager.CopyRecord(this' oldRecord' -1) : targetRow._newRecord; " is 131.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,MergeRow,The length of the statement  "                    Debug.Assert(saveIdxRecord == ((saveRowState == DataRowState.Added) ? targetRow._newRecord : targetRow._oldRecord)' "oops' you change index record without noticing it"); " is 169.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,Clone,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataTable.Clone|INFO> {0}' cloneDS={1}"' ObjectID' (cloneDS != null) ? cloneDS.ObjectID : 0); " is 153.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,CloneTo,The length of the statement  "            // we do clone datatables while we do readxmlschema' so we do not want to clone columnexpressions if we call this from ReadXmlSchema " is 132.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,CloneTo,The length of the statement  "            // add all expressions if Clone is invoked only on DataTable otherwise DataSet.Clone will assign expressions after creating all relationships. " is 142.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,InsertRow,The length of the statement  "                    SetNewRecordWorker(row' record' DataRowAction.Add' false' false' pos' fireEvent' out deferredException); // now we do add the row to collection before OnRowChanged (RaiseRowChanged) " is 181.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,Clear,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataTable.Clear|INFO> {0}' clearAll={1}"' ObjectID' clearAll); " is 122.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,Clear,The length of the statement  "                    for (ParentForeignKeyConstraintEnumerator constraints = new ParentForeignKeyConstraintEnumerator(_dataSet' this); constraints.GetNext();) " is 137.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,CascadeAll,The length of the statement  "                for (ParentForeignKeyConstraintEnumerator constraints = new ParentForeignKeyConstraintEnumerator(_dataSet' this); constraints.GetNext();) " is 137.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,GetChanges,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataTable.GetChanges|API> {0}' rowStates={1}"' ObjectID' rowStates); " is 128.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,InsertRow,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataTable.InsertRow|INFO> {0}' row={1}"' ObjectID' row._objectID); " is 126.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SilentlySetValue,The length of the statement  "                int[] oldIndex = dr.Table.RemoveRecordFromIndexes(dr' version);// conditional' if it exists it will try to remove with no event fired " is 133.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SilentlySetValue,The length of the statement  "                int[] newIndex = dr.Table.InsertRecordToIndexes(dr' version);// conditional' it will insert if it qualifies' no event will be fired " is 131.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,RemoveRow,The length of the statement  "                for (ParentForeignKeyConstraintEnumerator constraints = new ParentForeignKeyConstraintEnumerator(_dataSet' this); constraints.GetNext();) " is 137.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,RemoveRow,The length of the statement  "            RecordStateChanged(oldRecord' oldRecordStatePre' DataViewRowState.None' newRecord' newRecordStatePre' DataViewRowState.None); " is 125.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,RaiseRowChanged,The length of the statement  "                else if (DataRowAction.Delete == eAction && eRow._newRecord == -1 && (IsTypedDataTable || (null != _onRowDeletedDelegate))) " is 123.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,RaiseRowChanging,The length of the statement  "            else if (DataRowAction.Delete == eAction && eRow._newRecord != -1 && (IsTypedDataTable || (null != _onRowDeletingDelegate))) " is 124.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,Select,The length of the statement  "            DataCommonEventSource.Log.Trace("<ds.DataTable.Select|API> {0}' filterExpression='{1}'' sort='{2}'"' ObjectID' filterExpression' sort); " is 135.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,Select,The length of the statement  "            DataCommonEventSource.Log.Trace("<ds.DataTable.Select|API> {0}' filterExpression='{1}'' sort='{2}'' recordStates={3}"' ObjectID' filterExpression' sort' recordStates); " is 167.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SetNewRecord,The length of the statement  "            SetNewRecordWorker(row' proposedRecord' action' isInMerge' suppressEnsurePropertyChanged' -1' fireEvent' out deferredException); // we are going to call below overload from insert " is 179.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SetNewRecordWorker,The length of the statement  "            // 6) Evaluate all Expressions (exceptions are deferred)- this will fire ListChanged & PropertyChanged events on associated views " is 129.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SetNewRecordWorker,The length of the statement  "            // if the newRecord is changing' the propertychanged event should be allowed to triggered for ListChangedType.Changed or .Moved " is 127.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,LoadDataRow,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataTable.LoadDataRow|API> {0}' fAcceptChanges={1}"' ObjectID' fAcceptChanges); " is 139.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,LoadDataRow,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataTable.LoadDataRow|API> {0}' loadOption={1}"' ObjectID' loadOption); " is 131.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,AddUniqueKey,The length of the statement  "            { // we do have a problem and Imy idea is it is bug. Ask Enzo while Code review. Why we do not set ordinal when we call AddAt? " is 126.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,Merge,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataTable.Merge|API> {0}' table={1}' preserveChanges={2}' missingSchemaAction={3}"' ObjectID' (table != null) ? table.ObjectID : 0' preserveChanges' missingSchemaAction); " is 230.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,Load,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataTable.Load|API> {0}' loadOption={1}"' ObjectID' loadOption); " is 124.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,WriteXml,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataTable.WriteXml|API> {0}' fileName='{1}'' mode={2}"' ObjectID' fileName' mode); " is 142.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ReadXml,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataTable.ReadXml|INFO> {0}' denyResolving={1}"' ObjectID' denyResolving); " is 134.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ReadXml,The length of the statement  "                        if (reader.LocalName == Keywords.XSD_SCHEMA && reader.NamespaceURI.StartsWith(Keywords.XSD_NS_START' StringComparison.Ordinal)) " is 127.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ReadXml,The length of the statement  "                            { // we should not throw for constraint' we already will throw for unsupported schema' so restore enforce cost' but not via property " is 132.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ReadXml,The length of the statement  "                            if (reader.LocalName == Keywords.XSD_SCHEMA && reader.NamespaceURI.StartsWith(Keywords.XSD_NS_START' StringComparison.Ordinal)) " is 127.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ReadXml,The length of the statement  "                                    // we should not throw for constraint' we already will throw for unsupported schema' so restore enforce cost' but not via property " is 130.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ReadXml,The length of the statement  "                        if (reader.LocalName == Keywords.XSD_SCHEMA && reader.NamespaceURI.StartsWith(Keywords.XSD_NS_START' StringComparison.Ordinal)) " is 127.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ReadXml,The length of the statement  "                                // we should not throw for constraint' we already will throw for unsupported schema' so restore enforce cost' but not via property " is 130.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ReadXml,The length of the statement  "                        if (reader.LocalName == Keywords.XSD_SCHEMA && reader.NamespaceURI.StartsWith(Keywords.XSD_NS_START' StringComparison.Ordinal)) " is 127.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ReadXml,The length of the statement  "                                // we should not throw for constraint' we already will throw for unsupported schema' so restore enforce cost' but not via property " is 130.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,MoveToElement,The length of the statement  "            while (!reader.EOF && reader.NodeType != XmlNodeType.EndElement && reader.NodeType != XmlNodeType.Element && reader.Depth > depth) " is 130.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ReadXmlSchema,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataTable.ReadXmlSchema|INFO> {0}' denyResolving={1}"' ObjectID' denyResolving); " is 140.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ReadXmlSchema,The length of the statement  "                    string CurrentTableName = CurrentTableFullName.Substring(nsSeperator + 1' CurrentTableFullName.Length - nsSeperator - 1); " is 121.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ReadXmlSchema,The length of the statement  "                            ForeignKeyConstraint fkc = tempConstrain as ForeignKeyConstraint;  // we have already cloned the UKC when cloning the datatable " is 127.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,EvaluateExpressions,The length of the statement  "            else if ((action == DataRowAction.Delete || (action == DataRowAction.Rollback && row._oldRecord == -1 && row._newRecord == -1)) && _dependentColumns != null) " is 157.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,EvaluateExpressions,The length of the statement  "                            relatedRow.Table.EvaluateDependentExpressions(relatedRow.Table._dependentColumns' relatedRow' DataRowVersion.Original' null); " is 125.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,EvaluateExpressions,The length of the statement  "                            relatedRow.Table.EvaluateDependentExpressions(relatedRow.Table._dependentColumns' relatedRow' DataRowVersion.Current' null); " is 124.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,EvaluateExpressions,The length of the statement  "                            relatedRow.Table.EvaluateDependentExpressions(relatedRow.Table._dependentColumns' relatedRow' DataRowVersion.Proposed' null); " is 125.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,EvaluateDependentExpressions,The length of the statement  "                        SilentlySetValue(row' dc' version' dc.DataExpression == null ? dc.DefaultValue : dc.DataExpression.Evaluate(row' version)); " is 123.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,EvaluateDependentExpressions,The length of the statement  "                            if (cachedRow != null && ((cachedRow.RowState != DataRowState.Deleted) && (version != DataRowVersion.Original || cachedRow._oldRecord != -1))) " is 142.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,EvaluateDependentExpressions,The length of the statement  "                            if (parentRow != null && ((parentRow.RowState != DataRowState.Deleted) && (version != DataRowVersion.Original || parentRow._oldRecord != -1))) " is 142.
Long Statement,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,EvaluateDependentExpressions,The length of the statement  "                            if (childRow != null && ((childRow.RowState != DataRowState.Deleted) && (version != DataRowVersion.Original || childRow._oldRecord != -1))) " is 139.
Long Statement,System.Data,DSRowDiffIdUsageSection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,Prepare,The length of the statement  "                    Debug.Assert(!RowDiffIdUsageSection.t_usedTables.Contains(table)' "Nested call with same table can cause data corruption!"); " is 124.
Long Statement,System.Data,DataTableCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableCollection.cs,Add,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataTableCollection.Add|API> {0}' table={1}"' ObjectID' (table != null) ? table.ObjectID : 0); " is 154.
Long Statement,System.Data,DataTableCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableCollection.cs,CanRemove,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataTableCollection.CanRemove|INFO> {0}' table={1}' fThrowException={2}"' ObjectID' (table != null) ? table.ObjectID : 0' fThrowException); " is 199.
Long Statement,System.Data,DataTableCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableCollection.cs,CanRemove,The length of the statement  "                for (ParentForeignKeyConstraintEnumerator constraints = new ParentForeignKeyConstraintEnumerator(_dataSet' table); constraints.GetNext();) " is 138.
Long Statement,System.Data,DataTableCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableCollection.cs,CanRemove,The length of the statement  "                    if (constraint.Table == table && constraint.RelatedTable == table) // we can go with (constraint.Table ==  constraint.RelatedTable) " is 131.
Long Statement,System.Data,DataTableCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableCollection.cs,CanRemove,The length of the statement  "                for (ChildForeignKeyConstraintEnumerator constraints = new ChildForeignKeyConstraintEnumerator(_dataSet' table); constraints.GetNext();) " is 136.
Long Statement,System.Data,DataTableCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableCollection.cs,RegisterName,The length of the statement  "            DataCommonEventSource.Log.Trace("<ds.DataTableCollection.RegisterName|INFO> {0}' name='{1}'' tbNamespace='{2}'"' ObjectID' name' tbNamespace); " is 142.
Long Statement,System.Data,DataTableCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableCollection.cs,Remove,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataTableCollection.Remove|API> {0}' table={1}"' ObjectID' (table != null) ? table.ObjectID : 0); " is 157.
Long Statement,System.Data,DataTableCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableCollection.cs,RemoveAt,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataTableCollection.RemoveAt|API> {0}' index={1}"' ObjectID' index); " is 128.
Long Statement,System.Data,DataTableCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableCollection.cs,Remove,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataTableCollection.Remove|API> {0}' name='{1}'"' ObjectID' name); " is 126.
Long Statement,System.Data,DataTableReader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableReader.cs,GetSchemaTable,The length of the statement  "            // each time' we just get schema table of current table for once' no need to recreate each time' if schema is changed' reader is already " is 136.
Long Statement,System.Data,DataTableReader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableReader.cs,NextResult,The length of the statement  "                _listener.UpdataTable(_currentDataTable); // it will unsubscribe from preveous tables events and subscribe to new table's events " is 128.
Long Statement,System.Data,DataTableReader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableReader.cs,GetValues,The length of the statement  "            Array.Copy(_currentDataRow.ItemArray' values' _currentDataRow.ItemArray.Length > values.Length ? values.Length : _currentDataRow.ItemArray.Length); " is 147.
Long Statement,System.Data,DataTableReader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableReader.cs,ValidateReader,The length of the statement  "                throw ExceptionBuilder.DataTableReaderSchemaIsInvalid(_currentDataTable.TableName); // may be we can use better error message! " is 126.
Long Statement,System.Data,DataTableReader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableReader.cs,ValidateState,The length of the statement  "            //See if without any event raing' if our rows are deleted' or removed! Reader is not invalid' user should be able to read and reach goo row " is 139.
Long Statement,System.Data,DataTableReader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableReader.cs,ValidateState,The length of the statement  "            if ((_currentDataRow.RowState == DataRowState.Deleted) || (_currentDataRow.RowState == DataRowState.Detached) || _currentRowRemoved) " is 132.
Long Statement,System.Data,DataTableReader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableReader.cs,ValidateState,The length of the statement  "            // user may have called clear (which removes the rows without raing event) or deleted part of rows without raising event!if so reader is invalid. " is 145.
Long Statement,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,Delete,The length of the statement  "                long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataView.Delete|API> {0}' row={1}"' ObjectID' row._objectID); " is 121.
Long Statement,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,IndexOfDataRowView,The length of the statement  "            return _index.GetIndex(rowview.Row.GetRecordFromVersion(rowview.Row.GetDefaultRowVersion(RowStateFilter) & ~DataRowVersion.Proposed)); " is 134.
Long Statement,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,OnListChanged,The length of the statement  "            DataCommonEventSource.Log.Trace("<ds.DataView.OnListChanged|INFO> {0}' ListChangedType={1}"' ObjectID' e.ListChangedType); " is 122.
Long Statement,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,OnListChanged,The length of the statement  "                        Debug.Assert(((ListChangedType.ItemChanged == e.ListChangedType) && ((e.NewIndex == e.OldIndex) || (-1 == e.OldIndex))) || " is 122.
Long Statement,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,OnListChanged,The length of the statement  "                        ListChangedEventArgs newEventArg = new ListChangedEventArgs(e.ListChangedType' e.NewIndex' new DataColumnPropertyDescriptor(col)); " is 130.
Long Statement,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,ResetRowViewCache,The length of the statement  "            Dictionary<DataRow' DataRowView> rvc = new Dictionary<DataRow' DataRowView>(CountFromIndex' DataRowReferenceComparer.s_default); " is 128.
Long Statement,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,SetIndex2,The length of the statement  "            DataCommonEventSource.Log.Trace("<ds.DataView.SetIndex|INFO> {0}' newSort='{1}'' newRowStates={2}"' ObjectID' newSort' newRowStates); " is 133.
Long Statement,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,UpdateIndex,The length of the statement  "            long logScopeId = DataCommonEventSource.Log.EnterScope("<ds.DataView.UpdateIndex|INFO> {0}' force={1}"' ObjectID' force); " is 121.
Long Statement,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,ChildRelationCollectionChanged,The length of the statement  "                e.Action == CollectionChangeAction.Add ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorAdded' new DataRelationPropertyDescriptor((System.Data.DataRelation)e.Element)) : " is 181.
Long Statement,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,ChildRelationCollectionChanged,The length of the statement  "                e.Action == CollectionChangeAction.Refresh ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorChanged' NullProp) : " is 124.
Long Statement,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,ChildRelationCollectionChanged,The length of the statement  "                e.Action == CollectionChangeAction.Remove ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorDeleted' new DataRelationPropertyDescriptor((System.Data.DataRelation)e.Element)) : " is 186.
Long Statement,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,ParentRelationCollectionChanged,The length of the statement  "                e.Action == CollectionChangeAction.Add ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorAdded' new DataRelationPropertyDescriptor((System.Data.DataRelation)e.Element)) : " is 181.
Long Statement,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,ParentRelationCollectionChanged,The length of the statement  "                e.Action == CollectionChangeAction.Refresh ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorChanged' NullProp) : " is 124.
Long Statement,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,ParentRelationCollectionChanged,The length of the statement  "                e.Action == CollectionChangeAction.Remove ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorDeleted' new DataRelationPropertyDescriptor((System.Data.DataRelation)e.Element)) : " is 186.
Long Statement,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,ColumnCollectionChanged,The length of the statement  "                e.Action == CollectionChangeAction.Add ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorAdded' new DataColumnPropertyDescriptor((System.Data.DataColumn)e.Element)) : " is 177.
Long Statement,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,ColumnCollectionChanged,The length of the statement  "                e.Action == CollectionChangeAction.Refresh ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorChanged' NullProp) : " is 124.
Long Statement,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,ColumnCollectionChanged,The length of the statement  "                e.Action == CollectionChangeAction.Remove ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorDeleted' new DataColumnPropertyDescriptor((System.Data.DataColumn)e.Element)) : " is 182.
Long Statement,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,ToTable,The length of the statement  "            DataCommonEventSource.Log.Trace("<ds.DataView.ToTable|API> {0}' TableName='{1}'' distinct={2}"' ObjectID' tableName' distinct); " is 127.
Long Statement,System.Data,DataViewListener,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataViewListener.cs,RegisterMetaDataEvents,The length of the statement  "                ((DataRelationCollection.DataTableRelationCollection)(table.ChildRelations)).RelationPropertyChanged += handlerChildRelation; " is 125.
Long Statement,System.Data,DataViewListener,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataViewListener.cs,RegisterMetaDataEvents,The length of the statement  "                ((DataRelationCollection.DataTableRelationCollection)(table.ParentRelations)).RelationPropertyChanged += handlerParentRelation; " is 127.
Long Statement,System.Data,DataViewListener,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataViewListener.cs,UnregisterMetaDataEvents,The length of the statement  "                ((DataRelationCollection.DataTableRelationCollection)(table.ChildRelations)).RelationPropertyChanged -= handlerChildRelation; " is 125.
Long Statement,System.Data,DataViewListener,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataViewListener.cs,UnregisterMetaDataEvents,The length of the statement  "                ((DataRelationCollection.DataTableRelationCollection)(table.ParentRelations)).RelationPropertyChanged -= handlerParentRelation; " is 127.
Long Statement,System.Data,DataViewManager,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataViewManager.cs,TableCollectionChanged,The length of the statement  "                e.Action == CollectionChangeAction.Add ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorAdded' new DataTablePropertyDescriptor((System.Data.DataTable)e.Element)) : " is 175.
Long Statement,System.Data,DataViewManager,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataViewManager.cs,TableCollectionChanged,The length of the statement  "                e.Action == CollectionChangeAction.Refresh ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorChanged' NullProp) : " is 124.
Long Statement,System.Data,DataViewManager,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataViewManager.cs,TableCollectionChanged,The length of the statement  "                e.Action == CollectionChangeAction.Remove ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorDeleted' new DataTablePropertyDescriptor((System.Data.DataTable)e.Element)) : " is 180.
Long Statement,System.Data,DataViewManager,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataViewManager.cs,RelationCollectionChanged,The length of the statement  "                e.Action == CollectionChangeAction.Add ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorAdded' new DataRelationPropertyDescriptor((System.Data.DataRelation)e.Element)) : " is 181.
Long Statement,System.Data,DataViewManager,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataViewManager.cs,RelationCollectionChanged,The length of the statement  "                e.Action == CollectionChangeAction.Refresh ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorChanged' NullProp) : " is 124.
Long Statement,System.Data,DataViewManager,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataViewManager.cs,RelationCollectionChanged,The length of the statement  "                e.Action == CollectionChangeAction.Remove ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorDeleted' new DataRelationPropertyDescriptor((System.Data.DataRelation)e.Element)) : " is 186.
Long Statement,System.Data,ForeignKeyConstraint,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ForeignKeyConstraint.cs,IsConstraintViolated,The length of the statement  "                        string error = SR.Format(SR.DataConstraint_ForeignKeyViolation' ConstraintName' ExceptionBuilder.KeysToString(childValues)); " is 124.
Long Statement,System.Data,ForeignKeyConstraint,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ForeignKeyConstraint.cs,CascadeCommit,The length of the statement  "                Index childIndex = _childKey.GetSortIndex(row.RowState == DataRowState.Deleted ? DataViewRowState.Deleted : DataViewRowState.CurrentRows); " is 138.
Long Statement,System.Data,ForeignKeyConstraint,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ForeignKeyConstraint.cs,CascadeCommit,The length of the statement  "                object[] key = row.GetKeyValues(_parentKey' row.RowState == DataRowState.Deleted ? DataRowVersion.Original : DataRowVersion.Default); " is 133.
Long Statement,System.Data,ForeignKeyConstraint,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ForeignKeyConstraint.cs,CascadeRollback,The length of the statement  "            Index childIndex = _childKey.GetSortIndex(row.RowState == DataRowState.Deleted ? DataViewRowState.OriginalRows : DataViewRowState.CurrentRows); " is 143.
Long Statement,System.Data,ForeignKeyConstraint,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ForeignKeyConstraint.cs,CascadeRollback,The length of the statement  "            object[] key = row.GetKeyValues(_parentKey' row.RowState == DataRowState.Modified ? DataRowVersion.Current : DataRowVersion.Default); " is 133.
Long Statement,System.Data,ForeignKeyConstraint,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ForeignKeyConstraint.cs,CheckCanRemoveParentRow,The length of the statement  "            Debug.Assert(Table.DataSet != null' "Relation " + ConstraintName + " isn't part of a DataSet' so this check shouldn't be happening."); " is 134.
Long Statement,System.Data,ForeignKeyConstraint,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ForeignKeyConstraint.cs,CheckCascade,The length of the statement  "            Debug.Assert(Table.DataSet != null' "ForeignKeyConstraint " + ConstraintName + " isn't part of a DataSet' so this check shouldn't be happening."); " is 146.
Long Statement,System.Data,ForeignKeyConstraint,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ForeignKeyConstraint.cs,CheckConstraint,The length of the statement  "                        object[] parentKeyValues = parentRow.GetKeyValues(_parentKey' action == DataRowAction.Rollback ? version : DataRowVersion.Default); " is 131.
Long Statement,System.Data,ForeignKeyConstraint,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ForeignKeyConstraint.cs,NonVirtualCheckState,The length of the statement  "                        ((_parentKey.ColumnsReference[i].DataType == typeof(DateTime)) && (_parentKey.ColumnsReference[i].DateTimeMode != _childKey.ColumnsReference[i].DateTimeMode) && ((_parentKey.ColumnsReference[i].DateTimeMode & _childKey.ColumnsReference[i].DateTimeMode) != DataSetDateTime.Unspecified))) " is 286.
Long Statement,System.Data,Merger,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Merger.cs,MergeDataSet,The length of the statement  "                        targetTable = _dataSet.Tables[sourceTable.TableName' sourceTable.Namespace];// we know that target table won't be null since MissingSchemaAction is Add ' we have already added it! " is 179.
Long Statement,System.Data,Merger,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Merger.cs,MergeRows,The length of the statement  "                        ndxSearch = new Index(dst' dst._primaryKey.Key.GetIndexDesc()' DataViewRowState.OriginalRows | DataViewRowState.Added' null); " is 125.
Long Statement,System.Data,Merger,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Merger.cs,MergeSchema,The length of the statement  "                // in case of standalone table' we make sure that targetTable is not null' so if this check passes' it will be when it is called via detaset " is 140.
Long Statement,System.Data,Merger,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Merger.cs,MergeSchema,The length of the statement  "                    targetTable = table.Clone(table.DataSet); // if we are here mainly we are called from DataSet.Merge at this point we don't set " is 126.
Long Statement,System.Data,Merger,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Merger.cs,MergeSchema,The length of the statement  "                    //expression columns' since it might have refer to other columns via relation' so it won't find the table and we get exception; " is 127.
Long Statement,System.Data,Merger,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Merger.cs,MergeSchema,The length of the statement  "                                    _dataSet.RaiseMergeFailed(targetTable' SR.Format(SR.DataMerge_MissingColumnDefinition' table.TableName' src.ColumnName)' _missingSchemaAction); " is 143.
Long Statement,System.Data,Merger,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Merger.cs,MergeSchema,The length of the statement  "                                ((dest.DataType == typeof(DateTime)) && (dest.DateTimeMode != src.DateTimeMode) && ((dest.DateTimeMode & src.DateTimeMode) != DataSetDateTime.Unspecified))) " is 156.
Long Statement,System.Data,Merger,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Merger.cs,MergeSchema,The length of the statement  "                                    _dataSet.RaiseMergeFailed(targetTable' SR.Format(SR.DataMerge_DataTypeMismatch' src.ColumnName)' MissingSchemaAction.Error); " is 124.
Long Statement,System.Data,Merger,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Merger.cs,MergeRelation,The length of the statement  "                    Debug.Assert(MissingSchemaAction.Error == _missingSchemaAction' "Unexpected value of MissingSchemaAction parameter : " + _missingSchemaAction.ToString()); " is 154.
Long Statement,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetIndexOfPageWithFreeSlot,The length of the statement  "                        pageSegmentMap |= pageWithFreeSlot; // found "reset bit"' but unallocated page' mark it as unavaiable and continue search " is 121.
Long Statement,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetNewNode,The length of the statement  "                page = AllocPage(64 * 1024);          // Page size to accomodate more than 16 million slots (Max 2 Billion and 16 million slots) " is 128.
Long Statement,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,LeftRotate,The length of the statement  "                SetSubTreeSize(x_id' (SubTreeSize(Left(x_id)) + SubTreeSize(Right(x_id)) + (Next(x_id) == NIL ? 1 : SubTreeSize(Next(x_id))))); " is 127.
Long Statement,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,LeftRotate,The length of the statement  "                SetSubTreeSize(y_id' (SubTreeSize(Left(y_id)) + SubTreeSize(Right(y_id)) + (Next(y_id) == NIL ? 1 : SubTreeSize(Next(y_id))))); " is 127.
Long Statement,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,RightRotate,The length of the statement  "                SetSubTreeSize(x_id' (SubTreeSize(Left(x_id)) + SubTreeSize(Right(x_id)) + (Next(x_id) == NIL ? 1 : SubTreeSize(Next(x_id))))); " is 127.
Long Statement,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,RightRotate,The length of the statement  "                SetSubTreeSize(y_id' (SubTreeSize(Left(y_id)) + SubTreeSize(Right(y_id)) + (Next(y_id) == NIL ? 1 : SubTreeSize(Next(y_id))))); " is 127.
Long Statement,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,RBDeleteX,The length of the statement  "                root_id = RBDeleteFixup(root_id' x_id' py_id' mainTreeNodeID); // passing x.parent as y.parent' to handle x=Node.NIL case. " is 122.
Long Statement,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,RecomputeSize,The length of the statement  "            int myCorrectSize = SubTreeSize(Left(nodeId)) + SubTreeSize(Right(nodeId)) + (Next(nodeId) == NIL ? 1 : SubTreeSize(Next(nodeId))); " is 131.
Long Statement,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,VerifySize,The length of the statement  "            int myCorrectSize = SubTreeSize(Left(nodeId)) + SubTreeSize(Right(nodeId)) + (Next(nodeId) == NIL ? 1 : SubTreeSize(Next(nodeId))); " is 131.
Long Statement,System.Data,TreePage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,AllocSlot,The length of the statement  "                            Debug.Assert((_slotMap[segmentPos] & freeSlot) == 0' "Slot position segment[segmentPos ]: [freeSlot] is in use. Expected to be empty"); " is 135.
Long Statement,System.Data,RelatedView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RelatedView.cs,Equals,The length of the statement  "                return (CompareArray(_childKey.ColumnsReference' other._childKey.ColumnsReference) && CompareArray(_filterValues' other._filterValues)); " is 136.
Long Statement,System.Data,RelationshipConverter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RelationshipConverter.cs,ConvertTo,The length of the statement  "                    ctor = typeof(DataRelation).GetConstructor(new Type[] { typeof(string) /*relationName*/' typeof(string) /*parentTableName*/' typeof(string) /*childTableName */' " is 160.
Long Statement,System.Data,RelationshipConverter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RelationshipConverter.cs,ConvertTo,The length of the statement  "                    values = new object[] { rel.RelationName' rel.ParentKey.Table.TableName' rel.ChildKey.Table.TableName' rel.ParentColumnNames' rel.ChildColumnNames' rel.Nested }; " is 161.
Long Statement,System.Data,RelationshipConverter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RelationshipConverter.cs,ConvertTo,The length of the statement  "                    ctor = typeof(DataRelation).GetConstructor(new Type[] { typeof(string)/*relationName*/' typeof(string)/*parentTableName*/' typeof(string)/*parentTableNamespace*/' " is 162.
Long Statement,System.Data,RelationshipConverter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RelationshipConverter.cs,ConvertTo,The length of the statement  "                    values = new object[] { rel.RelationName' rel.ParentKey.Table.TableName' rel.ParentKey.Table.Namespace' rel.ChildKey.Table.TableName' " is 133.
Long Statement,System.Data,Select,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Select.cs,AnalyzeExpression,The length of the statement  "                        while (unaryNode._op == Operators.Noop && unaryNode._right is UnaryNode && ((UnaryNode)unaryNode._right)._op == Operators.Noop) " is 127.
Long Statement,System.Data,Select,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Select.cs,AnalyzeExpression,The length of the statement  "                        while (unaryNode._op == Operators.Noop && unaryNode._right is UnaryNode && ((UnaryNode)unaryNode._right)._op == Operators.Noop) " is 127.
Long Statement,System.Data,Select,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Select.cs,AnalyzeExpression,The length of the statement  "            _linearExpression = (_linearExpression == null ? expr : new BinaryNode(_table' Operators.And' expr' _linearExpression)); " is 120.
Long Statement,System.Data,Select,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Select.cs,BuildLinearExpression,The length of the statement  "            //            Debug.Assert(matchedCandidates==1 || candidateColumns[matchedCandidates-1].equalsOperator' "BuildLinearExpression : Invalid matched candidates"); " is 159.
Long Statement,System.Data,Select,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Select.cs,BuildLinearExpression,The length of the statement  "                            _linearExpression = (_linearExpression == null ? _candidateColumns[i].expr : new BinaryNode(_table' Operators.And' _candidateColumns[i].expr' _linearExpression)); " is 162.
Long Statement,System.Data,Select,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Select.cs,Eval,The length of the statement  "                    ((isLConst && !isRConst && (leftType == StorageType.String) && (rightType == StorageType.Guid) && (null != (namedNode = expr._right as NameNode)) && (namedNode._column.DataType == typeof(Guid))) || " is 197.
Long Statement,System.Data,Select,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Select.cs,Eval,The length of the statement  "                     (isRConst && !isLConst && (rightType == StorageType.String) && (leftType == StorageType.Guid) && (null != (namedNode = expr._left as NameNode)) && (namedNode._column.DataType == typeof(Guid)))) " is 193.
Long Statement,System.Data,Index,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Selection.cs,CompareRecords,The length of the statement  "                return _table.Rows.IndexOf(_table._recordManager[record1]).CompareTo(_table.Rows.IndexOf(_table._recordManager[record2])); " is 122.
Long Statement,System.Data,Index,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Selection.cs,CompareDuplicateRecords,The length of the statement  "                diff = ((int)_table._recordManager[record1].GetRecordState(record1)).CompareTo((int)_table._recordManager[record2].GetRecordState(record2)); " is 140.
Long Statement,System.Data,Index,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Selection.cs,DeleteRecord,The length of the statement  "            DataCommonEventSource.Log.Trace("<ds.Index.DeleteRecord|INFO> {0}' recordIndex={1}' fireEvent={2}"' ObjectID' recordIndex' fireEvent); " is 134.
Long Statement,System.Data,Index,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Selection.cs,GetReplaceAction,The length of the statement  "            return ((0 != (DataViewRowState.CurrentRows & oldState)) ? ReplaceNewRecordForCompare :    // Added/ModifiedCurrent/Unchanged " is 125.
Long Statement,System.Data,Index,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Selection.cs,InsertRecord,The length of the statement  "            DataCommonEventSource.Log.Trace("<ds.Index.InsertRecord|INFO> {0}' record={1}' fireEvent={2}"' ObjectID' record' fireEvent); " is 124.
Long Statement,System.Data,Index,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Selection.cs,RecordChanged,The length of the statement  "            DataCommonEventSource.Log.Trace("<ds.Index.RecordChanged|API> {0}' oldIndex={1}' newIndex={2}"' ObjectID' oldIndex' newIndex); " is 126.
Long Statement,System.Data,Index,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Selection.cs,RecordStateChanged,The length of the statement  "            DataCommonEventSource.Log.Trace("<ds.Index.RecordStateChanged|API> {0}' record={1}' oldState={2}' newState={3}"' ObjectID' record' oldState' newState); " is 151.
Long Statement,System.Data,Index,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Selection.cs,RecordStateChanged,The length of the statement  "            DataCommonEventSource.Log.Trace("<ds.Index.RecordStateChanged|API> {0}' oldRecord={1}' oldOldState={2}' oldNewState={3}' newRecord={4}' newOldState={5}' newNewState={6}"' " is 170.
Long Statement,System.Data,Index,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Selection.cs,RecordStateChanged,The length of the statement  "                        OnListChanged(ListChangedType.ItemChanged' newRecordIndex' oldRecordIndex); // be carefull remove oldrecord index if needed " is 123.
Long Statement,System.Data,UniqueConstraint,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\UniqueConstraint.cs,AssertConstraintAndKeyIndexes,The length of the statement  "            // ideally' we would like constraintIndex and key.GetSortIndex to share the same index underneath: Debug.Assert(_constraintIndex == key.GetSortIndex) " is 149.
Long Statement,System.Data,UniqueConstraint,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\UniqueConstraint.cs,AssertConstraintAndKeyIndexes,The length of the statement  "            // but' there is a scenario where constraint and key indexes are built from the same list of columns but in a different order " is 125.
Long Statement,System.Data,UniqueConstraint,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\UniqueConstraint.cs,AssertConstraintAndKeyIndexes,The length of the statement  "            Debug.Assert(DataKey.ColumnsEqual(_key.ColumnsReference' sortIndexColumns)' "UniqueConstraint index columns do not match the key sort index"); " is 142.
Long Statement,System.Data,UniqueConstraint,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\UniqueConstraint.cs,CanBeRemovedFromCollection,The length of the statement  "                Debug.Assert(constraints.Table._primaryKey == this' "If the primary key and this are 'Equal'' they should also be '=='"); " is 121.
Long Statement,System.Data,UniqueConstraint,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\UniqueConstraint.cs,CanBeRemovedFromCollection,The length of the statement  "            for (ParentForeignKeyConstraintEnumerator cs = new ParentForeignKeyConstraintEnumerator(Table.DataSet' Table); cs.GetNext();) " is 125.
Long Statement,System.Data,UniqueConstraint,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\UniqueConstraint.cs,Clone,The length of the statement  "                iDest = destination.Tables.IndexOf(Table.TableName' Table.Namespace' false);// pass false for last param to be backward compatable " is 130.
Long Statement,System.Data,ExpressionParser,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\ExpressionParser.cs,Parse,The length of the statement  "                                    Debug.Assert(_topNode > 0 && NodePeek().GetType() == typeof(FunctionNode)' "The function node should be created on '('"); " is 121.
Long Statement,System.Data,ExprException,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FilterException.cs,UnknownToken,The length of the statement  "            return _Syntax(SR.Format(SR.Expr_UnknownToken1' tokExpected.ToString()' tokCurr.ToString()' position.ToString(CultureInfo.InvariantCulture))); " is 142.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,Eval,The length of the statement  "            Debug.Assert(_argumentCount == s_funcs[_info]._argumentCount || s_funcs[_info]._isVariantArgumentList' "Invalid argument argumentCount."); " is 138.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,Eval,The length of the statement  "            { // We do not want to evaluate arguments of IIF' we will already do it in EvalFunction/ second point: we may go to div by 0 " is 124.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,Eval,The length of the statement  "                            if (s_funcs[_info]._parameters[i] == typeof(int) && ExpressionNode.IsInteger(DataStorage.GetStorageType(argumentValues[i].GetType()))) " is 134.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,Eval,The length of the statement  "                            else if ((s_funcs[_info]._id == FunctionId.Trim) || (s_funcs[_info]._id == FunctionId.Substring) || (s_funcs[_info]._id == FunctionId.Len)) " is 139.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,IsConstant,The length of the statement  "            Debug.Assert(_info > -1' "All function nodes should be bound at this point.");  // default info is -1' it means if not bounded' it should be -1' not 0!! " is 152.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,Optimize,The length of the statement  "            Debug.Assert(_info > -1' "Optimizing unbound function "); // default info is -1' it means if not bounded' it should be -1' not 0!! " is 130.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The length of the statement  "                    Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider)); " is 146.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The length of the statement  "                    Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider)); " is 146.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The length of the statement  "                    Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider)); " is 146.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The length of the statement  "                    Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider)); " is 146.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The length of the statement  "                    Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider)); " is 146.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The length of the statement  "                    Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider)); " is 146.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The length of the statement  "                    Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider)); " is 146.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The length of the statement  "                    Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider)); " is 146.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The length of the statement  "                    Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name); " is 133.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The length of the statement  "                    Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name); " is 178.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The length of the statement  "                    Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name); " is 138.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The length of the statement  "                    Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name); " is 137.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The length of the statement  "                        Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider)); " is 146.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The length of the statement  "                        Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name); " is 133.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The length of the statement  "                                return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider); " is 161.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The length of the statement  "                                return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider); " is 163.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The length of the statement  "                                return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider); " is 166.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The length of the statement  "                            if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2]) " is 125.
Long Statement,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The length of the statement  "                    return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0)); " is 120.
Long Statement,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,BinaryCompare,The length of the statement  "                                if (((vLeft.GetType() == typeof(SqlBoolean)) && ((vRight.GetType() == typeof(SqlBoolean)) || (vRight.GetType() == typeof(bool)))) || " is 132.
Long Statement,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,BinaryCompare,The length of the statement  "                                    ((vRight.GetType() == typeof(SqlBoolean)) && ((vLeft.GetType() == typeof(SqlBoolean)) || (vLeft.GetType() == typeof(bool))))) " is 125.
Long Statement,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The length of the statement  "                                    value = Convert.ToByte((Convert.ToByte(vLeft' FormatProvider) + Convert.ToByte(vRight' FormatProvider))' FormatProvider); " is 121.
Long Statement,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The length of the statement  "                                    value = Convert.ToSByte((Convert.ToSByte(vLeft' FormatProvider) + Convert.ToSByte(vRight' FormatProvider))' FormatProvider); " is 124.
Long Statement,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The length of the statement  "                                    value = Convert.ToInt16((Convert.ToInt16(vLeft' FormatProvider) + Convert.ToInt16(vRight' FormatProvider))' FormatProvider); " is 124.
Long Statement,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The length of the statement  "                                    value = Convert.ToUInt16((Convert.ToUInt16(vLeft' FormatProvider) + Convert.ToUInt16(vRight' FormatProvider))' FormatProvider); " is 127.
Long Statement,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The length of the statement  "                                    value = Convert.ToByte((Convert.ToByte(vLeft' FormatProvider) - Convert.ToByte(vRight' FormatProvider))' FormatProvider); " is 121.
Long Statement,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The length of the statement  "                                    value = Convert.ToSByte((Convert.ToSByte(vLeft' FormatProvider) - Convert.ToSByte(vRight' FormatProvider))' FormatProvider); " is 124.
Long Statement,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The length of the statement  "                                    value = Convert.ToInt16((Convert.ToInt16(vLeft' FormatProvider) - Convert.ToInt16(vRight' FormatProvider))' FormatProvider); " is 124.
Long Statement,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The length of the statement  "                                    value = Convert.ToUInt16((Convert.ToUInt16(vLeft' FormatProvider) - Convert.ToUInt16(vRight' FormatProvider))' FormatProvider); " is 127.
Long Statement,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The length of the statement  "                                    value = Convert.ToByte((Convert.ToByte(vLeft' FormatProvider) * Convert.ToByte(vRight' FormatProvider))' FormatProvider); " is 121.
Long Statement,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The length of the statement  "                                    value = Convert.ToSByte((Convert.ToSByte(vLeft' FormatProvider) * Convert.ToSByte(vRight' FormatProvider))' FormatProvider); " is 124.
Long Statement,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The length of the statement  "                                    value = Convert.ToInt16((Convert.ToInt16(vLeft' FormatProvider) * Convert.ToInt16(vRight' FormatProvider))' FormatProvider); " is 124.
Long Statement,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The length of the statement  "                                    value = Convert.ToUInt16((Convert.ToUInt16(vLeft' FormatProvider) * Convert.ToUInt16(vRight' FormatProvider))' FormatProvider); " is 127.
Long Statement,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The length of the statement  "                                    value = Convert.ToByte((Convert.ToByte(vLeft' FormatProvider) / Convert.ToByte(vRight' FormatProvider))' FormatProvider); " is 121.
Long Statement,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The length of the statement  "                                    value = Convert.ToSByte((Convert.ToSByte(vLeft' FormatProvider) / Convert.ToSByte(vRight' FormatProvider))' FormatProvider); " is 124.
Long Statement,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The length of the statement  "                                    value = Convert.ToInt16((Convert.ToInt16(vLeft' FormatProvider) / Convert.ToInt16(vRight' FormatProvider))' FormatProvider); " is 124.
Long Statement,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The length of the statement  "                                    value = Convert.ToUInt16((Convert.ToUInt16(vLeft' FormatProvider) / Convert.ToUInt16(vRight' FormatProvider))' FormatProvider); " is 127.
Long Statement,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,ResultSqlType,The length of the statement  "                if ((left != StorageType.Boolean && left != StorageType.SqlBoolean) || (right != StorageType.Boolean && right != StorageType.SqlBoolean)) " is 137.
Long Statement,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,ResultSqlType,The length of the statement  "            if ((left == StorageType.SqlBinary && right != StorageType.SqlBinary) || (left != StorageType.SqlBinary && right == StorageType.SqlBinary)) " is 139.
Long Statement,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,ResultSqlType,The length of the statement  "            if ((left == StorageType.SqlGuid && right != StorageType.SqlGuid) || (left != StorageType.SqlGuid && right == StorageType.SqlGuid)) " is 131.
Long Statement,System.Data,LikeNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,Eval,The length of the statement  "            // WhiteSpace Chars Include : 0x9' 0xA' 0xB' 0xC' 0xD' 0x20' 0xA0' 0x2000' 0x2001' 0x2002' 0x2003' 0x2004' 0x2005' 0x2006' 0x2007' 0x2008' 0x2009' 0x200A' 0x200B' 0x3000' and 0xFEFF. " is 182.
Long Statement,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,MappedValues,The length of the statement  "            Debug.Assert(_mappedLength == Math.Min(_readerDataValues.Length' _mappedDataValues.Length)' "incorrect precomputed length"); " is 124.
Long Statement,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,LoadDataRowChapters,The length of the statement  "                                datarowadded += _adapter.FillFromReader(_dataSet' null' chapterTableName' readerHandler' 0' 0' parentChapterColumn' parentChapterValue); " is 136.
Long Statement,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,SetupSchemaWithoutKeyInfo,The length of the statement  "                // We can always just create column if there are no existing column or column mappings' and the mapping action is passthrough " is 125.
Long Statement,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,SetupSchemaWithoutKeyInfo,The length of the statement  "                bool alwaysCreateColumns = ((_dataTable.Columns.Count == 0) && ((_tableMapping.ColumnMappings == null) || (_tableMapping.ColumnMappings.Count == 0)) && (mappingAction == MissingMappingAction.Passthrough)); " is 205.
Long Statement,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,SetupSchemaWithoutKeyInfo,The length of the statement  "                        dataColumn = DataColumnMapping.CreateDataColumnBySchemaAction(_fieldNames[i]' _fieldNames[i]' _dataTable' fieldType' schemaAction); " is 131.
Long Statement,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,SetupSchemaWithoutKeyInfo,The length of the statement  "                    chapterColumn = _tableMapping.GetDataColumn(_tableMapping.SourceTable' fieldType' _dataTable' mappingAction' schemaAction); " is 123.
Long Statement,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,SetupSchemaWithKeyInfo,The length of the statement  "            bool addPrimaryKeys = (((0 == _dataTable.PrimaryKey.Length) && ((4 <= (int)_loadOption) || (0 == _dataTable.Rows.Count))) " is 121.
Long Statement,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,SetupSchemaWithKeyInfo,The length of the statement  "                    string basetable = /*schemaRow.BaseServerName+schemaRow.BaseCatalogName+schemaRow.BaseSchemaName+*/ schemaRow.BaseTableName; " is 124.
Long Statement,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,SetupSchemaWithKeyInfo,The length of the statement  "                            // example SELECT [T2].[ID]' [T2].[ProdID]' [T2].[VendorName] FROM [Vendor] AS [T2]' [Prod] AS [T1] WHERE (([T1].[ProdID] = [T2].[ProdID])) " is 139.
Long Statement,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,SetupSchemaWithKeyInfo,The length of the statement  "                    chapterColumn = _tableMapping.GetDataColumn(_tableMapping.SourceTable' fieldType' _dataTable' mappingAction' schemaAction); " is 123.
Long Statement,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,AddRelation,The length of the statement  "                DataRelation relation = new DataRelation(name' new DataColumn[] { parentChapterColumn }' new DataColumn[] { chapterColumn }' false); " is 132.
Long Statement,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,CalculatePrecision,The length of the statement  "            Debug.Assert(precision == bActualPrecision' string.Format(null' "CalculatePrecision={0}' BActualPrec={1}. Results must be equal!"' precision' bActualPrecision)); " is 161.
Long Statement,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,FGt10_38,The length of the statement  "            Debug.Assert(rglData.Length == 4' "rglData.Length == 4"' "Wrong array length: " + rglData.Length.ToString(CultureInfo.InvariantCulture)); " is 137.
Long Statement,System.Data.SqlTypes,SqlXml,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SqlXml.cs,CreateReader,The length of the statement  "            Debug.Assert(_createSqlReaderMethodInfo != null' "MethodInfo reference for XmlReader.CreateSqlReader should not be null."); " is 123.
Long Statement,System.Data.SqlTypes,SqlXml,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SqlXml.cs,CreateSqlXmlReader,The length of the statement  "            // For particular callers' we need to wrap all exceptions inside a TargetInvocationException to simulate calling CreateSqlReader via MethodInfo.Invoke " is 150.
Long Statement,System.Data.SqlTypes,SqlXml,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SqlXml.cs,CreateSqlReaderDelegate,The length of the statement  "            Debug.Assert(CreateSqlReaderMethodInfo != null' "MethodInfo reference for XmlReader.CreateSqlReader should not be null."); " is 122.
Long Statement,System.Data.SqlTypes,SqlXml,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SqlXml.cs,CreateSqlReaderDelegate,The length of the statement  "            return (Func<Stream' XmlReaderSettings' XmlParserContext' XmlReader>)CreateSqlReaderMethodInfo.CreateDelegate(typeof(Func<Stream' XmlReaderSettings' XmlParserContext' XmlReader>)); " is 180.
Complex Conditional,System.Data.Common,CharStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\CharStorage.cs,Set,The conditional expression  "(ch >= (char)0xd800 && ch <= (char)0xdfff) || (ch < (char)0x21 && (ch == (char)0x9 || ch == (char)0xa || ch == (char)0xd))"  is complex.
Complex Conditional,System.Data.Common,DbCommandBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DBCommandBuilder.cs,BuildInformation,The conditional expression  "(0 != ADP.SrcCompare(baseTableName' tableName))                      || (0 != ADP.SrcCompare(baseSchemaName' schemaName))                      || (0 != ADP.SrcCompare(baseCatalogName' catalogName))                      || (0 != ADP.SrcCompare(baseServerName' serverName))"  is complex.
Complex Conditional,System.Data.Common,DbCommandBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DBCommandBuilder.cs,BuildInformation,The conditional expression  "(null != row) && (row.IsKey || row.IsUnique) && !row.IsLong && !row.IsRowVersion && row.IsHidden"  is complex.
Complex Conditional,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,AppendKeyValuePairBuilder,The conditional expression  "(0 < keyValue.Length) &&                          (('{' == keyValue[0]) || (0 <= keyValue.IndexOf(';')) || (0 == string.Compare(DbConnectionStringKeywords.Driver' keyName' StringComparison.OrdinalIgnoreCase))) &&                          !s_connectionStringQuoteOdbcValueRegex.IsMatch(keyValue)"  is complex.
Complex Conditional,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,UsersConnectionString,The conditional expression  "_hasPasswordKeyword && (forceHidePassword || (hidePassword && !HasPersistablePassword))"  is complex.
Complex Conditional,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,FillSchema,The conditional expression  "DesignMode && ((null == command) || (null == command.Connection) || string.IsNullOrEmpty(command.CommandText))"  is complex.
Complex Conditional,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,UpdateBatchExecute,The conditional expression  "((StatementType.Insert == statementType) || (StatementType.Update == statementType))                          && (0 != (UpdateRowSource.OutputParameters & batchCommand._updatedRowSource)) && (0 != rowAffected)"  is complex.
Complex Conditional,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,UpdateRowExecute,The conditional expression  "((StatementType.Insert == cmdIndex) || (StatementType.Update == cmdIndex))                  && (0 != (UpdateRowSource.OutputParameters & updatedRowSource)) && (0 != rowUpdatedEvent.RecordsAffected)"  is complex.
Complex Conditional,System.Xml,DataPointer,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\DataPointer.cs,NextColumn,The conditional expression  "!_doc.IsNotMapped(c) && (c.ColumnMapping == MappingType.Attribute) == fAttribute && (fNulls || !Convert.IsDBNull(row[c' rowVersion]))"  is complex.
Complex Conditional,System.Data,XDRSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XDRSchema.cs,FindTypeNode,The conditional expression  "(FEqualIdentity(vn' Keywords.XDR_ELEMENTTYPE' Keywords.XDRNS) &&                           FEqualIdentity(node' Keywords.XDR_ELEMENT' Keywords.XDRNS)) ||                          (FEqualIdentity(vn' Keywords.XDR_ATTRIBUTETYPE' Keywords.XDRNS) &&                           FEqualIdentity(node' Keywords.XDR_ATTRIBUTE' Keywords.XDRNS))"  is complex.
Complex Conditional,System.Data,XDRSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XDRSchema.cs,IsTextOnlyContent,The conditional expression  "value == Keywords.EMPTY || value == Keywords.ELTONLY || value == Keywords.ELEMENTONLY || value == Keywords.MIXED"  is complex.
Complex Conditional,System.Data,XmlDataLoader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XmlDataLoader.cs,LoadRows,The conditional expression  "parentElement.LocalName == Keywords.XSD_SCHEMA && parentElement.NamespaceURI == Keywords.XSDNS ||                  parentElement.LocalName == Keywords.SQL_SYNC && parentElement.NamespaceURI == Keywords.UPDGNS ||                  parentElement.LocalName == Keywords.XDR_SCHEMA && parentElement.NamespaceURI == Keywords.XDRNS"  is complex.
Complex Conditional,System.Data,XmlDataLoader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XmlDataLoader.cs,ProcessXsdSchema,The conditional expression  "((object)_dataReader.LocalName == _XDR_SCHEMA && (object)_dataReader.NamespaceURI == _XDRNS) ||                      ((object)_dataReader.LocalName == _SQL_SYNC && (object)_dataReader.NamespaceURI == _UPDGNS)"  is complex.
Complex Conditional,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,AddXdoProperties,The conditional expression  "!((instance is DataSet) || (instance is DataTable) || (instance is DataColumn) || (instance is DataRelation))"  is complex.
Complex Conditional,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,AddXdoProperty,The conditional expression  "bImplementsInullable == false &&                   type != typeof(string) &&     // DO NOT REMOVE THIS CHECK                   type != typeof(bool) &&                   type != typeof(Type) &&                   type != typeof(object) &&                   type != typeof(CultureInfo) &&                   type != typeof(long) &&                   type != typeof(int)"  is complex.
Complex Conditional,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,AddXdoProperty,The conditional expression  "string.Equals(pd.Name' "Namespace"' StringComparison.Ordinal) ||                  string.Equals(pd.Name' "PrimaryKey"' StringComparison.Ordinal) ||                  string.Equals(pd.Name' "ColumnName"' StringComparison.Ordinal) ||                  string.Equals(pd.Name' "DefaultValue"' StringComparison.Ordinal) ||                  string.Equals(pd.Name' "TableName"' StringComparison.Ordinal) ||                  string.Equals(pd.Name' "DataSetName"' StringComparison.Ordinal) ||                  string.Equals(pd.Name' "AllowDBNull"' StringComparison.Ordinal) ||                  string.Equals(pd.Name' "Unique"' StringComparison.Ordinal) ||                  string.Equals(pd.Name' "NestedInDataSet"' StringComparison.Ordinal) ||                  string.Equals(pd.Name' "Locale"' StringComparison.Ordinal) ||                  string.Equals(pd.Name' "CaseSensitive"' StringComparison.Ordinal) ||                  string.Equals(pd.Name' "RemotingFormat"' StringComparison.Ordinal)"  is complex.
Complex Conditional,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,AddXdoProperty,The conditional expression  "(dt.Length == 0) || bImplementsInullable || ((dt == Keywords.XSD_ANYTYPE) && (col.XmlDataType != Keywords.XSD_ANYTYPE)) || (col.DataType == typeof(DateTimeOffset))"  is complex.
Complex Conditional,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,XmlDataTypeName,The conditional expression  "type == typeof(string) || type == typeof(SqlGuid) || type == typeof(SqlString) || type == typeof(SqlChars)"  is complex.
Complex Conditional,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,SchemaTree,The conditional expression  "((_ds != null) && (_ds.Namespace == top[i].Namespace)) || string.IsNullOrEmpty(top[i].Namespace) || (_schFormat == SchemaFormat.Remoting)"  is complex.
Complex Conditional,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,SchemaTree,The conditional expression  "(_ds != null && _ds.Namespace == top[i].Namespace) || string.IsNullOrEmpty(top[i].Namespace) || (_schFormat == SchemaFormat.Remoting)"  is complex.
Complex Conditional,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,AddColumnProperties,The conditional expression  "(col.IsSqlType && ((dt.Length == 0) || col.ImplementsINullable)) || (typeof(SqlXml) == col.DataType) || col.DataType == typeof(DateTimeOffset) || col.DataType == typeof(System.Numerics.BigInteger)"  is complex.
Complex Conditional,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,AddColumnProperties,The conditional expression  "(dt.Length == 0) || col.ImplementsINullable || ((dt == Keywords.XSD_ANYTYPE) && (col.XmlDataType != Keywords.XSD_ANYTYPE))"  is complex.
Complex Conditional,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,FindTypeNode,The conditional expression  "XSDSchema.FEqualIdentity(child' Keywords.XSD_ELEMENT' Keywords.XSDNS) ||                      XSDSchema.FEqualIdentity(child' Keywords.XSD_ATTRIBUTE' Keywords.XSDNS) ||                      XSDSchema.FEqualIdentity(child' Keywords.XSD_COMPLEXTYPE' Keywords.XSDNS) ||                      XSDSchema.FEqualIdentity(child' Keywords.XSD_SIMPLETYPE' Keywords.XSDNS)"  is complex.
Complex Conditional,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleTable,The conditional expression  "((table.DataSet == null) || (_ds != null && table.Namespace != _ds.Namespace)) && (_schFormat == SchemaFormat.Remoting)"  is complex.
Complex Conditional,System.Data,NewDiffgramGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,GenerateColumn,The conditional expression  "valuesType == typeof(Type) || valuesType == typeof(Guid) || valuesType == typeof(char) ||                                      DataStorage.IsSqlType(valuesType)"  is complex.
Complex Conditional,System.Data,XmlDataTreeWriter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,Save,The conditional expression  "!writeSchema && _ds != null && _ds._fTopLevelTable && countTopTable == 1"  is complex.
Complex Conditional,System.Data,XmlDataTreeWriter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,XmlDataRowWriter,The conditional expression  "((value == DBNull.Value) || (col.ImplementsINullable && DataStorage.IsObjectSqlNull(value))) && (col.ColumnMapping == MappingType.SimpleContent)"  is complex.
Complex Conditional,System.Data,XmlDataTreeWriter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,XmlDataRowWriter,The conditional expression  "((value != DBNull.Value) && (!col.ImplementsINullable || !DataStorage.IsObjectSqlNull(value))) && (col._columnMapping != MappingType.Attribute)"  is complex.
Complex Conditional,System.Data,XmlDataTreeWriter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,XmlDataRowWriter,The conditional expression  "valuesType == typeof(Type) || valuesType == typeof(Guid) || valuesType == typeof(char) ||                                      DataStorage.IsSqlType(valuesType)"  is complex.
Complex Conditional,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,SetProperties,The conditional expression  "name == "DefaultValue" || name == "Ordinal" || name == "Locale" || name == "RemotingFormat""  is complex.
Complex Conditional,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleParticle,The conditional expression  "FromInference && pt is XmlSchemaChoice && pt.MaxOccurs > decimal.One && (el.SchemaType is XmlSchemaComplexType)"  is complex.
Complex Conditional,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleParticle,The conditional expression  "((el.Name == null) && (el.RefName.Name == table.EncodedTableName && el.RefName.Namespace == table.Namespace)) ||                          (IsTable(el) && el.Name == table.TableName)"  is complex.
Complex Conditional,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,HandleDataSet,The conditional expression  "(((XmlSchemaElement)choiceEl).RefName.Name.Length != 0) && (!FromInference && ((XmlSchemaElement)choiceEl).MaxOccurs != decimal.One && !(((XmlSchemaElement)choiceEl).SchemaType is XmlSchemaComplexType))"  is complex.
Complex Conditional,System.Data,DataColumn,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataColumn.cs,SetTable,The conditional expression  "(table == null) || (!table.fInitInProgress && ((table.DataSet == null) || (!table.DataSet._fIsSchemaLoading && !table.DataSet._fInitInProgress)))"  is complex.
Complex Conditional,System.Data,DataColumnCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataColumnCollection.cs,IndexOfCaseInsensitive,The conditional expression  "(hashcode == 0 || column._hashCode == 0 || column._hashCode == hashcode) &&                     NamesEqual(column.ColumnName' name' false' _table.Locale) != 0"  is complex.
Complex Conditional,System.Data,DataRelation,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRelation.cs,CheckState,The conditional expression  "(_parentKey.ColumnsReference[i].DataType != _childKey.ColumnsReference[i].DataType) ||                          ((_parentKey.ColumnsReference[i].DataType == typeof(DateTime)) &&                          (_parentKey.ColumnsReference[i].DateTimeMode != _childKey.ColumnsReference[i].DateTimeMode) &&                          ((_parentKey.ColumnsReference[i].DateTimeMode & _childKey.ColumnsReference[i].DateTimeMode) != DataSetDateTime.Unspecified))"  is complex.
Complex Conditional,System.Data,DataRow,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRow.cs,VerifyValueFromStorage,The conditional expression  "column.DataExpression != null && !_inChangingEvent && _tempRecord == -1 && _newRecord != -1"  is complex.
Complex Conditional,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,MoveToElement,The conditional expression  "!reader.EOF && reader.NodeType != XmlNodeType.EndElement && reader.NodeType != XmlNodeType.Element && reader.Depth > depth"  is complex.
Complex Conditional,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXml,The conditional expression  "!fSchemaFound && !fDataFound && reader.LocalName == Keywords.XDR_SCHEMA && reader.NamespaceURI == Keywords.XDRNS"  is complex.
Complex Conditional,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXmlDiffgram,The conditional expression  "((reader.LocalName == Keywords.SQL_BEFORE) && (reader.NamespaceURI == Keywords.DFFNS)) ||                          ((reader.LocalName == Keywords.MSD_ERRORS) && (reader.NamespaceURI == Keywords.DFFNS))"  is complex.
Complex Conditional,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXml,The conditional expression  "!fSchemaFound && !fDataFound && (mode != XmlReadMode.IgnoreSchema) && (mode != XmlReadMode.InferSchema) &&                                      (mode != XmlReadMode.InferTypedSchema)"  is complex.
Complex Conditional,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SetLocaleValue,The conditional expression  "userSet || resetIndexes || (!_cultureUserSet && !_culture.Equals(culture))"  is complex.
Complex Conditional,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,RaiseRowChanged,The conditional expression  "DataRowAction.Delete == eAction && eRow._newRecord == -1 && (IsTypedDataTable || (null != _onRowDeletedDelegate))"  is complex.
Complex Conditional,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,RaiseRowChanging,The conditional expression  "DataRowAction.Delete == eAction && eRow._newRecord != -1 && (IsTypedDataTable || (null != _onRowDeletingDelegate))"  is complex.
Complex Conditional,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SetNewRecordWorker,The conditional expression  "(action == DataRowAction.Delete || action == DataRowAction.Change) &&                  _dependentColumns != null && _dependentColumns.Count > 0"  is complex.
Complex Conditional,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SetNewRecordWorker,The conditional expression  "!suppressEnsurePropertyChanged && !row.HasPropertyChanged && (row._newRecord != proposedRecord)                  && (-1 != proposedRecord)                  && (-1 != row._newRecord)"  is complex.
Complex Conditional,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SetNewRecordWorker,The conditional expression  "(-1 == currentRecord) && (-1 != proposedRecord) && (-1 != row._oldRecord) && (proposedRecord != row._oldRecord)"  is complex.
Complex Conditional,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SetOldRecord,The conditional expression  "(-1 == originalRecord) && (-1 != proposedRecord) && (-1 != row._newRecord) && (proposedRecord != row._newRecord)"  is complex.
Complex Conditional,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SetOldRecord,The conditional expression  "(originalRecord != -1) && (originalRecord != row._tempRecord) &&                      (originalRecord != row._oldRecord) && (originalRecord != row._newRecord)"  is complex.
Complex Conditional,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,IsEmptyXml,The conditional expression  "(Namespace == reader.Value) &&                          (Prefix == reader.LocalName) &&                          (reader.Prefix == Keywords.XMLNS) &&                          (reader.NamespaceURI == Keywords.XSD_XMLNS_NS)"  is complex.
Complex Conditional,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ReadXml,The conditional expression  "!fSchemaFound && !fDataFound && reader.LocalName == Keywords.XDR_SCHEMA && reader.NamespaceURI == Keywords.XDRNS"  is complex.
Complex Conditional,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ReadXml,The conditional expression  "!fSchemaFound && !fDataFound && (mode != XmlReadMode.IgnoreSchema) && (mode != XmlReadMode.InferSchema)"  is complex.
Complex Conditional,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,MoveToElement,The conditional expression  "!reader.EOF && reader.NodeType != XmlNodeType.EndElement && reader.NodeType != XmlNodeType.Element && reader.Depth > depth"  is complex.
Complex Conditional,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ReadXmlDiffgram,The conditional expression  "((reader.LocalName == Keywords.SQL_BEFORE) && (reader.NamespaceURI == Keywords.DFFNS)) ||                      ((reader.LocalName == Keywords.MSD_ERRORS) && (reader.NamespaceURI == Keywords.DFFNS))"  is complex.
Complex Conditional,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,EvaluateExpressions,The conditional expression  "action == DataRowAction.Add ||                  action == DataRowAction.Change ||                  (action == DataRowAction.Rollback && (row._oldRecord != -1 || row._newRecord != -1))"  is complex.
Complex Conditional,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,EvaluateExpressions,The conditional expression  "(action == DataRowAction.Delete || (action == DataRowAction.Rollback && row._oldRecord == -1 && row._newRecord == -1)) && _dependentColumns != null"  is complex.
Complex Conditional,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,EvaluateDependentExpressions,The conditional expression  "cachedRow != null && ((cachedRow.RowState != DataRowState.Deleted) && (version != DataRowVersion.Original || cachedRow._oldRecord != -1))"  is complex.
Complex Conditional,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,EvaluateDependentExpressions,The conditional expression  "parentRow != null && ((parentRow.RowState != DataRowState.Deleted) && (version != DataRowVersion.Original || parentRow._oldRecord != -1))"  is complex.
Complex Conditional,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,EvaluateDependentExpressions,The conditional expression  "childRow != null && ((childRow.RowState != DataRowState.Deleted) && (version != DataRowVersion.Original || childRow._oldRecord != -1))"  is complex.
Complex Conditional,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,Equals,The conditional expression  "(null == view) ||                 Table != view.Table ||                 Count != view.Count ||                 !string.Equals(RowFilter' view.RowFilter' StringComparison.OrdinalIgnoreCase) ||  // case insensitive                 !string.Equals(Sort' view.Sort' StringComparison.OrdinalIgnoreCase) ||  // case insensitive                 !ReferenceEquals(SortComparison' view.SortComparison) ||                 !ReferenceEquals(RowPredicate' view.RowPredicate) ||                 RowStateFilter != view.RowStateFilter ||                 DataViewManager != view.DataViewManager ||                 AllowDelete != view.AllowDelete ||                 AllowNew != view.AllowNew ||                 AllowEdit != view.AllowEdit"  is complex.
Complex Conditional,System.Data,ForeignKeyConstraint,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ForeignKeyConstraint.cs,CheckConstraint,The conditional expression  "(action == DataRowAction.Change ||                   action == DataRowAction.Add ||                   action == DataRowAction.Rollback) &&                  Table.DataSet != null && Table.DataSet.EnforceConstraints &&                  childRow.HasKeyChanged(_childKey)"  is complex.
Complex Conditional,System.Data,ForeignKeyConstraint,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ForeignKeyConstraint.cs,NonVirtualCheckState,The conditional expression  "_parentKey.ColumnsReference[i].DataType != _childKey.ColumnsReference[i].DataType ||                          ((_parentKey.ColumnsReference[i].DataType == typeof(DateTime)) && (_parentKey.ColumnsReference[i].DateTimeMode != _childKey.ColumnsReference[i].DateTimeMode) && ((_parentKey.ColumnsReference[i].DateTimeMode & _childKey.ColumnsReference[i].DateTimeMode) != DataSetDateTime.Unspecified))"  is complex.
Complex Conditional,System.Data,Merger,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Merger.cs,MergeSchema,The conditional expression  "dest.DataType != src.DataType ||                                  ((dest.DataType == typeof(DateTime)) && (dest.DateTimeMode != src.DateTimeMode) && ((dest.DateTimeMode & src.DateTimeMode) != DataSetDateTime.Unspecified))"  is complex.
Complex Conditional,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,RBDeleteFixup,The conditional expression  "(x_id != NIL && x_id == Left(Parent(x_id))) || (x_id == NIL && Left(px_id) == NIL)"  is complex.
Complex Conditional,System.Data,Select,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Select.cs,CompareRecords,The conditional expression  "diff == 0 && record1 != record2 &&                  _table._recordManager[record1] != null && _table._recordManager[record2] != null"  is complex.
Complex Conditional,System.Data,Index,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Selection.cs,Equal,The conditional expression  "!_isSharable ||                  _indexFields.Length != indexDesc.Length ||                  _recordStates != recordStates ||                  null != rowFilter"  is complex.
Complex Conditional,System.Data,UniqueConstraint,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\UniqueConstraint.cs,CheckConstraint,The conditional expression  "Table.EnforceConstraints &&                  (action == DataRowAction.Add ||                   action == DataRowAction.Change ||                   (action == DataRowAction.Rollback && row._tempRecord != -1))"  is complex.
Complex Conditional,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,BinaryCompare,The conditional expression  "((vLeft.GetType() == typeof(SqlBoolean)) && ((vRight.GetType() == typeof(SqlBoolean)) || (vRight.GetType() == typeof(bool)))) ||                                      ((vRight.GetType() == typeof(SqlBoolean)) && ((vLeft.GetType() == typeof(SqlBoolean)) || (vLeft.GetType() == typeof(bool))))"  is complex.
Complex Conditional,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The conditional expression  "op != Operators.Or && op != Operators.And && op != Operators.In && op != Operators.Is && op != Operators.IsNot"  is complex.
Complex Conditional,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The conditional expression  "(vLeft == DBNull.Value) || (left.IsSqlColumn && DataStorage.IsObjectSqlNull(vLeft)) ||                               (vRight == DBNull.Value) || (right.IsSqlColumn && DataStorage.IsObjectSqlNull(vRight))"  is complex.
Complex Conditional,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The conditional expression  "(vLeft == DBNull.Value) || (left.IsSqlColumn && DataStorage.IsObjectSqlNull(vLeft)) ||                               (vRight == DBNull.Value) || (right.IsSqlColumn && DataStorage.IsObjectSqlNull(vRight))"  is complex.
Complex Conditional,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The conditional expression  "(vLeft == DBNull.Value) || (left.IsSqlColumn && DataStorage.IsObjectSqlNull(vLeft)) ||                               (vRight == DBNull.Value) || (right.IsSqlColumn && DataStorage.IsObjectSqlNull(vRight))"  is complex.
Complex Conditional,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The conditional expression  "(vLeft == DBNull.Value) || (left.IsSqlColumn && DataStorage.IsObjectSqlNull(vLeft)) ||                               (vRight == DBNull.Value) || (right.IsSqlColumn && DataStorage.IsObjectSqlNull(vRight))"  is complex.
Complex Conditional,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The conditional expression  "((vLeft == DBNull.Value) || (left.IsSqlColumn && DataStorage.IsObjectSqlNull(vLeft))) ||                               ((vRight == DBNull.Value) || (right.IsSqlColumn && DataStorage.IsObjectSqlNull(vRight)))"  is complex.
Complex Conditional,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,EvalBinaryOp,The conditional expression  "((vLeft == DBNull.Value) || (left.IsSqlColumn && DataStorage.IsObjectSqlNull(vLeft))) ||                               ((vRight == DBNull.Value) || (right.IsSqlColumn && DataStorage.IsObjectSqlNull(vRight)))"  is complex.
Complex Conditional,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,ResultSqlType,The conditional expression  "(left != StorageType.Boolean && left != StorageType.SqlBoolean) || (right != StorageType.Boolean && right != StorageType.SqlBoolean)"  is complex.
Complex Conditional,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,ResultSqlType,The conditional expression  "(left == StorageType.SqlBinary && right != StorageType.SqlBinary) || (left != StorageType.SqlBinary && right == StorageType.SqlBinary)"  is complex.
Complex Conditional,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,ResultSqlType,The conditional expression  "(left == StorageType.SqlGuid && right != StorageType.SqlGuid) || (left != StorageType.SqlGuid && right == StorageType.SqlGuid)"  is complex.
Complex Conditional,System.Data.SqlTypes,SqlDateTime,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDateTime.cs,SqlDateTime,The conditional expression  "year >= s_minYear && year <= s_maxYear && month >= 1 && month <= 12"  is complex.
Complex Conditional,System.Data.SqlTypes,SqlDateTime,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDateTime.cs,SqlDateTime,The conditional expression  "dayticks >= s_minDay && dayticks <= s_maxDay &&                          hour >= 0 && hour < 24 && minute >= 0 && minute < 60 &&                          second >= 0 && second < 60 && millisecond >= 0 && millisecond < 1000.0"  is complex.
Complex Conditional,System.Data.SqlTypes,SqlDateTime,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDateTime.cs,SqlDateTime,The conditional expression  "dayTicks < s_minDay || dayTicks > s_maxDay || timeTicks < s_minTime || timeTicks > s_maxTime"  is complex.
Complex Conditional,System.Data.SqlTypes,SqlDateTime,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDateTime.cs,ToDateTime,The conditional expression  "daypart < s_minDay || daypart > s_maxDay || timepart < s_minTime || timepart > s_maxTime"  is complex.
Complex Conditional,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,CheckValidPrecScale,The conditional expression  "bPrec < 1 || bPrec > MaxPrecision || bScale < 0 || bScale > MaxScale || bScale > bPrec"  is complex.
Complex Conditional,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,CheckValidPrecScale,The conditional expression  "iPrec < 1 || iPrec > MaxPrecision || iScale < 0 || iScale > MaxScale || iScale > iPrec"  is complex.
Complex Conditional,System.Data.SqlTypes,SqlMoney,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLMoney.cs,SqlMoney,The conditional expression  "fPositive && ulValue > long.MaxValue ||                  !fPositive && ulValue > unchecked((ulong)(long.MinValue))"  is complex.
Complex Conditional,System.Data.SqlTypes,SqlXmlStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SqlXml.cs,IsStreamClosed,The conditional expression  "_isClosed || _stream == null || (!_stream.CanRead && !_stream.CanWrite && !_stream.CanSeek)"  is complex.
Virtual Method Call from Constructor,System.Data,NewDiffgramGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,NewDiffgramGen,The constructor "NewDiffgramGen" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Data,NewDiffgramGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,NewDiffgramGen,The constructor "NewDiffgramGen" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Data,XmlDataTreeWriter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,XmlDataTreeWriter,The constructor "XmlDataTreeWriter" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Data,XmlDataTreeWriter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,XmlDataTreeWriter,The constructor "XmlDataTreeWriter" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Data,XmlDataTreeWriter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,XmlDataTreeWriter,The constructor "XmlDataTreeWriter" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Data,ConstraintEnumerator,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ConstraintEnumerator.cs,ConstraintEnumerator,The constructor "ConstraintEnumerator" calls a virtual method "GetEnumerator".
Virtual Method Call from Constructor,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,DataSet,The constructor "DataSet" calls a virtual method "InitializeDerivedDataSet".
Virtual Method Call from Constructor,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,DataView,The constructor "DataView" calls a virtual method "SetIndex".
Virtual Method Call from Constructor,System.Data,DataViewSettingsEnumerator,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataViewSettingCollection.cs,DataViewSettingsEnumerator,The constructor "DataViewSettingsEnumerator" calls a virtual method "GetEnumerator".
Virtual Method Call from Constructor,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,SchemaMapping,The constructor "SchemaMapping" calls a virtual method "ShouldSerializeFillLoadOption".
Empty Catch Block,System.Data.Common,DbCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbCommand.cs,CancelIgnoreFailure,The method has an empty catch block.
Empty Catch Block,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,HasPointers,The method has an empty catch block.
Empty Catch Block,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,OnColumnValueChanged,The method has an empty catch block.
Empty Catch Block,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,OnFoliated,The method has an empty catch block.
Magic Number,System.Data.Common,UInt64Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\UInt64Storage.cs,Aggregate,The following statement contains a magic number: try              {                  switch (kind)                  {                      case AggregateType.Sum:                          ulong sum = s_defaultValue;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { sum += _values[record]; }                                  hasData = true;                              }                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          decimal meanSum = s_defaultValue;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { meanSum += _values[record]; }                                  meanCount++;                                  hasData = true;                              }                          }                          if (hasData)                          {                              ulong mean;                              checked { mean = (ulong)(meanSum / (decimal)meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          double var = 0.0f;                          double prec = 0.0f;                          double dsum = 0.0f;                          double sqrsum = 0.0f;                            foreach (int record in records)                          {                              if (HasValue(record))                              {                                  dsum += _values[record];                                  sqrsum += _values[record] * (double)_values[record];                                  count++;                              }                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                              // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          ulong min = ulong.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  min = Math.Min(_values[record]' min);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          ulong max = ulong.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  max = Math.Max(_values[record]' max);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          return base.Aggregate(records' kind);                  }              }              catch (OverflowException)              {                  throw ExprException.Overflow(typeof(ulong));              }
Magic Number,System.Data.Common,ByteStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\ByteStorage.cs,Aggregate,The following statement contains a magic number: try              {                  switch (kind)                  {                      case AggregateType.Sum:                          ulong sum = defaultValue;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          long meanSum = defaultValue;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { meanSum += _values[record]; }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              byte mean;                              checked { mean = (byte)(meanSum / meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          double var = defaultValue;                          double prec = defaultValue;                          double dsum = defaultValue;                          double sqrsum = defaultValue;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += _values[record];                              sqrsum += _values[record] * (double)_values[record];                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                              // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          byte min = byte.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              min = Math.Min(_values[record]' min);                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          byte max = byte.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              max = Math.Max(_values[record]' max);                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          return base.Aggregate(records' kind);                  }              }              catch (OverflowException)              {                  throw ExprException.Overflow(typeof(byte));              }
Magic Number,System.Data.Common,DataStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataStorage.cs,CreateStorage,The following statement contains a magic number: switch (typeCode)              {                  case StorageType.Empty: throw ExceptionBuilder.InvalidStorageType(TypeCode.Empty);                  case StorageType.DBNull: throw ExceptionBuilder.InvalidStorageType((TypeCode)2); // TypeCode.DBNull);                  case StorageType.Object: return new ObjectStorage(column' dataType);                  case StorageType.Boolean: return new BooleanStorage(column);                  case StorageType.Char: return new CharStorage(column);                  case StorageType.SByte: return new SByteStorage(column);                  case StorageType.Byte: return new ByteStorage(column);                  case StorageType.Int16: return new Int16Storage(column);                  case StorageType.UInt16: return new UInt16Storage(column);                  case StorageType.Int32: return new Int32Storage(column);                  case StorageType.UInt32: return new UInt32Storage(column);                  case StorageType.Int64: return new Int64Storage(column);                  case StorageType.UInt64: return new UInt64Storage(column);                  case StorageType.Single: return new SingleStorage(column);                  case StorageType.Double: return new DoubleStorage(column);                  case StorageType.Decimal: return new DecimalStorage(column);                  case StorageType.DateTime: return new DateTimeStorage(column);                  case StorageType.TimeSpan: return new TimeSpanStorage(column);                  case StorageType.String: return new StringStorage(column);                  case StorageType.Guid: return new ObjectStorage(column' dataType);                    case StorageType.ByteArray: return new ObjectStorage(column' dataType);                  case StorageType.CharArray: return new ObjectStorage(column' dataType);                  case StorageType.Type: return new ObjectStorage(column' dataType);                  case StorageType.DateTimeOffset: return new DateTimeOffsetStorage(column);                  case StorageType.BigInteger: return new BigIntegerStorage(column);                  case StorageType.Uri: return new ObjectStorage(column' dataType);                    case StorageType.SqlBinary: return new SqlBinaryStorage(column);                  case StorageType.SqlBoolean: return new SqlBooleanStorage(column);                  case StorageType.SqlByte: return new SqlByteStorage(column);                  case StorageType.SqlBytes: return new SqlBytesStorage(column);                  case StorageType.SqlChars: return new SqlCharsStorage(column);                  case StorageType.SqlDateTime: return new SqlDateTimeStorage(column);                  case StorageType.SqlDecimal: return new SqlDecimalStorage(column);                  case StorageType.SqlDouble: return new SqlDoubleStorage(column);                  case StorageType.SqlGuid: return new SqlGuidStorage(column);                  case StorageType.SqlInt16: return new SqlInt16Storage(column);                  case StorageType.SqlInt32: return new SqlInt32Storage(column);                  case StorageType.SqlInt64: return new SqlInt64Storage(column);                  case StorageType.SqlMoney: return new SqlMoneyStorage(column);                  case StorageType.SqlSingle: return new SqlSingleStorage(column);                  case StorageType.SqlString: return new SqlStringStorage(column);                    default:                      Debug.Assert(false' "shouldn't be here");                      goto case StorageType.Object;              }
Magic Number,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,SplitConnectionString,The following statement contains a magic number: const int KeyIndex = 1' ValueIndex = 2;
Magic Number,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,SplitConnectionString,The following statement contains a magic number: if (null != connectionString)              {                  Match match = parser.Match(connectionString);                  if (!match.Success || (match.Length != connectionString.Length))                  {                      throw ADP.ConnectionStringSyntax(match.Length);                  }                  int indexValue = 0;                  CaptureCollection keyvalues = match.Groups[ValueIndex].Captures;                  foreach (Capture keypair in match.Groups[KeyIndex].Captures)                  {                      string keyname = (firstKey ? keypair.Value : keypair.Value.Replace("=="' "=")).ToLower(CultureInfo.InvariantCulture);                      string keyvalue = keyvalues[indexValue++].Value;                      if (0 < keyvalue.Length)                      {                          if (!firstKey)                          {                              switch (keyvalue[0])                              {                                  case '\"':                                      keyvalue = keyvalue.Substring(1' keyvalue.Length - 2).Replace("\"\""' "\"");                                      break;                                  case '\'':                                      keyvalue = keyvalue.Substring(1' keyvalue.Length - 2).Replace("\'\'"' "\'");                                      break;                                  default:                                      break;                              }                          }                      }                      else                      {                          keyvalue = null;                      }                      DebugTraceKeyValuePair(keyname' keyvalue' synonyms);                      string synonym;                      string realkeyname = null != synonyms ?                          (synonyms.TryGetValue(keyname' out synonym) ? synonym : null) : keyname;                         if (!IsKeyNameValid(realkeyname))                      {                          throw ADP.KeywordNotSupported(keyname);                      }                      if (!firstKey || !parsetable.ContainsKey(realkeyname))                      {                          parsetable[realkeyname] = keyvalue; // last key-value pair wins (or first)                      }                  }              }
Magic Number,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbConnectionOptions.cs,SplitConnectionString,The following statement contains a magic number: if (null != connectionString)              {                  Match match = parser.Match(connectionString);                  if (!match.Success || (match.Length != connectionString.Length))                  {                      throw ADP.ConnectionStringSyntax(match.Length);                  }                  int indexValue = 0;                  CaptureCollection keyvalues = match.Groups[ValueIndex].Captures;                  foreach (Capture keypair in match.Groups[KeyIndex].Captures)                  {                      string keyname = (firstKey ? keypair.Value : keypair.Value.Replace("=="' "=")).ToLower(CultureInfo.InvariantCulture);                      string keyvalue = keyvalues[indexValue++].Value;                      if (0 < keyvalue.Length)                      {                          if (!firstKey)                          {                              switch (keyvalue[0])                              {                                  case '\"':                                      keyvalue = keyvalue.Substring(1' keyvalue.Length - 2).Replace("\"\""' "\"");                                      break;                                  case '\'':                                      keyvalue = keyvalue.Substring(1' keyvalue.Length - 2).Replace("\'\'"' "\'");                                      break;                                  default:                                      break;                              }                          }                      }                      else                      {                          keyvalue = null;                      }                      DebugTraceKeyValuePair(keyname' keyvalue' synonyms);                      string synonym;                      string realkeyname = null != synonyms ?                          (synonyms.TryGetValue(keyname' out synonym) ? synonym : null) : keyname;                         if (!IsKeyNameValid(realkeyname))                      {                          throw ADP.KeywordNotSupported(keyname);                      }                      if (!firstKey || !parsetable.ContainsKey(realkeyname))                      {                          parsetable[realkeyname] = keyvalue; // last key-value pair wins (or first)                      }                  }              }
Magic Number,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,Update,The following statement contains a magic number: try              {                  Debug.Assert((null != dataRows) && (0 < dataRows.Length)' "Update: bad dataRows");                  Debug.Assert(null != tableMapping' "Update: bad DataTableMapping");                    // If records were affected' increment row count by one - that is number of rows affected in dataset.                  int cumulativeDataRowsAffected = 0;                    IDbConnection[] connections = new IDbConnection[5]; // one for each statementtype                  ConnectionState[] connectionStates = new ConnectionState[5]; // closed by default (== 0)                    bool useSelectConnectionState = false;                  IDbCommand tmpcmd = _IDbDataAdapter.SelectCommand;                  if (null != tmpcmd)                  {                      connections[0] = tmpcmd.Connection;                      if (null != connections[0])                      {                          connectionStates[0] = connections[0].State;                          useSelectConnectionState = true;                      }                  }                    int maxBatchCommands = Math.Min(UpdateBatchSize' dataRows.Length);                    if (maxBatchCommands < 1)                  {  // batch size of zero indicates one batch' no matter how large...                      maxBatchCommands = dataRows.Length;                  }                    BatchCommandInfo[] batchCommands = new BatchCommandInfo[maxBatchCommands];                  DataRow[] rowBatch = new DataRow[maxBatchCommands];                  int commandCount = 0;                    // the outer try/finally is for closing any connections we may have opened                  try                  {                      try                      {                          if (1 != maxBatchCommands)                          {                              InitializeBatching();                          }                          StatementType statementType = StatementType.Select;                          IDbCommand dataCommand = null;                            // for each row which is either insert' update' or delete                          foreach (DataRow dataRow in dataRows)                          {                              if (null == dataRow)                              {                                  continue; // foreach DataRow                              }                              bool isCommandFromRowUpdating = false;                                // obtain the appropriate command                              switch (dataRow.RowState)                              {                                  case DataRowState.Detached:                                  case DataRowState.Unchanged:                                      continue; // foreach DataRow                                  case DataRowState.Added:                                      statementType = StatementType.Insert;                                      dataCommand = _IDbDataAdapter.InsertCommand;                                      break;                                  case DataRowState.Deleted:                                      statementType = StatementType.Delete;                                      dataCommand = _IDbDataAdapter.DeleteCommand;                                      break;                                  case DataRowState.Modified:                                      statementType = StatementType.Update;                                      dataCommand = _IDbDataAdapter.UpdateCommand;                                      break;                                  default:                                      Debug.Assert(false' "InvalidDataRowState");                                      throw ADP.InvalidDataRowState(dataRow.RowState); // out of Update without completing batch                              }                                // setup the event to be raised                              RowUpdatingEventArgs rowUpdatingEvent = CreateRowUpdatingEvent(dataRow' dataCommand' statementType' tableMapping);                                // this try/catch for any exceptions during the parameter initialization                              try                              {                                  dataRow.RowError = null;                                  if (null != dataCommand)                                  {                                      // prepare the parameters for the user who then can modify them during OnRowUpdating                                      ParameterInput(dataCommand.Parameters' statementType' dataRow' tableMapping);                                  }                              }                              catch (Exception e) when (ADP.IsCatchableExceptionType(e))                              {                                  ADP.TraceExceptionForCapture(e);                                  rowUpdatingEvent.Errors = e;                                  rowUpdatingEvent.Status = UpdateStatus.ErrorsOccurred;                              }                                OnRowUpdating(rowUpdatingEvent); // user may throw out of Update without completing batch                                IDbCommand tmpCommand = rowUpdatingEvent.Command;                              isCommandFromRowUpdating = (dataCommand != tmpCommand);                              dataCommand = tmpCommand;                              tmpCommand = null;                                // handle the status from RowUpdating event                              UpdateStatus rowUpdatingStatus = rowUpdatingEvent.Status;                              if (UpdateStatus.Continue != rowUpdatingStatus)                              {                                  if (UpdateStatus.ErrorsOccurred == rowUpdatingStatus)                                  {                                      UpdatingRowStatusErrors(rowUpdatingEvent' dataRow);                                      continue; // foreach DataRow                                  }                                  else if (UpdateStatus.SkipCurrentRow == rowUpdatingStatus)                                  {                                      if (DataRowState.Unchanged == dataRow.RowState)                                      {                                          cumulativeDataRowsAffected++;                                      }                                      continue; // foreach DataRow                                  }                                  else if (UpdateStatus.SkipAllRemainingRows == rowUpdatingStatus)                                  {                                      if (DataRowState.Unchanged == dataRow.RowState)                                      {                                          cumulativeDataRowsAffected++;                                      }                                      break; // execute existing batch and return                                  }                                  else                                  {                                      throw ADP.InvalidUpdateStatus(rowUpdatingStatus);  // out of Update                                  }                              }                              // else onward to Append/ExecuteNonQuery/ExecuteReader                                rowUpdatingEvent = null;                              RowUpdatedEventArgs rowUpdatedEvent = null;                                if (1 == maxBatchCommands)                              {                                  if (null != dataCommand)                                  {                                      batchCommands[0]._commandIdentifier = 0;                                      batchCommands[0]._parameterCount = dataCommand.Parameters.Count;                                      batchCommands[0]._statementType = statementType;                                      batchCommands[0]._updatedRowSource = dataCommand.UpdatedRowSource;                                  }                                  batchCommands[0]._row = dataRow;                                  rowBatch[0] = dataRow; // not doing a batch update' just simplifying code...                                  commandCount = 1;                              }                              else                              {                                  Exception errors = null;                                    try                                  {                                      if (null != dataCommand)                                      {                                          if (0 == (UpdateRowSource.FirstReturnedRecord & dataCommand.UpdatedRowSource))                                          {                                              // append the command to the commandset. If an exception                                              // occurs' then the user must append and continue                                                batchCommands[commandCount]._commandIdentifier = AddToBatch(dataCommand);                                              batchCommands[commandCount]._parameterCount = dataCommand.Parameters.Count;                                              batchCommands[commandCount]._row = dataRow;                                              batchCommands[commandCount]._statementType = statementType;                                              batchCommands[commandCount]._updatedRowSource = dataCommand.UpdatedRowSource;                                                rowBatch[commandCount] = dataRow;                                              commandCount++;                                                if (commandCount < maxBatchCommands)                                              {                                                  continue; // foreach DataRow                                              }                                              // else onward execute the batch                                          }                                          else                                          {                                              // do not allow the expectation that returned results will be used                                              errors = ADP.ResultsNotAllowedDuringBatch();                                          }                                      }                                      else                                      {                                          // null Command will force RowUpdatedEvent with ErrorsOccurred without completing batch                                          errors = ADP.UpdateRequiresCommand(statementType' isCommandFromRowUpdating);                                      }                                  }                                  catch (Exception e) when (ADP.IsCatchableExceptionType(e))                                  {                                      // try/catch for RowUpdatedEventArgs                                      ADP.TraceExceptionForCapture(e);                                      errors = e;                                  }                                    if (null != errors)                                  {                                      rowUpdatedEvent = CreateRowUpdatedEvent(dataRow' dataCommand' StatementType.Batch' tableMapping);                                      rowUpdatedEvent.Errors = errors;                                      rowUpdatedEvent.Status = UpdateStatus.ErrorsOccurred;                                        OnRowUpdated(rowUpdatedEvent); // user may throw out of Update                                      if (errors != rowUpdatedEvent.Errors)                                      { // user set the error msg and we will use it                                          for (int i = 0; i < batchCommands.Length; ++i)                                          {                                              batchCommands[i]._errors = null;                                          }                                      }                                        cumulativeDataRowsAffected += UpdatedRowStatus(rowUpdatedEvent' batchCommands' commandCount);                                      if (UpdateStatus.SkipAllRemainingRows == rowUpdatedEvent.Status)                                      {                                          break;                                      }                                      continue; // foreach datarow                                  }                              }                                rowUpdatedEvent = CreateRowUpdatedEvent(dataRow' dataCommand' statementType' tableMapping);                                // this try/catch for any exceptions during the execution' population' output parameters                              try                              {                                  if (1 != maxBatchCommands)                                  {                                      IDbConnection connection = DbDataAdapter.GetConnection1(this);                                        ConnectionState state = UpdateConnectionOpen(connection' StatementType.Batch' connections' connectionStates' useSelectConnectionState);                                      rowUpdatedEvent.AdapterInit(rowBatch);                                        if (ConnectionState.Open == state)                                      {                                          UpdateBatchExecute(batchCommands' commandCount' rowUpdatedEvent);                                      }                                      else                                      {                                          // null Connection will force RowUpdatedEvent with ErrorsOccurred without completing batch                                          rowUpdatedEvent.Errors = ADP.UpdateOpenConnectionRequired(StatementType.Batch' false' state);                                          rowUpdatedEvent.Status = UpdateStatus.ErrorsOccurred;                                      }                                  }                                  else if (null != dataCommand)                                  {                                      IDbConnection connection = DbDataAdapter.GetConnection4(this' dataCommand' statementType' isCommandFromRowUpdating);                                      ConnectionState state = UpdateConnectionOpen(connection' statementType' connections' connectionStates' useSelectConnectionState);                                      if (ConnectionState.Open == state)                                      {                                          UpdateRowExecute(rowUpdatedEvent' dataCommand' statementType);                                          batchCommands[0]._recordsAffected = rowUpdatedEvent.RecordsAffected;                                          batchCommands[0]._errors = null;                                      }                                      else                                      {                                          // null Connection will force RowUpdatedEvent with ErrorsOccurred without completing batch                                          rowUpdatedEvent.Errors = ADP.UpdateOpenConnectionRequired(statementType' isCommandFromRowUpdating' state);                                          rowUpdatedEvent.Status = UpdateStatus.ErrorsOccurred;                                      }                                  }                                  else                                  {                                      // null Command will force RowUpdatedEvent with ErrorsOccurred without completing batch                                      rowUpdatedEvent.Errors = ADP.UpdateRequiresCommand(statementType' isCommandFromRowUpdating);                                      rowUpdatedEvent.Status = UpdateStatus.ErrorsOccurred;                                  }                              }                              catch (Exception e) when (ADP.IsCatchableExceptionType(e))                              {                                  // try/catch for RowUpdatedEventArgs                                  ADP.TraceExceptionForCapture(e);                                  rowUpdatedEvent.Errors = e;                                  rowUpdatedEvent.Status = UpdateStatus.ErrorsOccurred;                              }                                bool clearBatchOnSkipAll = (UpdateStatus.ErrorsOccurred == rowUpdatedEvent.Status);                                {                                  Exception errors = rowUpdatedEvent.Errors;                                  OnRowUpdated(rowUpdatedEvent); // user may throw out of Update                                  // NOTE: the contents of rowBatch are now tainted...                                  if (errors != rowUpdatedEvent.Errors)                                  { // user set the error msg and we will use it                                      for (int i = 0; i < batchCommands.Length; ++i)                                      {                                          batchCommands[i]._errors = null;                                      }                                  }                              }                                cumulativeDataRowsAffected += UpdatedRowStatus(rowUpdatedEvent' batchCommands' commandCount);                                if (UpdateStatus.SkipAllRemainingRows == rowUpdatedEvent.Status)                              {                                  if (clearBatchOnSkipAll && 1 != maxBatchCommands)                                  {                                      ClearBatch();                                      commandCount = 0;                                  }                                  break; // from update                              }                                if (1 != maxBatchCommands)                              {                                  ClearBatch();                                  commandCount = 0;                              }                              for (int i = 0; i < batchCommands.Length; ++i)                              {                                  batchCommands[i] = default(BatchCommandInfo);                              }                              commandCount = 0;                          } // foreach DataRow                            // must handle the last batch                          if (1 != maxBatchCommands && 0 < commandCount)                          {                              RowUpdatedEventArgs rowUpdatedEvent = CreateRowUpdatedEvent(null' dataCommand' statementType' tableMapping);                                try                              {                                  IDbConnection connection = DbDataAdapter.GetConnection1(this);                                    ConnectionState state = UpdateConnectionOpen(connection' StatementType.Batch' connections' connectionStates' useSelectConnectionState);                                    DataRow[] finalRowBatch = rowBatch;                                    if (commandCount < rowBatch.Length)                                  {                                      finalRowBatch = new DataRow[commandCount];                                      Array.Copy(rowBatch' 0' finalRowBatch' 0' commandCount);                                  }                                  rowUpdatedEvent.AdapterInit(finalRowBatch);                                    if (ConnectionState.Open == state)                                  {                                      UpdateBatchExecute(batchCommands' commandCount' rowUpdatedEvent);                                  }                                  else                                  {                                      // null Connection will force RowUpdatedEvent with ErrorsOccurred without completing batch                                      rowUpdatedEvent.Errors = ADP.UpdateOpenConnectionRequired(StatementType.Batch' false' state);                                      rowUpdatedEvent.Status = UpdateStatus.ErrorsOccurred;                                  }                              }                              catch (Exception e) when (ADP.IsCatchableExceptionType(e))                              {                                  // try/catch for RowUpdatedEventArgs                                  ADP.TraceExceptionForCapture(e);                                  rowUpdatedEvent.Errors = e;                                  rowUpdatedEvent.Status = UpdateStatus.ErrorsOccurred;                              }                              Exception errors = rowUpdatedEvent.Errors;                              OnRowUpdated(rowUpdatedEvent); // user may throw out of Update                              // NOTE: the contents of rowBatch are now tainted...                              if (errors != rowUpdatedEvent.Errors)                              { // user set the error msg and we will use it                                  for (int i = 0; i < batchCommands.Length; ++i)                                  {                                      batchCommands[i]._errors = null;                                  }                              }                                cumulativeDataRowsAffected += UpdatedRowStatus(rowUpdatedEvent' batchCommands' commandCount);                          }                      }                      finally                      {                          if (1 != maxBatchCommands)                          {                              TerminateBatching();                          }                      }                  }                  finally                  { // try/finally for connection cleanup                      for (int i = 0; i < connections.Length; ++i)                      {                          QuietClose(connections[i]' connectionStates[i]);                      }                  }                  return cumulativeDataRowsAffected;              }              finally              {                  DataCommonEventSource.Log.ExitScope(logScopeId);              }
Magic Number,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,Update,The following statement contains a magic number: try              {                  Debug.Assert((null != dataRows) && (0 < dataRows.Length)' "Update: bad dataRows");                  Debug.Assert(null != tableMapping' "Update: bad DataTableMapping");                    // If records were affected' increment row count by one - that is number of rows affected in dataset.                  int cumulativeDataRowsAffected = 0;                    IDbConnection[] connections = new IDbConnection[5]; // one for each statementtype                  ConnectionState[] connectionStates = new ConnectionState[5]; // closed by default (== 0)                    bool useSelectConnectionState = false;                  IDbCommand tmpcmd = _IDbDataAdapter.SelectCommand;                  if (null != tmpcmd)                  {                      connections[0] = tmpcmd.Connection;                      if (null != connections[0])                      {                          connectionStates[0] = connections[0].State;                          useSelectConnectionState = true;                      }                  }                    int maxBatchCommands = Math.Min(UpdateBatchSize' dataRows.Length);                    if (maxBatchCommands < 1)                  {  // batch size of zero indicates one batch' no matter how large...                      maxBatchCommands = dataRows.Length;                  }                    BatchCommandInfo[] batchCommands = new BatchCommandInfo[maxBatchCommands];                  DataRow[] rowBatch = new DataRow[maxBatchCommands];                  int commandCount = 0;                    // the outer try/finally is for closing any connections we may have opened                  try                  {                      try                      {                          if (1 != maxBatchCommands)                          {                              InitializeBatching();                          }                          StatementType statementType = StatementType.Select;                          IDbCommand dataCommand = null;                            // for each row which is either insert' update' or delete                          foreach (DataRow dataRow in dataRows)                          {                              if (null == dataRow)                              {                                  continue; // foreach DataRow                              }                              bool isCommandFromRowUpdating = false;                                // obtain the appropriate command                              switch (dataRow.RowState)                              {                                  case DataRowState.Detached:                                  case DataRowState.Unchanged:                                      continue; // foreach DataRow                                  case DataRowState.Added:                                      statementType = StatementType.Insert;                                      dataCommand = _IDbDataAdapter.InsertCommand;                                      break;                                  case DataRowState.Deleted:                                      statementType = StatementType.Delete;                                      dataCommand = _IDbDataAdapter.DeleteCommand;                                      break;                                  case DataRowState.Modified:                                      statementType = StatementType.Update;                                      dataCommand = _IDbDataAdapter.UpdateCommand;                                      break;                                  default:                                      Debug.Assert(false' "InvalidDataRowState");                                      throw ADP.InvalidDataRowState(dataRow.RowState); // out of Update without completing batch                              }                                // setup the event to be raised                              RowUpdatingEventArgs rowUpdatingEvent = CreateRowUpdatingEvent(dataRow' dataCommand' statementType' tableMapping);                                // this try/catch for any exceptions during the parameter initialization                              try                              {                                  dataRow.RowError = null;                                  if (null != dataCommand)                                  {                                      // prepare the parameters for the user who then can modify them during OnRowUpdating                                      ParameterInput(dataCommand.Parameters' statementType' dataRow' tableMapping);                                  }                              }                              catch (Exception e) when (ADP.IsCatchableExceptionType(e))                              {                                  ADP.TraceExceptionForCapture(e);                                  rowUpdatingEvent.Errors = e;                                  rowUpdatingEvent.Status = UpdateStatus.ErrorsOccurred;                              }                                OnRowUpdating(rowUpdatingEvent); // user may throw out of Update without completing batch                                IDbCommand tmpCommand = rowUpdatingEvent.Command;                              isCommandFromRowUpdating = (dataCommand != tmpCommand);                              dataCommand = tmpCommand;                              tmpCommand = null;                                // handle the status from RowUpdating event                              UpdateStatus rowUpdatingStatus = rowUpdatingEvent.Status;                              if (UpdateStatus.Continue != rowUpdatingStatus)                              {                                  if (UpdateStatus.ErrorsOccurred == rowUpdatingStatus)                                  {                                      UpdatingRowStatusErrors(rowUpdatingEvent' dataRow);                                      continue; // foreach DataRow                                  }                                  else if (UpdateStatus.SkipCurrentRow == rowUpdatingStatus)                                  {                                      if (DataRowState.Unchanged == dataRow.RowState)                                      {                                          cumulativeDataRowsAffected++;                                      }                                      continue; // foreach DataRow                                  }                                  else if (UpdateStatus.SkipAllRemainingRows == rowUpdatingStatus)                                  {                                      if (DataRowState.Unchanged == dataRow.RowState)                                      {                                          cumulativeDataRowsAffected++;                                      }                                      break; // execute existing batch and return                                  }                                  else                                  {                                      throw ADP.InvalidUpdateStatus(rowUpdatingStatus);  // out of Update                                  }                              }                              // else onward to Append/ExecuteNonQuery/ExecuteReader                                rowUpdatingEvent = null;                              RowUpdatedEventArgs rowUpdatedEvent = null;                                if (1 == maxBatchCommands)                              {                                  if (null != dataCommand)                                  {                                      batchCommands[0]._commandIdentifier = 0;                                      batchCommands[0]._parameterCount = dataCommand.Parameters.Count;                                      batchCommands[0]._statementType = statementType;                                      batchCommands[0]._updatedRowSource = dataCommand.UpdatedRowSource;                                  }                                  batchCommands[0]._row = dataRow;                                  rowBatch[0] = dataRow; // not doing a batch update' just simplifying code...                                  commandCount = 1;                              }                              else                              {                                  Exception errors = null;                                    try                                  {                                      if (null != dataCommand)                                      {                                          if (0 == (UpdateRowSource.FirstReturnedRecord & dataCommand.UpdatedRowSource))                                          {                                              // append the command to the commandset. If an exception                                              // occurs' then the user must append and continue                                                batchCommands[commandCount]._commandIdentifier = AddToBatch(dataCommand);                                              batchCommands[commandCount]._parameterCount = dataCommand.Parameters.Count;                                              batchCommands[commandCount]._row = dataRow;                                              batchCommands[commandCount]._statementType = statementType;                                              batchCommands[commandCount]._updatedRowSource = dataCommand.UpdatedRowSource;                                                rowBatch[commandCount] = dataRow;                                              commandCount++;                                                if (commandCount < maxBatchCommands)                                              {                                                  continue; // foreach DataRow                                              }                                              // else onward execute the batch                                          }                                          else                                          {                                              // do not allow the expectation that returned results will be used                                              errors = ADP.ResultsNotAllowedDuringBatch();                                          }                                      }                                      else                                      {                                          // null Command will force RowUpdatedEvent with ErrorsOccurred without completing batch                                          errors = ADP.UpdateRequiresCommand(statementType' isCommandFromRowUpdating);                                      }                                  }                                  catch (Exception e) when (ADP.IsCatchableExceptionType(e))                                  {                                      // try/catch for RowUpdatedEventArgs                                      ADP.TraceExceptionForCapture(e);                                      errors = e;                                  }                                    if (null != errors)                                  {                                      rowUpdatedEvent = CreateRowUpdatedEvent(dataRow' dataCommand' StatementType.Batch' tableMapping);                                      rowUpdatedEvent.Errors = errors;                                      rowUpdatedEvent.Status = UpdateStatus.ErrorsOccurred;                                        OnRowUpdated(rowUpdatedEvent); // user may throw out of Update                                      if (errors != rowUpdatedEvent.Errors)                                      { // user set the error msg and we will use it                                          for (int i = 0; i < batchCommands.Length; ++i)                                          {                                              batchCommands[i]._errors = null;                                          }                                      }                                        cumulativeDataRowsAffected += UpdatedRowStatus(rowUpdatedEvent' batchCommands' commandCount);                                      if (UpdateStatus.SkipAllRemainingRows == rowUpdatedEvent.Status)                                      {                                          break;                                      }                                      continue; // foreach datarow                                  }                              }                                rowUpdatedEvent = CreateRowUpdatedEvent(dataRow' dataCommand' statementType' tableMapping);                                // this try/catch for any exceptions during the execution' population' output parameters                              try                              {                                  if (1 != maxBatchCommands)                                  {                                      IDbConnection connection = DbDataAdapter.GetConnection1(this);                                        ConnectionState state = UpdateConnectionOpen(connection' StatementType.Batch' connections' connectionStates' useSelectConnectionState);                                      rowUpdatedEvent.AdapterInit(rowBatch);                                        if (ConnectionState.Open == state)                                      {                                          UpdateBatchExecute(batchCommands' commandCount' rowUpdatedEvent);                                      }                                      else                                      {                                          // null Connection will force RowUpdatedEvent with ErrorsOccurred without completing batch                                          rowUpdatedEvent.Errors = ADP.UpdateOpenConnectionRequired(StatementType.Batch' false' state);                                          rowUpdatedEvent.Status = UpdateStatus.ErrorsOccurred;                                      }                                  }                                  else if (null != dataCommand)                                  {                                      IDbConnection connection = DbDataAdapter.GetConnection4(this' dataCommand' statementType' isCommandFromRowUpdating);                                      ConnectionState state = UpdateConnectionOpen(connection' statementType' connections' connectionStates' useSelectConnectionState);                                      if (ConnectionState.Open == state)                                      {                                          UpdateRowExecute(rowUpdatedEvent' dataCommand' statementType);                                          batchCommands[0]._recordsAffected = rowUpdatedEvent.RecordsAffected;                                          batchCommands[0]._errors = null;                                      }                                      else                                      {                                          // null Connection will force RowUpdatedEvent with ErrorsOccurred without completing batch                                          rowUpdatedEvent.Errors = ADP.UpdateOpenConnectionRequired(statementType' isCommandFromRowUpdating' state);                                          rowUpdatedEvent.Status = UpdateStatus.ErrorsOccurred;                                      }                                  }                                  else                                  {                                      // null Command will force RowUpdatedEvent with ErrorsOccurred without completing batch                                      rowUpdatedEvent.Errors = ADP.UpdateRequiresCommand(statementType' isCommandFromRowUpdating);                                      rowUpdatedEvent.Status = UpdateStatus.ErrorsOccurred;                                  }                              }                              catch (Exception e) when (ADP.IsCatchableExceptionType(e))                              {                                  // try/catch for RowUpdatedEventArgs                                  ADP.TraceExceptionForCapture(e);                                  rowUpdatedEvent.Errors = e;                                  rowUpdatedEvent.Status = UpdateStatus.ErrorsOccurred;                              }                                bool clearBatchOnSkipAll = (UpdateStatus.ErrorsOccurred == rowUpdatedEvent.Status);                                {                                  Exception errors = rowUpdatedEvent.Errors;                                  OnRowUpdated(rowUpdatedEvent); // user may throw out of Update                                  // NOTE: the contents of rowBatch are now tainted...                                  if (errors != rowUpdatedEvent.Errors)                                  { // user set the error msg and we will use it                                      for (int i = 0; i < batchCommands.Length; ++i)                                      {                                          batchCommands[i]._errors = null;                                      }                                  }                              }                                cumulativeDataRowsAffected += UpdatedRowStatus(rowUpdatedEvent' batchCommands' commandCount);                                if (UpdateStatus.SkipAllRemainingRows == rowUpdatedEvent.Status)                              {                                  if (clearBatchOnSkipAll && 1 != maxBatchCommands)                                  {                                      ClearBatch();                                      commandCount = 0;                                  }                                  break; // from update                              }                                if (1 != maxBatchCommands)                              {                                  ClearBatch();                                  commandCount = 0;                              }                              for (int i = 0; i < batchCommands.Length; ++i)                              {                                  batchCommands[i] = default(BatchCommandInfo);                              }                              commandCount = 0;                          } // foreach DataRow                            // must handle the last batch                          if (1 != maxBatchCommands && 0 < commandCount)                          {                              RowUpdatedEventArgs rowUpdatedEvent = CreateRowUpdatedEvent(null' dataCommand' statementType' tableMapping);                                try                              {                                  IDbConnection connection = DbDataAdapter.GetConnection1(this);                                    ConnectionState state = UpdateConnectionOpen(connection' StatementType.Batch' connections' connectionStates' useSelectConnectionState);                                    DataRow[] finalRowBatch = rowBatch;                                    if (commandCount < rowBatch.Length)                                  {                                      finalRowBatch = new DataRow[commandCount];                                      Array.Copy(rowBatch' 0' finalRowBatch' 0' commandCount);                                  }                                  rowUpdatedEvent.AdapterInit(finalRowBatch);                                    if (ConnectionState.Open == state)                                  {                                      UpdateBatchExecute(batchCommands' commandCount' rowUpdatedEvent);                                  }                                  else                                  {                                      // null Connection will force RowUpdatedEvent with ErrorsOccurred without completing batch                                      rowUpdatedEvent.Errors = ADP.UpdateOpenConnectionRequired(StatementType.Batch' false' state);                                      rowUpdatedEvent.Status = UpdateStatus.ErrorsOccurred;                                  }                              }                              catch (Exception e) when (ADP.IsCatchableExceptionType(e))                              {                                  // try/catch for RowUpdatedEventArgs                                  ADP.TraceExceptionForCapture(e);                                  rowUpdatedEvent.Errors = e;                                  rowUpdatedEvent.Status = UpdateStatus.ErrorsOccurred;                              }                              Exception errors = rowUpdatedEvent.Errors;                              OnRowUpdated(rowUpdatedEvent); // user may throw out of Update                              // NOTE: the contents of rowBatch are now tainted...                              if (errors != rowUpdatedEvent.Errors)                              { // user set the error msg and we will use it                                  for (int i = 0; i < batchCommands.Length; ++i)                                  {                                      batchCommands[i]._errors = null;                                  }                              }                                cumulativeDataRowsAffected += UpdatedRowStatus(rowUpdatedEvent' batchCommands' commandCount);                          }                      }                      finally                      {                          if (1 != maxBatchCommands)                          {                              TerminateBatching();                          }                      }                  }                  finally                  { // try/finally for connection cleanup                      for (int i = 0; i < connections.Length; ++i)                      {                          QuietClose(connections[i]' connectionStates[i]);                      }                  }                  return cumulativeDataRowsAffected;              }              finally              {                  DataCommonEventSource.Log.ExitScope(logScopeId);              }
Magic Number,System.Data.Common,DbDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataReader.cs,GetStream,The following statement contains a magic number: using (MemoryStream bufferStream = new MemoryStream())              {                  long bytesRead = 0;                  long bytesReadTotal = 0;                  byte[] buffer = new byte[4096];                  do                  {                      bytesRead = GetBytes(ordinal' bytesReadTotal' buffer' 0' buffer.Length);                      bufferStream.Write(buffer' 0' (int)bytesRead);                      bytesReadTotal += bytesRead;                  }                  while (bytesRead > 0);                    return new MemoryStream(bufferStream.ToArray()' false);              }
Magic Number,System.Data.Common,DecimalStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DecimalStorage.cs,Aggregate,The following statement contains a magic number: try              {                  switch (kind)                  {                      case AggregateType.Sum:                          decimal sum = s_defaultValue;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { sum += _values[record]; }                                  hasData = true;                              }                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          decimal meanSum = s_defaultValue;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { meanSum += _values[record]; }                                  meanCount++;                                  hasData = true;                              }                          }                          if (hasData)                          {                              decimal mean;                              checked { mean = (meanSum / meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          double var = (double)s_defaultValue;                          double prec = (double)s_defaultValue;                          double dsum = (double)s_defaultValue;                          double sqrsum = (double)s_defaultValue;                            foreach (int record in records)                          {                              if (HasValue(record))                              {                                  dsum += (double)_values[record];                                  sqrsum += (double)_values[record] * (double)_values[record];                                  count++;                              }                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                              // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          decimal min = decimal.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  min = Math.Min(_values[record]' min);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          decimal max = decimal.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  max = Math.Max(_values[record]' max);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          return base.Aggregate(records' kind);                  }              }              catch (OverflowException)              {                  throw ExprException.Overflow(typeof(decimal));              }
Magic Number,System.Data.Common,DoubleStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DoubleStorage.cs,Aggregate,The following statement contains a magic number: try              {                  switch (kind)                  {                      case AggregateType.Sum:                          double sum = defaultValue;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          double meanSum = defaultValue;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { meanSum += _values[record]; }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              double mean;                              checked { mean = meanSum / meanCount; }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          double var = defaultValue;                          double prec = defaultValue;                          double dsum = defaultValue;                          double sqrsum = defaultValue;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += _values[record];                              sqrsum += _values[record] * _values[record];                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                              // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          double min = double.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              min = Math.Min(_values[record]' min);                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          double max = double.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              max = Math.Max(_values[record]' max);                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          return base.Aggregate(records' kind);                  }              }              catch (OverflowException)              {                  throw ExprException.Overflow(typeof(double));              }
Magic Number,System.Data.Common,Int16Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\Int16Storage.cs,Aggregate,The following statement contains a magic number: try              {                  switch (kind)                  {                      case AggregateType.Sum:                          long sum = defaultValue;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { sum += _values[record]; }                                  hasData = true;                              }                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          long meanSum = defaultValue;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { meanSum += _values[record]; }                                  meanCount++;                                  hasData = true;                              }                          }                          if (hasData)                          {                              short mean;                              checked { mean = (short)(meanSum / meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          double var = 0.0f;                          double prec = 0.0f;                          double dsum = 0.0f;                          double sqrsum = 0.0f;                            foreach (int record in records)                          {                              if (HasValue(record))                              {                                  dsum += _values[record];                                  sqrsum += _values[record] * (double)_values[record];                                  count++;                              }                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                              // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var);                              }                              return var;                          }                          return _nullValue;                          case AggregateType.Min:                          short min = short.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  min = Math.Min(_values[record]' min);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          short max = short.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  max = Math.Max(_values[record]' max);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (HasValue(records[i]))                              {                                  count++;                              }                          }                          return count;                  }              }              catch (OverflowException)              {                  throw ExprException.Overflow(typeof(short));              }
Magic Number,System.Data.Common,Int32Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\Int32Storage.cs,Aggregate,The following statement contains a magic number: try              {                  switch (kind)                  {                      case AggregateType.Sum:                          long sum = 0;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { sum += _values[record]; }                                  hasData = true;                              }                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          long meanSum = 0;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { meanSum += _values[record]; }                                  meanCount++;                                  hasData = true;                              }                          }                          if (hasData)                          {                              int mean;                              checked { mean = (int)(meanSum / meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          double var = 0.0f;                          double prec = 0.0f;                          double dsum = 0.0f;                          double sqrsum = 0.0f;                            foreach (int record in records)                          {                              if (HasValue(record))                              {                                  dsum += _values[record];                                  sqrsum += _values[record] * (double)_values[record];                                  count++;                              }                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                              // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          int min = int.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  min = Math.Min(_values[record]' min);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          int max = int.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  max = Math.Max(_values[record]' max);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (HasValue(records[i]))                              {                                  count++;                              }                          }                          return count;                  }              }              catch (OverflowException)              {                  throw ExprException.Overflow(typeof(int));              }
Magic Number,System.Data.Common,Int64Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\Int64Storage.cs,Aggregate,The following statement contains a magic number: try              {                  switch (kind)                  {                      case AggregateType.Sum:                          long sum = defaultValue;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { sum += _values[record]; }                                  hasData = true;                              }                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          decimal meanSum = defaultValue;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { meanSum += _values[record]; }                                  meanCount++;                                  hasData = true;                              }                          }                          if (hasData)                          {                              long mean;                              checked { mean = (long)(meanSum / (decimal)meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          double var = 0.0f;                          double prec = 0.0f;                          double dsum = 0.0f;                          double sqrsum = 0.0f;                            foreach (int record in records)                          {                              if (HasValue(record))                              {                                  dsum += _values[record];                                  sqrsum += _values[record] * (double)_values[record];                                  count++;                              }                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                              // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          long min = long.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  min = Math.Min(_values[record]' min);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          long max = long.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  max = Math.Max(_values[record]' max);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          return base.Aggregate(records' kind);                  }              }              catch (OverflowException)              {                  throw ExprException.Overflow(typeof(long));              }
Magic Number,System.Data.Common,ObjectStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\ObjectStorage.cs,ConvertXmlToObject,The following statement contains a magic number: if (null == xmlAttrib)              { // this means type implements IXmlSerializable                  Type type = null;                  string typeName = xmlReader.GetAttribute(Keywords.MSD_INSTANCETYPE' Keywords.MSDNS);                  if (typeName == null || typeName.Length == 0)                  { // No CDT polumorphism                      string xsdTypeName = xmlReader.GetAttribute(Keywords.TYPE' Keywords.XSINS); // this xsd type: Base type polymorphism                      if (null != xsdTypeName && xsdTypeName.Length > 0)                      {                          string[] _typename = xsdTypeName.Split(':');                          if (_typename.Length == 2)                          { // split will return aray of size 1 if ":" is not there                              if (xmlReader.LookupNamespace(_typename[0]) == Keywords.XSDNS)                              {                                  xsdTypeName = _typename[1]; // trim the prefix and just continue with                              }                          } // for other case' let say we have two ':' in type' the we throws (as old behavior)                          type = XSDSchema.XsdtoClr(xsdTypeName);                          isBaseCLRType = true;                      }                      else if (_dataType == typeof(object))                      {// there is no Keywords.MSD_INSTANCETYPE and no Keywords.TYPE                          legacyUDT = true;             // see if our type is object                      }                  }                    if (legacyUDT)                  { // if Everett UDT' just read it and return string                      retValue = xmlReader.ReadString();                  }                  else                  {                      if (typeName == Keywords.TYPEINSTANCE)                      {                          retValue = Type.GetType(xmlReader.ReadString());                          xmlReader.Read(); // need to move to next node                      }                      else                      {                          if (null == type)                          {                              type = (typeName == null) ? _dataType : DataStorage.GetType(typeName);                          }                            if (type == typeof(char) || type == typeof(Guid))                          { //msdata:char and msdata:guid imply base types.                              isBaseCLRType = true;                          }                            if (type == typeof(object))                              throw ExceptionBuilder.CanNotDeserializeObjectType();                          if (!isBaseCLRType)                          {                              retValue = System.Activator.CreateInstance(type' true);                              Debug.Assert(xmlReader is DataTextReader' "Invalid DataTextReader is being passed to customer");                              ((IXmlSerializable)retValue).ReadXml(xmlReader);                          }                          else                          {  // Process Base CLR type                             // for Element Node' if it is Empty' ReadString does not move to End Element; we need to move it                              if (type == typeof(string) && xmlReader.NodeType == XmlNodeType.Element && xmlReader.IsEmptyElement)                              {                                  retValue = string.Empty;                              }                              else                              {                                  retValue = xmlReader.ReadString();                                  if (type != typeof(byte[]))                                  {                                      retValue = SqlConvert.ChangeTypeForXML(retValue' type);                                  }                                  else                                  {                                      retValue = Convert.FromBase64String(retValue.ToString());                                  }                              }                              xmlReader.Read();                          }                      }                  }              }              else              {                  XmlSerializer deserializerWithRootAttribute = ObjectStorage.GetXmlSerializer(_dataType' xmlAttrib);                  retValue = deserializerWithRootAttribute.Deserialize(xmlReader);              }
Magic Number,System.Data.Common,SByteStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SByteStorage.cs,Aggregate,The following statement contains a magic number: try              {                  switch (kind)                  {                      case AggregateType.Sum:                          long sum = defaultValue;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          long meanSum = defaultValue;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { meanSum += _values[record]; }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              sbyte mean;                              checked { mean = (sbyte)(meanSum / meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          double var = defaultValue;                          double prec = defaultValue;                          double dsum = defaultValue;                          double sqrsum = defaultValue;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += _values[record];                              sqrsum += _values[record] * (double)_values[record];                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                              // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          sbyte min = sbyte.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              min = Math.Min(_values[record]' min);                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          sbyte max = sbyte.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              max = Math.Max(_values[record]' max);                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          return base.Aggregate(records' kind);                  }              }              catch (OverflowException)              {                  throw ExprException.Overflow(typeof(sbyte));              }
Magic Number,System.Data.Common,SingleStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SingleStorage.cs,Aggregate,The following statement contains a magic number: try              {                  switch (kind)                  {                      case AggregateType.Sum:                          float sum = defaultValue;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          double meanSum = defaultValue;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { meanSum += _values[record]; }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              float mean;                              checked { mean = (float)(meanSum / meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          double var = defaultValue;                          double prec = defaultValue;                          double dsum = defaultValue;                          double sqrsum = defaultValue;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += _values[record];                              sqrsum += _values[record] * (double)_values[record];                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                              // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var);                              }                              return var;                          }                          return _nullValue;                          case AggregateType.Min:                          float min = float.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              min = Math.Min(_values[record]' min);                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          float max = float.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              max = Math.Max(_values[record]' max);                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          return base.Aggregate(records' kind);                  }              }              catch (OverflowException)              {                  throw ExprException.Overflow(typeof(float));              }
Magic Number,System.Data.Common,UInt16Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\UInt16Storage.cs,Aggregate,The following statement contains a magic number: try              {                  switch (kind)                  {                      case AggregateType.Sum:                          ulong sum = s_defaultValue;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { sum += _values[record]; }                                  hasData = true;                              }                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          long meanSum = s_defaultValue;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { meanSum += _values[record]; }                                  meanCount++;                                  hasData = true;                              }                          }                          if (hasData)                          {                              ushort mean;                              checked { mean = (ushort)(meanSum / meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          double var = 0.0f;                          double prec = 0.0f;                          double dsum = 0.0f;                          double sqrsum = 0.0f;                            foreach (int record in records)                          {                              if (HasValue(record))                              {                                  dsum += _values[record];                                  sqrsum += _values[record] * (double)_values[record];                                  count++;                              }                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                              // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          ushort min = ushort.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  min = Math.Min(_values[record]' min);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          ushort max = ushort.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  max = Math.Max(_values[record]' max);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (HasValue(records[i]))                              {                                  count++;                              }                          }                          return count;                  }              }              catch (OverflowException)              {                  throw ExprException.Overflow(typeof(ushort));              }
Magic Number,System.Data.Common,UInt32Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\UInt32Storage.cs,Aggregate,The following statement contains a magic number: try              {                  switch (kind)                  {                      case AggregateType.Sum:                          ulong sum = s_defaultValue;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { sum += _values[record]; }                                  hasData = true;                              }                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          long meanSum = s_defaultValue;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { meanSum += _values[record]; }                                  meanCount++;                                  hasData = true;                              }                          }                          if (hasData)                          {                              uint mean;                              checked { mean = (uint)(meanSum / meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          double var = 0.0f;                          double prec = 0.0f;                          double dsum = 0.0f;                          double sqrsum = 0.0f;                            foreach (int record in records)                          {                              if (HasValue(record))                              {                                  dsum += _values[record];                                  sqrsum += _values[record] * (double)_values[record];                                  count++;                              }                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                              // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          uint min = uint.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  min = Math.Min(_values[record]' min);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          uint max = uint.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  max = Math.Max(_values[record]' max);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (HasValue(records[i]))                                  count++;                          }                          return count;                  }              }              catch (OverflowException)              {                  throw ExprException.Overflow(typeof(uint));              }
Magic Number,System.Data.Common,SqlDecimalStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLDecimalStorage.cs,Aggregate,The following statement contains a magic number: try              {                  switch (kind)                  {                      case AggregateType.Sum:                          SqlDecimal sum = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          SqlDecimal meanSum = 0;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { meanSum += _values[record]; }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              SqlDecimal mean = 0;                              checked { mean = (meanSum / meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          SqlDouble var = 0;                          SqlDouble prec = 0;                          SqlDouble dsum = 0;                          SqlDouble sqrsum = 0;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += _values[record].ToSqlDouble();                              sqrsum += (_values[record]).ToSqlDouble() * (_values[record]).ToSqlDouble();                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                               // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var.Value);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          SqlDecimal min = SqlDecimal.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlDecimal.LessThan(_values[record]' min)).IsTrue)                                  min = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          SqlDecimal max = SqlDecimal.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlDecimal.GreaterThan(_values[record]' max)).IsTrue)                                  max = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                      case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (!IsNull(records[i]))                                  count++;                          }                          return count;                  }              }              catch (OverflowException)              {                  throw ExprException.Overflow(typeof(SqlDecimal));              }
Magic Number,System.Data.Common,SqlDoubleStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLDoubleStorage.cs,Aggregate,The following statement contains a magic number: try              {                  switch (kind)                  {                      case AggregateType.Sum:                          SqlDouble sum = 0.0d;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          SqlDouble meanSum = 0.0d;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { meanSum += _values[record]; }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              SqlDouble mean = 0.0d;                              checked { mean = (meanSum / meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          SqlDouble var = 0.0d;                          SqlDouble prec = 0.0d;                          SqlDouble dsum = 0.0d;                          SqlDouble sqrsum = 0.0d;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += _values[record];                              sqrsum += _values[record] * _values[record];                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                               // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var.Value);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          SqlDouble min = SqlDouble.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlDouble.LessThan(_values[record]' min)).IsTrue)                                  min = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          SqlDouble max = SqlDouble.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlDouble.GreaterThan(_values[record]' max)).IsTrue)                                  max = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;// no data => null                        case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (!IsNull(records[i]))                                  count++;                          }                          return count;                  }              }              catch (OverflowException)              {                  throw ExprException.Overflow(typeof(SqlDouble));              }
Magic Number,System.Data.Common,SqlInt16Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLInt16Storage.cs,Aggregate,The following statement contains a magic number: try              {                  switch (kind)                  {                      case AggregateType.Sum:                          SqlInt64 sum = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          SqlInt64 meanSum = 0;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { meanSum += (_values[record]).ToSqlInt64(); }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              SqlInt16 mean = 0;                              checked { mean = (meanSum / meanCount).ToSqlInt16(); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          SqlDouble var = 0;                          SqlDouble prec = 0;                          SqlDouble dsum = 0;                          SqlDouble sqrsum = 0;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += (_values[record]).ToSqlDouble();                              sqrsum += (_values[record]).ToSqlDouble() * (_values[record]).ToSqlDouble();                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                               // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var.Value);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          SqlInt16 min = SqlInt16.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlInt16.LessThan(_values[record]' min)).IsTrue)                                  min = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          SqlInt16 max = SqlInt16.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlInt16.GreaterThan(_values[record]' max)).IsTrue)                                  max = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;// no data => null                        case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (!IsNull(records[i]))                                  count++;                          }                          return count;                  }              }              catch (OverflowException)              {                  throw ExprException.Overflow(typeof(SqlInt16));              }
Magic Number,System.Data.Common,SqlInt32Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLInt32Storage.cs,Aggregate,The following statement contains a magic number: try              {                  switch (kind)                  {                      case AggregateType.Sum:                          SqlInt64 sum = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          SqlInt64 meanSum = 0;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { meanSum += (_values[record]).ToSqlInt64(); }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              SqlInt32 mean = 0;                              checked { mean = (meanSum / meanCount).ToSqlInt32(); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          SqlDouble var = 0;                          SqlDouble prec = 0;                          SqlDouble dsum = 0;                          SqlDouble sqrsum = 0;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += (_values[record]).ToSqlDouble();                              sqrsum += (_values[record]).ToSqlDouble() * (_values[record]).ToSqlDouble();                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                               // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var.Value);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          SqlInt32 min = SqlInt32.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlInt32.LessThan(_values[record]' min)).IsTrue)                                  min = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          SqlInt32 max = SqlInt32.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlInt32.GreaterThan(_values[record]' max)).IsTrue)                                  max = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (!IsNull(records[i]))                                  count++;                          }                          return count;                  }              }              catch (OverflowException)              {                  throw ExprException.Overflow(typeof(SqlInt32));              }
Magic Number,System.Data.Common,SqlInt64Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLInt64Storage.cs,Aggregate,The following statement contains a magic number: try              {                  switch (kind)                  {                      case AggregateType.Sum:                          SqlInt64 sum = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          SqlDecimal meanSum = 0;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { meanSum += _values[record].ToSqlDecimal(); }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              SqlInt64 mean = 0;                              checked { mean = (meanSum / meanCount).ToSqlInt64(); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          SqlDouble var = 0;                          SqlDouble prec = 0;                          SqlDouble dsum = 0;                          SqlDouble sqrsum = 0;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += (_values[record]).ToSqlDouble();                              sqrsum += (_values[record]).ToSqlDouble() * (_values[record]).ToSqlDouble();                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                               // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var.Value);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          SqlInt64 min = SqlInt64.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlInt64.LessThan(_values[record]' min)).IsTrue)                                  min = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          SqlInt64 max = SqlInt64.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                                if ((SqlInt64.GreaterThan(_values[record]' max)).IsTrue)                                  max = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;// no data => null                        case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (!IsNull(records[i]))                                  count++;                          }                          return count;                  }              }              catch (OverflowException)              {                  throw ExprException.Overflow(typeof(SqlInt64));              }
Magic Number,System.Data.Common,SqlMoneyStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLMoneyStorage.cs,Aggregate,The following statement contains a magic number: try              {                  switch (kind)                  {                      case AggregateType.Sum:                          SqlDecimal sum = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          SqlDecimal meanSum = 0;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { meanSum += (_values[record]).ToSqlDecimal(); }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              SqlMoney mean = 0;                              checked { mean = (meanSum / meanCount).ToSqlMoney(); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          SqlDouble var = 0;                          SqlDouble prec = 0;                          SqlDouble dsum = 0;                          SqlDouble sqrsum = 0;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += _values[record].ToSqlDouble();                              sqrsum += (_values[record]).ToSqlDouble() * (_values[record]).ToSqlDouble();                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                               // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var.Value);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          SqlMoney min = SqlMoney.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlMoney.LessThan(_values[record]' min)).IsTrue)                                  min = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          SqlMoney max = SqlMoney.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlMoney.GreaterThan(_values[record]' max)).IsTrue)                                  max = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (!IsNull(records[i]))                                  count++;                          }                          return count;                  }              }              catch (OverflowException)              {                  throw ExprException.Overflow(typeof(SqlMoney));              }
Magic Number,System.Data.Common,SqlSingleStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLSingleStorage.cs,Aggregate,The following statement contains a magic number: try              {                  switch (kind)                  {                      case AggregateType.Sum:                          SqlSingle sum = 0.0f;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                              return sum;                            return _nullValue;                        case AggregateType.Mean:                          SqlDouble meanSum = 0.0f;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                                checked { meanSum += _values[record].ToSqlDouble(); }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              SqlSingle mean = 0;                              checked { mean = (meanSum / meanCount).ToSqlSingle(); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          SqlDouble var = 0;                          SqlDouble prec = 0;                          SqlDouble dsum = 0;                          SqlDouble sqrsum = 0;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += _values[record].ToSqlDouble();                              sqrsum += (_values[record]).ToSqlDouble() * (_values[record]).ToSqlDouble();                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                               // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var.Value);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          SqlSingle min = SqlSingle.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                                if ((SqlSingle.LessThan(_values[record]' min)).IsTrue)                                  min = _values[record];                              hasData = true;                          }                          if (hasData)                              return min;                          return _nullValue;                        case AggregateType.Max:                          SqlSingle max = SqlSingle.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                                if ((SqlSingle.GreaterThan(_values[record]' max)).IsTrue)                                  max = _values[record];                              hasData = true;                          }                          if (hasData)                              return max;                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (!IsNull(records[i]))                                  count++;                          }                          return count;                  }              }              catch (OverflowException)              {                  throw ExprException.Overflow(typeof(SqlSingle));              }
Magic Number,System.Data.Common,SqlByteStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLByteStorage.cs,Aggregate,The following statement contains a magic number: try              {                  switch (kind)                  {                      case AggregateType.Sum:                          SqlInt64 sum = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          SqlInt64 meanSum = 0;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { meanSum += _values[record].ToSqlInt64(); }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              SqlByte mean = 0;                              checked { mean = (meanSum / meanCount).ToSqlByte(); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          SqlDouble var = 0;                          SqlDouble prec = 0;                          SqlDouble dsum = 0;                          SqlDouble sqrsum = 0;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += _values[record].ToSqlDouble();                              sqrsum += _values[record].ToSqlDouble() * _values[record].ToSqlDouble();                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                               // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var.Value);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          SqlByte min = SqlByte.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlByte.LessThan(_values[record]' min)).IsTrue)                                  min = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          SqlByte max = SqlByte.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlByte.GreaterThan(_values[record]' max)).IsTrue)                                  max = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;// no data => null                        case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (!IsNull(records[i]))                                  count++;                          }                          return count;                  }              }              catch (OverflowException)              {                  throw ExprException.Overflow(typeof(SqlByte));              }
Magic Number,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,AddPointer,The following statement contains a magic number: lock (_pointers)              {                  _countAddPointer++;                  if (_countAddPointer >= 5)                  {   // 5 is choosed to be small enough to not affect perf' but high enough so we will not scan all the time                      ArrayList al = new ArrayList();                      foreach (DictionaryEntry entry in _pointers)                      {                          IXmlDataVirtualNode temp = (IXmlDataVirtualNode)(entry.Value);                          Debug.Assert(temp != null);                          if (!temp.IsInUse())                              al.Add(temp);                      }                      for (int i = 0; i < al.Count; i++)                      {                          _pointers.Remove(al[i]);                      }                      _countAddPointer = 0;                  }                  _pointers[pointer] = pointer;              }
Magic Number,System.Xml,XPathNodePointer,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XPathNodePointer.cs,XPathNodePointer,The following statement contains a magic number: s_xmlNodeType_To_XpathNodeType_Map = new int[20];
Magic Number,System.Data,XDRSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XDRSchema.cs,ParseDataType,The following statement contains a magic number: if (parts.Length > 2)              {                  throw ExceptionBuilder.InvalidAttributeValue("type"' dt);              }              else if (parts.Length == 2)              {                  // CONSIDER: check that we have valid prefix                  strType = parts[1];              }
Magic Number,System.Data,XDRSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XDRSchema.cs,ParseDataType,The following statement contains a magic number: if (parts.Length > 2)              {                  throw ExceptionBuilder.InvalidAttributeValue("type"' dt);              }              else if (parts.Length == 2)              {                  // CONSIDER: check that we have valid prefix                  strType = parts[1];              }
Magic Number,System.Data,XmlDataLoader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XmlDataLoader.cs,XmlDataLoader,The following statement contains a magic number: _childRowsStack = new Stack(50);
Magic Number,System.Data,XmlDataLoader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XmlDataLoader.cs,XmlDataLoader,The following statement contains a magic number: _childRowsStack = new Stack(50);
Magic Number,System.Data,XmlDataLoader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XmlDataLoader.cs,LoadTable,The following statement contains a magic number: for (int i = _dataReader.AttributeCount - 1; i >= 0; --i)              {                  // Check all attributes one by one                  _dataReader.MoveToAttribute(i);                  // Get this attribute                    c = _nodeToSchemaMap.GetColumnSchema(table' _dataReader' FIgnoreNamespace(_dataReader)) as DataColumn;                  // Try to get column for this attribute                    if ((c != null) && (c.ColumnMapping == MappingType.Attribute))                  {                      // Yep' it is a column mapped as attribute                      // Get value from XML and store it in the object array                      foundColumns[c.Ordinal] = c.ConvertXmlToObject(_dataReader.Value);                  }                                               // Oops. No column for this element                    if (_isDiffgram)                  {                             // Now handle some diffgram attributes                       if (_dataReader.NamespaceURI == Keywords.DFFNS)                      {                          switch (_dataReader.LocalName)                          {                              case Keywords.DIFFID:                   // Is it a diffgeam ID ?                                  diffId = _dataReader.Value;          // Store ID                                  break;                              case Keywords.HASCHANGES:               // Has changes attribute ?                                  hasChanges = _dataReader.Value;      // Store value                                  break;                              case Keywords.HASERRORS:                // Has errors attribute ?                                  hasErrors = (bool)Convert.ChangeType(_dataReader.Value' typeof(bool)' CultureInfo.InvariantCulture);                                  // Store value                                  break;                          }                      }                      else if (_dataReader.NamespaceURI == Keywords.MSDNS)                      {                          if (_dataReader.LocalName == Keywords.ROWORDER)                          {                              // Is it a row order attribute ?                              rowOrder = (int)Convert.ChangeType(_dataReader.Value' typeof(int)' CultureInfo.InvariantCulture);                              // Store it                          }                          else if (_dataReader.LocalName.StartsWith("hidden"' StringComparison.Ordinal))                          {                              // Hidden column ?                              c = collection[XmlConvert.DecodeName(_dataReader.LocalName.Substring(6))];                              // Let's see if we have one.                               // We have to decode name before we look it up                              // We could not use XmlToDataSet map as it contains                              // no hidden columns                              if ((c != null) && (c.ColumnMapping == MappingType.Hidden))                              {                                  // Got column and it is hidden ?                                  foundColumns[c.Ordinal] = c.ConvertXmlToObject(_dataReader.Value);                              }                          }                      }                  }              }
Magic Number,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleRelation,The following statement contains a magic number: if ((_ds == null) || (_ds.Tables.InternalIndexOf(rel.ParentKey.Table.TableName) == -3))                  root.SetAttribute(Keywords.MSD_PARENTTABLENS' Keywords.MSDNS' rel.ParentKey.Table.Namespace);
Magic Number,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleRelation,The following statement contains a magic number: if ((_ds == null) || (_ds.Tables.InternalIndexOf(rel.ChildKey.Table.TableName) == -3))                  root.SetAttribute(Keywords.MSD_CHILDTABLENS' Keywords.MSDNS' rel.ChildKey.Table.Namespace);
Magic Number,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleTable,The following statement contains a magic number: if (cCount == 1 || cCount == 2)                  for (int i = 0; i < cCount; i++)                  {                      DataColumn col = columns[i];                        if (col.ColumnMapping == MappingType.Hidden)                      {                          DataRelationCollection childRelations = table.ChildRelations;                          for (int j = 0; j < childRelations.Count; j++)                          {                              if (childRelations[j].Nested && childRelations[j].ParentKey.ColumnsReference.Length == 1 && childRelations[j].ParentKey.ColumnsReference[0] == col)                                  realCount++;                          }                      }                        if (col.ColumnMapping == MappingType.Element)                          realCount++;                  }
Magic Number,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleTable,The following statement contains a magic number: for (int i = 0; i < constraints.Count; i++)              {                  XmlElement constraint = null;                  DataColumn[] fields;                    if (constraints[i] is UniqueConstraint)                  {                      UniqueConstraint unique = (UniqueConstraint)constraints[i];                        if (IsAutoGenerated(unique))                          continue;                        // special case of the ghosted constraints:                      fields = unique.Key.ColumnsReference;                          constraint = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_UNIQUE' Keywords.XSDNS);                        if ((_ds == null) || (_ds.Tables.InternalIndexOf(table.TableName) == -3))                          constraint.SetAttribute(Keywords.MSD_TABLENS' Keywords.MSDNS' table.Namespace);                      // convert constraint name to valid xml name                      constraint.SetAttribute(Keywords.NAME' XmlConvert.EncodeLocalName(unique.SchemaName));                        if (unique.ConstraintName != unique.SchemaName)                          constraint.SetAttribute(Keywords.MSD_CONSTRAINTNAME' Keywords.MSDNS' unique.ConstraintName);                        AddExtendedProperties(unique._extendedProperties' constraint);                          selector = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_SELECTOR' Keywords.XSDNS);                      selector.SetAttribute(Keywords.XSD_XPATH' ".//" + xpathprefix + table.EncodedTableName);                        constraint.AppendChild(selector);                          if (unique.IsPrimaryKey)                      {                          constraint.SetAttribute(Keywords.MSD_PRIMARYKEY' Keywords.MSDNS' Keywords.TRUE);                      }                        if (0 < fields.Length)                      {                          StringBuilder encodedName = new StringBuilder();                          for (int k = 0; k < fields.Length; k++)                          {                              encodedName.Length = 0;                                if (_schFormat != SchemaFormat.Remoting)                              {                                  GetSchema(fields[k].Namespace);                                  if (!string.IsNullOrEmpty(fields[k].Namespace))                                  {                                      encodedName.Append(_prefixes[fields[k].Namespace]).Append(':');                                  }                                  encodedName.Append(fields[k].EncodedColumnName);                              }                              else                              {                                  encodedName.Append(xpathprefix).Append(fields[k].EncodedColumnName);                              }                              if ((fields[k].ColumnMapping == MappingType.Attribute) || (fields[k].ColumnMapping == MappingType.Hidden))                              {                                  encodedName.Insert(0' '@');                              }                              field = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_FIELD' Keywords.XSDNS);                              field.SetAttribute(Keywords.XSD_XPATH' encodedName.ToString());                                constraint.AppendChild(field);                          }                      }                        _dsElement.InsertBefore(constraint' _constraintSeparator);                  }                  else if (constraints[i] is ForeignKeyConstraint && genNested)                  {                      ForeignKeyConstraint foreign = (ForeignKeyConstraint)constraints[i];                        if (_tables.Count > 0)                      {                          if (!_tables.Contains(foreign.RelatedTable) || !_tables.Contains(foreign.Table))                              continue;                      }                        if (IsAutoGenerated(foreign))                          continue;                          DataRelation rel = foreign.FindParentRelation();                        // special case of the ghosted constraints:                      fields = foreign.RelatedColumnsReference;                          UniqueConstraint _constraint = (UniqueConstraint)foreign.RelatedTable.Constraints.FindConstraint(new UniqueConstraint("TEMP"' fields));                        if (_constraint == null)                      {                          constraint = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_KEY' Keywords.XSDNS);                          constraint.SetAttribute(Keywords.NAME' XmlConvert.EncodeLocalName(foreign.SchemaName));                            if ((_ds == null) || (_ds.Tables.InternalIndexOf(table.TableName) == -3))                              constraint.SetAttribute(Keywords.MSD_TABLENS' Keywords.MSDNS' table.Namespace);                            selector = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_SELECTOR' Keywords.XSDNS);                          selector.SetAttribute(Keywords.XSD_XPATH' ".//" + xpathprefix + foreign.RelatedTable.EncodedTableName);                            constraint.AppendChild(selector);                            if (0 < fields.Length)                          {                              StringBuilder encodedName = new StringBuilder();                              for (int k = 0; k < fields.Length; k++)                              {                                  encodedName.Length = 0;                                    if (_schFormat != SchemaFormat.Remoting)                                  {                                      GetSchema(fields[k].Namespace);                                      if (!string.IsNullOrEmpty(fields[k].Namespace))                                      {                                          encodedName.Append(_prefixes[fields[k].Namespace]).Append(':');                                      }                                      encodedName.Append(fields[k].EncodedColumnName);                                  }                                  else                                  {                                      encodedName.Append(xpathprefix).Append(fields[k].EncodedColumnName);                                  }                                  if ((fields[k].ColumnMapping == MappingType.Attribute) || (fields[k].ColumnMapping == MappingType.Hidden))                                  {                                      encodedName.Insert(0' '@');                                  }                                  field = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_FIELD' Keywords.XSDNS);                                  field.SetAttribute(Keywords.XSD_XPATH' encodedName.ToString());                                    constraint.AppendChild(field);                              }                          }                            _dsElement.InsertBefore(constraint' _constraintSeparator);                      }                        constraint = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_KEYREF' Keywords.XSDNS);                      // convert constraint name to valid xml name                      constraint.SetAttribute(Keywords.NAME' XmlConvert.EncodeLocalName(foreign.SchemaName));                        if ((_ds == null) || (_ds.Tables.InternalIndexOf(foreign.RelatedTable.TableName) == -3)) // if there is a conflicting name/namespace only                          constraint.SetAttribute(Keywords.MSD_TABLENS' Keywords.MSDNS' foreign.Table.Namespace);                        if (_constraint == null)                          constraint.SetAttribute(Keywords.REFER' XmlConvert.EncodeLocalName(foreign.SchemaName));                      else                          constraint.SetAttribute(Keywords.REFER' XmlConvert.EncodeLocalName(_constraint.SchemaName));                        AddExtendedProperties(foreign._extendedProperties' constraint' typeof(ForeignKeyConstraint));                        if (foreign.ConstraintName != foreign.SchemaName)                          constraint.SetAttribute(Keywords.MSD_CONSTRAINTNAME' Keywords.MSDNS' foreign.ConstraintName);                        if (null == rel)                      {                          constraint.SetAttribute(Keywords.MSD_CONSTRAINTONLY' Keywords.MSDNS' Keywords.TRUE);                      }                      else                      {                          if (rel.Nested)                              constraint.SetAttribute(Keywords.MSD_ISNESTED' Keywords.MSDNS' Keywords.TRUE);                            AddExtendedProperties(rel._extendedProperties' constraint' typeof(DataRelation));                          if (foreign.ConstraintName != rel.RelationName)                          {                              constraint.SetAttribute(Keywords.MSD_RELATIONNAME' Keywords.MSDNS' XmlConvert.EncodeLocalName(rel.RelationName));                          }                      }                        selector = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_SELECTOR' Keywords.XSDNS);                      selector.SetAttribute(Keywords.XSD_XPATH' ".//" + xpathprefix + table.EncodedTableName);                        constraint.AppendChild(selector);                        if (foreign.AcceptRejectRule != ForeignKeyConstraint.AcceptRejectRule_Default)                          constraint.SetAttribute(Keywords.MSD_ACCEPTREJECTRULE' Keywords.MSDNS'                                                  TranslateAcceptRejectRule(foreign.AcceptRejectRule));                        if (foreign.UpdateRule != ForeignKeyConstraint.Rule_Default)                          constraint.SetAttribute(Keywords.MSD_UPDATERULE' Keywords.MSDNS' TranslateRule(foreign.UpdateRule));                        if (foreign.DeleteRule != ForeignKeyConstraint.Rule_Default)                          constraint.SetAttribute(Keywords.MSD_DELETERULE' Keywords.MSDNS' TranslateRule(foreign.DeleteRule));                        fields = foreign.Columns;                        if (0 < fields.Length)                      {                          StringBuilder encodedName = new StringBuilder();                          for (int k = 0; k < fields.Length; k++)                          {                              encodedName.Length = 0;                                if (_schFormat != SchemaFormat.Remoting)                              {                                  GetSchema(fields[k].Namespace);                                  if (!string.IsNullOrEmpty(fields[k].Namespace))                                  {                                      encodedName.Append(_prefixes[fields[k].Namespace]).Append(':');                                  }                                  encodedName.Append(fields[k].EncodedColumnName);                              }                              else                              {                                  encodedName.Append(xpathprefix).Append(fields[k].EncodedColumnName);                              }                              if ((fields[k].ColumnMapping == MappingType.Attribute) || (fields[k].ColumnMapping == MappingType.Hidden))                              {                                  encodedName.Insert(0' '@');                              }                              field = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_FIELD' Keywords.XSDNS);                              field.SetAttribute(Keywords.XSD_XPATH' encodedName.ToString());                                constraint.AppendChild(field);                          }                      }                        _dsElement.InsertAfter(constraint' _constraintSeparator);                  }              }
Magic Number,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleTable,The following statement contains a magic number: for (int i = 0; i < constraints.Count; i++)              {                  XmlElement constraint = null;                  DataColumn[] fields;                    if (constraints[i] is UniqueConstraint)                  {                      UniqueConstraint unique = (UniqueConstraint)constraints[i];                        if (IsAutoGenerated(unique))                          continue;                        // special case of the ghosted constraints:                      fields = unique.Key.ColumnsReference;                          constraint = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_UNIQUE' Keywords.XSDNS);                        if ((_ds == null) || (_ds.Tables.InternalIndexOf(table.TableName) == -3))                          constraint.SetAttribute(Keywords.MSD_TABLENS' Keywords.MSDNS' table.Namespace);                      // convert constraint name to valid xml name                      constraint.SetAttribute(Keywords.NAME' XmlConvert.EncodeLocalName(unique.SchemaName));                        if (unique.ConstraintName != unique.SchemaName)                          constraint.SetAttribute(Keywords.MSD_CONSTRAINTNAME' Keywords.MSDNS' unique.ConstraintName);                        AddExtendedProperties(unique._extendedProperties' constraint);                          selector = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_SELECTOR' Keywords.XSDNS);                      selector.SetAttribute(Keywords.XSD_XPATH' ".//" + xpathprefix + table.EncodedTableName);                        constraint.AppendChild(selector);                          if (unique.IsPrimaryKey)                      {                          constraint.SetAttribute(Keywords.MSD_PRIMARYKEY' Keywords.MSDNS' Keywords.TRUE);                      }                        if (0 < fields.Length)                      {                          StringBuilder encodedName = new StringBuilder();                          for (int k = 0; k < fields.Length; k++)                          {                              encodedName.Length = 0;                                if (_schFormat != SchemaFormat.Remoting)                              {                                  GetSchema(fields[k].Namespace);                                  if (!string.IsNullOrEmpty(fields[k].Namespace))                                  {                                      encodedName.Append(_prefixes[fields[k].Namespace]).Append(':');                                  }                                  encodedName.Append(fields[k].EncodedColumnName);                              }                              else                              {                                  encodedName.Append(xpathprefix).Append(fields[k].EncodedColumnName);                              }                              if ((fields[k].ColumnMapping == MappingType.Attribute) || (fields[k].ColumnMapping == MappingType.Hidden))                              {                                  encodedName.Insert(0' '@');                              }                              field = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_FIELD' Keywords.XSDNS);                              field.SetAttribute(Keywords.XSD_XPATH' encodedName.ToString());                                constraint.AppendChild(field);                          }                      }                        _dsElement.InsertBefore(constraint' _constraintSeparator);                  }                  else if (constraints[i] is ForeignKeyConstraint && genNested)                  {                      ForeignKeyConstraint foreign = (ForeignKeyConstraint)constraints[i];                        if (_tables.Count > 0)                      {                          if (!_tables.Contains(foreign.RelatedTable) || !_tables.Contains(foreign.Table))                              continue;                      }                        if (IsAutoGenerated(foreign))                          continue;                          DataRelation rel = foreign.FindParentRelation();                        // special case of the ghosted constraints:                      fields = foreign.RelatedColumnsReference;                          UniqueConstraint _constraint = (UniqueConstraint)foreign.RelatedTable.Constraints.FindConstraint(new UniqueConstraint("TEMP"' fields));                        if (_constraint == null)                      {                          constraint = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_KEY' Keywords.XSDNS);                          constraint.SetAttribute(Keywords.NAME' XmlConvert.EncodeLocalName(foreign.SchemaName));                            if ((_ds == null) || (_ds.Tables.InternalIndexOf(table.TableName) == -3))                              constraint.SetAttribute(Keywords.MSD_TABLENS' Keywords.MSDNS' table.Namespace);                            selector = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_SELECTOR' Keywords.XSDNS);                          selector.SetAttribute(Keywords.XSD_XPATH' ".//" + xpathprefix + foreign.RelatedTable.EncodedTableName);                            constraint.AppendChild(selector);                            if (0 < fields.Length)                          {                              StringBuilder encodedName = new StringBuilder();                              for (int k = 0; k < fields.Length; k++)                              {                                  encodedName.Length = 0;                                    if (_schFormat != SchemaFormat.Remoting)                                  {                                      GetSchema(fields[k].Namespace);                                      if (!string.IsNullOrEmpty(fields[k].Namespace))                                      {                                          encodedName.Append(_prefixes[fields[k].Namespace]).Append(':');                                      }                                      encodedName.Append(fields[k].EncodedColumnName);                                  }                                  else                                  {                                      encodedName.Append(xpathprefix).Append(fields[k].EncodedColumnName);                                  }                                  if ((fields[k].ColumnMapping == MappingType.Attribute) || (fields[k].ColumnMapping == MappingType.Hidden))                                  {                                      encodedName.Insert(0' '@');                                  }                                  field = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_FIELD' Keywords.XSDNS);                                  field.SetAttribute(Keywords.XSD_XPATH' encodedName.ToString());                                    constraint.AppendChild(field);                              }                          }                            _dsElement.InsertBefore(constraint' _constraintSeparator);                      }                        constraint = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_KEYREF' Keywords.XSDNS);                      // convert constraint name to valid xml name                      constraint.SetAttribute(Keywords.NAME' XmlConvert.EncodeLocalName(foreign.SchemaName));                        if ((_ds == null) || (_ds.Tables.InternalIndexOf(foreign.RelatedTable.TableName) == -3)) // if there is a conflicting name/namespace only                          constraint.SetAttribute(Keywords.MSD_TABLENS' Keywords.MSDNS' foreign.Table.Namespace);                        if (_constraint == null)                          constraint.SetAttribute(Keywords.REFER' XmlConvert.EncodeLocalName(foreign.SchemaName));                      else                          constraint.SetAttribute(Keywords.REFER' XmlConvert.EncodeLocalName(_constraint.SchemaName));                        AddExtendedProperties(foreign._extendedProperties' constraint' typeof(ForeignKeyConstraint));                        if (foreign.ConstraintName != foreign.SchemaName)                          constraint.SetAttribute(Keywords.MSD_CONSTRAINTNAME' Keywords.MSDNS' foreign.ConstraintName);                        if (null == rel)                      {                          constraint.SetAttribute(Keywords.MSD_CONSTRAINTONLY' Keywords.MSDNS' Keywords.TRUE);                      }                      else                      {                          if (rel.Nested)                              constraint.SetAttribute(Keywords.MSD_ISNESTED' Keywords.MSDNS' Keywords.TRUE);                            AddExtendedProperties(rel._extendedProperties' constraint' typeof(DataRelation));                          if (foreign.ConstraintName != rel.RelationName)                          {                              constraint.SetAttribute(Keywords.MSD_RELATIONNAME' Keywords.MSDNS' XmlConvert.EncodeLocalName(rel.RelationName));                          }                      }                        selector = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_SELECTOR' Keywords.XSDNS);                      selector.SetAttribute(Keywords.XSD_XPATH' ".//" + xpathprefix + table.EncodedTableName);                        constraint.AppendChild(selector);                        if (foreign.AcceptRejectRule != ForeignKeyConstraint.AcceptRejectRule_Default)                          constraint.SetAttribute(Keywords.MSD_ACCEPTREJECTRULE' Keywords.MSDNS'                                                  TranslateAcceptRejectRule(foreign.AcceptRejectRule));                        if (foreign.UpdateRule != ForeignKeyConstraint.Rule_Default)                          constraint.SetAttribute(Keywords.MSD_UPDATERULE' Keywords.MSDNS' TranslateRule(foreign.UpdateRule));                        if (foreign.DeleteRule != ForeignKeyConstraint.Rule_Default)                          constraint.SetAttribute(Keywords.MSD_DELETERULE' Keywords.MSDNS' TranslateRule(foreign.DeleteRule));                        fields = foreign.Columns;                        if (0 < fields.Length)                      {                          StringBuilder encodedName = new StringBuilder();                          for (int k = 0; k < fields.Length; k++)                          {                              encodedName.Length = 0;                                if (_schFormat != SchemaFormat.Remoting)                              {                                  GetSchema(fields[k].Namespace);                                  if (!string.IsNullOrEmpty(fields[k].Namespace))                                  {                                      encodedName.Append(_prefixes[fields[k].Namespace]).Append(':');                                  }                                  encodedName.Append(fields[k].EncodedColumnName);                              }                              else                              {                                  encodedName.Append(xpathprefix).Append(fields[k].EncodedColumnName);                              }                              if ((fields[k].ColumnMapping == MappingType.Attribute) || (fields[k].ColumnMapping == MappingType.Hidden))                              {                                  encodedName.Insert(0' '@');                              }                              field = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_FIELD' Keywords.XSDNS);                              field.SetAttribute(Keywords.XSD_XPATH' encodedName.ToString());                                constraint.AppendChild(field);                          }                      }                        _dsElement.InsertAfter(constraint' _constraintSeparator);                  }              }
Magic Number,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleTable,The following statement contains a magic number: for (int i = 0; i < constraints.Count; i++)              {                  XmlElement constraint = null;                  DataColumn[] fields;                    if (constraints[i] is UniqueConstraint)                  {                      UniqueConstraint unique = (UniqueConstraint)constraints[i];                        if (IsAutoGenerated(unique))                          continue;                        // special case of the ghosted constraints:                      fields = unique.Key.ColumnsReference;                          constraint = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_UNIQUE' Keywords.XSDNS);                        if ((_ds == null) || (_ds.Tables.InternalIndexOf(table.TableName) == -3))                          constraint.SetAttribute(Keywords.MSD_TABLENS' Keywords.MSDNS' table.Namespace);                      // convert constraint name to valid xml name                      constraint.SetAttribute(Keywords.NAME' XmlConvert.EncodeLocalName(unique.SchemaName));                        if (unique.ConstraintName != unique.SchemaName)                          constraint.SetAttribute(Keywords.MSD_CONSTRAINTNAME' Keywords.MSDNS' unique.ConstraintName);                        AddExtendedProperties(unique._extendedProperties' constraint);                          selector = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_SELECTOR' Keywords.XSDNS);                      selector.SetAttribute(Keywords.XSD_XPATH' ".//" + xpathprefix + table.EncodedTableName);                        constraint.AppendChild(selector);                          if (unique.IsPrimaryKey)                      {                          constraint.SetAttribute(Keywords.MSD_PRIMARYKEY' Keywords.MSDNS' Keywords.TRUE);                      }                        if (0 < fields.Length)                      {                          StringBuilder encodedName = new StringBuilder();                          for (int k = 0; k < fields.Length; k++)                          {                              encodedName.Length = 0;                                if (_schFormat != SchemaFormat.Remoting)                              {                                  GetSchema(fields[k].Namespace);                                  if (!string.IsNullOrEmpty(fields[k].Namespace))                                  {                                      encodedName.Append(_prefixes[fields[k].Namespace]).Append(':');                                  }                                  encodedName.Append(fields[k].EncodedColumnName);                              }                              else                              {                                  encodedName.Append(xpathprefix).Append(fields[k].EncodedColumnName);                              }                              if ((fields[k].ColumnMapping == MappingType.Attribute) || (fields[k].ColumnMapping == MappingType.Hidden))                              {                                  encodedName.Insert(0' '@');                              }                              field = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_FIELD' Keywords.XSDNS);                              field.SetAttribute(Keywords.XSD_XPATH' encodedName.ToString());                                constraint.AppendChild(field);                          }                      }                        _dsElement.InsertBefore(constraint' _constraintSeparator);                  }                  else if (constraints[i] is ForeignKeyConstraint && genNested)                  {                      ForeignKeyConstraint foreign = (ForeignKeyConstraint)constraints[i];                        if (_tables.Count > 0)                      {                          if (!_tables.Contains(foreign.RelatedTable) || !_tables.Contains(foreign.Table))                              continue;                      }                        if (IsAutoGenerated(foreign))                          continue;                          DataRelation rel = foreign.FindParentRelation();                        // special case of the ghosted constraints:                      fields = foreign.RelatedColumnsReference;                          UniqueConstraint _constraint = (UniqueConstraint)foreign.RelatedTable.Constraints.FindConstraint(new UniqueConstraint("TEMP"' fields));                        if (_constraint == null)                      {                          constraint = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_KEY' Keywords.XSDNS);                          constraint.SetAttribute(Keywords.NAME' XmlConvert.EncodeLocalName(foreign.SchemaName));                            if ((_ds == null) || (_ds.Tables.InternalIndexOf(table.TableName) == -3))                              constraint.SetAttribute(Keywords.MSD_TABLENS' Keywords.MSDNS' table.Namespace);                            selector = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_SELECTOR' Keywords.XSDNS);                          selector.SetAttribute(Keywords.XSD_XPATH' ".//" + xpathprefix + foreign.RelatedTable.EncodedTableName);                            constraint.AppendChild(selector);                            if (0 < fields.Length)                          {                              StringBuilder encodedName = new StringBuilder();                              for (int k = 0; k < fields.Length; k++)                              {                                  encodedName.Length = 0;                                    if (_schFormat != SchemaFormat.Remoting)                                  {                                      GetSchema(fields[k].Namespace);                                      if (!string.IsNullOrEmpty(fields[k].Namespace))                                      {                                          encodedName.Append(_prefixes[fields[k].Namespace]).Append(':');                                      }                                      encodedName.Append(fields[k].EncodedColumnName);                                  }                                  else                                  {                                      encodedName.Append(xpathprefix).Append(fields[k].EncodedColumnName);                                  }                                  if ((fields[k].ColumnMapping == MappingType.Attribute) || (fields[k].ColumnMapping == MappingType.Hidden))                                  {                                      encodedName.Insert(0' '@');                                  }                                  field = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_FIELD' Keywords.XSDNS);                                  field.SetAttribute(Keywords.XSD_XPATH' encodedName.ToString());                                    constraint.AppendChild(field);                              }                          }                            _dsElement.InsertBefore(constraint' _constraintSeparator);                      }                        constraint = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_KEYREF' Keywords.XSDNS);                      // convert constraint name to valid xml name                      constraint.SetAttribute(Keywords.NAME' XmlConvert.EncodeLocalName(foreign.SchemaName));                        if ((_ds == null) || (_ds.Tables.InternalIndexOf(foreign.RelatedTable.TableName) == -3)) // if there is a conflicting name/namespace only                          constraint.SetAttribute(Keywords.MSD_TABLENS' Keywords.MSDNS' foreign.Table.Namespace);                        if (_constraint == null)                          constraint.SetAttribute(Keywords.REFER' XmlConvert.EncodeLocalName(foreign.SchemaName));                      else                          constraint.SetAttribute(Keywords.REFER' XmlConvert.EncodeLocalName(_constraint.SchemaName));                        AddExtendedProperties(foreign._extendedProperties' constraint' typeof(ForeignKeyConstraint));                        if (foreign.ConstraintName != foreign.SchemaName)                          constraint.SetAttribute(Keywords.MSD_CONSTRAINTNAME' Keywords.MSDNS' foreign.ConstraintName);                        if (null == rel)                      {                          constraint.SetAttribute(Keywords.MSD_CONSTRAINTONLY' Keywords.MSDNS' Keywords.TRUE);                      }                      else                      {                          if (rel.Nested)                              constraint.SetAttribute(Keywords.MSD_ISNESTED' Keywords.MSDNS' Keywords.TRUE);                            AddExtendedProperties(rel._extendedProperties' constraint' typeof(DataRelation));                          if (foreign.ConstraintName != rel.RelationName)                          {                              constraint.SetAttribute(Keywords.MSD_RELATIONNAME' Keywords.MSDNS' XmlConvert.EncodeLocalName(rel.RelationName));                          }                      }                        selector = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_SELECTOR' Keywords.XSDNS);                      selector.SetAttribute(Keywords.XSD_XPATH' ".//" + xpathprefix + table.EncodedTableName);                        constraint.AppendChild(selector);                        if (foreign.AcceptRejectRule != ForeignKeyConstraint.AcceptRejectRule_Default)                          constraint.SetAttribute(Keywords.MSD_ACCEPTREJECTRULE' Keywords.MSDNS'                                                  TranslateAcceptRejectRule(foreign.AcceptRejectRule));                        if (foreign.UpdateRule != ForeignKeyConstraint.Rule_Default)                          constraint.SetAttribute(Keywords.MSD_UPDATERULE' Keywords.MSDNS' TranslateRule(foreign.UpdateRule));                        if (foreign.DeleteRule != ForeignKeyConstraint.Rule_Default)                          constraint.SetAttribute(Keywords.MSD_DELETERULE' Keywords.MSDNS' TranslateRule(foreign.DeleteRule));                        fields = foreign.Columns;                        if (0 < fields.Length)                      {                          StringBuilder encodedName = new StringBuilder();                          for (int k = 0; k < fields.Length; k++)                          {                              encodedName.Length = 0;                                if (_schFormat != SchemaFormat.Remoting)                              {                                  GetSchema(fields[k].Namespace);                                  if (!string.IsNullOrEmpty(fields[k].Namespace))                                  {                                      encodedName.Append(_prefixes[fields[k].Namespace]).Append(':');                                  }                                  encodedName.Append(fields[k].EncodedColumnName);                              }                              else                              {                                  encodedName.Append(xpathprefix).Append(fields[k].EncodedColumnName);                              }                              if ((fields[k].ColumnMapping == MappingType.Attribute) || (fields[k].ColumnMapping == MappingType.Hidden))                              {                                  encodedName.Insert(0' '@');                              }                              field = dc.CreateElement(Keywords.XSD_PREFIX' Keywords.XSD_FIELD' Keywords.XSDNS);                              field.SetAttribute(Keywords.XSD_XPATH' encodedName.ToString());                                constraint.AppendChild(field);                          }                      }                        _dsElement.InsertAfter(constraint' _constraintSeparator);                  }              }
Magic Number,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,SetExtProperties,The following statement contains a magic number: for (int i = 0; i < attrs.Length; i++)              {                  if (attrs[i].NamespaceURI == Keywords.MSPROPNS)                  {                      if (props == null)                      {                          object val = TypeDescriptor.GetProperties(instance)["ExtendedProperties"].GetValue(instance);                          Debug.Assert(val is PropertyCollection' "We can set values only for classes that have ExtendedProperties");                          props = (PropertyCollection)val;                      }                      string propName = XmlConvert.DecodeName(attrs[i].LocalName);                        if (instance is ForeignKeyConstraint)                      {                          if (propName.StartsWith(Keywords.MSD_FK_PREFIX' StringComparison.Ordinal))                              propName = propName.Substring(3);                          else                              continue;                      }                      if ((instance is DataRelation) && (propName.StartsWith(Keywords.MSD_REL_PREFIX' StringComparison.Ordinal)))                      {                          propName = propName.Substring(4);                      }                      else if ((instance is DataRelation) && (propName.StartsWith(Keywords.MSD_FK_PREFIX' StringComparison.Ordinal)))                      {                          continue;                      }                        props.Add(propName' attrs[i].Value);                  }              }
Magic Number,System.Data,XSDSchema,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XMLSchema.cs,SetExtProperties,The following statement contains a magic number: for (int i = 0; i < attrs.Length; i++)              {                  if (attrs[i].NamespaceURI == Keywords.MSPROPNS)                  {                      if (props == null)                      {                          object val = TypeDescriptor.GetProperties(instance)["ExtendedProperties"].GetValue(instance);                          Debug.Assert(val is PropertyCollection' "We can set values only for classes that have ExtendedProperties");                          props = (PropertyCollection)val;                      }                      string propName = XmlConvert.DecodeName(attrs[i].LocalName);                        if (instance is ForeignKeyConstraint)                      {                          if (propName.StartsWith(Keywords.MSD_FK_PREFIX' StringComparison.Ordinal))                              propName = propName.Substring(3);                          else                              continue;                      }                      if ((instance is DataRelation) && (propName.StartsWith(Keywords.MSD_REL_PREFIX' StringComparison.Ordinal)))                      {                          propName = propName.Substring(4);                      }                      else if ((instance is DataRelation) && (propName.StartsWith(Keywords.MSD_FK_PREFIX' StringComparison.Ordinal)))                      {                          continue;                      }                        props.Add(propName' attrs[i].Value);                  }              }
Magic Number,System.Data,ConstraintCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ConstraintCollection.cs,InternalIndexOf,The following statement contains a magic number: if ((null != constraintName) && (0 < constraintName.Length))              {                  int constraintCount = List.Count;                  int result = 0;                  for (int i = 0; i < constraintCount; i++)                  {                      Constraint constraint = (Constraint)List[i];                      result = NamesEqual(constraint.ConstraintName' constraintName' false' _table.Locale);                      if (result == 1)                          return i;                        if (result == -1)                          cachedI = (cachedI == -1) ? i : -2;                  }              }
Magic Number,System.Data,DataColumn,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataColumn.cs,SetOrdinalInternal,The following statement contains a magic number: if (_ordinal != ordinal)              {                  if (Unique && _ordinal != -1 && ordinal == -1)                  {                      UniqueConstraint key = _table.Constraints.FindKeyConstraint(this);                      if (key != null)                      {                          _table.Constraints.Remove(key);                      }                  }                    if ((null != _sortIndex) && (-1 == ordinal))                  {                      Debug.Assert(2 <= _sortIndex.RefCount' "bad sortIndex refcount");                      _sortIndex.RemoveRef();                      _sortIndex.RemoveRef(); // second should remove it from index collection                      _sortIndex = null;                  }                    int originalOrdinal = _ordinal;                  _ordinal = ordinal;                  if (originalOrdinal == -1 && _ordinal != -1)                  {                      if (Unique)                      {                          UniqueConstraint key = new UniqueConstraint(this);                          _table.Constraints.Add(key);                      }                  }              }
Magic Number,System.Data,DataColumnCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataColumnCollection.cs,IndexOfCaseInsensitive,The following statement contains a magic number: for (int i = 0; i < Count; i++)              {                  column = (DataColumn)_list[i];                  if ((hashcode == 0 || column._hashCode == 0 || column._hashCode == hashcode) &&                     NamesEqual(column.ColumnName' name' false' _table.Locale) != 0)                  {                      if (cachedI == -1)                      {                          cachedI = i;                      }                      else                      {                          return -2;                      }                  }              }
Magic Number,System.Data,DataError,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataError.cs,IndexOf,The following statement contains a magic number: if (_count >= _errorList.Length)              {                  int newCapacity = Math.Min(_count * 2' column.Table.Columns.Count);                  var biggerList = new ColumnError[newCapacity];                  Array.Copy(_errorList' 0' biggerList' 0' _count);                  _errorList = biggerList;              }
Magic Number,System.Data,DataRelationCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataRelationCollection.cs,InternalIndexOf,The following statement contains a magic number: if ((null != name) && (0 < name.Length))              {                  int count = List.Count;                  int result = 0;                  for (int i = 0; i < count; i++)                  {                      DataRelation relation = (DataRelation)List[i];                      result = NamesEqual(relation.RelationName' name' false' GetDataSet().Locale);                      if (result == 1)                      {                          return i;                      }                        if (result == -1)                      {                          cachedI = (cachedI == -1) ? i : -2;                      }                  }              }
Magic Number,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,SerializeDataSet,The following statement contains a magic number: info.AddValue("DataSet.RemotingVersion"' new Version(2' 0));
Magic Number,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,SerializeDataSet,The following statement contains a magic number: if (remotingFormat != SerializationFormat.Xml)              {                  if (SchemaSerializationMode == SchemaSerializationMode.IncludeSchema)                  {                      //DataSet public state properties                      SerializeDataSetProperties(info' context);                        //Tables Count                      info.AddValue("DataSet.Tables.Count"' Tables.Count);                        //Tables' Columns' Rows                      for (int i = 0; i < Tables.Count; i++)                      {                          BinaryFormatter bf = new BinaryFormatter(null' new StreamingContext(context.State' false));                          MemoryStream memStream = new MemoryStream();                          bf.Serialize(memStream' Tables[i]);                          memStream.Position = 0;                          info.AddValue(string.Format(CultureInfo.InvariantCulture' "DataSet.Tables_{0}"' i)' memStream.GetBuffer());                      }                        //Constraints                      for (int i = 0; i < Tables.Count; i++)                      {                          Tables[i].SerializeConstraints(info' context' i' true);                      }                        //Relations                      SerializeRelations(info' context);                        //Expression Columns                      for (int i = 0; i < Tables.Count; i++)                      {                          Tables[i].SerializeExpressionColumns(info' context' i);                      }                  }                  else                  {                      //Serialize  DataSet public properties.                      SerializeDataSetProperties(info' context);                  }                    //Rows                  for (int i = 0; i < Tables.Count; i++)                  {                      Tables[i].SerializeTableData(info' context' i);                  }              }              else              {                  // old behaviour                  string strSchema = GetXmlSchemaForRemoting(null);                    string strData = null;                  info.AddValue(KEY_XMLSCHEMA' strSchema);                    StringBuilder strBuilder = new StringBuilder(EstimatedXmlStringSize() * 2);                  StringWriter strWriter = new StringWriter(strBuilder' CultureInfo.InvariantCulture);                  XmlTextWriter w = new XmlTextWriter(strWriter);                  WriteXml(w' XmlWriteMode.DiffGram);                  strData = strWriter.ToString();                  info.AddValue(KEY_XMLDIFFGRAM' strData);              }
Magic Number,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,DeserializeRelations,The following statement contains a magic number: foreach (ArrayList list in relationList)              {                  string relationName = (string)list[0];                  int[] parentInfo = (int[])list[1];                  int[] childInfo = (int[])list[2];                  bool isNested = (bool)list[3];                  PropertyCollection extendedProperties = (PropertyCollection)list[4];                    //ParentKey Columns.                  DataColumn[] parentkeyColumns = new DataColumn[parentInfo.Length - 1];                  for (int i = 0; i < parentkeyColumns.Length; i++)                  {                      parentkeyColumns[i] = Tables[parentInfo[0]].Columns[parentInfo[i + 1]];                  }                    //ChildKey Columns.                  DataColumn[] childkeyColumns = new DataColumn[childInfo.Length - 1];                  for (int i = 0; i < childkeyColumns.Length; i++)                  {                      childkeyColumns[i] = Tables[childInfo[0]].Columns[childInfo[i + 1]];                  }                    //Create the Relation' without any constraints[Assumption: The constraints are added earlier than the relations]                  DataRelation rel = new DataRelation(relationName' parentkeyColumns' childkeyColumns' false);                  rel.CheckMultipleNested = false; // disable the check for multiple nested parent                  rel.Nested = isNested;                  rel._extendedProperties = extendedProperties;                    Relations.Add(rel);                  rel.CheckMultipleNested = true; // enable the check for multiple nested parent              }
Magic Number,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,DeserializeRelations,The following statement contains a magic number: foreach (ArrayList list in relationList)              {                  string relationName = (string)list[0];                  int[] parentInfo = (int[])list[1];                  int[] childInfo = (int[])list[2];                  bool isNested = (bool)list[3];                  PropertyCollection extendedProperties = (PropertyCollection)list[4];                    //ParentKey Columns.                  DataColumn[] parentkeyColumns = new DataColumn[parentInfo.Length - 1];                  for (int i = 0; i < parentkeyColumns.Length; i++)                  {                      parentkeyColumns[i] = Tables[parentInfo[0]].Columns[parentInfo[i + 1]];                  }                    //ChildKey Columns.                  DataColumn[] childkeyColumns = new DataColumn[childInfo.Length - 1];                  for (int i = 0; i < childkeyColumns.Length; i++)                  {                      childkeyColumns[i] = Tables[childInfo[0]].Columns[childInfo[i + 1]];                  }                    //Create the Relation' without any constraints[Assumption: The constraints are added earlier than the relations]                  DataRelation rel = new DataRelation(relationName' parentkeyColumns' childkeyColumns' false);                  rel.CheckMultipleNested = false; // disable the check for multiple nested parent                  rel.Nested = isNested;                  rel._extendedProperties = extendedProperties;                    Relations.Add(rel);                  rel.CheckMultipleNested = true; // enable the check for multiple nested parent              }
Magic Number,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,DeserializeRelations,The following statement contains a magic number: foreach (ArrayList list in relationList)              {                  string relationName = (string)list[0];                  int[] parentInfo = (int[])list[1];                  int[] childInfo = (int[])list[2];                  bool isNested = (bool)list[3];                  PropertyCollection extendedProperties = (PropertyCollection)list[4];                    //ParentKey Columns.                  DataColumn[] parentkeyColumns = new DataColumn[parentInfo.Length - 1];                  for (int i = 0; i < parentkeyColumns.Length; i++)                  {                      parentkeyColumns[i] = Tables[parentInfo[0]].Columns[parentInfo[i + 1]];                  }                    //ChildKey Columns.                  DataColumn[] childkeyColumns = new DataColumn[childInfo.Length - 1];                  for (int i = 0; i < childkeyColumns.Length; i++)                  {                      childkeyColumns[i] = Tables[childInfo[0]].Columns[childInfo[i + 1]];                  }                    //Create the Relation' without any constraints[Assumption: The constraints are added earlier than the relations]                  DataRelation rel = new DataRelation(relationName' parentkeyColumns' childkeyColumns' false);                  rel.CheckMultipleNested = false; // disable the check for multiple nested parent                  rel.Nested = isNested;                  rel._extendedProperties = extendedProperties;                    Relations.Add(rel);                  rel.CheckMultipleNested = true; // enable the check for multiple nested parent              }
Magic Number,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,EstimatedXmlStringSize,The following statement contains a magic number: int bytes = 100;
Magic Number,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,EstimatedXmlStringSize,The following statement contains a magic number: for (int i = 0; i < Tables.Count; i++)              {                  int rowBytes = (Tables[i].TableName.Length + 4) << 2;                  DataTable table = Tables[i];                  for (int j = 0; j < table.Columns.Count; j++)                  {                      rowBytes += ((table.Columns[j].ColumnName.Length + 4) << 2);                      rowBytes += 20;                  }                  bytes += table.Rows.Count * rowBytes;              }
Magic Number,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,EstimatedXmlStringSize,The following statement contains a magic number: for (int i = 0; i < Tables.Count; i++)              {                  int rowBytes = (Tables[i].TableName.Length + 4) << 2;                  DataTable table = Tables[i];                  for (int j = 0; j < table.Columns.Count; j++)                  {                      rowBytes += ((table.Columns[j].ColumnName.Length + 4) << 2);                      rowBytes += 20;                  }                  bytes += table.Rows.Count * rowBytes;              }
Magic Number,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,EstimatedXmlStringSize,The following statement contains a magic number: for (int i = 0; i < Tables.Count; i++)              {                  int rowBytes = (Tables[i].TableName.Length + 4) << 2;                  DataTable table = Tables[i];                  for (int j = 0; j < table.Columns.Count; j++)                  {                      rowBytes += ((table.Columns[j].ColumnName.Length + 4) << 2);                      rowBytes += 20;                  }                  bytes += table.Rows.Count * rowBytes;              }
Magic Number,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,EstimatedXmlStringSize,The following statement contains a magic number: for (int i = 0; i < Tables.Count; i++)              {                  int rowBytes = (Tables[i].TableName.Length + 4) << 2;                  DataTable table = Tables[i];                  for (int j = 0; j < table.Columns.Count; j++)                  {                      rowBytes += ((table.Columns[j].ColumnName.Length + 4) << 2);                      rowBytes += 20;                  }                  bytes += table.Rows.Count * rowBytes;              }
Magic Number,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,EstimatedXmlStringSize,The following statement contains a magic number: for (int i = 0; i < Tables.Count; i++)              {                  int rowBytes = (Tables[i].TableName.Length + 4) << 2;                  DataTable table = Tables[i];                  for (int j = 0; j < table.Columns.Count; j++)                  {                      rowBytes += ((table.Columns[j].ColumnName.Length + 4) << 2);                      rowBytes += 20;                  }                  bytes += table.Rows.Count * rowBytes;              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SerializeDataTable,The following statement contains a magic number: info.AddValue("DataTable.RemotingVersion"' new Version(2' 0));
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeConstraints,The following statement contains a magic number: foreach (ArrayList list in constraintList)              {                  string con = (string)list[0];                    if (con.Equals("U"))                  {                      //Unique Constraints                      string constraintName = (string)list[1];                        int[] keyColumnIndexes = (int[])list[2];                      bool isPrimaryKey = (bool)list[3];                      PropertyCollection extendedProperties = (PropertyCollection)list[4];                        DataColumn[] keyColumns = new DataColumn[keyColumnIndexes.Length];                      for (int i = 0; i < keyColumnIndexes.Length; i++)                      {                          keyColumns[i] = Columns[keyColumnIndexes[i]];                      }                        //Create the constraint.                      UniqueConstraint uc = new UniqueConstraint(constraintName' keyColumns' isPrimaryKey);                      uc._extendedProperties = extendedProperties;                        //Add the unique constraint and it will in turn set the primary keys also if needed.                      Constraints.Add(uc);                  }                  else                  {                      //ForeignKeyConstraints                      Debug.Assert(con.Equals("F"));                        string constraintName = (string)list[1];                      int[] parentInfo = (int[])list[2];                      int[] childInfo = (int[])list[3];                      int[] rules = (int[])list[4];                      PropertyCollection extendedProperties = (PropertyCollection)list[5];                        //ParentKey Columns.                      DataTable parentTable = (allConstraints == false) ? this : DataSet.Tables[parentInfo[0]];                      DataColumn[] parentkeyColumns = new DataColumn[parentInfo.Length - 1];                      for (int i = 0; i < parentkeyColumns.Length; i++)                      {                          parentkeyColumns[i] = parentTable.Columns[parentInfo[i + 1]];                      }                        //ChildKey Columns.                      DataTable childTable = (allConstraints == false) ? this : DataSet.Tables[childInfo[0]];                      DataColumn[] childkeyColumns = new DataColumn[childInfo.Length - 1];                      for (int i = 0; i < childkeyColumns.Length; i++)                      {                          childkeyColumns[i] = childTable.Columns[childInfo[i + 1]];                      }                        //Create the Constraint.                      ForeignKeyConstraint fk = new ForeignKeyConstraint(constraintName' parentkeyColumns' childkeyColumns);                      fk.AcceptRejectRule = (AcceptRejectRule)rules[0];                      fk.UpdateRule = (Rule)rules[1];                      fk.DeleteRule = (Rule)rules[2];                      fk._extendedProperties = extendedProperties;                        //Add just the foreign key constraint without creating unique constraint.                      Constraints.Add(fk' false);                  }              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeConstraints,The following statement contains a magic number: foreach (ArrayList list in constraintList)              {                  string con = (string)list[0];                    if (con.Equals("U"))                  {                      //Unique Constraints                      string constraintName = (string)list[1];                        int[] keyColumnIndexes = (int[])list[2];                      bool isPrimaryKey = (bool)list[3];                      PropertyCollection extendedProperties = (PropertyCollection)list[4];                        DataColumn[] keyColumns = new DataColumn[keyColumnIndexes.Length];                      for (int i = 0; i < keyColumnIndexes.Length; i++)                      {                          keyColumns[i] = Columns[keyColumnIndexes[i]];                      }                        //Create the constraint.                      UniqueConstraint uc = new UniqueConstraint(constraintName' keyColumns' isPrimaryKey);                      uc._extendedProperties = extendedProperties;                        //Add the unique constraint and it will in turn set the primary keys also if needed.                      Constraints.Add(uc);                  }                  else                  {                      //ForeignKeyConstraints                      Debug.Assert(con.Equals("F"));                        string constraintName = (string)list[1];                      int[] parentInfo = (int[])list[2];                      int[] childInfo = (int[])list[3];                      int[] rules = (int[])list[4];                      PropertyCollection extendedProperties = (PropertyCollection)list[5];                        //ParentKey Columns.                      DataTable parentTable = (allConstraints == false) ? this : DataSet.Tables[parentInfo[0]];                      DataColumn[] parentkeyColumns = new DataColumn[parentInfo.Length - 1];                      for (int i = 0; i < parentkeyColumns.Length; i++)                      {                          parentkeyColumns[i] = parentTable.Columns[parentInfo[i + 1]];                      }                        //ChildKey Columns.                      DataTable childTable = (allConstraints == false) ? this : DataSet.Tables[childInfo[0]];                      DataColumn[] childkeyColumns = new DataColumn[childInfo.Length - 1];                      for (int i = 0; i < childkeyColumns.Length; i++)                      {                          childkeyColumns[i] = childTable.Columns[childInfo[i + 1]];                      }                        //Create the Constraint.                      ForeignKeyConstraint fk = new ForeignKeyConstraint(constraintName' parentkeyColumns' childkeyColumns);                      fk.AcceptRejectRule = (AcceptRejectRule)rules[0];                      fk.UpdateRule = (Rule)rules[1];                      fk.DeleteRule = (Rule)rules[2];                      fk._extendedProperties = extendedProperties;                        //Add just the foreign key constraint without creating unique constraint.                      Constraints.Add(fk' false);                  }              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeConstraints,The following statement contains a magic number: foreach (ArrayList list in constraintList)              {                  string con = (string)list[0];                    if (con.Equals("U"))                  {                      //Unique Constraints                      string constraintName = (string)list[1];                        int[] keyColumnIndexes = (int[])list[2];                      bool isPrimaryKey = (bool)list[3];                      PropertyCollection extendedProperties = (PropertyCollection)list[4];                        DataColumn[] keyColumns = new DataColumn[keyColumnIndexes.Length];                      for (int i = 0; i < keyColumnIndexes.Length; i++)                      {                          keyColumns[i] = Columns[keyColumnIndexes[i]];                      }                        //Create the constraint.                      UniqueConstraint uc = new UniqueConstraint(constraintName' keyColumns' isPrimaryKey);                      uc._extendedProperties = extendedProperties;                        //Add the unique constraint and it will in turn set the primary keys also if needed.                      Constraints.Add(uc);                  }                  else                  {                      //ForeignKeyConstraints                      Debug.Assert(con.Equals("F"));                        string constraintName = (string)list[1];                      int[] parentInfo = (int[])list[2];                      int[] childInfo = (int[])list[3];                      int[] rules = (int[])list[4];                      PropertyCollection extendedProperties = (PropertyCollection)list[5];                        //ParentKey Columns.                      DataTable parentTable = (allConstraints == false) ? this : DataSet.Tables[parentInfo[0]];                      DataColumn[] parentkeyColumns = new DataColumn[parentInfo.Length - 1];                      for (int i = 0; i < parentkeyColumns.Length; i++)                      {                          parentkeyColumns[i] = parentTable.Columns[parentInfo[i + 1]];                      }                        //ChildKey Columns.                      DataTable childTable = (allConstraints == false) ? this : DataSet.Tables[childInfo[0]];                      DataColumn[] childkeyColumns = new DataColumn[childInfo.Length - 1];                      for (int i = 0; i < childkeyColumns.Length; i++)                      {                          childkeyColumns[i] = childTable.Columns[childInfo[i + 1]];                      }                        //Create the Constraint.                      ForeignKeyConstraint fk = new ForeignKeyConstraint(constraintName' parentkeyColumns' childkeyColumns);                      fk.AcceptRejectRule = (AcceptRejectRule)rules[0];                      fk.UpdateRule = (Rule)rules[1];                      fk.DeleteRule = (Rule)rules[2];                      fk._extendedProperties = extendedProperties;                        //Add just the foreign key constraint without creating unique constraint.                      Constraints.Add(fk' false);                  }              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeConstraints,The following statement contains a magic number: foreach (ArrayList list in constraintList)              {                  string con = (string)list[0];                    if (con.Equals("U"))                  {                      //Unique Constraints                      string constraintName = (string)list[1];                        int[] keyColumnIndexes = (int[])list[2];                      bool isPrimaryKey = (bool)list[3];                      PropertyCollection extendedProperties = (PropertyCollection)list[4];                        DataColumn[] keyColumns = new DataColumn[keyColumnIndexes.Length];                      for (int i = 0; i < keyColumnIndexes.Length; i++)                      {                          keyColumns[i] = Columns[keyColumnIndexes[i]];                      }                        //Create the constraint.                      UniqueConstraint uc = new UniqueConstraint(constraintName' keyColumns' isPrimaryKey);                      uc._extendedProperties = extendedProperties;                        //Add the unique constraint and it will in turn set the primary keys also if needed.                      Constraints.Add(uc);                  }                  else                  {                      //ForeignKeyConstraints                      Debug.Assert(con.Equals("F"));                        string constraintName = (string)list[1];                      int[] parentInfo = (int[])list[2];                      int[] childInfo = (int[])list[3];                      int[] rules = (int[])list[4];                      PropertyCollection extendedProperties = (PropertyCollection)list[5];                        //ParentKey Columns.                      DataTable parentTable = (allConstraints == false) ? this : DataSet.Tables[parentInfo[0]];                      DataColumn[] parentkeyColumns = new DataColumn[parentInfo.Length - 1];                      for (int i = 0; i < parentkeyColumns.Length; i++)                      {                          parentkeyColumns[i] = parentTable.Columns[parentInfo[i + 1]];                      }                        //ChildKey Columns.                      DataTable childTable = (allConstraints == false) ? this : DataSet.Tables[childInfo[0]];                      DataColumn[] childkeyColumns = new DataColumn[childInfo.Length - 1];                      for (int i = 0; i < childkeyColumns.Length; i++)                      {                          childkeyColumns[i] = childTable.Columns[childInfo[i + 1]];                      }                        //Create the Constraint.                      ForeignKeyConstraint fk = new ForeignKeyConstraint(constraintName' parentkeyColumns' childkeyColumns);                      fk.AcceptRejectRule = (AcceptRejectRule)rules[0];                      fk.UpdateRule = (Rule)rules[1];                      fk.DeleteRule = (Rule)rules[2];                      fk._extendedProperties = extendedProperties;                        //Add just the foreign key constraint without creating unique constraint.                      Constraints.Add(fk' false);                  }              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeConstraints,The following statement contains a magic number: foreach (ArrayList list in constraintList)              {                  string con = (string)list[0];                    if (con.Equals("U"))                  {                      //Unique Constraints                      string constraintName = (string)list[1];                        int[] keyColumnIndexes = (int[])list[2];                      bool isPrimaryKey = (bool)list[3];                      PropertyCollection extendedProperties = (PropertyCollection)list[4];                        DataColumn[] keyColumns = new DataColumn[keyColumnIndexes.Length];                      for (int i = 0; i < keyColumnIndexes.Length; i++)                      {                          keyColumns[i] = Columns[keyColumnIndexes[i]];                      }                        //Create the constraint.                      UniqueConstraint uc = new UniqueConstraint(constraintName' keyColumns' isPrimaryKey);                      uc._extendedProperties = extendedProperties;                        //Add the unique constraint and it will in turn set the primary keys also if needed.                      Constraints.Add(uc);                  }                  else                  {                      //ForeignKeyConstraints                      Debug.Assert(con.Equals("F"));                        string constraintName = (string)list[1];                      int[] parentInfo = (int[])list[2];                      int[] childInfo = (int[])list[3];                      int[] rules = (int[])list[4];                      PropertyCollection extendedProperties = (PropertyCollection)list[5];                        //ParentKey Columns.                      DataTable parentTable = (allConstraints == false) ? this : DataSet.Tables[parentInfo[0]];                      DataColumn[] parentkeyColumns = new DataColumn[parentInfo.Length - 1];                      for (int i = 0; i < parentkeyColumns.Length; i++)                      {                          parentkeyColumns[i] = parentTable.Columns[parentInfo[i + 1]];                      }                        //ChildKey Columns.                      DataTable childTable = (allConstraints == false) ? this : DataSet.Tables[childInfo[0]];                      DataColumn[] childkeyColumns = new DataColumn[childInfo.Length - 1];                      for (int i = 0; i < childkeyColumns.Length; i++)                      {                          childkeyColumns[i] = childTable.Columns[childInfo[i + 1]];                      }                        //Create the Constraint.                      ForeignKeyConstraint fk = new ForeignKeyConstraint(constraintName' parentkeyColumns' childkeyColumns);                      fk.AcceptRejectRule = (AcceptRejectRule)rules[0];                      fk.UpdateRule = (Rule)rules[1];                      fk.DeleteRule = (Rule)rules[2];                      fk._extendedProperties = extendedProperties;                        //Add just the foreign key constraint without creating unique constraint.                      Constraints.Add(fk' false);                  }              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeConstraints,The following statement contains a magic number: foreach (ArrayList list in constraintList)              {                  string con = (string)list[0];                    if (con.Equals("U"))                  {                      //Unique Constraints                      string constraintName = (string)list[1];                        int[] keyColumnIndexes = (int[])list[2];                      bool isPrimaryKey = (bool)list[3];                      PropertyCollection extendedProperties = (PropertyCollection)list[4];                        DataColumn[] keyColumns = new DataColumn[keyColumnIndexes.Length];                      for (int i = 0; i < keyColumnIndexes.Length; i++)                      {                          keyColumns[i] = Columns[keyColumnIndexes[i]];                      }                        //Create the constraint.                      UniqueConstraint uc = new UniqueConstraint(constraintName' keyColumns' isPrimaryKey);                      uc._extendedProperties = extendedProperties;                        //Add the unique constraint and it will in turn set the primary keys also if needed.                      Constraints.Add(uc);                  }                  else                  {                      //ForeignKeyConstraints                      Debug.Assert(con.Equals("F"));                        string constraintName = (string)list[1];                      int[] parentInfo = (int[])list[2];                      int[] childInfo = (int[])list[3];                      int[] rules = (int[])list[4];                      PropertyCollection extendedProperties = (PropertyCollection)list[5];                        //ParentKey Columns.                      DataTable parentTable = (allConstraints == false) ? this : DataSet.Tables[parentInfo[0]];                      DataColumn[] parentkeyColumns = new DataColumn[parentInfo.Length - 1];                      for (int i = 0; i < parentkeyColumns.Length; i++)                      {                          parentkeyColumns[i] = parentTable.Columns[parentInfo[i + 1]];                      }                        //ChildKey Columns.                      DataTable childTable = (allConstraints == false) ? this : DataSet.Tables[childInfo[0]];                      DataColumn[] childkeyColumns = new DataColumn[childInfo.Length - 1];                      for (int i = 0; i < childkeyColumns.Length; i++)                      {                          childkeyColumns[i] = childTable.Columns[childInfo[i + 1]];                      }                        //Create the Constraint.                      ForeignKeyConstraint fk = new ForeignKeyConstraint(constraintName' parentkeyColumns' childkeyColumns);                      fk.AcceptRejectRule = (AcceptRejectRule)rules[0];                      fk.UpdateRule = (Rule)rules[1];                      fk.DeleteRule = (Rule)rules[2];                      fk._extendedProperties = extendedProperties;                        //Add just the foreign key constraint without creating unique constraint.                      Constraints.Add(fk' false);                  }              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeConstraints,The following statement contains a magic number: foreach (ArrayList list in constraintList)              {                  string con = (string)list[0];                    if (con.Equals("U"))                  {                      //Unique Constraints                      string constraintName = (string)list[1];                        int[] keyColumnIndexes = (int[])list[2];                      bool isPrimaryKey = (bool)list[3];                      PropertyCollection extendedProperties = (PropertyCollection)list[4];                        DataColumn[] keyColumns = new DataColumn[keyColumnIndexes.Length];                      for (int i = 0; i < keyColumnIndexes.Length; i++)                      {                          keyColumns[i] = Columns[keyColumnIndexes[i]];                      }                        //Create the constraint.                      UniqueConstraint uc = new UniqueConstraint(constraintName' keyColumns' isPrimaryKey);                      uc._extendedProperties = extendedProperties;                        //Add the unique constraint and it will in turn set the primary keys also if needed.                      Constraints.Add(uc);                  }                  else                  {                      //ForeignKeyConstraints                      Debug.Assert(con.Equals("F"));                        string constraintName = (string)list[1];                      int[] parentInfo = (int[])list[2];                      int[] childInfo = (int[])list[3];                      int[] rules = (int[])list[4];                      PropertyCollection extendedProperties = (PropertyCollection)list[5];                        //ParentKey Columns.                      DataTable parentTable = (allConstraints == false) ? this : DataSet.Tables[parentInfo[0]];                      DataColumn[] parentkeyColumns = new DataColumn[parentInfo.Length - 1];                      for (int i = 0; i < parentkeyColumns.Length; i++)                      {                          parentkeyColumns[i] = parentTable.Columns[parentInfo[i + 1]];                      }                        //ChildKey Columns.                      DataTable childTable = (allConstraints == false) ? this : DataSet.Tables[childInfo[0]];                      DataColumn[] childkeyColumns = new DataColumn[childInfo.Length - 1];                      for (int i = 0; i < childkeyColumns.Length; i++)                      {                          childkeyColumns[i] = childTable.Columns[childInfo[i + 1]];                      }                        //Create the Constraint.                      ForeignKeyConstraint fk = new ForeignKeyConstraint(constraintName' parentkeyColumns' childkeyColumns);                      fk.AcceptRejectRule = (AcceptRejectRule)rules[0];                      fk.UpdateRule = (Rule)rules[1];                      fk.DeleteRule = (Rule)rules[2];                      fk._extendedProperties = extendedProperties;                        //Add just the foreign key constraint without creating unique constraint.                      Constraints.Add(fk' false);                  }              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeConstraints,The following statement contains a magic number: foreach (ArrayList list in constraintList)              {                  string con = (string)list[0];                    if (con.Equals("U"))                  {                      //Unique Constraints                      string constraintName = (string)list[1];                        int[] keyColumnIndexes = (int[])list[2];                      bool isPrimaryKey = (bool)list[3];                      PropertyCollection extendedProperties = (PropertyCollection)list[4];                        DataColumn[] keyColumns = new DataColumn[keyColumnIndexes.Length];                      for (int i = 0; i < keyColumnIndexes.Length; i++)                      {                          keyColumns[i] = Columns[keyColumnIndexes[i]];                      }                        //Create the constraint.                      UniqueConstraint uc = new UniqueConstraint(constraintName' keyColumns' isPrimaryKey);                      uc._extendedProperties = extendedProperties;                        //Add the unique constraint and it will in turn set the primary keys also if needed.                      Constraints.Add(uc);                  }                  else                  {                      //ForeignKeyConstraints                      Debug.Assert(con.Equals("F"));                        string constraintName = (string)list[1];                      int[] parentInfo = (int[])list[2];                      int[] childInfo = (int[])list[3];                      int[] rules = (int[])list[4];                      PropertyCollection extendedProperties = (PropertyCollection)list[5];                        //ParentKey Columns.                      DataTable parentTable = (allConstraints == false) ? this : DataSet.Tables[parentInfo[0]];                      DataColumn[] parentkeyColumns = new DataColumn[parentInfo.Length - 1];                      for (int i = 0; i < parentkeyColumns.Length; i++)                      {                          parentkeyColumns[i] = parentTable.Columns[parentInfo[i + 1]];                      }                        //ChildKey Columns.                      DataTable childTable = (allConstraints == false) ? this : DataSet.Tables[childInfo[0]];                      DataColumn[] childkeyColumns = new DataColumn[childInfo.Length - 1];                      for (int i = 0; i < childkeyColumns.Length; i++)                      {                          childkeyColumns[i] = childTable.Columns[childInfo[i + 1]];                      }                        //Create the Constraint.                      ForeignKeyConstraint fk = new ForeignKeyConstraint(constraintName' parentkeyColumns' childkeyColumns);                      fk.AcceptRejectRule = (AcceptRejectRule)rules[0];                      fk.UpdateRule = (Rule)rules[1];                      fk.DeleteRule = (Rule)rules[2];                      fk._extendedProperties = extendedProperties;                        //Add just the foreign key constraint without creating unique constraint.                      Constraints.Add(fk' false);                  }              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SerializeTableData,The following statement contains a magic number: BitArray rowStates = new BitArray(rowCount * 3' false);
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SerializeTableData,The following statement contains a magic number: for (int i = 0; i < rowCount; i++)              {                  int bitIndex = i * 3;                  DataRow row = Rows[i];                  DataRowState rowState = row.RowState;                  switch (rowState)                  {                      case DataRowState.Unchanged:                          //rowStates[bitIndex] = false;                          //rowStates[bitIndex + 1] = false;                          break;                      case DataRowState.Added:                          //rowStates[bitIndex] = false;                          rowStates[bitIndex + 1] = true;                          break;                      case DataRowState.Modified:                          rowStates[bitIndex] = true;                          //rowStates[bitIndex + 1] = false;                          modifiedRowCount++;                          break;                      case DataRowState.Deleted:                          rowStates[bitIndex] = true;                          rowStates[bitIndex + 1] = true;                          break;                      default:                          throw ExceptionBuilder.InvalidRowState(rowState);                  }                  if (-1 != row._tempRecord)                  {                      rowStates[bitIndex + 2] = true;                      editRowCount++;                  }              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SerializeTableData,The following statement contains a magic number: for (int i = 0; i < rowCount; i++)              {                  int bitIndex = i * 3;                  DataRow row = Rows[i];                  DataRowState rowState = row.RowState;                  switch (rowState)                  {                      case DataRowState.Unchanged:                          //rowStates[bitIndex] = false;                          //rowStates[bitIndex + 1] = false;                          break;                      case DataRowState.Added:                          //rowStates[bitIndex] = false;                          rowStates[bitIndex + 1] = true;                          break;                      case DataRowState.Modified:                          rowStates[bitIndex] = true;                          //rowStates[bitIndex + 1] = false;                          modifiedRowCount++;                          break;                      case DataRowState.Deleted:                          rowStates[bitIndex] = true;                          rowStates[bitIndex + 1] = true;                          break;                      default:                          throw ExceptionBuilder.InvalidRowState(rowState);                  }                  if (-1 != row._tempRecord)                  {                      rowStates[bitIndex + 2] = true;                      editRowCount++;                  }              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeTableData,The following statement contains a magic number: try              {                  _enforceConstraints = false;                  _inDataLoad = true;                  IFormatProvider formatProvider = CultureInfo.InvariantCulture;                  int rowCount = info.GetInt32(string.Format(formatProvider' "DataTable_{0}.Rows.Count"' serIndex));                  int recordCount = info.GetInt32(string.Format(formatProvider' "DataTable_{0}.Records.Count"' serIndex));                  BitArray rowStates = (BitArray)info.GetValue(string.Format(formatProvider' "DataTable_{0}.RowStates"' serIndex)' typeof(BitArray));                  ArrayList storeList = (ArrayList)info.GetValue(string.Format(formatProvider' "DataTable_{0}.Records"' serIndex)' typeof(ArrayList));                  ArrayList nullbitList = (ArrayList)info.GetValue(string.Format(formatProvider' "DataTable_{0}.NullBits"' serIndex)' typeof(ArrayList));                  Hashtable rowErrors = (Hashtable)info.GetValue(string.Format(formatProvider' "DataTable_{0}.RowErrors"' serIndex)' typeof(Hashtable));                  rowErrors.OnDeserialization(this);//OnDeSerialization must be called since the hashtable gets deserialized after the whole graph gets deserialized                  Hashtable colErrors = (Hashtable)info.GetValue(string.Format(formatProvider' "DataTable_{0}.ColumnErrors"' serIndex)' typeof(Hashtable));                  colErrors.OnDeserialization(this);//OnDeSerialization must be called since the hashtable gets deserialized after the whole graph gets deserialized                    if (recordCount <= 0)                  {                      //No need for deserialization of the storage and errors if there are no records.                      return;                  }                    //Point the record manager storage to the deserialized values.                  for (int i = 0; i < Columns.Count; i++)                  {                      Columns[i].SetStorage(storeList[i]' (BitArray)nullbitList[i]);                  }                    //Create rows and set the records appropriately.                  int recordIndex = 0;                  DataRow[] rowArr = new DataRow[recordCount];                  for (int i = 0; i < rowCount; i++)                  {                      //Create a new row which sets old and new records to -1.                      DataRow row = NewEmptyRow();                      rowArr[recordIndex] = row;                      int bitIndex = i * 3;                      switch (ConvertToRowState(rowStates' bitIndex))                      {                          case DataRowState.Unchanged:                              row._oldRecord = recordIndex;                              row._newRecord = recordIndex;                              recordIndex += 1;                              break;                          case DataRowState.Added:                              row._oldRecord = -1;                              row._newRecord = recordIndex;                              recordIndex += 1;                              break;                          case DataRowState.Modified:                              row._oldRecord = recordIndex;                              row._newRecord = recordIndex + 1;                              rowArr[recordIndex + 1] = row;                              recordIndex += 2;                              break;                          case DataRowState.Deleted:                              row._oldRecord = recordIndex;                              row._newRecord = -1;                              recordIndex += 1;                              break;                      }                      if (rowStates[bitIndex + 2])                      {                          row._tempRecord = recordIndex;                          rowArr[recordIndex] = row;                          recordIndex += 1;                      }                      else                      {                          row._tempRecord = -1;                      }                      Rows.ArrayAdd(row);                      row.rowID = _nextRowID;                      _nextRowID++;                      ConvertToRowError(i' rowErrors' colErrors);                  }                  _recordManager.SetRowCache(rowArr);                  ResetIndexes();              }              finally              {                  _enforceConstraints = enforceConstraintsOrg;                  _inDataLoad = inDataLoadOrg;              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeTableData,The following statement contains a magic number: try              {                  _enforceConstraints = false;                  _inDataLoad = true;                  IFormatProvider formatProvider = CultureInfo.InvariantCulture;                  int rowCount = info.GetInt32(string.Format(formatProvider' "DataTable_{0}.Rows.Count"' serIndex));                  int recordCount = info.GetInt32(string.Format(formatProvider' "DataTable_{0}.Records.Count"' serIndex));                  BitArray rowStates = (BitArray)info.GetValue(string.Format(formatProvider' "DataTable_{0}.RowStates"' serIndex)' typeof(BitArray));                  ArrayList storeList = (ArrayList)info.GetValue(string.Format(formatProvider' "DataTable_{0}.Records"' serIndex)' typeof(ArrayList));                  ArrayList nullbitList = (ArrayList)info.GetValue(string.Format(formatProvider' "DataTable_{0}.NullBits"' serIndex)' typeof(ArrayList));                  Hashtable rowErrors = (Hashtable)info.GetValue(string.Format(formatProvider' "DataTable_{0}.RowErrors"' serIndex)' typeof(Hashtable));                  rowErrors.OnDeserialization(this);//OnDeSerialization must be called since the hashtable gets deserialized after the whole graph gets deserialized                  Hashtable colErrors = (Hashtable)info.GetValue(string.Format(formatProvider' "DataTable_{0}.ColumnErrors"' serIndex)' typeof(Hashtable));                  colErrors.OnDeserialization(this);//OnDeSerialization must be called since the hashtable gets deserialized after the whole graph gets deserialized                    if (recordCount <= 0)                  {                      //No need for deserialization of the storage and errors if there are no records.                      return;                  }                    //Point the record manager storage to the deserialized values.                  for (int i = 0; i < Columns.Count; i++)                  {                      Columns[i].SetStorage(storeList[i]' (BitArray)nullbitList[i]);                  }                    //Create rows and set the records appropriately.                  int recordIndex = 0;                  DataRow[] rowArr = new DataRow[recordCount];                  for (int i = 0; i < rowCount; i++)                  {                      //Create a new row which sets old and new records to -1.                      DataRow row = NewEmptyRow();                      rowArr[recordIndex] = row;                      int bitIndex = i * 3;                      switch (ConvertToRowState(rowStates' bitIndex))                      {                          case DataRowState.Unchanged:                              row._oldRecord = recordIndex;                              row._newRecord = recordIndex;                              recordIndex += 1;                              break;                          case DataRowState.Added:                              row._oldRecord = -1;                              row._newRecord = recordIndex;                              recordIndex += 1;                              break;                          case DataRowState.Modified:                              row._oldRecord = recordIndex;                              row._newRecord = recordIndex + 1;                              rowArr[recordIndex + 1] = row;                              recordIndex += 2;                              break;                          case DataRowState.Deleted:                              row._oldRecord = recordIndex;                              row._newRecord = -1;                              recordIndex += 1;                              break;                      }                      if (rowStates[bitIndex + 2])                      {                          row._tempRecord = recordIndex;                          rowArr[recordIndex] = row;                          recordIndex += 1;                      }                      else                      {                          row._tempRecord = -1;                      }                      Rows.ArrayAdd(row);                      row.rowID = _nextRowID;                      _nextRowID++;                      ConvertToRowError(i' rowErrors' colErrors);                  }                  _recordManager.SetRowCache(rowArr);                  ResetIndexes();              }              finally              {                  _enforceConstraints = enforceConstraintsOrg;                  _inDataLoad = inDataLoadOrg;              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeTableData,The following statement contains a magic number: try              {                  _enforceConstraints = false;                  _inDataLoad = true;                  IFormatProvider formatProvider = CultureInfo.InvariantCulture;                  int rowCount = info.GetInt32(string.Format(formatProvider' "DataTable_{0}.Rows.Count"' serIndex));                  int recordCount = info.GetInt32(string.Format(formatProvider' "DataTable_{0}.Records.Count"' serIndex));                  BitArray rowStates = (BitArray)info.GetValue(string.Format(formatProvider' "DataTable_{0}.RowStates"' serIndex)' typeof(BitArray));                  ArrayList storeList = (ArrayList)info.GetValue(string.Format(formatProvider' "DataTable_{0}.Records"' serIndex)' typeof(ArrayList));                  ArrayList nullbitList = (ArrayList)info.GetValue(string.Format(formatProvider' "DataTable_{0}.NullBits"' serIndex)' typeof(ArrayList));                  Hashtable rowErrors = (Hashtable)info.GetValue(string.Format(formatProvider' "DataTable_{0}.RowErrors"' serIndex)' typeof(Hashtable));                  rowErrors.OnDeserialization(this);//OnDeSerialization must be called since the hashtable gets deserialized after the whole graph gets deserialized                  Hashtable colErrors = (Hashtable)info.GetValue(string.Format(formatProvider' "DataTable_{0}.ColumnErrors"' serIndex)' typeof(Hashtable));                  colErrors.OnDeserialization(this);//OnDeSerialization must be called since the hashtable gets deserialized after the whole graph gets deserialized                    if (recordCount <= 0)                  {                      //No need for deserialization of the storage and errors if there are no records.                      return;                  }                    //Point the record manager storage to the deserialized values.                  for (int i = 0; i < Columns.Count; i++)                  {                      Columns[i].SetStorage(storeList[i]' (BitArray)nullbitList[i]);                  }                    //Create rows and set the records appropriately.                  int recordIndex = 0;                  DataRow[] rowArr = new DataRow[recordCount];                  for (int i = 0; i < rowCount; i++)                  {                      //Create a new row which sets old and new records to -1.                      DataRow row = NewEmptyRow();                      rowArr[recordIndex] = row;                      int bitIndex = i * 3;                      switch (ConvertToRowState(rowStates' bitIndex))                      {                          case DataRowState.Unchanged:                              row._oldRecord = recordIndex;                              row._newRecord = recordIndex;                              recordIndex += 1;                              break;                          case DataRowState.Added:                              row._oldRecord = -1;                              row._newRecord = recordIndex;                              recordIndex += 1;                              break;                          case DataRowState.Modified:                              row._oldRecord = recordIndex;                              row._newRecord = recordIndex + 1;                              rowArr[recordIndex + 1] = row;                              recordIndex += 2;                              break;                          case DataRowState.Deleted:                              row._oldRecord = recordIndex;                              row._newRecord = -1;                              recordIndex += 1;                              break;                      }                      if (rowStates[bitIndex + 2])                      {                          row._tempRecord = recordIndex;                          rowArr[recordIndex] = row;                          recordIndex += 1;                      }                      else                      {                          row._tempRecord = -1;                      }                      Rows.ArrayAdd(row);                      row.rowID = _nextRowID;                      _nextRowID++;                      ConvertToRowError(i' rowErrors' colErrors);                  }                  _recordManager.SetRowCache(rowArr);                  ResetIndexes();              }              finally              {                  _enforceConstraints = enforceConstraintsOrg;                  _inDataLoad = inDataLoadOrg;              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ParseSortString,The following statement contains a magic number: if ((null != sortString) && (0 < sortString.Length))              {                  string[] split = sortString.Split(new char[] { ''' });                  indexDesc = new IndexField[split.Length];                    for (int i = 0; i < split.Length; i++)                  {                      string current = split[i].Trim();                        // handle ASC and DESC.                      int length = current.Length;                      bool descending = false;                      if (length >= 5 && string.Compare(current' length - 4' " ASC"' 0' 4' StringComparison.OrdinalIgnoreCase) == 0)                      {                          current = current.Substring(0' length - 4).Trim();                      }                      else if (length >= 6 && string.Compare(current' length - 5' " DESC"' 0' 5' StringComparison.OrdinalIgnoreCase) == 0)                      {                          descending = true;                          current = current.Substring(0' length - 5).Trim();                      }                        // handle brackets.                      if (current.StartsWith("["' StringComparison.Ordinal))                      {                          if (current.EndsWith("]"' StringComparison.Ordinal))                          {                              current = current.Substring(1' current.Length - 2);                          }                          else                          {                              throw ExceptionBuilder.InvalidSortString(split[i]);                          }                      }                        // find the column.                      DataColumn column = Columns[current];                      if (column == null)                      {                          throw ExceptionBuilder.ColumnOutOfRange(current);                      }                      indexDesc[i] = new IndexField(column' descending);                  }              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ParseSortString,The following statement contains a magic number: if ((null != sortString) && (0 < sortString.Length))              {                  string[] split = sortString.Split(new char[] { ''' });                  indexDesc = new IndexField[split.Length];                    for (int i = 0; i < split.Length; i++)                  {                      string current = split[i].Trim();                        // handle ASC and DESC.                      int length = current.Length;                      bool descending = false;                      if (length >= 5 && string.Compare(current' length - 4' " ASC"' 0' 4' StringComparison.OrdinalIgnoreCase) == 0)                      {                          current = current.Substring(0' length - 4).Trim();                      }                      else if (length >= 6 && string.Compare(current' length - 5' " DESC"' 0' 5' StringComparison.OrdinalIgnoreCase) == 0)                      {                          descending = true;                          current = current.Substring(0' length - 5).Trim();                      }                        // handle brackets.                      if (current.StartsWith("["' StringComparison.Ordinal))                      {                          if (current.EndsWith("]"' StringComparison.Ordinal))                          {                              current = current.Substring(1' current.Length - 2);                          }                          else                          {                              throw ExceptionBuilder.InvalidSortString(split[i]);                          }                      }                        // find the column.                      DataColumn column = Columns[current];                      if (column == null)                      {                          throw ExceptionBuilder.ColumnOutOfRange(current);                      }                      indexDesc[i] = new IndexField(column' descending);                  }              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ParseSortString,The following statement contains a magic number: if ((null != sortString) && (0 < sortString.Length))              {                  string[] split = sortString.Split(new char[] { ''' });                  indexDesc = new IndexField[split.Length];                    for (int i = 0; i < split.Length; i++)                  {                      string current = split[i].Trim();                        // handle ASC and DESC.                      int length = current.Length;                      bool descending = false;                      if (length >= 5 && string.Compare(current' length - 4' " ASC"' 0' 4' StringComparison.OrdinalIgnoreCase) == 0)                      {                          current = current.Substring(0' length - 4).Trim();                      }                      else if (length >= 6 && string.Compare(current' length - 5' " DESC"' 0' 5' StringComparison.OrdinalIgnoreCase) == 0)                      {                          descending = true;                          current = current.Substring(0' length - 5).Trim();                      }                        // handle brackets.                      if (current.StartsWith("["' StringComparison.Ordinal))                      {                          if (current.EndsWith("]"' StringComparison.Ordinal))                          {                              current = current.Substring(1' current.Length - 2);                          }                          else                          {                              throw ExceptionBuilder.InvalidSortString(split[i]);                          }                      }                        // find the column.                      DataColumn column = Columns[current];                      if (column == null)                      {                          throw ExceptionBuilder.ColumnOutOfRange(current);                      }                      indexDesc[i] = new IndexField(column' descending);                  }              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ParseSortString,The following statement contains a magic number: if ((null != sortString) && (0 < sortString.Length))              {                  string[] split = sortString.Split(new char[] { ''' });                  indexDesc = new IndexField[split.Length];                    for (int i = 0; i < split.Length; i++)                  {                      string current = split[i].Trim();                        // handle ASC and DESC.                      int length = current.Length;                      bool descending = false;                      if (length >= 5 && string.Compare(current' length - 4' " ASC"' 0' 4' StringComparison.OrdinalIgnoreCase) == 0)                      {                          current = current.Substring(0' length - 4).Trim();                      }                      else if (length >= 6 && string.Compare(current' length - 5' " DESC"' 0' 5' StringComparison.OrdinalIgnoreCase) == 0)                      {                          descending = true;                          current = current.Substring(0' length - 5).Trim();                      }                        // handle brackets.                      if (current.StartsWith("["' StringComparison.Ordinal))                      {                          if (current.EndsWith("]"' StringComparison.Ordinal))                          {                              current = current.Substring(1' current.Length - 2);                          }                          else                          {                              throw ExceptionBuilder.InvalidSortString(split[i]);                          }                      }                        // find the column.                      DataColumn column = Columns[current];                      if (column == null)                      {                          throw ExceptionBuilder.ColumnOutOfRange(current);                      }                      indexDesc[i] = new IndexField(column' descending);                  }              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ParseSortString,The following statement contains a magic number: if ((null != sortString) && (0 < sortString.Length))              {                  string[] split = sortString.Split(new char[] { ''' });                  indexDesc = new IndexField[split.Length];                    for (int i = 0; i < split.Length; i++)                  {                      string current = split[i].Trim();                        // handle ASC and DESC.                      int length = current.Length;                      bool descending = false;                      if (length >= 5 && string.Compare(current' length - 4' " ASC"' 0' 4' StringComparison.OrdinalIgnoreCase) == 0)                      {                          current = current.Substring(0' length - 4).Trim();                      }                      else if (length >= 6 && string.Compare(current' length - 5' " DESC"' 0' 5' StringComparison.OrdinalIgnoreCase) == 0)                      {                          descending = true;                          current = current.Substring(0' length - 5).Trim();                      }                        // handle brackets.                      if (current.StartsWith("["' StringComparison.Ordinal))                      {                          if (current.EndsWith("]"' StringComparison.Ordinal))                          {                              current = current.Substring(1' current.Length - 2);                          }                          else                          {                              throw ExceptionBuilder.InvalidSortString(split[i]);                          }                      }                        // find the column.                      DataColumn column = Columns[current];                      if (column == null)                      {                          throw ExceptionBuilder.ColumnOutOfRange(current);                      }                      indexDesc[i] = new IndexField(column' descending);                  }              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ParseSortString,The following statement contains a magic number: if ((null != sortString) && (0 < sortString.Length))              {                  string[] split = sortString.Split(new char[] { ''' });                  indexDesc = new IndexField[split.Length];                    for (int i = 0; i < split.Length; i++)                  {                      string current = split[i].Trim();                        // handle ASC and DESC.                      int length = current.Length;                      bool descending = false;                      if (length >= 5 && string.Compare(current' length - 4' " ASC"' 0' 4' StringComparison.OrdinalIgnoreCase) == 0)                      {                          current = current.Substring(0' length - 4).Trim();                      }                      else if (length >= 6 && string.Compare(current' length - 5' " DESC"' 0' 5' StringComparison.OrdinalIgnoreCase) == 0)                      {                          descending = true;                          current = current.Substring(0' length - 5).Trim();                      }                        // handle brackets.                      if (current.StartsWith("["' StringComparison.Ordinal))                      {                          if (current.EndsWith("]"' StringComparison.Ordinal))                          {                              current = current.Substring(1' current.Length - 2);                          }                          else                          {                              throw ExceptionBuilder.InvalidSortString(split[i]);                          }                      }                        // find the column.                      DataColumn column = Columns[current];                      if (column == null)                      {                          throw ExceptionBuilder.ColumnOutOfRange(current);                      }                      indexDesc[i] = new IndexField(column' descending);                  }              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ParseSortString,The following statement contains a magic number: if ((null != sortString) && (0 < sortString.Length))              {                  string[] split = sortString.Split(new char[] { ''' });                  indexDesc = new IndexField[split.Length];                    for (int i = 0; i < split.Length; i++)                  {                      string current = split[i].Trim();                        // handle ASC and DESC.                      int length = current.Length;                      bool descending = false;                      if (length >= 5 && string.Compare(current' length - 4' " ASC"' 0' 4' StringComparison.OrdinalIgnoreCase) == 0)                      {                          current = current.Substring(0' length - 4).Trim();                      }                      else if (length >= 6 && string.Compare(current' length - 5' " DESC"' 0' 5' StringComparison.OrdinalIgnoreCase) == 0)                      {                          descending = true;                          current = current.Substring(0' length - 5).Trim();                      }                        // handle brackets.                      if (current.StartsWith("["' StringComparison.Ordinal))                      {                          if (current.EndsWith("]"' StringComparison.Ordinal))                          {                              current = current.Substring(1' current.Length - 2);                          }                          else                          {                              throw ExceptionBuilder.InvalidSortString(split[i]);                          }                      }                        // find the column.                      DataColumn column = Columns[current];                      if (column == null)                      {                          throw ExceptionBuilder.ColumnOutOfRange(current);                      }                      indexDesc[i] = new IndexField(column' descending);                  }              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ParseSortString,The following statement contains a magic number: if ((null != sortString) && (0 < sortString.Length))              {                  string[] split = sortString.Split(new char[] { ''' });                  indexDesc = new IndexField[split.Length];                    for (int i = 0; i < split.Length; i++)                  {                      string current = split[i].Trim();                        // handle ASC and DESC.                      int length = current.Length;                      bool descending = false;                      if (length >= 5 && string.Compare(current' length - 4' " ASC"' 0' 4' StringComparison.OrdinalIgnoreCase) == 0)                      {                          current = current.Substring(0' length - 4).Trim();                      }                      else if (length >= 6 && string.Compare(current' length - 5' " DESC"' 0' 5' StringComparison.OrdinalIgnoreCase) == 0)                      {                          descending = true;                          current = current.Substring(0' length - 5).Trim();                      }                        // handle brackets.                      if (current.StartsWith("["' StringComparison.Ordinal))                      {                          if (current.EndsWith("]"' StringComparison.Ordinal))                          {                              current = current.Substring(1' current.Length - 2);                          }                          else                          {                              throw ExceptionBuilder.InvalidSortString(split[i]);                          }                      }                        // find the column.                      DataColumn column = Columns[current];                      if (column == null)                      {                          throw ExceptionBuilder.ColumnOutOfRange(current);                      }                      indexDesc[i] = new IndexField(column' descending);                  }              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,ParseSortString,The following statement contains a magic number: if ((null != sortString) && (0 < sortString.Length))              {                  string[] split = sortString.Split(new char[] { ''' });                  indexDesc = new IndexField[split.Length];                    for (int i = 0; i < split.Length; i++)                  {                      string current = split[i].Trim();                        // handle ASC and DESC.                      int length = current.Length;                      bool descending = false;                      if (length >= 5 && string.Compare(current' length - 4' " ASC"' 0' 4' StringComparison.OrdinalIgnoreCase) == 0)                      {                          current = current.Substring(0' length - 4).Trim();                      }                      else if (length >= 6 && string.Compare(current' length - 5' " DESC"' 0' 5' StringComparison.OrdinalIgnoreCase) == 0)                      {                          descending = true;                          current = current.Substring(0' length - 5).Trim();                      }                        // handle brackets.                      if (current.StartsWith("["' StringComparison.Ordinal))                      {                          if (current.EndsWith("]"' StringComparison.Ordinal))                          {                              current = current.Substring(1' current.Length - 2);                          }                          else                          {                              throw ExceptionBuilder.InvalidSortString(split[i]);                          }                      }                        // find the column.                      DataColumn column = Columns[current];                      if (column == null)                      {                          throw ExceptionBuilder.ColumnOutOfRange(current);                      }                      indexDesc[i] = new IndexField(column' descending);                  }              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,LoadDataRow,The following statement contains a magic number: try              {                  DataRow row;                  if (_inDataLoad)                  {                      int record = NewRecordFromArray(values);                      if (_loadIndex != null)                      {                          // not expecting LiveIndexes to clear the index we use between calls to LoadDataRow                          Debug.Assert(2 <= _loadIndex.RefCount' "bad loadIndex.RefCount");                            int result = _loadIndex.FindRecord(record);                          if (result != -1)                          {                              int resultRecord = _loadIndex.GetRecord(result);                              row = _recordManager[resultRecord];                              Debug.Assert(row != null' "Row can't be null for index record");                              row.CancelEdit();                              if (row.RowState == DataRowState.Deleted)                              {                                  SetNewRecord(row' row._oldRecord' DataRowAction.Rollback' false' true);                              }                              SetNewRecord(row' record' DataRowAction.Change' false' true);                              if (fAcceptChanges)                              {                                  row.AcceptChanges();                              }                              return row;                          }                      }                      row = NewRow(record);                      AddRow(row);                      if (fAcceptChanges)                      {                          row.AcceptChanges();                      }                      return row;                  }                  else                  {                      // In case' BeginDataLoad is not called yet                      row = UpdatingAdd(values);                      if (fAcceptChanges)                      {                          row.AcceptChanges();                      }                      return row;                  }              }              finally              {                  DataCommonEventSource.Log.ExitScope(logScopeId);              }
Magic Number,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,LoadDataRow,The following statement contains a magic number: try              {                  Index indextoUse = null;                  if (_primaryKey != null)                  {                      if (loadOption == LoadOption.Upsert)                      {                          // CurrentVersion' and Deleted                          if (_loadIndexwithCurrentDeleted == null)                          {                              _loadIndexwithCurrentDeleted = _primaryKey.Key.GetSortIndex(DataViewRowState.CurrentRows | DataViewRowState.Deleted);                              Debug.Assert(_loadIndexwithCurrentDeleted != null' "loadIndexwithCurrentDeleted should not be null");                              if (_loadIndexwithCurrentDeleted != null)                              {                                  _loadIndexwithCurrentDeleted.AddRef();                              }                          }                          indextoUse = _loadIndexwithCurrentDeleted;                      }                      else                      {                          // CurrentVersion' and Deleted : OverwriteRow' PreserveCurrentValues                          if (_loadIndexwithOriginalAdded == null)                          {                              _loadIndexwithOriginalAdded = _primaryKey.Key.GetSortIndex(DataViewRowState.OriginalRows | DataViewRowState.Added);                              Debug.Assert(_loadIndexwithOriginalAdded != null' "loadIndexwithOriginalAdded should not be null");                              if (_loadIndexwithOriginalAdded != null)                              {                                  _loadIndexwithOriginalAdded.AddRef();                              }                          }                          indextoUse = _loadIndexwithOriginalAdded;                      }                      // not expecting LiveIndexes to clear the index we use between calls to LoadDataRow                      Debug.Assert(2 <= indextoUse.RefCount' "bad indextoUse.RefCount");                  }                  if (_inDataLoad && !AreIndexEventsSuspended)                  {                      // we do not want to fire any listchanged in new Load/Fill                      SuspendIndexEvents();// so suspend events here(not suspended == table already has some rows initially)                  }                    DataRow dataRow = LoadRow(values' loadOption' indextoUse);// if indextoUse == null' it means we dont have PK'                                                                            // so LoadRow will take care of just adding the row to end                    return dataRow;              }              finally              {                  DataCommonEventSource.Log.ExitScope(logScopeId);              }
Magic Number,System.Data,DataTableCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableCollection.cs,InternalIndexOf,The following statement contains a magic number: if ((null != tableName) && (0 < tableName.Length))              {                  int count = _list.Count;                  int result = 0;                  for (int i = 0; i < count; i++)                  {                      DataTable table = (DataTable)_list[i];                      result = NamesEqual(table.TableName' tableName' false' _dataSet.Locale);                      if (result == 1)                      {                          // ok' we have found a table with the same name.                          // let's see if there are any others with the same name                          // if any let's return (-3) otherwise...                          for (int j = i + 1; j < count; j++)                          {                              DataTable dupTable = (DataTable)_list[j];                              if (NamesEqual(dupTable.TableName' tableName' false' _dataSet.Locale) == 1)                                  return -3;                          }                          //... let's just return i                          return i;                      }                        if (result == -1)                          cachedI = (cachedI == -1) ? i : -2;                  }              }
Magic Number,System.Data,DataTableCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableCollection.cs,InternalIndexOf,The following statement contains a magic number: if ((null != tableName) && (0 < tableName.Length))              {                  int count = _list.Count;                  int result = 0;                  for (int i = 0; i < count; i++)                  {                      DataTable table = (DataTable)_list[i];                      result = NamesEqual(table.TableName' tableName' false' _dataSet.Locale);                      if (result == 1)                      {                          // ok' we have found a table with the same name.                          // let's see if there are any others with the same name                          // if any let's return (-3) otherwise...                          for (int j = i + 1; j < count; j++)                          {                              DataTable dupTable = (DataTable)_list[j];                              if (NamesEqual(dupTable.TableName' tableName' false' _dataSet.Locale) == 1)                                  return -3;                          }                          //... let's just return i                          return i;                      }                        if (result == -1)                          cachedI = (cachedI == -1) ? i : -2;                  }              }
Magic Number,System.Data,DataTableCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTableCollection.cs,InternalIndexOf,The following statement contains a magic number: if ((null != tableName) && (0 < tableName.Length))              {                  int count = _list.Count;                  int result = 0;                  for (int i = 0; i < count; i++)                  {                      DataTable table = (DataTable)_list[i];                      result = NamesEqual(table.TableName' tableName' false' _dataSet.Locale);                      if ((result == 1) && (table.Namespace == tableNamespace))                          return i;                        if ((result == -1) && (table.Namespace == tableNamespace))                          cachedI = (cachedI == -1) ? i : -2;                  }              }
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,AllocPage,The following statement contains a magic number: if (freePageIndex != -1)              {                  _pageTable[freePageIndex] = new TreePage(size);                  _nextFreePageLine = freePageIndex / TreePage.slotLineSize;              }              else              {                  // no free position found' increase pageTable size                  TreePage[] newPageTable = new TreePage[_pageTable.Length * 2];                  Array.Copy(_pageTable' 0' newPageTable' 0' _pageTable.Length);                  int[] newPageTableMap = new int[(newPageTable.Length + TreePage.slotLineSize - 1) / TreePage.slotLineSize];                  Array.Copy(_pageTableMap' 0' newPageTableMap' 0' _pageTableMap.Length);                    _nextFreePageLine = _pageTableMap.Length;                  freePageIndex = _pageTable.Length;                  _pageTable = newPageTable;                  _pageTableMap = newPageTableMap;                  _pageTable[freePageIndex] = new TreePage(size);              }
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetIntValueFromBitMap,The following statement contains a magic number: if ((bitMap & 0xFFFF0000) != 0)              {                  value += 16;                  bitMap >>= 16;              }
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetIntValueFromBitMap,The following statement contains a magic number: if ((bitMap & 0xFFFF0000) != 0)              {                  value += 16;                  bitMap >>= 16;              }
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetIntValueFromBitMap,The following statement contains a magic number: if ((bitMap & 0x0000FF00) != 0)              {                  value += 8;                  bitMap >>= 8;              }
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetIntValueFromBitMap,The following statement contains a magic number: if ((bitMap & 0x0000FF00) != 0)              {                  value += 8;                  bitMap >>= 8;              }
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetIntValueFromBitMap,The following statement contains a magic number: if ((bitMap & 0x000000F0) != 0)              {                  value += 4;                  bitMap >>= 4;              }
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetIntValueFromBitMap,The following statement contains a magic number: if ((bitMap & 0x000000F0) != 0)              {                  value += 4;                  bitMap >>= 4;              }
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetIntValueFromBitMap,The following statement contains a magic number: if ((bitMap & 0x0000000C) != 0)              {                  value += 2;                  bitMap >>= 2;              }
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetIntValueFromBitMap,The following statement contains a magic number: if ((bitMap & 0x0000000C) != 0)              {                  value += 2;                  bitMap >>= 2;              }
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,FreeNode,The following statement contains a magic number: TreePage page = _pageTable[nodeId >> 16];
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetNewNode,The following statement contains a magic number: if (freePageIndex != -1)                  page = _pageTable[freePageIndex];              else if (_inUsePageCount < (4))                  page = AllocPage(DefaultPageSize);  // First 128 slots              else if (_inUsePageCount < (32))                  page = AllocPage(256);              else if (_inUsePageCount < (128))                  page = AllocPage(1024);              else if (_inUsePageCount < (4096))                  page = AllocPage(4096);              else if (_inUsePageCount < (32 * 1024))                  page = AllocPage(8192);              // approximately First 16 million slots (2^24)              else                  page = AllocPage(64 * 1024);
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetNewNode,The following statement contains a magic number: if (freePageIndex != -1)                  page = _pageTable[freePageIndex];              else if (_inUsePageCount < (4))                  page = AllocPage(DefaultPageSize);  // First 128 slots              else if (_inUsePageCount < (32))                  page = AllocPage(256);              else if (_inUsePageCount < (128))                  page = AllocPage(1024);              else if (_inUsePageCount < (4096))                  page = AllocPage(4096);              else if (_inUsePageCount < (32 * 1024))                  page = AllocPage(8192);              // approximately First 16 million slots (2^24)              else                  page = AllocPage(64 * 1024);
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetNewNode,The following statement contains a magic number: if (freePageIndex != -1)                  page = _pageTable[freePageIndex];              else if (_inUsePageCount < (4))                  page = AllocPage(DefaultPageSize);  // First 128 slots              else if (_inUsePageCount < (32))                  page = AllocPage(256);              else if (_inUsePageCount < (128))                  page = AllocPage(1024);              else if (_inUsePageCount < (4096))                  page = AllocPage(4096);              else if (_inUsePageCount < (32 * 1024))                  page = AllocPage(8192);              // approximately First 16 million slots (2^24)              else                  page = AllocPage(64 * 1024);
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetNewNode,The following statement contains a magic number: if (freePageIndex != -1)                  page = _pageTable[freePageIndex];              else if (_inUsePageCount < (4))                  page = AllocPage(DefaultPageSize);  // First 128 slots              else if (_inUsePageCount < (32))                  page = AllocPage(256);              else if (_inUsePageCount < (128))                  page = AllocPage(1024);              else if (_inUsePageCount < (4096))                  page = AllocPage(4096);              else if (_inUsePageCount < (32 * 1024))                  page = AllocPage(8192);              // approximately First 16 million slots (2^24)              else                  page = AllocPage(64 * 1024);
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetNewNode,The following statement contains a magic number: if (freePageIndex != -1)                  page = _pageTable[freePageIndex];              else if (_inUsePageCount < (4))                  page = AllocPage(DefaultPageSize);  // First 128 slots              else if (_inUsePageCount < (32))                  page = AllocPage(256);              else if (_inUsePageCount < (128))                  page = AllocPage(1024);              else if (_inUsePageCount < (4096))                  page = AllocPage(4096);              else if (_inUsePageCount < (32 * 1024))                  page = AllocPage(8192);              // approximately First 16 million slots (2^24)              else                  page = AllocPage(64 * 1024);
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetNewNode,The following statement contains a magic number: if (freePageIndex != -1)                  page = _pageTable[freePageIndex];              else if (_inUsePageCount < (4))                  page = AllocPage(DefaultPageSize);  // First 128 slots              else if (_inUsePageCount < (32))                  page = AllocPage(256);              else if (_inUsePageCount < (128))                  page = AllocPage(1024);              else if (_inUsePageCount < (4096))                  page = AllocPage(4096);              else if (_inUsePageCount < (32 * 1024))                  page = AllocPage(8192);              // approximately First 16 million slots (2^24)              else                  page = AllocPage(64 * 1024);
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetNewNode,The following statement contains a magic number: if (freePageIndex != -1)                  page = _pageTable[freePageIndex];              else if (_inUsePageCount < (4))                  page = AllocPage(DefaultPageSize);  // First 128 slots              else if (_inUsePageCount < (32))                  page = AllocPage(256);              else if (_inUsePageCount < (128))                  page = AllocPage(1024);              else if (_inUsePageCount < (4096))                  page = AllocPage(4096);              else if (_inUsePageCount < (32 * 1024))                  page = AllocPage(8192);              // approximately First 16 million slots (2^24)              else                  page = AllocPage(64 * 1024);
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetNewNode,The following statement contains a magic number: if (freePageIndex != -1)                  page = _pageTable[freePageIndex];              else if (_inUsePageCount < (4))                  page = AllocPage(DefaultPageSize);  // First 128 slots              else if (_inUsePageCount < (32))                  page = AllocPage(256);              else if (_inUsePageCount < (128))                  page = AllocPage(1024);              else if (_inUsePageCount < (4096))                  page = AllocPage(4096);              else if (_inUsePageCount < (32 * 1024))                  page = AllocPage(8192);              // approximately First 16 million slots (2^24)              else                  page = AllocPage(64 * 1024);
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetNewNode,The following statement contains a magic number: if (freePageIndex != -1)                  page = _pageTable[freePageIndex];              else if (_inUsePageCount < (4))                  page = AllocPage(DefaultPageSize);  // First 128 slots              else if (_inUsePageCount < (32))                  page = AllocPage(256);              else if (_inUsePageCount < (128))                  page = AllocPage(1024);              else if (_inUsePageCount < (4096))                  page = AllocPage(4096);              else if (_inUsePageCount < (32 * 1024))                  page = AllocPage(8192);              // approximately First 16 million slots (2^24)              else                  page = AllocPage(64 * 1024);
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetNewNode,The following statement contains a magic number: if (freePageIndex != -1)                  page = _pageTable[freePageIndex];              else if (_inUsePageCount < (4))                  page = AllocPage(DefaultPageSize);  // First 128 slots              else if (_inUsePageCount < (32))                  page = AllocPage(256);              else if (_inUsePageCount < (128))                  page = AllocPage(1024);              else if (_inUsePageCount < (4096))                  page = AllocPage(4096);              else if (_inUsePageCount < (32 * 1024))                  page = AllocPage(8192);              // approximately First 16 million slots (2^24)              else                  page = AllocPage(64 * 1024);
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetNewNode,The following statement contains a magic number: if (freePageIndex != -1)                  page = _pageTable[freePageIndex];              else if (_inUsePageCount < (4))                  page = AllocPage(DefaultPageSize);  // First 128 slots              else if (_inUsePageCount < (32))                  page = AllocPage(256);              else if (_inUsePageCount < (128))                  page = AllocPage(1024);              else if (_inUsePageCount < (4096))                  page = AllocPage(4096);              else if (_inUsePageCount < (32 * 1024))                  page = AllocPage(8192);              // approximately First 16 million slots (2^24)              else                  page = AllocPage(64 * 1024);
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetNewNode,The following statement contains a magic number: if (freePageIndex != -1)                  page = _pageTable[freePageIndex];              else if (_inUsePageCount < (4))                  page = AllocPage(DefaultPageSize);  // First 128 slots              else if (_inUsePageCount < (32))                  page = AllocPage(256);              else if (_inUsePageCount < (128))                  page = AllocPage(1024);              else if (_inUsePageCount < (4096))                  page = AllocPage(4096);              else if (_inUsePageCount < (32 * 1024))                  page = AllocPage(8192);              // approximately First 16 million slots (2^24)              else                  page = AllocPage(64 * 1024);
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,GetNewNode,The following statement contains a magic number: page._slots[slotId]._selfId = (int)(((uint)page.PageId) << 16) | slotId;
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,RBDeleteX,The following statement contains a magic number: if (SubTreeSize(Next(mNode)) == 2) // Next(mNode) == root_id                  isCase3 = true;              else if (SubTreeSize(Next(mNode)) == 1)              {                  throw ExceptionBuilder.InternalRBTreeError(RBTreeError.InvalidNextSizeInDelete);              }
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,SetRight,The following statement contains a magic number: _pageTable[nodeId >> 16]._slots[nodeId & 0xFFFF]._rightId = rightNodeId;
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,SetLeft,The following statement contains a magic number: _pageTable[nodeId >> 16]._slots[nodeId & 0xFFFF]._leftId = leftNodeId;
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,SetParent,The following statement contains a magic number: _pageTable[nodeId >> 16]._slots[nodeId & 0xFFFF]._parentId = parentNodeId;
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,SetColor,The following statement contains a magic number: _pageTable[nodeId >> 16]._slots[nodeId & 0xFFFF]._nodeColor = color;
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,SetKey,The following statement contains a magic number: _pageTable[nodeId >> 16]._slots[nodeId & 0xFFFF]._keyOfNode = key;
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,SetNext,The following statement contains a magic number: _pageTable[nodeId >> 16]._slots[nodeId & 0xFFFF]._nextId = nextNodeId;
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,SetSubTreeSize,The following statement contains a magic number: Debug.Assert(nodeId != NIL &&                           (size != 0 || _pageTable[nodeId >> 16]._slots[nodeId & 0xFFFF]._selfId == NIL) &&                           (size != 1 || _pageTable[nodeId >> 16]._slots[nodeId & 0xFFFF]._nextId == NIL)' "SetSize");
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,SetSubTreeSize,The following statement contains a magic number: Debug.Assert(nodeId != NIL &&                           (size != 0 || _pageTable[nodeId >> 16]._slots[nodeId & 0xFFFF]._selfId == NIL) &&                           (size != 1 || _pageTable[nodeId >> 16]._slots[nodeId & 0xFFFF]._nextId == NIL)' "SetSize");
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,SetSubTreeSize,The following statement contains a magic number: _pageTable[nodeId >> 16]._slots[nodeId & 0xFFFF]._subTreeSize = size;
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,IncreaseSize,The following statement contains a magic number: _pageTable[nodeId >> 16]._slots[nodeId & 0xFFFF]._subTreeSize += 1;
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,RecomputeSize,The following statement contains a magic number: _pageTable[nodeId >> 16]._slots[nodeId & 0xFFFF]._subTreeSize = myCorrectSize;
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,DecreaseSize,The following statement contains a magic number: _pageTable[nodeId >> 16]._slots[nodeId & 0xFFFF]._subTreeSize -= 1;
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,DecreaseSize,The following statement contains a magic number: VerifySize(nodeId' _pageTable[nodeId >> 16]._slots[nodeId & 0xFFFF]._subTreeSize);
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,Right,The following statement contains a magic number: return (_pageTable[nodeId >> 16]._slots[nodeId & 0xFFFF]._rightId);
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,Left,The following statement contains a magic number: return (_pageTable[nodeId >> 16]._slots[nodeId & 0xFFFF]._leftId);
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,Parent,The following statement contains a magic number: return (_pageTable[nodeId >> 16]._slots[nodeId & 0xFFFF]._parentId);
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,color,The following statement contains a magic number: return (_pageTable[nodeId >> 16]._slots[nodeId & 0xFFFF]._nodeColor);
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,Next,The following statement contains a magic number: return (_pageTable[nodeId >> 16]._slots[nodeId & 0xFFFF]._nextId);
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,SubTreeSize,The following statement contains a magic number: return (_pageTable[nodeId >> 16]._slots[nodeId & 0xFFFF]._subTreeSize);
Magic Number,System.Data,RBTree<K>,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,Key,The following statement contains a magic number: return (_pageTable[nodeId >> 16]._slots[nodeId & 0xFFFF]._keyOfNode);
Magic Number,System.Data,TreePage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,TreePage,The following statement contains a magic number: if (size > 64 * 1024)                  {                      throw ExceptionBuilder.InternalRBTreeError(RBTreeError.InvalidPageSize);                  }
Magic Number,System.Data,TreePage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RbTree.cs,TreePage,The following statement contains a magic number: if (size > 64 * 1024)                  {                      throw ExceptionBuilder.InternalRBTreeError(RBTreeError.InvalidPageSize);                  }
Magic Number,System.Data,RecordManager,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RecordManager.cs,NormalizedMinimumCapacity,The following statement contains a magic number: if (capacity < 1024 - 10)              {                  if (capacity < 256 - 10)                  {                      if (capacity < 54)                          return 64;                      return 256;                  }                  return 1024;              }
Magic Number,System.Data,RecordManager,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RecordManager.cs,NormalizedMinimumCapacity,The following statement contains a magic number: if (capacity < 1024 - 10)              {                  if (capacity < 256 - 10)                  {                      if (capacity < 54)                          return 64;                      return 256;                  }                  return 1024;              }
Magic Number,System.Data,RecordManager,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RecordManager.cs,NormalizedMinimumCapacity,The following statement contains a magic number: if (capacity < 1024 - 10)              {                  if (capacity < 256 - 10)                  {                      if (capacity < 54)                          return 64;                      return 256;                  }                  return 1024;              }
Magic Number,System.Data,RecordManager,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RecordManager.cs,NormalizedMinimumCapacity,The following statement contains a magic number: if (capacity < 1024 - 10)              {                  if (capacity < 256 - 10)                  {                      if (capacity < 54)                          return 64;                      return 256;                  }                  return 1024;              }
Magic Number,System.Data,RecordManager,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RecordManager.cs,NormalizedMinimumCapacity,The following statement contains a magic number: if (capacity < 1024 - 10)              {                  if (capacity < 256 - 10)                  {                      if (capacity < 54)                          return 64;                      return 256;                  }                  return 1024;              }
Magic Number,System.Data,RecordManager,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RecordManager.cs,NormalizedMinimumCapacity,The following statement contains a magic number: if (capacity < 1024 - 10)              {                  if (capacity < 256 - 10)                  {                      if (capacity < 54)                          return 64;                      return 256;                  }                  return 1024;              }
Magic Number,System.Data,RecordManager,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RecordManager.cs,NormalizedMinimumCapacity,The following statement contains a magic number: if (capacity < 1024 - 10)              {                  if (capacity < 256 - 10)                  {                      if (capacity < 54)                          return 64;                      return 256;                  }                  return 1024;              }
Magic Number,System.Data,RecordManager,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RecordManager.cs,NormalizedMinimumCapacity,The following statement contains a magic number: if (capacity < 1024 - 10)              {                  if (capacity < 256 - 10)                  {                      if (capacity < 54)                          return 64;                      return 256;                  }                  return 1024;              }
Magic Number,System.Data,RecordManager,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RecordManager.cs,NormalizedMinimumCapacity,The following statement contains a magic number: return (((capacity + 10) >> 10) + 1) << 10;
Magic Number,System.Data,RecordManager,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RecordManager.cs,NormalizedMinimumCapacity,The following statement contains a magic number: return (((capacity + 10) >> 10) + 1) << 10;
Magic Number,System.Data,RecordManager,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\RecordManager.cs,NormalizedMinimumCapacity,The following statement contains a magic number: return (((capacity + 10) >> 10) + 1) << 10;
Magic Number,System.Data,ExpressionParser,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\ExpressionParser.cs,Parse,The following statement contains a magic number: while (_token != Tokens.EOS)              {              loop:                  Scan();                    switch (_token)                  {                      case Tokens.EOS:                          // End of string: must be operand; force out expression;                          // check for bomb; check nothing left on stack.                            if (_prevOperand == Empty)                          {                              if (_topNode == 0)                              {                                  // we have an empty expression                                  break;                              }                              // set error missing operator                              // read the last operator info                              opInfo = _ops[_topOperator - 1];                                throw ExprException.MissingOperand(opInfo);                          }                          // collect all nodes                          BuildExpression(Operators.priLow);                          if (_topOperator != 1)                          {                              throw ExprException.MissingRightParen();                          }                          break;                        case Tokens.Name:                      case Tokens.Parent:                      case Tokens.Numeric:                      case Tokens.Decimal:                      case Tokens.Float:                      case Tokens.StringConst:                      case Tokens.Date:                          ExpressionNode node = null;                          string str = null;                            /* Constants and identifiers: create leaf node */                            if (_prevOperand != Empty)                          {                              // set error missing operator                              throw ExprException.MissingOperator(new string(_text' _start' _pos - _start));                          }                            if (_topOperator > 0)                          {                              // special check for IN without parentheses                                opInfo = _ops[_topOperator - 1];                                if (opInfo._type == Nodes.Binop && opInfo._op == Operators.In && _token != Tokens.Parent)                              {                                  throw ExprException.InWithoutParentheses();                              }                          }                            _prevOperand = Scalar;                            switch (_token)                          {                              case Tokens.Parent:                                  string relname;                                  string colname;                                    // parsing Parent[(relation_name)].column_name)                                  try                                  {                                      // expecting an '(' or '.'                                      Scan();                                      if (_token == Tokens.LeftParen)                                      {                                          //read the relation name                                          ScanToken(Tokens.Name);                                          relname = NameNode.ParseName(_text' _start' _pos);                                          ScanToken(Tokens.RightParen);                                          ScanToken(Tokens.Dot);                                      }                                      else                                      {                                          relname = null;                                          CheckToken(Tokens.Dot);                                      }                                  }                                  catch (Exception e) when (Common.ADP.IsCatchableExceptionType(e))                                  {                                      throw ExprException.LookupArgument();                                  }                                    ScanToken(Tokens.Name);                                  colname = NameNode.ParseName(_text' _start' _pos);                                    opInfo = _ops[_topOperator - 1];                                  node = new LookupNode(_table' colname' relname);                                    break;                                case Tokens.Name:                                  /* Qualify name now for nice error checking */                                    opInfo = _ops[_topOperator - 1];                                    /* Create tree element -                */                                  // CONSIDER: Check for reserved proc names here                                  node = new NameNode(_table' _text' _start' _pos);                                    break;                                case Tokens.Numeric:                                  str = new string(_text' _start' _pos - _start);                                  node = new ConstNode(_table' ValueType.Numeric' str);                                  break;                              case Tokens.Decimal:                                  str = new string(_text' _start' _pos - _start);                                  node = new ConstNode(_table' ValueType.Decimal' str);                                  break;                              case Tokens.Float:                                  str = new string(_text' _start' _pos - _start);                                  node = new ConstNode(_table' ValueType.Float' str);                                  break;                              case Tokens.StringConst:                                  Debug.Assert(_text[_start] == '\'' && _text[_pos - 1] == '\''' "The expression contains an invalid string constant");                                  Debug.Assert(_pos - _start > 1' "The expression contains an invalid string constant");                                  // Store string without quotes..                                  str = new string(_text' _start + 1' _pos - _start - 2);                                  node = new ConstNode(_table' ValueType.Str' str);                                  break;                              case Tokens.Date:                                  Debug.Assert(_text[_start] == '#' && _text[_pos - 1] == '#'' "The expression contains invalid date constant.");                                  Debug.Assert(_pos - _start > 2' "The expression contains invalid date constant '{0}'.");                                  // Store date without delimiters(#s)..                                  str = new string(_text' _start + 1' _pos - _start - 2);                                  node = new ConstNode(_table' ValueType.Date' str);                                  break;                              default:                                  Debug.Assert(false' "unhandled token");                                  break;                          }                            NodePush(node);                          goto loop;                        case Tokens.LeftParen:                          cParens++;                          if (_prevOperand == Empty)                          {                              // Check for ( following IN/IFF. if not' we have a normal (.                              // Peek: take a look at the operators stack                                Debug.Assert(_topOperator > 0' "Empty operator stack!!");                              opInfo = _ops[_topOperator - 1];                                if (opInfo._type == Nodes.Binop && opInfo._op == Operators.In)                              {                                  /* IN - handle as procedure call */                                    node = new FunctionNode(_table' "In");                                  NodePush(node);                                  /* Push operator decriptor */                                  _ops[_topOperator++] = new OperatorInfo(Nodes.Call' Operators.Noop' Operators.priParen);                              }                              else                              {  /* Normal ( */                                  /* Push operator decriptor */                                  _ops[_topOperator++] = new OperatorInfo(Nodes.Paren' Operators.Noop' Operators.priParen);                              }                          }                          else                          {                              // This is a procedure call or () qualification                              // Force out any dot qualifiers; check for bomb                                BuildExpression(Operators.priProc);                              _prevOperand = Empty;                              ExpressionNode nodebefore = NodePeek();                                if (nodebefore == null || nodebefore.GetType() != typeof(NameNode))                              {                                  // this is more like an assert' so we not care about "nice" exception text..                                  throw ExprException.SyntaxError();                              }                                /* Get the proc name */                              NameNode name = (NameNode)NodePop();                                // Make sure that we can bind the name as a Function                              // then get the argument count and types' and parse arguments..                                node = new FunctionNode(_table' name._name);                                // check to see if this is an aggregate function                              Aggregate agg = (Aggregate)(int)((FunctionNode)node).Aggregate;                              if (agg != Aggregate.None)                              {                                  node = ParseAggregateArgument((FunctionId)(int)agg);                                  NodePush(node);                                  _prevOperand = Expr;                                  goto loop;                              }                                NodePush(node);                              _ops[_topOperator++] = new OperatorInfo(Nodes.Call' Operators.Noop' Operators.priParen);                          }                          goto loop;                        case Tokens.RightParen:                          {                              /* Right parentheses: Build expression if we have an operand. */                              if (_prevOperand != Empty)                              {                                  BuildExpression(Operators.priLow);                              }                                /* We must have Tokens.LeftParen on stack. If no operand' must be procedure call. */                              if (_topOperator <= 1)                              {                                  // set error' syntax: too many right parens..                                  throw ExprException.TooManyRightParentheses();                              }                                Debug.Assert(_topOperator > 1' "melformed operator stack.");                              _topOperator--;                              opInfo = _ops[_topOperator];                                if (_prevOperand == Empty && opInfo._type != Nodes.Call)                              {                                  // set error' syntax: missing operand.                                  throw ExprException.MissingOperand(opInfo);                              }                                Debug.Assert(opInfo._priority == Operators.priParen' "melformed operator stack.");                                if (opInfo._type == Nodes.Call)                              {                                  /* add argument to the function call. */                                    if (_prevOperand != Empty)                                  {                                      // read last function argument                                      ExpressionNode argument = NodePop();                                        /* Get the procedure name and append argument */                                      Debug.Assert(_topNode > 0 && NodePeek().GetType() == typeof(FunctionNode)' "The function node should be created on '('");                                        FunctionNode func = (FunctionNode)NodePop();                                      func.AddArgument(argument);                                      func.Check();                                      NodePush(func);                                  }                              }                              else                              {                                  /* Normal parentheses: create tree node */                                  // Construct & Put the Nodes.Paren node on node stack                                  node = NodePop();                                  node = new UnaryNode(_table' Operators.Noop' node);                                  NodePush(node);                              }                                _prevOperand = Expr;                              cParens--;                              goto loop;                          }                      case Tokens.ListSeparator:                          {                              /* Comma encountered: Must be operand; force out subexpression */                                if (_prevOperand == Empty)                              {                                  throw ExprException.MissingOperandBefore("'");                              }                                /* We are be in a procedure call */                                /* build next argument */                              BuildExpression(Operators.priLow);                                opInfo = _ops[_topOperator - 1];                                if (opInfo._type != Nodes.Call)                                  throw ExprException.SyntaxError();                                ExpressionNode argument2 = NodePop();                                /* Get the procedure name */                                FunctionNode func = (FunctionNode)NodePop();                                func.AddArgument(argument2);                                NodePush(func);                                _prevOperand = Empty;                                goto loop;                          }                      case Tokens.BinaryOp:                          if (_prevOperand == Empty)                          {                              /* Check for unary plus/minus */                              if (_op == Operators.Plus)                              {                                  _op = Operators.UnaryPlus;                                  // fall through to UnaryOperator;                              }                              else if (_op == Operators.Minus)                              {                                  /* Unary minus */                                  _op = Operators.Negative;                                  // fall through to UnaryOperator;                              }                              else                              {                                  // Error missing operand:                                  throw ExprException.MissingOperandBefore(Operators.ToString(_op));                              }                          }                          else                          {                              _prevOperand = Empty;                                /* CNSIDER: If we are going to support BETWEEN Translate AND to special BetweenAnd if it is. */                                /* Force out to appropriate precedence; push operator. */                                BuildExpression(Operators.Priority(_op));                                // PushOperator descriptor                              _ops[_topOperator++] = new OperatorInfo(Nodes.Binop' _op' Operators.Priority(_op));                              goto loop;                          }                          goto                      case Tokens.UnaryOp; // fall through to UnaryOperator;                        case Tokens.UnaryOp:                          /* Must be no operand. Push it. */                          _ops[_topOperator++] = new OperatorInfo(Nodes.Unop' _op' Operators.Priority(_op));                          goto loop;                        case Tokens.ZeroOp:                          // check the we have operator on the stack                          if (_prevOperand != Empty)                          {                              // set error missing operator                              throw ExprException.MissingOperator(new string(_text' _start' _pos - _start));                          }                            // PushOperator descriptor                          _ops[_topOperator++] = new OperatorInfo(Nodes.Zop' _op' Operators.priMax);                          _prevOperand = Expr;                          goto loop;                        case Tokens.Dot:                          //if there is a name on the stack append it.                          ExpressionNode before = NodePeek();                            if (before != null && before.GetType() == typeof(NameNode))                          {                              Scan();                                if (_token == Tokens.Name)                              {                                  NameNode nameBefore = (NameNode)NodePop();                                  string newName = nameBefore._name + "." + NameNode.ParseName(_text' _start' _pos);                                  NodePush(new NameNode(_table' newName));                                  goto loop;                              }                          }                          // fall through to default                          goto default;                      default:                          throw ExprException.UnknownToken(new string(_text' _start' _pos - _start)' _start + 1);                  }              }
Magic Number,System.Data,ExpressionParser,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\ExpressionParser.cs,Parse,The following statement contains a magic number: while (_token != Tokens.EOS)              {              loop:                  Scan();                    switch (_token)                  {                      case Tokens.EOS:                          // End of string: must be operand; force out expression;                          // check for bomb; check nothing left on stack.                            if (_prevOperand == Empty)                          {                              if (_topNode == 0)                              {                                  // we have an empty expression                                  break;                              }                              // set error missing operator                              // read the last operator info                              opInfo = _ops[_topOperator - 1];                                throw ExprException.MissingOperand(opInfo);                          }                          // collect all nodes                          BuildExpression(Operators.priLow);                          if (_topOperator != 1)                          {                              throw ExprException.MissingRightParen();                          }                          break;                        case Tokens.Name:                      case Tokens.Parent:                      case Tokens.Numeric:                      case Tokens.Decimal:                      case Tokens.Float:                      case Tokens.StringConst:                      case Tokens.Date:                          ExpressionNode node = null;                          string str = null;                            /* Constants and identifiers: create leaf node */                            if (_prevOperand != Empty)                          {                              // set error missing operator                              throw ExprException.MissingOperator(new string(_text' _start' _pos - _start));                          }                            if (_topOperator > 0)                          {                              // special check for IN without parentheses                                opInfo = _ops[_topOperator - 1];                                if (opInfo._type == Nodes.Binop && opInfo._op == Operators.In && _token != Tokens.Parent)                              {                                  throw ExprException.InWithoutParentheses();                              }                          }                            _prevOperand = Scalar;                            switch (_token)                          {                              case Tokens.Parent:                                  string relname;                                  string colname;                                    // parsing Parent[(relation_name)].column_name)                                  try                                  {                                      // expecting an '(' or '.'                                      Scan();                                      if (_token == Tokens.LeftParen)                                      {                                          //read the relation name                                          ScanToken(Tokens.Name);                                          relname = NameNode.ParseName(_text' _start' _pos);                                          ScanToken(Tokens.RightParen);                                          ScanToken(Tokens.Dot);                                      }                                      else                                      {                                          relname = null;                                          CheckToken(Tokens.Dot);                                      }                                  }                                  catch (Exception e) when (Common.ADP.IsCatchableExceptionType(e))                                  {                                      throw ExprException.LookupArgument();                                  }                                    ScanToken(Tokens.Name);                                  colname = NameNode.ParseName(_text' _start' _pos);                                    opInfo = _ops[_topOperator - 1];                                  node = new LookupNode(_table' colname' relname);                                    break;                                case Tokens.Name:                                  /* Qualify name now for nice error checking */                                    opInfo = _ops[_topOperator - 1];                                    /* Create tree element -                */                                  // CONSIDER: Check for reserved proc names here                                  node = new NameNode(_table' _text' _start' _pos);                                    break;                                case Tokens.Numeric:                                  str = new string(_text' _start' _pos - _start);                                  node = new ConstNode(_table' ValueType.Numeric' str);                                  break;                              case Tokens.Decimal:                                  str = new string(_text' _start' _pos - _start);                                  node = new ConstNode(_table' ValueType.Decimal' str);                                  break;                              case Tokens.Float:                                  str = new string(_text' _start' _pos - _start);                                  node = new ConstNode(_table' ValueType.Float' str);                                  break;                              case Tokens.StringConst:                                  Debug.Assert(_text[_start] == '\'' && _text[_pos - 1] == '\''' "The expression contains an invalid string constant");                                  Debug.Assert(_pos - _start > 1' "The expression contains an invalid string constant");                                  // Store string without quotes..                                  str = new string(_text' _start + 1' _pos - _start - 2);                                  node = new ConstNode(_table' ValueType.Str' str);                                  break;                              case Tokens.Date:                                  Debug.Assert(_text[_start] == '#' && _text[_pos - 1] == '#'' "The expression contains invalid date constant.");                                  Debug.Assert(_pos - _start > 2' "The expression contains invalid date constant '{0}'.");                                  // Store date without delimiters(#s)..                                  str = new string(_text' _start + 1' _pos - _start - 2);                                  node = new ConstNode(_table' ValueType.Date' str);                                  break;                              default:                                  Debug.Assert(false' "unhandled token");                                  break;                          }                            NodePush(node);                          goto loop;                        case Tokens.LeftParen:                          cParens++;                          if (_prevOperand == Empty)                          {                              // Check for ( following IN/IFF. if not' we have a normal (.                              // Peek: take a look at the operators stack                                Debug.Assert(_topOperator > 0' "Empty operator stack!!");                              opInfo = _ops[_topOperator - 1];                                if (opInfo._type == Nodes.Binop && opInfo._op == Operators.In)                              {                                  /* IN - handle as procedure call */                                    node = new FunctionNode(_table' "In");                                  NodePush(node);                                  /* Push operator decriptor */                                  _ops[_topOperator++] = new OperatorInfo(Nodes.Call' Operators.Noop' Operators.priParen);                              }                              else                              {  /* Normal ( */                                  /* Push operator decriptor */                                  _ops[_topOperator++] = new OperatorInfo(Nodes.Paren' Operators.Noop' Operators.priParen);                              }                          }                          else                          {                              // This is a procedure call or () qualification                              // Force out any dot qualifiers; check for bomb                                BuildExpression(Operators.priProc);                              _prevOperand = Empty;                              ExpressionNode nodebefore = NodePeek();                                if (nodebefore == null || nodebefore.GetType() != typeof(NameNode))                              {                                  // this is more like an assert' so we not care about "nice" exception text..                                  throw ExprException.SyntaxError();                              }                                /* Get the proc name */                              NameNode name = (NameNode)NodePop();                                // Make sure that we can bind the name as a Function                              // then get the argument count and types' and parse arguments..                                node = new FunctionNode(_table' name._name);                                // check to see if this is an aggregate function                              Aggregate agg = (Aggregate)(int)((FunctionNode)node).Aggregate;                              if (agg != Aggregate.None)                              {                                  node = ParseAggregateArgument((FunctionId)(int)agg);                                  NodePush(node);                                  _prevOperand = Expr;                                  goto loop;                              }                                NodePush(node);                              _ops[_topOperator++] = new OperatorInfo(Nodes.Call' Operators.Noop' Operators.priParen);                          }                          goto loop;                        case Tokens.RightParen:                          {                              /* Right parentheses: Build expression if we have an operand. */                              if (_prevOperand != Empty)                              {                                  BuildExpression(Operators.priLow);                              }                                /* We must have Tokens.LeftParen on stack. If no operand' must be procedure call. */                              if (_topOperator <= 1)                              {                                  // set error' syntax: too many right parens..                                  throw ExprException.TooManyRightParentheses();                              }                                Debug.Assert(_topOperator > 1' "melformed operator stack.");                              _topOperator--;                              opInfo = _ops[_topOperator];                                if (_prevOperand == Empty && opInfo._type != Nodes.Call)                              {                                  // set error' syntax: missing operand.                                  throw ExprException.MissingOperand(opInfo);                              }                                Debug.Assert(opInfo._priority == Operators.priParen' "melformed operator stack.");                                if (opInfo._type == Nodes.Call)                              {                                  /* add argument to the function call. */                                    if (_prevOperand != Empty)                                  {                                      // read last function argument                                      ExpressionNode argument = NodePop();                                        /* Get the procedure name and append argument */                                      Debug.Assert(_topNode > 0 && NodePeek().GetType() == typeof(FunctionNode)' "The function node should be created on '('");                                        FunctionNode func = (FunctionNode)NodePop();                                      func.AddArgument(argument);                                      func.Check();                                      NodePush(func);                                  }                              }                              else                              {                                  /* Normal parentheses: create tree node */                                  // Construct & Put the Nodes.Paren node on node stack                                  node = NodePop();                                  node = new UnaryNode(_table' Operators.Noop' node);                                  NodePush(node);                              }                                _prevOperand = Expr;                              cParens--;                              goto loop;                          }                      case Tokens.ListSeparator:                          {                              /* Comma encountered: Must be operand; force out subexpression */                                if (_prevOperand == Empty)                              {                                  throw ExprException.MissingOperandBefore("'");                              }                                /* We are be in a procedure call */                                /* build next argument */                              BuildExpression(Operators.priLow);                                opInfo = _ops[_topOperator - 1];                                if (opInfo._type != Nodes.Call)                                  throw ExprException.SyntaxError();                                ExpressionNode argument2 = NodePop();                                /* Get the procedure name */                                FunctionNode func = (FunctionNode)NodePop();                                func.AddArgument(argument2);                                NodePush(func);                                _prevOperand = Empty;                                goto loop;                          }                      case Tokens.BinaryOp:                          if (_prevOperand == Empty)                          {                              /* Check for unary plus/minus */                              if (_op == Operators.Plus)                              {                                  _op = Operators.UnaryPlus;                                  // fall through to UnaryOperator;                              }                              else if (_op == Operators.Minus)                              {                                  /* Unary minus */                                  _op = Operators.Negative;                                  // fall through to UnaryOperator;                              }                              else                              {                                  // Error missing operand:                                  throw ExprException.MissingOperandBefore(Operators.ToString(_op));                              }                          }                          else                          {                              _prevOperand = Empty;                                /* CNSIDER: If we are going to support BETWEEN Translate AND to special BetweenAnd if it is. */                                /* Force out to appropriate precedence; push operator. */                                BuildExpression(Operators.Priority(_op));                                // PushOperator descriptor                              _ops[_topOperator++] = new OperatorInfo(Nodes.Binop' _op' Operators.Priority(_op));                              goto loop;                          }                          goto                      case Tokens.UnaryOp; // fall through to UnaryOperator;                        case Tokens.UnaryOp:                          /* Must be no operand. Push it. */                          _ops[_topOperator++] = new OperatorInfo(Nodes.Unop' _op' Operators.Priority(_op));                          goto loop;                        case Tokens.ZeroOp:                          // check the we have operator on the stack                          if (_prevOperand != Empty)                          {                              // set error missing operator                              throw ExprException.MissingOperator(new string(_text' _start' _pos - _start));                          }                            // PushOperator descriptor                          _ops[_topOperator++] = new OperatorInfo(Nodes.Zop' _op' Operators.priMax);                          _prevOperand = Expr;                          goto loop;                        case Tokens.Dot:                          //if there is a name on the stack append it.                          ExpressionNode before = NodePeek();                            if (before != null && before.GetType() == typeof(NameNode))                          {                              Scan();                                if (_token == Tokens.Name)                              {                                  NameNode nameBefore = (NameNode)NodePop();                                  string newName = nameBefore._name + "." + NameNode.ParseName(_text' _start' _pos);                                  NodePush(new NameNode(_table' newName));                                  goto loop;                              }                          }                          // fall through to default                          goto default;                      default:                          throw ExprException.UnknownToken(new string(_text' _start' _pos - _start)' _start + 1);                  }              }
Magic Number,System.Data,ExpressionParser,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\ExpressionParser.cs,Parse,The following statement contains a magic number: while (_token != Tokens.EOS)              {              loop:                  Scan();                    switch (_token)                  {                      case Tokens.EOS:                          // End of string: must be operand; force out expression;                          // check for bomb; check nothing left on stack.                            if (_prevOperand == Empty)                          {                              if (_topNode == 0)                              {                                  // we have an empty expression                                  break;                              }                              // set error missing operator                              // read the last operator info                              opInfo = _ops[_topOperator - 1];                                throw ExprException.MissingOperand(opInfo);                          }                          // collect all nodes                          BuildExpression(Operators.priLow);                          if (_topOperator != 1)                          {                              throw ExprException.MissingRightParen();                          }                          break;                        case Tokens.Name:                      case Tokens.Parent:                      case Tokens.Numeric:                      case Tokens.Decimal:                      case Tokens.Float:                      case Tokens.StringConst:                      case Tokens.Date:                          ExpressionNode node = null;                          string str = null;                            /* Constants and identifiers: create leaf node */                            if (_prevOperand != Empty)                          {                              // set error missing operator                              throw ExprException.MissingOperator(new string(_text' _start' _pos - _start));                          }                            if (_topOperator > 0)                          {                              // special check for IN without parentheses                                opInfo = _ops[_topOperator - 1];                                if (opInfo._type == Nodes.Binop && opInfo._op == Operators.In && _token != Tokens.Parent)                              {                                  throw ExprException.InWithoutParentheses();                              }                          }                            _prevOperand = Scalar;                            switch (_token)                          {                              case Tokens.Parent:                                  string relname;                                  string colname;                                    // parsing Parent[(relation_name)].column_name)                                  try                                  {                                      // expecting an '(' or '.'                                      Scan();                                      if (_token == Tokens.LeftParen)                                      {                                          //read the relation name                                          ScanToken(Tokens.Name);                                          relname = NameNode.ParseName(_text' _start' _pos);                                          ScanToken(Tokens.RightParen);                                          ScanToken(Tokens.Dot);                                      }                                      else                                      {                                          relname = null;                                          CheckToken(Tokens.Dot);                                      }                                  }                                  catch (Exception e) when (Common.ADP.IsCatchableExceptionType(e))                                  {                                      throw ExprException.LookupArgument();                                  }                                    ScanToken(Tokens.Name);                                  colname = NameNode.ParseName(_text' _start' _pos);                                    opInfo = _ops[_topOperator - 1];                                  node = new LookupNode(_table' colname' relname);                                    break;                                case Tokens.Name:                                  /* Qualify name now for nice error checking */                                    opInfo = _ops[_topOperator - 1];                                    /* Create tree element -                */                                  // CONSIDER: Check for reserved proc names here                                  node = new NameNode(_table' _text' _start' _pos);                                    break;                                case Tokens.Numeric:                                  str = new string(_text' _start' _pos - _start);                                  node = new ConstNode(_table' ValueType.Numeric' str);                                  break;                              case Tokens.Decimal:                                  str = new string(_text' _start' _pos - _start);                                  node = new ConstNode(_table' ValueType.Decimal' str);                                  break;                              case Tokens.Float:                                  str = new string(_text' _start' _pos - _start);                                  node = new ConstNode(_table' ValueType.Float' str);                                  break;                              case Tokens.StringConst:                                  Debug.Assert(_text[_start] == '\'' && _text[_pos - 1] == '\''' "The expression contains an invalid string constant");                                  Debug.Assert(_pos - _start > 1' "The expression contains an invalid string constant");                                  // Store string without quotes..                                  str = new string(_text' _start + 1' _pos - _start - 2);                                  node = new ConstNode(_table' ValueType.Str' str);                                  break;                              case Tokens.Date:                                  Debug.Assert(_text[_start] == '#' && _text[_pos - 1] == '#'' "The expression contains invalid date constant.");                                  Debug.Assert(_pos - _start > 2' "The expression contains invalid date constant '{0}'.");                                  // Store date without delimiters(#s)..                                  str = new string(_text' _start + 1' _pos - _start - 2);                                  node = new ConstNode(_table' ValueType.Date' str);                                  break;                              default:                                  Debug.Assert(false' "unhandled token");                                  break;                          }                            NodePush(node);                          goto loop;                        case Tokens.LeftParen:                          cParens++;                          if (_prevOperand == Empty)                          {                              // Check for ( following IN/IFF. if not' we have a normal (.                              // Peek: take a look at the operators stack                                Debug.Assert(_topOperator > 0' "Empty operator stack!!");                              opInfo = _ops[_topOperator - 1];                                if (opInfo._type == Nodes.Binop && opInfo._op == Operators.In)                              {                                  /* IN - handle as procedure call */                                    node = new FunctionNode(_table' "In");                                  NodePush(node);                                  /* Push operator decriptor */                                  _ops[_topOperator++] = new OperatorInfo(Nodes.Call' Operators.Noop' Operators.priParen);                              }                              else                              {  /* Normal ( */                                  /* Push operator decriptor */                                  _ops[_topOperator++] = new OperatorInfo(Nodes.Paren' Operators.Noop' Operators.priParen);                              }                          }                          else                          {                              // This is a procedure call or () qualification                              // Force out any dot qualifiers; check for bomb                                BuildExpression(Operators.priProc);                              _prevOperand = Empty;                              ExpressionNode nodebefore = NodePeek();                                if (nodebefore == null || nodebefore.GetType() != typeof(NameNode))                              {                                  // this is more like an assert' so we not care about "nice" exception text..                                  throw ExprException.SyntaxError();                              }                                /* Get the proc name */                              NameNode name = (NameNode)NodePop();                                // Make sure that we can bind the name as a Function                              // then get the argument count and types' and parse arguments..                                node = new FunctionNode(_table' name._name);                                // check to see if this is an aggregate function                              Aggregate agg = (Aggregate)(int)((FunctionNode)node).Aggregate;                              if (agg != Aggregate.None)                              {                                  node = ParseAggregateArgument((FunctionId)(int)agg);                                  NodePush(node);                                  _prevOperand = Expr;                                  goto loop;                              }                                NodePush(node);                              _ops[_topOperator++] = new OperatorInfo(Nodes.Call' Operators.Noop' Operators.priParen);                          }                          goto loop;                        case Tokens.RightParen:                          {                              /* Right parentheses: Build expression if we have an operand. */                              if (_prevOperand != Empty)                              {                                  BuildExpression(Operators.priLow);                              }                                /* We must have Tokens.LeftParen on stack. If no operand' must be procedure call. */                              if (_topOperator <= 1)                              {                                  // set error' syntax: too many right parens..                                  throw ExprException.TooManyRightParentheses();                              }                                Debug.Assert(_topOperator > 1' "melformed operator stack.");                              _topOperator--;                              opInfo = _ops[_topOperator];                                if (_prevOperand == Empty && opInfo._type != Nodes.Call)                              {                                  // set error' syntax: missing operand.                                  throw ExprException.MissingOperand(opInfo);                              }                                Debug.Assert(opInfo._priority == Operators.priParen' "melformed operator stack.");                                if (opInfo._type == Nodes.Call)                              {                                  /* add argument to the function call. */                                    if (_prevOperand != Empty)                                  {                                      // read last function argument                                      ExpressionNode argument = NodePop();                                        /* Get the procedure name and append argument */                                      Debug.Assert(_topNode > 0 && NodePeek().GetType() == typeof(FunctionNode)' "The function node should be created on '('");                                        FunctionNode func = (FunctionNode)NodePop();                                      func.AddArgument(argument);                                      func.Check();                                      NodePush(func);                                  }                              }                              else                              {                                  /* Normal parentheses: create tree node */                                  // Construct & Put the Nodes.Paren node on node stack                                  node = NodePop();                                  node = new UnaryNode(_table' Operators.Noop' node);                                  NodePush(node);                              }                                _prevOperand = Expr;                              cParens--;                              goto loop;                          }                      case Tokens.ListSeparator:                          {                              /* Comma encountered: Must be operand; force out subexpression */                                if (_prevOperand == Empty)                              {                                  throw ExprException.MissingOperandBefore("'");                              }                                /* We are be in a procedure call */                                /* build next argument */                              BuildExpression(Operators.priLow);                                opInfo = _ops[_topOperator - 1];                                if (opInfo._type != Nodes.Call)                                  throw ExprException.SyntaxError();                                ExpressionNode argument2 = NodePop();                                /* Get the procedure name */                                FunctionNode func = (FunctionNode)NodePop();                                func.AddArgument(argument2);                                NodePush(func);                                _prevOperand = Empty;                                goto loop;                          }                      case Tokens.BinaryOp:                          if (_prevOperand == Empty)                          {                              /* Check for unary plus/minus */                              if (_op == Operators.Plus)                              {                                  _op = Operators.UnaryPlus;                                  // fall through to UnaryOperator;                              }                              else if (_op == Operators.Minus)                              {                                  /* Unary minus */                                  _op = Operators.Negative;                                  // fall through to UnaryOperator;                              }                              else                              {                                  // Error missing operand:                                  throw ExprException.MissingOperandBefore(Operators.ToString(_op));                              }                          }                          else                          {                              _prevOperand = Empty;                                /* CNSIDER: If we are going to support BETWEEN Translate AND to special BetweenAnd if it is. */                                /* Force out to appropriate precedence; push operator. */                                BuildExpression(Operators.Priority(_op));                                // PushOperator descriptor                              _ops[_topOperator++] = new OperatorInfo(Nodes.Binop' _op' Operators.Priority(_op));                              goto loop;                          }                          goto                      case Tokens.UnaryOp; // fall through to UnaryOperator;                        case Tokens.UnaryOp:                          /* Must be no operand. Push it. */                          _ops[_topOperator++] = new OperatorInfo(Nodes.Unop' _op' Operators.Priority(_op));                          goto loop;                        case Tokens.ZeroOp:                          // check the we have operator on the stack                          if (_prevOperand != Empty)                          {                              // set error missing operator                              throw ExprException.MissingOperator(new string(_text' _start' _pos - _start));                          }                            // PushOperator descriptor                          _ops[_topOperator++] = new OperatorInfo(Nodes.Zop' _op' Operators.priMax);                          _prevOperand = Expr;                          goto loop;                        case Tokens.Dot:                          //if there is a name on the stack append it.                          ExpressionNode before = NodePeek();                            if (before != null && before.GetType() == typeof(NameNode))                          {                              Scan();                                if (_token == Tokens.Name)                              {                                  NameNode nameBefore = (NameNode)NodePop();                                  string newName = nameBefore._name + "." + NameNode.ParseName(_text' _start' _pos);                                  NodePush(new NameNode(_table' newName));                                  goto loop;                              }                          }                          // fall through to default                          goto default;                      default:                          throw ExprException.UnknownToken(new string(_text' _start' _pos - _start)' _start + 1);                  }              }
Magic Number,System.Data,ExpressionParser,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\ExpressionParser.cs,NodePush,The following statement contains a magic number: if (_topNode >= MaxPredicates - 2)              {                  throw ExprException.ExpressionTooComplex();              }
Magic Number,System.Data,ExpressionParser,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\ExpressionParser.cs,ScanReserved,The following statement contains a magic number: if (IsAlpha(text[_pos]))              {                  ScanName();                    Debug.Assert(_token == Tokens.Name' "Exprecing an identifier.");                  Debug.Assert(_pos > _start' "Exprecing an identifier.");                    string name = new string(text' _start' _pos - _start);                  Debug.Assert(name != null' "Make sure the arguments for Compare method are OK");                      CompareInfo comparer = CultureInfo.InvariantCulture.CompareInfo;                  // binary search reserved words                  int lo = 0;                  int hi = s_reservedwords.Length - 1;                  do                  {                      int i = (lo + hi) / 2;                      Debug.Assert(s_reservedwords[i]._word != null' "Make sure the arguments for Compare method are OK");                      int c = comparer.Compare(s_reservedwords[i]._word' name' CompareOptions.IgnoreCase);                        if (c == 0)                      {                          // we found the reserved word..                          _token = s_reservedwords[i]._token;                          _op = s_reservedwords[i]._op;                          return;                      }                      if (c < 0)                      {                          lo = i + 1;                      }                      else                      {                          hi = i - 1;                      }                  } while (lo <= hi);                    Debug.Assert(_token == Tokens.Name' "Exprecing an identifier.");              }
Magic Number,System.Data,ExpressionParser,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\ExpressionParser.cs,IsWhiteSpace,The following statement contains a magic number: return ch <= 32 && ch != '\0';
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,AddArgument,The following statement contains a magic number: if (_arguments == null)              {                  _arguments = new ExpressionNode[initialCapacity];              }              else if (_argumentCount == _arguments.Length)              {                  ExpressionNode[] bigger = new ExpressionNode[_argumentCount * 2];                  Array.Copy(_arguments' 0' bigger' 0' _argumentCount);                  _arguments = bigger;              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,Bind,The following statement contains a magic number: if (s_funcs[_info]._id == FunctionId.Convert)              {                  if (_argumentCount != 2)                      throw ExprException.FunctionArgumentCount(_name);                  _arguments[0].Bind(table' list);                    if (_arguments[1].GetType() == typeof(NameNode))                  {                      NameNode type = (NameNode)_arguments[1];                      _arguments[1] = new ConstNode(table' ValueType.Str' type._name);                  }                  _arguments[1].Bind(table' list);              }              else              {                  for (int i = 0; i < _argumentCount; i++)                  {                      _arguments[i].Bind(table' list);                  }              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,Eval,The following statement contains a magic number: if (s_funcs[_info]._id == FunctionId.Convert)              {                  if (_argumentCount != 2)                      throw ExprException.FunctionArgumentCount(_name);                    argumentValues[0] = _arguments[0].Eval(row' version);                  argumentValues[1] = GetDataType(_arguments[1]);              }              else if (s_funcs[_info]._id != FunctionId.Iif)              { // We do not want to evaluate arguments of IIF' we will already do it in EvalFunction/ second point: we may go to div by 0                  for (int i = 0; i < _argumentCount; i++)                  {                      argumentValues[i] = _arguments[i].Eval(row' version);                        if (s_funcs[_info]._isValidateArguments)                      {                          if ((argumentValues[i] == DBNull.Value) || (typeof(object) == s_funcs[_info]._parameters[i]))                          {                              // currently all supported functions with IsValidateArguments set to true                              // NOTE: for IIF and ISNULL IsValidateArguments set to false                              return DBNull.Value;                          }                            if (argumentValues[i].GetType() != s_funcs[_info]._parameters[i])                          {                              // We are allowing conversions in one very specific case: int' int64'...'nice' numeric to numeric..                                if (s_funcs[_info]._parameters[i] == typeof(int) && ExpressionNode.IsInteger(DataStorage.GetStorageType(argumentValues[i].GetType())))                              {                                  argumentValues[i] = Convert.ToInt32(argumentValues[i]' FormatProvider);                              }                              else if ((s_funcs[_info]._id == FunctionId.Trim) || (s_funcs[_info]._id == FunctionId.Substring) || (s_funcs[_info]._id == FunctionId.Len))                              {                                  if ((typeof(string) != (argumentValues[i].GetType())) && (typeof(SqlString) != (argumentValues[i].GetType())))                                  {                                      throw ExprException.ArgumentType(s_funcs[_info]._name' i + 1' s_funcs[_info]._parameters[i]);                                  }                              }                              else                              {                                  throw ExprException.ArgumentType(s_funcs[_info]._name' i + 1' s_funcs[_info]._parameters[i]);                              }                          }                      }                  }              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,GetDataType,The following statement contains a magic number: if (typeName == null)              {                  throw ExprException.ArgumentType(s_funcs[_info]._name' 2' typeof(Type));              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following statement contains a magic number: switch (id)              {                  case FunctionId.Abs:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      if (ExpressionNode.IsInteger(storageType))                          return (Math.Abs((long)argumentValues[0]));                      if (ExpressionNode.IsNumeric(storageType))                          return (Math.Abs((double)argumentValues[0]));                        throw ExprException.ArgumentTypeInteger(s_funcs[_info]._name' 1);                    case FunctionId.cBool:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      switch (storageType)                      {                          case StorageType.Boolean:                              return (bool)argumentValues[0];                          case StorageType.Int32:                              return ((int)argumentValues[0] != 0);                          case StorageType.Double:                              return ((double)argumentValues[0] != 0.0);                          case StorageType.String:                              return bool.Parse((string)argumentValues[0]);                          default:                              throw ExprException.DatatypeConvertion(argumentValues[0].GetType()' typeof(bool));                      }                    case FunctionId.cInt:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToInt32(argumentValues[0]' FormatProvider);                    case FunctionId.cDate:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDateTime(argumentValues[0]' FormatProvider);                    case FunctionId.cDbl:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDouble(argumentValues[0]' FormatProvider);                    case FunctionId.cStr:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToString(argumentValues[0]' FormatProvider);                    case FunctionId.Charindex:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        Debug.Assert(argumentValues[0] is string' "Invalid argument type for " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is string' "Invalid argument type for " + s_funcs[_info]._name);                        if (DataStorage.IsObjectNull(argumentValues[0]) || DataStorage.IsObjectNull(argumentValues[1]))                          return DBNull.Value;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        if (argumentValues[1] is SqlString)                          argumentValues[1] = ((SqlString)argumentValues[1]).Value;                        return ((string)argumentValues[1]).IndexOf((string)argumentValues[0]' StringComparison.Ordinal);                    case FunctionId.Iif:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                        object first = _arguments[0].Eval(row' version);                        if (DataExpression.ToBoolean(first) != false)                      {                          return _arguments[1].Eval(row' version);                      }                      else                      {                          return _arguments[2].Eval(row' version);                      }                    case FunctionId.In:                      // we never evaluate IN directly: IN as a binary operator' so evaluation of this should be in                      // BinaryNode class                      throw ExprException.NYI(s_funcs[_info]._name);                    case FunctionId.IsNull:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount: ");                        if (DataStorage.IsObjectNull(argumentValues[0]))                          return argumentValues[1];                      else                          return argumentValues[0];                    case FunctionId.Len:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                        if (argumentValues[0] is SqlString)                      {                          if (((SqlString)argumentValues[0]).IsNull)                          {                              return DBNull.Value;                          }                          else                          {                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                          }                      }                        return ((string)argumentValues[0]).Length;                      case FunctionId.Substring:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name);                        // work around the differences in .NET and VBA implementation of the Substring function                      // 1. The <index> Argument is 0-based in .NET' and 1-based in VBA                      // 2. If the <Length> argument is longer then the string length .NET throws an ArgumentException                      //    but our users still want to get a result.                        int start = (int)argumentValues[1] - 1;                        int length = (int)argumentValues[2];                        if (start < 0)                          throw ExprException.FunctionArgumentOutOfRange("index"' "Substring");                        if (length < 0)                          throw ExprException.FunctionArgumentOutOfRange("length"' "Substring");                        if (length == 0)                          return string.Empty;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        int src_length = ((string)argumentValues[0]).Length;                        if (start > src_length)                      {                          return DBNull.Value;                      }                        if (start + length > src_length)                      {                          length = src_length - start;                      }                        return ((string)argumentValues[0]).Substring(start' length);                    case FunctionId.Trim:                      {                          Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                          Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                            if (DataStorage.IsObjectNull(argumentValues[0]))                              return DBNull.Value;                            if (argumentValues[0] is SqlString)                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                            return (((string)argumentValues[0]).Trim());                      }                    case FunctionId.Convert:                      if (_argumentCount != 2)                          throw ExprException.FunctionArgumentCount(_name);                        if (argumentValues[0] == DBNull.Value)                      {                          return DBNull.Value;                      }                        Type type = (Type)argumentValues[1];                      StorageType mytype = DataStorage.GetStorageType(type);                      storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                        if (mytype == StorageType.DateTimeOffset)                      {                          if (storageType == StorageType.String)                          {                              return SqlConvert.ConvertStringToDateTimeOffset((string)argumentValues[0]' FormatProvider);                          }                      }                        if (StorageType.Object != mytype)                      {                          if ((mytype == StorageType.Guid) && (storageType == StorageType.String))                              return new Guid((string)argumentValues[0]);                            if (ExpressionNode.IsFloatSql(storageType) && ExpressionNode.IsIntegerSql(mytype))                          {                              if (StorageType.Single == storageType)                              {                                  return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Double == storageType)                              {                                  return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Decimal == storageType)                              {                                  return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider);                              }                              return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                          }                            return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                      }                        return argumentValues[0];                    case FunctionId.DateTimeOffset:                      if (argumentValues[0] == DBNull.Value || argumentValues[1] == DBNull.Value || argumentValues[2] == DBNull.Value)                          return DBNull.Value;                      switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }                      if ((int)argumentValues[1] < -14 || (int)argumentValues[1] > 14)                          throw ExprException.InvalidHoursArgument();                      if ((int)argumentValues[2] < -59 || (int)argumentValues[2] > 59)                          throw ExprException.InvalidMinutesArgument();                      // range should be within -14 hours and  +14 hours                      if ((int)argumentValues[1] == 14 && (int)argumentValues[2] > 0)                          throw ExprException.InvalidTimeZoneRange();                      if ((int)argumentValues[1] == -14 && (int)argumentValues[2] < 0)                          throw ExprException.InvalidTimeZoneRange();                        return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0));                    default:                      throw ExprException.UndefinedFunction(s_funcs[_info]._name);              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following statement contains a magic number: switch (id)              {                  case FunctionId.Abs:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      if (ExpressionNode.IsInteger(storageType))                          return (Math.Abs((long)argumentValues[0]));                      if (ExpressionNode.IsNumeric(storageType))                          return (Math.Abs((double)argumentValues[0]));                        throw ExprException.ArgumentTypeInteger(s_funcs[_info]._name' 1);                    case FunctionId.cBool:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      switch (storageType)                      {                          case StorageType.Boolean:                              return (bool)argumentValues[0];                          case StorageType.Int32:                              return ((int)argumentValues[0] != 0);                          case StorageType.Double:                              return ((double)argumentValues[0] != 0.0);                          case StorageType.String:                              return bool.Parse((string)argumentValues[0]);                          default:                              throw ExprException.DatatypeConvertion(argumentValues[0].GetType()' typeof(bool));                      }                    case FunctionId.cInt:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToInt32(argumentValues[0]' FormatProvider);                    case FunctionId.cDate:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDateTime(argumentValues[0]' FormatProvider);                    case FunctionId.cDbl:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDouble(argumentValues[0]' FormatProvider);                    case FunctionId.cStr:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToString(argumentValues[0]' FormatProvider);                    case FunctionId.Charindex:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        Debug.Assert(argumentValues[0] is string' "Invalid argument type for " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is string' "Invalid argument type for " + s_funcs[_info]._name);                        if (DataStorage.IsObjectNull(argumentValues[0]) || DataStorage.IsObjectNull(argumentValues[1]))                          return DBNull.Value;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        if (argumentValues[1] is SqlString)                          argumentValues[1] = ((SqlString)argumentValues[1]).Value;                        return ((string)argumentValues[1]).IndexOf((string)argumentValues[0]' StringComparison.Ordinal);                    case FunctionId.Iif:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                        object first = _arguments[0].Eval(row' version);                        if (DataExpression.ToBoolean(first) != false)                      {                          return _arguments[1].Eval(row' version);                      }                      else                      {                          return _arguments[2].Eval(row' version);                      }                    case FunctionId.In:                      // we never evaluate IN directly: IN as a binary operator' so evaluation of this should be in                      // BinaryNode class                      throw ExprException.NYI(s_funcs[_info]._name);                    case FunctionId.IsNull:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount: ");                        if (DataStorage.IsObjectNull(argumentValues[0]))                          return argumentValues[1];                      else                          return argumentValues[0];                    case FunctionId.Len:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                        if (argumentValues[0] is SqlString)                      {                          if (((SqlString)argumentValues[0]).IsNull)                          {                              return DBNull.Value;                          }                          else                          {                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                          }                      }                        return ((string)argumentValues[0]).Length;                      case FunctionId.Substring:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name);                        // work around the differences in .NET and VBA implementation of the Substring function                      // 1. The <index> Argument is 0-based in .NET' and 1-based in VBA                      // 2. If the <Length> argument is longer then the string length .NET throws an ArgumentException                      //    but our users still want to get a result.                        int start = (int)argumentValues[1] - 1;                        int length = (int)argumentValues[2];                        if (start < 0)                          throw ExprException.FunctionArgumentOutOfRange("index"' "Substring");                        if (length < 0)                          throw ExprException.FunctionArgumentOutOfRange("length"' "Substring");                        if (length == 0)                          return string.Empty;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        int src_length = ((string)argumentValues[0]).Length;                        if (start > src_length)                      {                          return DBNull.Value;                      }                        if (start + length > src_length)                      {                          length = src_length - start;                      }                        return ((string)argumentValues[0]).Substring(start' length);                    case FunctionId.Trim:                      {                          Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                          Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                            if (DataStorage.IsObjectNull(argumentValues[0]))                              return DBNull.Value;                            if (argumentValues[0] is SqlString)                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                            return (((string)argumentValues[0]).Trim());                      }                    case FunctionId.Convert:                      if (_argumentCount != 2)                          throw ExprException.FunctionArgumentCount(_name);                        if (argumentValues[0] == DBNull.Value)                      {                          return DBNull.Value;                      }                        Type type = (Type)argumentValues[1];                      StorageType mytype = DataStorage.GetStorageType(type);                      storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                        if (mytype == StorageType.DateTimeOffset)                      {                          if (storageType == StorageType.String)                          {                              return SqlConvert.ConvertStringToDateTimeOffset((string)argumentValues[0]' FormatProvider);                          }                      }                        if (StorageType.Object != mytype)                      {                          if ((mytype == StorageType.Guid) && (storageType == StorageType.String))                              return new Guid((string)argumentValues[0]);                            if (ExpressionNode.IsFloatSql(storageType) && ExpressionNode.IsIntegerSql(mytype))                          {                              if (StorageType.Single == storageType)                              {                                  return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Double == storageType)                              {                                  return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Decimal == storageType)                              {                                  return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider);                              }                              return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                          }                            return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                      }                        return argumentValues[0];                    case FunctionId.DateTimeOffset:                      if (argumentValues[0] == DBNull.Value || argumentValues[1] == DBNull.Value || argumentValues[2] == DBNull.Value)                          return DBNull.Value;                      switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }                      if ((int)argumentValues[1] < -14 || (int)argumentValues[1] > 14)                          throw ExprException.InvalidHoursArgument();                      if ((int)argumentValues[2] < -59 || (int)argumentValues[2] > 59)                          throw ExprException.InvalidMinutesArgument();                      // range should be within -14 hours and  +14 hours                      if ((int)argumentValues[1] == 14 && (int)argumentValues[2] > 0)                          throw ExprException.InvalidTimeZoneRange();                      if ((int)argumentValues[1] == -14 && (int)argumentValues[2] < 0)                          throw ExprException.InvalidTimeZoneRange();                        return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0));                    default:                      throw ExprException.UndefinedFunction(s_funcs[_info]._name);              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following statement contains a magic number: switch (id)              {                  case FunctionId.Abs:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      if (ExpressionNode.IsInteger(storageType))                          return (Math.Abs((long)argumentValues[0]));                      if (ExpressionNode.IsNumeric(storageType))                          return (Math.Abs((double)argumentValues[0]));                        throw ExprException.ArgumentTypeInteger(s_funcs[_info]._name' 1);                    case FunctionId.cBool:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      switch (storageType)                      {                          case StorageType.Boolean:                              return (bool)argumentValues[0];                          case StorageType.Int32:                              return ((int)argumentValues[0] != 0);                          case StorageType.Double:                              return ((double)argumentValues[0] != 0.0);                          case StorageType.String:                              return bool.Parse((string)argumentValues[0]);                          default:                              throw ExprException.DatatypeConvertion(argumentValues[0].GetType()' typeof(bool));                      }                    case FunctionId.cInt:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToInt32(argumentValues[0]' FormatProvider);                    case FunctionId.cDate:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDateTime(argumentValues[0]' FormatProvider);                    case FunctionId.cDbl:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDouble(argumentValues[0]' FormatProvider);                    case FunctionId.cStr:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToString(argumentValues[0]' FormatProvider);                    case FunctionId.Charindex:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        Debug.Assert(argumentValues[0] is string' "Invalid argument type for " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is string' "Invalid argument type for " + s_funcs[_info]._name);                        if (DataStorage.IsObjectNull(argumentValues[0]) || DataStorage.IsObjectNull(argumentValues[1]))                          return DBNull.Value;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        if (argumentValues[1] is SqlString)                          argumentValues[1] = ((SqlString)argumentValues[1]).Value;                        return ((string)argumentValues[1]).IndexOf((string)argumentValues[0]' StringComparison.Ordinal);                    case FunctionId.Iif:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                        object first = _arguments[0].Eval(row' version);                        if (DataExpression.ToBoolean(first) != false)                      {                          return _arguments[1].Eval(row' version);                      }                      else                      {                          return _arguments[2].Eval(row' version);                      }                    case FunctionId.In:                      // we never evaluate IN directly: IN as a binary operator' so evaluation of this should be in                      // BinaryNode class                      throw ExprException.NYI(s_funcs[_info]._name);                    case FunctionId.IsNull:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount: ");                        if (DataStorage.IsObjectNull(argumentValues[0]))                          return argumentValues[1];                      else                          return argumentValues[0];                    case FunctionId.Len:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                        if (argumentValues[0] is SqlString)                      {                          if (((SqlString)argumentValues[0]).IsNull)                          {                              return DBNull.Value;                          }                          else                          {                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                          }                      }                        return ((string)argumentValues[0]).Length;                      case FunctionId.Substring:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name);                        // work around the differences in .NET and VBA implementation of the Substring function                      // 1. The <index> Argument is 0-based in .NET' and 1-based in VBA                      // 2. If the <Length> argument is longer then the string length .NET throws an ArgumentException                      //    but our users still want to get a result.                        int start = (int)argumentValues[1] - 1;                        int length = (int)argumentValues[2];                        if (start < 0)                          throw ExprException.FunctionArgumentOutOfRange("index"' "Substring");                        if (length < 0)                          throw ExprException.FunctionArgumentOutOfRange("length"' "Substring");                        if (length == 0)                          return string.Empty;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        int src_length = ((string)argumentValues[0]).Length;                        if (start > src_length)                      {                          return DBNull.Value;                      }                        if (start + length > src_length)                      {                          length = src_length - start;                      }                        return ((string)argumentValues[0]).Substring(start' length);                    case FunctionId.Trim:                      {                          Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                          Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                            if (DataStorage.IsObjectNull(argumentValues[0]))                              return DBNull.Value;                            if (argumentValues[0] is SqlString)                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                            return (((string)argumentValues[0]).Trim());                      }                    case FunctionId.Convert:                      if (_argumentCount != 2)                          throw ExprException.FunctionArgumentCount(_name);                        if (argumentValues[0] == DBNull.Value)                      {                          return DBNull.Value;                      }                        Type type = (Type)argumentValues[1];                      StorageType mytype = DataStorage.GetStorageType(type);                      storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                        if (mytype == StorageType.DateTimeOffset)                      {                          if (storageType == StorageType.String)                          {                              return SqlConvert.ConvertStringToDateTimeOffset((string)argumentValues[0]' FormatProvider);                          }                      }                        if (StorageType.Object != mytype)                      {                          if ((mytype == StorageType.Guid) && (storageType == StorageType.String))                              return new Guid((string)argumentValues[0]);                            if (ExpressionNode.IsFloatSql(storageType) && ExpressionNode.IsIntegerSql(mytype))                          {                              if (StorageType.Single == storageType)                              {                                  return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Double == storageType)                              {                                  return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Decimal == storageType)                              {                                  return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider);                              }                              return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                          }                            return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                      }                        return argumentValues[0];                    case FunctionId.DateTimeOffset:                      if (argumentValues[0] == DBNull.Value || argumentValues[1] == DBNull.Value || argumentValues[2] == DBNull.Value)                          return DBNull.Value;                      switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }                      if ((int)argumentValues[1] < -14 || (int)argumentValues[1] > 14)                          throw ExprException.InvalidHoursArgument();                      if ((int)argumentValues[2] < -59 || (int)argumentValues[2] > 59)                          throw ExprException.InvalidMinutesArgument();                      // range should be within -14 hours and  +14 hours                      if ((int)argumentValues[1] == 14 && (int)argumentValues[2] > 0)                          throw ExprException.InvalidTimeZoneRange();                      if ((int)argumentValues[1] == -14 && (int)argumentValues[2] < 0)                          throw ExprException.InvalidTimeZoneRange();                        return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0));                    default:                      throw ExprException.UndefinedFunction(s_funcs[_info]._name);              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following statement contains a magic number: switch (id)              {                  case FunctionId.Abs:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      if (ExpressionNode.IsInteger(storageType))                          return (Math.Abs((long)argumentValues[0]));                      if (ExpressionNode.IsNumeric(storageType))                          return (Math.Abs((double)argumentValues[0]));                        throw ExprException.ArgumentTypeInteger(s_funcs[_info]._name' 1);                    case FunctionId.cBool:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      switch (storageType)                      {                          case StorageType.Boolean:                              return (bool)argumentValues[0];                          case StorageType.Int32:                              return ((int)argumentValues[0] != 0);                          case StorageType.Double:                              return ((double)argumentValues[0] != 0.0);                          case StorageType.String:                              return bool.Parse((string)argumentValues[0]);                          default:                              throw ExprException.DatatypeConvertion(argumentValues[0].GetType()' typeof(bool));                      }                    case FunctionId.cInt:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToInt32(argumentValues[0]' FormatProvider);                    case FunctionId.cDate:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDateTime(argumentValues[0]' FormatProvider);                    case FunctionId.cDbl:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDouble(argumentValues[0]' FormatProvider);                    case FunctionId.cStr:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToString(argumentValues[0]' FormatProvider);                    case FunctionId.Charindex:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        Debug.Assert(argumentValues[0] is string' "Invalid argument type for " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is string' "Invalid argument type for " + s_funcs[_info]._name);                        if (DataStorage.IsObjectNull(argumentValues[0]) || DataStorage.IsObjectNull(argumentValues[1]))                          return DBNull.Value;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        if (argumentValues[1] is SqlString)                          argumentValues[1] = ((SqlString)argumentValues[1]).Value;                        return ((string)argumentValues[1]).IndexOf((string)argumentValues[0]' StringComparison.Ordinal);                    case FunctionId.Iif:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                        object first = _arguments[0].Eval(row' version);                        if (DataExpression.ToBoolean(first) != false)                      {                          return _arguments[1].Eval(row' version);                      }                      else                      {                          return _arguments[2].Eval(row' version);                      }                    case FunctionId.In:                      // we never evaluate IN directly: IN as a binary operator' so evaluation of this should be in                      // BinaryNode class                      throw ExprException.NYI(s_funcs[_info]._name);                    case FunctionId.IsNull:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount: ");                        if (DataStorage.IsObjectNull(argumentValues[0]))                          return argumentValues[1];                      else                          return argumentValues[0];                    case FunctionId.Len:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                        if (argumentValues[0] is SqlString)                      {                          if (((SqlString)argumentValues[0]).IsNull)                          {                              return DBNull.Value;                          }                          else                          {                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                          }                      }                        return ((string)argumentValues[0]).Length;                      case FunctionId.Substring:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name);                        // work around the differences in .NET and VBA implementation of the Substring function                      // 1. The <index> Argument is 0-based in .NET' and 1-based in VBA                      // 2. If the <Length> argument is longer then the string length .NET throws an ArgumentException                      //    but our users still want to get a result.                        int start = (int)argumentValues[1] - 1;                        int length = (int)argumentValues[2];                        if (start < 0)                          throw ExprException.FunctionArgumentOutOfRange("index"' "Substring");                        if (length < 0)                          throw ExprException.FunctionArgumentOutOfRange("length"' "Substring");                        if (length == 0)                          return string.Empty;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        int src_length = ((string)argumentValues[0]).Length;                        if (start > src_length)                      {                          return DBNull.Value;                      }                        if (start + length > src_length)                      {                          length = src_length - start;                      }                        return ((string)argumentValues[0]).Substring(start' length);                    case FunctionId.Trim:                      {                          Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                          Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                            if (DataStorage.IsObjectNull(argumentValues[0]))                              return DBNull.Value;                            if (argumentValues[0] is SqlString)                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                            return (((string)argumentValues[0]).Trim());                      }                    case FunctionId.Convert:                      if (_argumentCount != 2)                          throw ExprException.FunctionArgumentCount(_name);                        if (argumentValues[0] == DBNull.Value)                      {                          return DBNull.Value;                      }                        Type type = (Type)argumentValues[1];                      StorageType mytype = DataStorage.GetStorageType(type);                      storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                        if (mytype == StorageType.DateTimeOffset)                      {                          if (storageType == StorageType.String)                          {                              return SqlConvert.ConvertStringToDateTimeOffset((string)argumentValues[0]' FormatProvider);                          }                      }                        if (StorageType.Object != mytype)                      {                          if ((mytype == StorageType.Guid) && (storageType == StorageType.String))                              return new Guid((string)argumentValues[0]);                            if (ExpressionNode.IsFloatSql(storageType) && ExpressionNode.IsIntegerSql(mytype))                          {                              if (StorageType.Single == storageType)                              {                                  return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Double == storageType)                              {                                  return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Decimal == storageType)                              {                                  return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider);                              }                              return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                          }                            return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                      }                        return argumentValues[0];                    case FunctionId.DateTimeOffset:                      if (argumentValues[0] == DBNull.Value || argumentValues[1] == DBNull.Value || argumentValues[2] == DBNull.Value)                          return DBNull.Value;                      switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }                      if ((int)argumentValues[1] < -14 || (int)argumentValues[1] > 14)                          throw ExprException.InvalidHoursArgument();                      if ((int)argumentValues[2] < -59 || (int)argumentValues[2] > 59)                          throw ExprException.InvalidMinutesArgument();                      // range should be within -14 hours and  +14 hours                      if ((int)argumentValues[1] == 14 && (int)argumentValues[2] > 0)                          throw ExprException.InvalidTimeZoneRange();                      if ((int)argumentValues[1] == -14 && (int)argumentValues[2] < 0)                          throw ExprException.InvalidTimeZoneRange();                        return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0));                    default:                      throw ExprException.UndefinedFunction(s_funcs[_info]._name);              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following statement contains a magic number: switch (id)              {                  case FunctionId.Abs:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      if (ExpressionNode.IsInteger(storageType))                          return (Math.Abs((long)argumentValues[0]));                      if (ExpressionNode.IsNumeric(storageType))                          return (Math.Abs((double)argumentValues[0]));                        throw ExprException.ArgumentTypeInteger(s_funcs[_info]._name' 1);                    case FunctionId.cBool:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      switch (storageType)                      {                          case StorageType.Boolean:                              return (bool)argumentValues[0];                          case StorageType.Int32:                              return ((int)argumentValues[0] != 0);                          case StorageType.Double:                              return ((double)argumentValues[0] != 0.0);                          case StorageType.String:                              return bool.Parse((string)argumentValues[0]);                          default:                              throw ExprException.DatatypeConvertion(argumentValues[0].GetType()' typeof(bool));                      }                    case FunctionId.cInt:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToInt32(argumentValues[0]' FormatProvider);                    case FunctionId.cDate:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDateTime(argumentValues[0]' FormatProvider);                    case FunctionId.cDbl:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDouble(argumentValues[0]' FormatProvider);                    case FunctionId.cStr:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToString(argumentValues[0]' FormatProvider);                    case FunctionId.Charindex:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        Debug.Assert(argumentValues[0] is string' "Invalid argument type for " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is string' "Invalid argument type for " + s_funcs[_info]._name);                        if (DataStorage.IsObjectNull(argumentValues[0]) || DataStorage.IsObjectNull(argumentValues[1]))                          return DBNull.Value;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        if (argumentValues[1] is SqlString)                          argumentValues[1] = ((SqlString)argumentValues[1]).Value;                        return ((string)argumentValues[1]).IndexOf((string)argumentValues[0]' StringComparison.Ordinal);                    case FunctionId.Iif:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                        object first = _arguments[0].Eval(row' version);                        if (DataExpression.ToBoolean(first) != false)                      {                          return _arguments[1].Eval(row' version);                      }                      else                      {                          return _arguments[2].Eval(row' version);                      }                    case FunctionId.In:                      // we never evaluate IN directly: IN as a binary operator' so evaluation of this should be in                      // BinaryNode class                      throw ExprException.NYI(s_funcs[_info]._name);                    case FunctionId.IsNull:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount: ");                        if (DataStorage.IsObjectNull(argumentValues[0]))                          return argumentValues[1];                      else                          return argumentValues[0];                    case FunctionId.Len:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                        if (argumentValues[0] is SqlString)                      {                          if (((SqlString)argumentValues[0]).IsNull)                          {                              return DBNull.Value;                          }                          else                          {                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                          }                      }                        return ((string)argumentValues[0]).Length;                      case FunctionId.Substring:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name);                        // work around the differences in .NET and VBA implementation of the Substring function                      // 1. The <index> Argument is 0-based in .NET' and 1-based in VBA                      // 2. If the <Length> argument is longer then the string length .NET throws an ArgumentException                      //    but our users still want to get a result.                        int start = (int)argumentValues[1] - 1;                        int length = (int)argumentValues[2];                        if (start < 0)                          throw ExprException.FunctionArgumentOutOfRange("index"' "Substring");                        if (length < 0)                          throw ExprException.FunctionArgumentOutOfRange("length"' "Substring");                        if (length == 0)                          return string.Empty;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        int src_length = ((string)argumentValues[0]).Length;                        if (start > src_length)                      {                          return DBNull.Value;                      }                        if (start + length > src_length)                      {                          length = src_length - start;                      }                        return ((string)argumentValues[0]).Substring(start' length);                    case FunctionId.Trim:                      {                          Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                          Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                            if (DataStorage.IsObjectNull(argumentValues[0]))                              return DBNull.Value;                            if (argumentValues[0] is SqlString)                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                            return (((string)argumentValues[0]).Trim());                      }                    case FunctionId.Convert:                      if (_argumentCount != 2)                          throw ExprException.FunctionArgumentCount(_name);                        if (argumentValues[0] == DBNull.Value)                      {                          return DBNull.Value;                      }                        Type type = (Type)argumentValues[1];                      StorageType mytype = DataStorage.GetStorageType(type);                      storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                        if (mytype == StorageType.DateTimeOffset)                      {                          if (storageType == StorageType.String)                          {                              return SqlConvert.ConvertStringToDateTimeOffset((string)argumentValues[0]' FormatProvider);                          }                      }                        if (StorageType.Object != mytype)                      {                          if ((mytype == StorageType.Guid) && (storageType == StorageType.String))                              return new Guid((string)argumentValues[0]);                            if (ExpressionNode.IsFloatSql(storageType) && ExpressionNode.IsIntegerSql(mytype))                          {                              if (StorageType.Single == storageType)                              {                                  return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Double == storageType)                              {                                  return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Decimal == storageType)                              {                                  return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider);                              }                              return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                          }                            return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                      }                        return argumentValues[0];                    case FunctionId.DateTimeOffset:                      if (argumentValues[0] == DBNull.Value || argumentValues[1] == DBNull.Value || argumentValues[2] == DBNull.Value)                          return DBNull.Value;                      switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }                      if ((int)argumentValues[1] < -14 || (int)argumentValues[1] > 14)                          throw ExprException.InvalidHoursArgument();                      if ((int)argumentValues[2] < -59 || (int)argumentValues[2] > 59)                          throw ExprException.InvalidMinutesArgument();                      // range should be within -14 hours and  +14 hours                      if ((int)argumentValues[1] == 14 && (int)argumentValues[2] > 0)                          throw ExprException.InvalidTimeZoneRange();                      if ((int)argumentValues[1] == -14 && (int)argumentValues[2] < 0)                          throw ExprException.InvalidTimeZoneRange();                        return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0));                    default:                      throw ExprException.UndefinedFunction(s_funcs[_info]._name);              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following statement contains a magic number: switch (id)              {                  case FunctionId.Abs:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      if (ExpressionNode.IsInteger(storageType))                          return (Math.Abs((long)argumentValues[0]));                      if (ExpressionNode.IsNumeric(storageType))                          return (Math.Abs((double)argumentValues[0]));                        throw ExprException.ArgumentTypeInteger(s_funcs[_info]._name' 1);                    case FunctionId.cBool:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      switch (storageType)                      {                          case StorageType.Boolean:                              return (bool)argumentValues[0];                          case StorageType.Int32:                              return ((int)argumentValues[0] != 0);                          case StorageType.Double:                              return ((double)argumentValues[0] != 0.0);                          case StorageType.String:                              return bool.Parse((string)argumentValues[0]);                          default:                              throw ExprException.DatatypeConvertion(argumentValues[0].GetType()' typeof(bool));                      }                    case FunctionId.cInt:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToInt32(argumentValues[0]' FormatProvider);                    case FunctionId.cDate:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDateTime(argumentValues[0]' FormatProvider);                    case FunctionId.cDbl:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDouble(argumentValues[0]' FormatProvider);                    case FunctionId.cStr:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToString(argumentValues[0]' FormatProvider);                    case FunctionId.Charindex:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        Debug.Assert(argumentValues[0] is string' "Invalid argument type for " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is string' "Invalid argument type for " + s_funcs[_info]._name);                        if (DataStorage.IsObjectNull(argumentValues[0]) || DataStorage.IsObjectNull(argumentValues[1]))                          return DBNull.Value;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        if (argumentValues[1] is SqlString)                          argumentValues[1] = ((SqlString)argumentValues[1]).Value;                        return ((string)argumentValues[1]).IndexOf((string)argumentValues[0]' StringComparison.Ordinal);                    case FunctionId.Iif:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                        object first = _arguments[0].Eval(row' version);                        if (DataExpression.ToBoolean(first) != false)                      {                          return _arguments[1].Eval(row' version);                      }                      else                      {                          return _arguments[2].Eval(row' version);                      }                    case FunctionId.In:                      // we never evaluate IN directly: IN as a binary operator' so evaluation of this should be in                      // BinaryNode class                      throw ExprException.NYI(s_funcs[_info]._name);                    case FunctionId.IsNull:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount: ");                        if (DataStorage.IsObjectNull(argumentValues[0]))                          return argumentValues[1];                      else                          return argumentValues[0];                    case FunctionId.Len:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                        if (argumentValues[0] is SqlString)                      {                          if (((SqlString)argumentValues[0]).IsNull)                          {                              return DBNull.Value;                          }                          else                          {                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                          }                      }                        return ((string)argumentValues[0]).Length;                      case FunctionId.Substring:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name);                        // work around the differences in .NET and VBA implementation of the Substring function                      // 1. The <index> Argument is 0-based in .NET' and 1-based in VBA                      // 2. If the <Length> argument is longer then the string length .NET throws an ArgumentException                      //    but our users still want to get a result.                        int start = (int)argumentValues[1] - 1;                        int length = (int)argumentValues[2];                        if (start < 0)                          throw ExprException.FunctionArgumentOutOfRange("index"' "Substring");                        if (length < 0)                          throw ExprException.FunctionArgumentOutOfRange("length"' "Substring");                        if (length == 0)                          return string.Empty;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        int src_length = ((string)argumentValues[0]).Length;                        if (start > src_length)                      {                          return DBNull.Value;                      }                        if (start + length > src_length)                      {                          length = src_length - start;                      }                        return ((string)argumentValues[0]).Substring(start' length);                    case FunctionId.Trim:                      {                          Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                          Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                            if (DataStorage.IsObjectNull(argumentValues[0]))                              return DBNull.Value;                            if (argumentValues[0] is SqlString)                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                            return (((string)argumentValues[0]).Trim());                      }                    case FunctionId.Convert:                      if (_argumentCount != 2)                          throw ExprException.FunctionArgumentCount(_name);                        if (argumentValues[0] == DBNull.Value)                      {                          return DBNull.Value;                      }                        Type type = (Type)argumentValues[1];                      StorageType mytype = DataStorage.GetStorageType(type);                      storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                        if (mytype == StorageType.DateTimeOffset)                      {                          if (storageType == StorageType.String)                          {                              return SqlConvert.ConvertStringToDateTimeOffset((string)argumentValues[0]' FormatProvider);                          }                      }                        if (StorageType.Object != mytype)                      {                          if ((mytype == StorageType.Guid) && (storageType == StorageType.String))                              return new Guid((string)argumentValues[0]);                            if (ExpressionNode.IsFloatSql(storageType) && ExpressionNode.IsIntegerSql(mytype))                          {                              if (StorageType.Single == storageType)                              {                                  return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Double == storageType)                              {                                  return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Decimal == storageType)                              {                                  return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider);                              }                              return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                          }                            return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                      }                        return argumentValues[0];                    case FunctionId.DateTimeOffset:                      if (argumentValues[0] == DBNull.Value || argumentValues[1] == DBNull.Value || argumentValues[2] == DBNull.Value)                          return DBNull.Value;                      switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }                      if ((int)argumentValues[1] < -14 || (int)argumentValues[1] > 14)                          throw ExprException.InvalidHoursArgument();                      if ((int)argumentValues[2] < -59 || (int)argumentValues[2] > 59)                          throw ExprException.InvalidMinutesArgument();                      // range should be within -14 hours and  +14 hours                      if ((int)argumentValues[1] == 14 && (int)argumentValues[2] > 0)                          throw ExprException.InvalidTimeZoneRange();                      if ((int)argumentValues[1] == -14 && (int)argumentValues[2] < 0)                          throw ExprException.InvalidTimeZoneRange();                        return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0));                    default:                      throw ExprException.UndefinedFunction(s_funcs[_info]._name);              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following statement contains a magic number: switch (id)              {                  case FunctionId.Abs:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      if (ExpressionNode.IsInteger(storageType))                          return (Math.Abs((long)argumentValues[0]));                      if (ExpressionNode.IsNumeric(storageType))                          return (Math.Abs((double)argumentValues[0]));                        throw ExprException.ArgumentTypeInteger(s_funcs[_info]._name' 1);                    case FunctionId.cBool:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      switch (storageType)                      {                          case StorageType.Boolean:                              return (bool)argumentValues[0];                          case StorageType.Int32:                              return ((int)argumentValues[0] != 0);                          case StorageType.Double:                              return ((double)argumentValues[0] != 0.0);                          case StorageType.String:                              return bool.Parse((string)argumentValues[0]);                          default:                              throw ExprException.DatatypeConvertion(argumentValues[0].GetType()' typeof(bool));                      }                    case FunctionId.cInt:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToInt32(argumentValues[0]' FormatProvider);                    case FunctionId.cDate:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDateTime(argumentValues[0]' FormatProvider);                    case FunctionId.cDbl:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDouble(argumentValues[0]' FormatProvider);                    case FunctionId.cStr:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToString(argumentValues[0]' FormatProvider);                    case FunctionId.Charindex:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        Debug.Assert(argumentValues[0] is string' "Invalid argument type for " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is string' "Invalid argument type for " + s_funcs[_info]._name);                        if (DataStorage.IsObjectNull(argumentValues[0]) || DataStorage.IsObjectNull(argumentValues[1]))                          return DBNull.Value;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        if (argumentValues[1] is SqlString)                          argumentValues[1] = ((SqlString)argumentValues[1]).Value;                        return ((string)argumentValues[1]).IndexOf((string)argumentValues[0]' StringComparison.Ordinal);                    case FunctionId.Iif:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                        object first = _arguments[0].Eval(row' version);                        if (DataExpression.ToBoolean(first) != false)                      {                          return _arguments[1].Eval(row' version);                      }                      else                      {                          return _arguments[2].Eval(row' version);                      }                    case FunctionId.In:                      // we never evaluate IN directly: IN as a binary operator' so evaluation of this should be in                      // BinaryNode class                      throw ExprException.NYI(s_funcs[_info]._name);                    case FunctionId.IsNull:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount: ");                        if (DataStorage.IsObjectNull(argumentValues[0]))                          return argumentValues[1];                      else                          return argumentValues[0];                    case FunctionId.Len:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                        if (argumentValues[0] is SqlString)                      {                          if (((SqlString)argumentValues[0]).IsNull)                          {                              return DBNull.Value;                          }                          else                          {                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                          }                      }                        return ((string)argumentValues[0]).Length;                      case FunctionId.Substring:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name);                        // work around the differences in .NET and VBA implementation of the Substring function                      // 1. The <index> Argument is 0-based in .NET' and 1-based in VBA                      // 2. If the <Length> argument is longer then the string length .NET throws an ArgumentException                      //    but our users still want to get a result.                        int start = (int)argumentValues[1] - 1;                        int length = (int)argumentValues[2];                        if (start < 0)                          throw ExprException.FunctionArgumentOutOfRange("index"' "Substring");                        if (length < 0)                          throw ExprException.FunctionArgumentOutOfRange("length"' "Substring");                        if (length == 0)                          return string.Empty;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        int src_length = ((string)argumentValues[0]).Length;                        if (start > src_length)                      {                          return DBNull.Value;                      }                        if (start + length > src_length)                      {                          length = src_length - start;                      }                        return ((string)argumentValues[0]).Substring(start' length);                    case FunctionId.Trim:                      {                          Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                          Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                            if (DataStorage.IsObjectNull(argumentValues[0]))                              return DBNull.Value;                            if (argumentValues[0] is SqlString)                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                            return (((string)argumentValues[0]).Trim());                      }                    case FunctionId.Convert:                      if (_argumentCount != 2)                          throw ExprException.FunctionArgumentCount(_name);                        if (argumentValues[0] == DBNull.Value)                      {                          return DBNull.Value;                      }                        Type type = (Type)argumentValues[1];                      StorageType mytype = DataStorage.GetStorageType(type);                      storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                        if (mytype == StorageType.DateTimeOffset)                      {                          if (storageType == StorageType.String)                          {                              return SqlConvert.ConvertStringToDateTimeOffset((string)argumentValues[0]' FormatProvider);                          }                      }                        if (StorageType.Object != mytype)                      {                          if ((mytype == StorageType.Guid) && (storageType == StorageType.String))                              return new Guid((string)argumentValues[0]);                            if (ExpressionNode.IsFloatSql(storageType) && ExpressionNode.IsIntegerSql(mytype))                          {                              if (StorageType.Single == storageType)                              {                                  return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Double == storageType)                              {                                  return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Decimal == storageType)                              {                                  return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider);                              }                              return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                          }                            return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                      }                        return argumentValues[0];                    case FunctionId.DateTimeOffset:                      if (argumentValues[0] == DBNull.Value || argumentValues[1] == DBNull.Value || argumentValues[2] == DBNull.Value)                          return DBNull.Value;                      switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }                      if ((int)argumentValues[1] < -14 || (int)argumentValues[1] > 14)                          throw ExprException.InvalidHoursArgument();                      if ((int)argumentValues[2] < -59 || (int)argumentValues[2] > 59)                          throw ExprException.InvalidMinutesArgument();                      // range should be within -14 hours and  +14 hours                      if ((int)argumentValues[1] == 14 && (int)argumentValues[2] > 0)                          throw ExprException.InvalidTimeZoneRange();                      if ((int)argumentValues[1] == -14 && (int)argumentValues[2] < 0)                          throw ExprException.InvalidTimeZoneRange();                        return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0));                    default:                      throw ExprException.UndefinedFunction(s_funcs[_info]._name);              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following statement contains a magic number: switch (id)              {                  case FunctionId.Abs:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      if (ExpressionNode.IsInteger(storageType))                          return (Math.Abs((long)argumentValues[0]));                      if (ExpressionNode.IsNumeric(storageType))                          return (Math.Abs((double)argumentValues[0]));                        throw ExprException.ArgumentTypeInteger(s_funcs[_info]._name' 1);                    case FunctionId.cBool:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      switch (storageType)                      {                          case StorageType.Boolean:                              return (bool)argumentValues[0];                          case StorageType.Int32:                              return ((int)argumentValues[0] != 0);                          case StorageType.Double:                              return ((double)argumentValues[0] != 0.0);                          case StorageType.String:                              return bool.Parse((string)argumentValues[0]);                          default:                              throw ExprException.DatatypeConvertion(argumentValues[0].GetType()' typeof(bool));                      }                    case FunctionId.cInt:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToInt32(argumentValues[0]' FormatProvider);                    case FunctionId.cDate:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDateTime(argumentValues[0]' FormatProvider);                    case FunctionId.cDbl:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDouble(argumentValues[0]' FormatProvider);                    case FunctionId.cStr:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToString(argumentValues[0]' FormatProvider);                    case FunctionId.Charindex:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        Debug.Assert(argumentValues[0] is string' "Invalid argument type for " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is string' "Invalid argument type for " + s_funcs[_info]._name);                        if (DataStorage.IsObjectNull(argumentValues[0]) || DataStorage.IsObjectNull(argumentValues[1]))                          return DBNull.Value;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        if (argumentValues[1] is SqlString)                          argumentValues[1] = ((SqlString)argumentValues[1]).Value;                        return ((string)argumentValues[1]).IndexOf((string)argumentValues[0]' StringComparison.Ordinal);                    case FunctionId.Iif:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                        object first = _arguments[0].Eval(row' version);                        if (DataExpression.ToBoolean(first) != false)                      {                          return _arguments[1].Eval(row' version);                      }                      else                      {                          return _arguments[2].Eval(row' version);                      }                    case FunctionId.In:                      // we never evaluate IN directly: IN as a binary operator' so evaluation of this should be in                      // BinaryNode class                      throw ExprException.NYI(s_funcs[_info]._name);                    case FunctionId.IsNull:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount: ");                        if (DataStorage.IsObjectNull(argumentValues[0]))                          return argumentValues[1];                      else                          return argumentValues[0];                    case FunctionId.Len:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                        if (argumentValues[0] is SqlString)                      {                          if (((SqlString)argumentValues[0]).IsNull)                          {                              return DBNull.Value;                          }                          else                          {                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                          }                      }                        return ((string)argumentValues[0]).Length;                      case FunctionId.Substring:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name);                        // work around the differences in .NET and VBA implementation of the Substring function                      // 1. The <index> Argument is 0-based in .NET' and 1-based in VBA                      // 2. If the <Length> argument is longer then the string length .NET throws an ArgumentException                      //    but our users still want to get a result.                        int start = (int)argumentValues[1] - 1;                        int length = (int)argumentValues[2];                        if (start < 0)                          throw ExprException.FunctionArgumentOutOfRange("index"' "Substring");                        if (length < 0)                          throw ExprException.FunctionArgumentOutOfRange("length"' "Substring");                        if (length == 0)                          return string.Empty;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        int src_length = ((string)argumentValues[0]).Length;                        if (start > src_length)                      {                          return DBNull.Value;                      }                        if (start + length > src_length)                      {                          length = src_length - start;                      }                        return ((string)argumentValues[0]).Substring(start' length);                    case FunctionId.Trim:                      {                          Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                          Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                            if (DataStorage.IsObjectNull(argumentValues[0]))                              return DBNull.Value;                            if (argumentValues[0] is SqlString)                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                            return (((string)argumentValues[0]).Trim());                      }                    case FunctionId.Convert:                      if (_argumentCount != 2)                          throw ExprException.FunctionArgumentCount(_name);                        if (argumentValues[0] == DBNull.Value)                      {                          return DBNull.Value;                      }                        Type type = (Type)argumentValues[1];                      StorageType mytype = DataStorage.GetStorageType(type);                      storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                        if (mytype == StorageType.DateTimeOffset)                      {                          if (storageType == StorageType.String)                          {                              return SqlConvert.ConvertStringToDateTimeOffset((string)argumentValues[0]' FormatProvider);                          }                      }                        if (StorageType.Object != mytype)                      {                          if ((mytype == StorageType.Guid) && (storageType == StorageType.String))                              return new Guid((string)argumentValues[0]);                            if (ExpressionNode.IsFloatSql(storageType) && ExpressionNode.IsIntegerSql(mytype))                          {                              if (StorageType.Single == storageType)                              {                                  return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Double == storageType)                              {                                  return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Decimal == storageType)                              {                                  return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider);                              }                              return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                          }                            return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                      }                        return argumentValues[0];                    case FunctionId.DateTimeOffset:                      if (argumentValues[0] == DBNull.Value || argumentValues[1] == DBNull.Value || argumentValues[2] == DBNull.Value)                          return DBNull.Value;                      switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }                      if ((int)argumentValues[1] < -14 || (int)argumentValues[1] > 14)                          throw ExprException.InvalidHoursArgument();                      if ((int)argumentValues[2] < -59 || (int)argumentValues[2] > 59)                          throw ExprException.InvalidMinutesArgument();                      // range should be within -14 hours and  +14 hours                      if ((int)argumentValues[1] == 14 && (int)argumentValues[2] > 0)                          throw ExprException.InvalidTimeZoneRange();                      if ((int)argumentValues[1] == -14 && (int)argumentValues[2] < 0)                          throw ExprException.InvalidTimeZoneRange();                        return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0));                    default:                      throw ExprException.UndefinedFunction(s_funcs[_info]._name);              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following statement contains a magic number: switch (id)              {                  case FunctionId.Abs:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      if (ExpressionNode.IsInteger(storageType))                          return (Math.Abs((long)argumentValues[0]));                      if (ExpressionNode.IsNumeric(storageType))                          return (Math.Abs((double)argumentValues[0]));                        throw ExprException.ArgumentTypeInteger(s_funcs[_info]._name' 1);                    case FunctionId.cBool:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      switch (storageType)                      {                          case StorageType.Boolean:                              return (bool)argumentValues[0];                          case StorageType.Int32:                              return ((int)argumentValues[0] != 0);                          case StorageType.Double:                              return ((double)argumentValues[0] != 0.0);                          case StorageType.String:                              return bool.Parse((string)argumentValues[0]);                          default:                              throw ExprException.DatatypeConvertion(argumentValues[0].GetType()' typeof(bool));                      }                    case FunctionId.cInt:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToInt32(argumentValues[0]' FormatProvider);                    case FunctionId.cDate:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDateTime(argumentValues[0]' FormatProvider);                    case FunctionId.cDbl:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDouble(argumentValues[0]' FormatProvider);                    case FunctionId.cStr:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToString(argumentValues[0]' FormatProvider);                    case FunctionId.Charindex:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        Debug.Assert(argumentValues[0] is string' "Invalid argument type for " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is string' "Invalid argument type for " + s_funcs[_info]._name);                        if (DataStorage.IsObjectNull(argumentValues[0]) || DataStorage.IsObjectNull(argumentValues[1]))                          return DBNull.Value;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        if (argumentValues[1] is SqlString)                          argumentValues[1] = ((SqlString)argumentValues[1]).Value;                        return ((string)argumentValues[1]).IndexOf((string)argumentValues[0]' StringComparison.Ordinal);                    case FunctionId.Iif:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                        object first = _arguments[0].Eval(row' version);                        if (DataExpression.ToBoolean(first) != false)                      {                          return _arguments[1].Eval(row' version);                      }                      else                      {                          return _arguments[2].Eval(row' version);                      }                    case FunctionId.In:                      // we never evaluate IN directly: IN as a binary operator' so evaluation of this should be in                      // BinaryNode class                      throw ExprException.NYI(s_funcs[_info]._name);                    case FunctionId.IsNull:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount: ");                        if (DataStorage.IsObjectNull(argumentValues[0]))                          return argumentValues[1];                      else                          return argumentValues[0];                    case FunctionId.Len:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                        if (argumentValues[0] is SqlString)                      {                          if (((SqlString)argumentValues[0]).IsNull)                          {                              return DBNull.Value;                          }                          else                          {                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                          }                      }                        return ((string)argumentValues[0]).Length;                      case FunctionId.Substring:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name);                        // work around the differences in .NET and VBA implementation of the Substring function                      // 1. The <index> Argument is 0-based in .NET' and 1-based in VBA                      // 2. If the <Length> argument is longer then the string length .NET throws an ArgumentException                      //    but our users still want to get a result.                        int start = (int)argumentValues[1] - 1;                        int length = (int)argumentValues[2];                        if (start < 0)                          throw ExprException.FunctionArgumentOutOfRange("index"' "Substring");                        if (length < 0)                          throw ExprException.FunctionArgumentOutOfRange("length"' "Substring");                        if (length == 0)                          return string.Empty;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        int src_length = ((string)argumentValues[0]).Length;                        if (start > src_length)                      {                          return DBNull.Value;                      }                        if (start + length > src_length)                      {                          length = src_length - start;                      }                        return ((string)argumentValues[0]).Substring(start' length);                    case FunctionId.Trim:                      {                          Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                          Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                            if (DataStorage.IsObjectNull(argumentValues[0]))                              return DBNull.Value;                            if (argumentValues[0] is SqlString)                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                            return (((string)argumentValues[0]).Trim());                      }                    case FunctionId.Convert:                      if (_argumentCount != 2)                          throw ExprException.FunctionArgumentCount(_name);                        if (argumentValues[0] == DBNull.Value)                      {                          return DBNull.Value;                      }                        Type type = (Type)argumentValues[1];                      StorageType mytype = DataStorage.GetStorageType(type);                      storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                        if (mytype == StorageType.DateTimeOffset)                      {                          if (storageType == StorageType.String)                          {                              return SqlConvert.ConvertStringToDateTimeOffset((string)argumentValues[0]' FormatProvider);                          }                      }                        if (StorageType.Object != mytype)                      {                          if ((mytype == StorageType.Guid) && (storageType == StorageType.String))                              return new Guid((string)argumentValues[0]);                            if (ExpressionNode.IsFloatSql(storageType) && ExpressionNode.IsIntegerSql(mytype))                          {                              if (StorageType.Single == storageType)                              {                                  return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Double == storageType)                              {                                  return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Decimal == storageType)                              {                                  return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider);                              }                              return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                          }                            return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                      }                        return argumentValues[0];                    case FunctionId.DateTimeOffset:                      if (argumentValues[0] == DBNull.Value || argumentValues[1] == DBNull.Value || argumentValues[2] == DBNull.Value)                          return DBNull.Value;                      switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }                      if ((int)argumentValues[1] < -14 || (int)argumentValues[1] > 14)                          throw ExprException.InvalidHoursArgument();                      if ((int)argumentValues[2] < -59 || (int)argumentValues[2] > 59)                          throw ExprException.InvalidMinutesArgument();                      // range should be within -14 hours and  +14 hours                      if ((int)argumentValues[1] == 14 && (int)argumentValues[2] > 0)                          throw ExprException.InvalidTimeZoneRange();                      if ((int)argumentValues[1] == -14 && (int)argumentValues[2] < 0)                          throw ExprException.InvalidTimeZoneRange();                        return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0));                    default:                      throw ExprException.UndefinedFunction(s_funcs[_info]._name);              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following statement contains a magic number: switch (id)              {                  case FunctionId.Abs:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      if (ExpressionNode.IsInteger(storageType))                          return (Math.Abs((long)argumentValues[0]));                      if (ExpressionNode.IsNumeric(storageType))                          return (Math.Abs((double)argumentValues[0]));                        throw ExprException.ArgumentTypeInteger(s_funcs[_info]._name' 1);                    case FunctionId.cBool:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      switch (storageType)                      {                          case StorageType.Boolean:                              return (bool)argumentValues[0];                          case StorageType.Int32:                              return ((int)argumentValues[0] != 0);                          case StorageType.Double:                              return ((double)argumentValues[0] != 0.0);                          case StorageType.String:                              return bool.Parse((string)argumentValues[0]);                          default:                              throw ExprException.DatatypeConvertion(argumentValues[0].GetType()' typeof(bool));                      }                    case FunctionId.cInt:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToInt32(argumentValues[0]' FormatProvider);                    case FunctionId.cDate:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDateTime(argumentValues[0]' FormatProvider);                    case FunctionId.cDbl:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDouble(argumentValues[0]' FormatProvider);                    case FunctionId.cStr:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToString(argumentValues[0]' FormatProvider);                    case FunctionId.Charindex:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        Debug.Assert(argumentValues[0] is string' "Invalid argument type for " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is string' "Invalid argument type for " + s_funcs[_info]._name);                        if (DataStorage.IsObjectNull(argumentValues[0]) || DataStorage.IsObjectNull(argumentValues[1]))                          return DBNull.Value;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        if (argumentValues[1] is SqlString)                          argumentValues[1] = ((SqlString)argumentValues[1]).Value;                        return ((string)argumentValues[1]).IndexOf((string)argumentValues[0]' StringComparison.Ordinal);                    case FunctionId.Iif:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                        object first = _arguments[0].Eval(row' version);                        if (DataExpression.ToBoolean(first) != false)                      {                          return _arguments[1].Eval(row' version);                      }                      else                      {                          return _arguments[2].Eval(row' version);                      }                    case FunctionId.In:                      // we never evaluate IN directly: IN as a binary operator' so evaluation of this should be in                      // BinaryNode class                      throw ExprException.NYI(s_funcs[_info]._name);                    case FunctionId.IsNull:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount: ");                        if (DataStorage.IsObjectNull(argumentValues[0]))                          return argumentValues[1];                      else                          return argumentValues[0];                    case FunctionId.Len:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                        if (argumentValues[0] is SqlString)                      {                          if (((SqlString)argumentValues[0]).IsNull)                          {                              return DBNull.Value;                          }                          else                          {                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                          }                      }                        return ((string)argumentValues[0]).Length;                      case FunctionId.Substring:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name);                        // work around the differences in .NET and VBA implementation of the Substring function                      // 1. The <index> Argument is 0-based in .NET' and 1-based in VBA                      // 2. If the <Length> argument is longer then the string length .NET throws an ArgumentException                      //    but our users still want to get a result.                        int start = (int)argumentValues[1] - 1;                        int length = (int)argumentValues[2];                        if (start < 0)                          throw ExprException.FunctionArgumentOutOfRange("index"' "Substring");                        if (length < 0)                          throw ExprException.FunctionArgumentOutOfRange("length"' "Substring");                        if (length == 0)                          return string.Empty;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        int src_length = ((string)argumentValues[0]).Length;                        if (start > src_length)                      {                          return DBNull.Value;                      }                        if (start + length > src_length)                      {                          length = src_length - start;                      }                        return ((string)argumentValues[0]).Substring(start' length);                    case FunctionId.Trim:                      {                          Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                          Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                            if (DataStorage.IsObjectNull(argumentValues[0]))                              return DBNull.Value;                            if (argumentValues[0] is SqlString)                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                            return (((string)argumentValues[0]).Trim());                      }                    case FunctionId.Convert:                      if (_argumentCount != 2)                          throw ExprException.FunctionArgumentCount(_name);                        if (argumentValues[0] == DBNull.Value)                      {                          return DBNull.Value;                      }                        Type type = (Type)argumentValues[1];                      StorageType mytype = DataStorage.GetStorageType(type);                      storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                        if (mytype == StorageType.DateTimeOffset)                      {                          if (storageType == StorageType.String)                          {                              return SqlConvert.ConvertStringToDateTimeOffset((string)argumentValues[0]' FormatProvider);                          }                      }                        if (StorageType.Object != mytype)                      {                          if ((mytype == StorageType.Guid) && (storageType == StorageType.String))                              return new Guid((string)argumentValues[0]);                            if (ExpressionNode.IsFloatSql(storageType) && ExpressionNode.IsIntegerSql(mytype))                          {                              if (StorageType.Single == storageType)                              {                                  return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Double == storageType)                              {                                  return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Decimal == storageType)                              {                                  return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider);                              }                              return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                          }                            return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                      }                        return argumentValues[0];                    case FunctionId.DateTimeOffset:                      if (argumentValues[0] == DBNull.Value || argumentValues[1] == DBNull.Value || argumentValues[2] == DBNull.Value)                          return DBNull.Value;                      switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }                      if ((int)argumentValues[1] < -14 || (int)argumentValues[1] > 14)                          throw ExprException.InvalidHoursArgument();                      if ((int)argumentValues[2] < -59 || (int)argumentValues[2] > 59)                          throw ExprException.InvalidMinutesArgument();                      // range should be within -14 hours and  +14 hours                      if ((int)argumentValues[1] == 14 && (int)argumentValues[2] > 0)                          throw ExprException.InvalidTimeZoneRange();                      if ((int)argumentValues[1] == -14 && (int)argumentValues[2] < 0)                          throw ExprException.InvalidTimeZoneRange();                        return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0));                    default:                      throw ExprException.UndefinedFunction(s_funcs[_info]._name);              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following statement contains a magic number: switch (id)              {                  case FunctionId.Abs:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      if (ExpressionNode.IsInteger(storageType))                          return (Math.Abs((long)argumentValues[0]));                      if (ExpressionNode.IsNumeric(storageType))                          return (Math.Abs((double)argumentValues[0]));                        throw ExprException.ArgumentTypeInteger(s_funcs[_info]._name' 1);                    case FunctionId.cBool:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      switch (storageType)                      {                          case StorageType.Boolean:                              return (bool)argumentValues[0];                          case StorageType.Int32:                              return ((int)argumentValues[0] != 0);                          case StorageType.Double:                              return ((double)argumentValues[0] != 0.0);                          case StorageType.String:                              return bool.Parse((string)argumentValues[0]);                          default:                              throw ExprException.DatatypeConvertion(argumentValues[0].GetType()' typeof(bool));                      }                    case FunctionId.cInt:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToInt32(argumentValues[0]' FormatProvider);                    case FunctionId.cDate:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDateTime(argumentValues[0]' FormatProvider);                    case FunctionId.cDbl:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDouble(argumentValues[0]' FormatProvider);                    case FunctionId.cStr:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToString(argumentValues[0]' FormatProvider);                    case FunctionId.Charindex:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        Debug.Assert(argumentValues[0] is string' "Invalid argument type for " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is string' "Invalid argument type for " + s_funcs[_info]._name);                        if (DataStorage.IsObjectNull(argumentValues[0]) || DataStorage.IsObjectNull(argumentValues[1]))                          return DBNull.Value;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        if (argumentValues[1] is SqlString)                          argumentValues[1] = ((SqlString)argumentValues[1]).Value;                        return ((string)argumentValues[1]).IndexOf((string)argumentValues[0]' StringComparison.Ordinal);                    case FunctionId.Iif:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                        object first = _arguments[0].Eval(row' version);                        if (DataExpression.ToBoolean(first) != false)                      {                          return _arguments[1].Eval(row' version);                      }                      else                      {                          return _arguments[2].Eval(row' version);                      }                    case FunctionId.In:                      // we never evaluate IN directly: IN as a binary operator' so evaluation of this should be in                      // BinaryNode class                      throw ExprException.NYI(s_funcs[_info]._name);                    case FunctionId.IsNull:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount: ");                        if (DataStorage.IsObjectNull(argumentValues[0]))                          return argumentValues[1];                      else                          return argumentValues[0];                    case FunctionId.Len:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                        if (argumentValues[0] is SqlString)                      {                          if (((SqlString)argumentValues[0]).IsNull)                          {                              return DBNull.Value;                          }                          else                          {                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                          }                      }                        return ((string)argumentValues[0]).Length;                      case FunctionId.Substring:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name);                        // work around the differences in .NET and VBA implementation of the Substring function                      // 1. The <index> Argument is 0-based in .NET' and 1-based in VBA                      // 2. If the <Length> argument is longer then the string length .NET throws an ArgumentException                      //    but our users still want to get a result.                        int start = (int)argumentValues[1] - 1;                        int length = (int)argumentValues[2];                        if (start < 0)                          throw ExprException.FunctionArgumentOutOfRange("index"' "Substring");                        if (length < 0)                          throw ExprException.FunctionArgumentOutOfRange("length"' "Substring");                        if (length == 0)                          return string.Empty;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        int src_length = ((string)argumentValues[0]).Length;                        if (start > src_length)                      {                          return DBNull.Value;                      }                        if (start + length > src_length)                      {                          length = src_length - start;                      }                        return ((string)argumentValues[0]).Substring(start' length);                    case FunctionId.Trim:                      {                          Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                          Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                            if (DataStorage.IsObjectNull(argumentValues[0]))                              return DBNull.Value;                            if (argumentValues[0] is SqlString)                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                            return (((string)argumentValues[0]).Trim());                      }                    case FunctionId.Convert:                      if (_argumentCount != 2)                          throw ExprException.FunctionArgumentCount(_name);                        if (argumentValues[0] == DBNull.Value)                      {                          return DBNull.Value;                      }                        Type type = (Type)argumentValues[1];                      StorageType mytype = DataStorage.GetStorageType(type);                      storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                        if (mytype == StorageType.DateTimeOffset)                      {                          if (storageType == StorageType.String)                          {                              return SqlConvert.ConvertStringToDateTimeOffset((string)argumentValues[0]' FormatProvider);                          }                      }                        if (StorageType.Object != mytype)                      {                          if ((mytype == StorageType.Guid) && (storageType == StorageType.String))                              return new Guid((string)argumentValues[0]);                            if (ExpressionNode.IsFloatSql(storageType) && ExpressionNode.IsIntegerSql(mytype))                          {                              if (StorageType.Single == storageType)                              {                                  return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Double == storageType)                              {                                  return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Decimal == storageType)                              {                                  return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider);                              }                              return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                          }                            return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                      }                        return argumentValues[0];                    case FunctionId.DateTimeOffset:                      if (argumentValues[0] == DBNull.Value || argumentValues[1] == DBNull.Value || argumentValues[2] == DBNull.Value)                          return DBNull.Value;                      switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }                      if ((int)argumentValues[1] < -14 || (int)argumentValues[1] > 14)                          throw ExprException.InvalidHoursArgument();                      if ((int)argumentValues[2] < -59 || (int)argumentValues[2] > 59)                          throw ExprException.InvalidMinutesArgument();                      // range should be within -14 hours and  +14 hours                      if ((int)argumentValues[1] == 14 && (int)argumentValues[2] > 0)                          throw ExprException.InvalidTimeZoneRange();                      if ((int)argumentValues[1] == -14 && (int)argumentValues[2] < 0)                          throw ExprException.InvalidTimeZoneRange();                        return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0));                    default:                      throw ExprException.UndefinedFunction(s_funcs[_info]._name);              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following statement contains a magic number: switch (id)              {                  case FunctionId.Abs:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      if (ExpressionNode.IsInteger(storageType))                          return (Math.Abs((long)argumentValues[0]));                      if (ExpressionNode.IsNumeric(storageType))                          return (Math.Abs((double)argumentValues[0]));                        throw ExprException.ArgumentTypeInteger(s_funcs[_info]._name' 1);                    case FunctionId.cBool:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      switch (storageType)                      {                          case StorageType.Boolean:                              return (bool)argumentValues[0];                          case StorageType.Int32:                              return ((int)argumentValues[0] != 0);                          case StorageType.Double:                              return ((double)argumentValues[0] != 0.0);                          case StorageType.String:                              return bool.Parse((string)argumentValues[0]);                          default:                              throw ExprException.DatatypeConvertion(argumentValues[0].GetType()' typeof(bool));                      }                    case FunctionId.cInt:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToInt32(argumentValues[0]' FormatProvider);                    case FunctionId.cDate:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDateTime(argumentValues[0]' FormatProvider);                    case FunctionId.cDbl:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDouble(argumentValues[0]' FormatProvider);                    case FunctionId.cStr:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToString(argumentValues[0]' FormatProvider);                    case FunctionId.Charindex:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        Debug.Assert(argumentValues[0] is string' "Invalid argument type for " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is string' "Invalid argument type for " + s_funcs[_info]._name);                        if (DataStorage.IsObjectNull(argumentValues[0]) || DataStorage.IsObjectNull(argumentValues[1]))                          return DBNull.Value;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        if (argumentValues[1] is SqlString)                          argumentValues[1] = ((SqlString)argumentValues[1]).Value;                        return ((string)argumentValues[1]).IndexOf((string)argumentValues[0]' StringComparison.Ordinal);                    case FunctionId.Iif:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                        object first = _arguments[0].Eval(row' version);                        if (DataExpression.ToBoolean(first) != false)                      {                          return _arguments[1].Eval(row' version);                      }                      else                      {                          return _arguments[2].Eval(row' version);                      }                    case FunctionId.In:                      // we never evaluate IN directly: IN as a binary operator' so evaluation of this should be in                      // BinaryNode class                      throw ExprException.NYI(s_funcs[_info]._name);                    case FunctionId.IsNull:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount: ");                        if (DataStorage.IsObjectNull(argumentValues[0]))                          return argumentValues[1];                      else                          return argumentValues[0];                    case FunctionId.Len:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                        if (argumentValues[0] is SqlString)                      {                          if (((SqlString)argumentValues[0]).IsNull)                          {                              return DBNull.Value;                          }                          else                          {                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                          }                      }                        return ((string)argumentValues[0]).Length;                      case FunctionId.Substring:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name);                        // work around the differences in .NET and VBA implementation of the Substring function                      // 1. The <index> Argument is 0-based in .NET' and 1-based in VBA                      // 2. If the <Length> argument is longer then the string length .NET throws an ArgumentException                      //    but our users still want to get a result.                        int start = (int)argumentValues[1] - 1;                        int length = (int)argumentValues[2];                        if (start < 0)                          throw ExprException.FunctionArgumentOutOfRange("index"' "Substring");                        if (length < 0)                          throw ExprException.FunctionArgumentOutOfRange("length"' "Substring");                        if (length == 0)                          return string.Empty;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        int src_length = ((string)argumentValues[0]).Length;                        if (start > src_length)                      {                          return DBNull.Value;                      }                        if (start + length > src_length)                      {                          length = src_length - start;                      }                        return ((string)argumentValues[0]).Substring(start' length);                    case FunctionId.Trim:                      {                          Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                          Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                            if (DataStorage.IsObjectNull(argumentValues[0]))                              return DBNull.Value;                            if (argumentValues[0] is SqlString)                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                            return (((string)argumentValues[0]).Trim());                      }                    case FunctionId.Convert:                      if (_argumentCount != 2)                          throw ExprException.FunctionArgumentCount(_name);                        if (argumentValues[0] == DBNull.Value)                      {                          return DBNull.Value;                      }                        Type type = (Type)argumentValues[1];                      StorageType mytype = DataStorage.GetStorageType(type);                      storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                        if (mytype == StorageType.DateTimeOffset)                      {                          if (storageType == StorageType.String)                          {                              return SqlConvert.ConvertStringToDateTimeOffset((string)argumentValues[0]' FormatProvider);                          }                      }                        if (StorageType.Object != mytype)                      {                          if ((mytype == StorageType.Guid) && (storageType == StorageType.String))                              return new Guid((string)argumentValues[0]);                            if (ExpressionNode.IsFloatSql(storageType) && ExpressionNode.IsIntegerSql(mytype))                          {                              if (StorageType.Single == storageType)                              {                                  return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Double == storageType)                              {                                  return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Decimal == storageType)                              {                                  return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider);                              }                              return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                          }                            return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                      }                        return argumentValues[0];                    case FunctionId.DateTimeOffset:                      if (argumentValues[0] == DBNull.Value || argumentValues[1] == DBNull.Value || argumentValues[2] == DBNull.Value)                          return DBNull.Value;                      switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }                      if ((int)argumentValues[1] < -14 || (int)argumentValues[1] > 14)                          throw ExprException.InvalidHoursArgument();                      if ((int)argumentValues[2] < -59 || (int)argumentValues[2] > 59)                          throw ExprException.InvalidMinutesArgument();                      // range should be within -14 hours and  +14 hours                      if ((int)argumentValues[1] == 14 && (int)argumentValues[2] > 0)                          throw ExprException.InvalidTimeZoneRange();                      if ((int)argumentValues[1] == -14 && (int)argumentValues[2] < 0)                          throw ExprException.InvalidTimeZoneRange();                        return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0));                    default:                      throw ExprException.UndefinedFunction(s_funcs[_info]._name);              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following statement contains a magic number: switch (id)              {                  case FunctionId.Abs:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      if (ExpressionNode.IsInteger(storageType))                          return (Math.Abs((long)argumentValues[0]));                      if (ExpressionNode.IsNumeric(storageType))                          return (Math.Abs((double)argumentValues[0]));                        throw ExprException.ArgumentTypeInteger(s_funcs[_info]._name' 1);                    case FunctionId.cBool:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      switch (storageType)                      {                          case StorageType.Boolean:                              return (bool)argumentValues[0];                          case StorageType.Int32:                              return ((int)argumentValues[0] != 0);                          case StorageType.Double:                              return ((double)argumentValues[0] != 0.0);                          case StorageType.String:                              return bool.Parse((string)argumentValues[0]);                          default:                              throw ExprException.DatatypeConvertion(argumentValues[0].GetType()' typeof(bool));                      }                    case FunctionId.cInt:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToInt32(argumentValues[0]' FormatProvider);                    case FunctionId.cDate:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDateTime(argumentValues[0]' FormatProvider);                    case FunctionId.cDbl:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDouble(argumentValues[0]' FormatProvider);                    case FunctionId.cStr:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToString(argumentValues[0]' FormatProvider);                    case FunctionId.Charindex:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        Debug.Assert(argumentValues[0] is string' "Invalid argument type for " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is string' "Invalid argument type for " + s_funcs[_info]._name);                        if (DataStorage.IsObjectNull(argumentValues[0]) || DataStorage.IsObjectNull(argumentValues[1]))                          return DBNull.Value;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        if (argumentValues[1] is SqlString)                          argumentValues[1] = ((SqlString)argumentValues[1]).Value;                        return ((string)argumentValues[1]).IndexOf((string)argumentValues[0]' StringComparison.Ordinal);                    case FunctionId.Iif:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                        object first = _arguments[0].Eval(row' version);                        if (DataExpression.ToBoolean(first) != false)                      {                          return _arguments[1].Eval(row' version);                      }                      else                      {                          return _arguments[2].Eval(row' version);                      }                    case FunctionId.In:                      // we never evaluate IN directly: IN as a binary operator' so evaluation of this should be in                      // BinaryNode class                      throw ExprException.NYI(s_funcs[_info]._name);                    case FunctionId.IsNull:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount: ");                        if (DataStorage.IsObjectNull(argumentValues[0]))                          return argumentValues[1];                      else                          return argumentValues[0];                    case FunctionId.Len:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                        if (argumentValues[0] is SqlString)                      {                          if (((SqlString)argumentValues[0]).IsNull)                          {                              return DBNull.Value;                          }                          else                          {                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                          }                      }                        return ((string)argumentValues[0]).Length;                      case FunctionId.Substring:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name);                        // work around the differences in .NET and VBA implementation of the Substring function                      // 1. The <index> Argument is 0-based in .NET' and 1-based in VBA                      // 2. If the <Length> argument is longer then the string length .NET throws an ArgumentException                      //    but our users still want to get a result.                        int start = (int)argumentValues[1] - 1;                        int length = (int)argumentValues[2];                        if (start < 0)                          throw ExprException.FunctionArgumentOutOfRange("index"' "Substring");                        if (length < 0)                          throw ExprException.FunctionArgumentOutOfRange("length"' "Substring");                        if (length == 0)                          return string.Empty;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        int src_length = ((string)argumentValues[0]).Length;                        if (start > src_length)                      {                          return DBNull.Value;                      }                        if (start + length > src_length)                      {                          length = src_length - start;                      }                        return ((string)argumentValues[0]).Substring(start' length);                    case FunctionId.Trim:                      {                          Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                          Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                            if (DataStorage.IsObjectNull(argumentValues[0]))                              return DBNull.Value;                            if (argumentValues[0] is SqlString)                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                            return (((string)argumentValues[0]).Trim());                      }                    case FunctionId.Convert:                      if (_argumentCount != 2)                          throw ExprException.FunctionArgumentCount(_name);                        if (argumentValues[0] == DBNull.Value)                      {                          return DBNull.Value;                      }                        Type type = (Type)argumentValues[1];                      StorageType mytype = DataStorage.GetStorageType(type);                      storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                        if (mytype == StorageType.DateTimeOffset)                      {                          if (storageType == StorageType.String)                          {                              return SqlConvert.ConvertStringToDateTimeOffset((string)argumentValues[0]' FormatProvider);                          }                      }                        if (StorageType.Object != mytype)                      {                          if ((mytype == StorageType.Guid) && (storageType == StorageType.String))                              return new Guid((string)argumentValues[0]);                            if (ExpressionNode.IsFloatSql(storageType) && ExpressionNode.IsIntegerSql(mytype))                          {                              if (StorageType.Single == storageType)                              {                                  return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Double == storageType)                              {                                  return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Decimal == storageType)                              {                                  return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider);                              }                              return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                          }                            return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                      }                        return argumentValues[0];                    case FunctionId.DateTimeOffset:                      if (argumentValues[0] == DBNull.Value || argumentValues[1] == DBNull.Value || argumentValues[2] == DBNull.Value)                          return DBNull.Value;                      switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }                      if ((int)argumentValues[1] < -14 || (int)argumentValues[1] > 14)                          throw ExprException.InvalidHoursArgument();                      if ((int)argumentValues[2] < -59 || (int)argumentValues[2] > 59)                          throw ExprException.InvalidMinutesArgument();                      // range should be within -14 hours and  +14 hours                      if ((int)argumentValues[1] == 14 && (int)argumentValues[2] > 0)                          throw ExprException.InvalidTimeZoneRange();                      if ((int)argumentValues[1] == -14 && (int)argumentValues[2] < 0)                          throw ExprException.InvalidTimeZoneRange();                        return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0));                    default:                      throw ExprException.UndefinedFunction(s_funcs[_info]._name);              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following statement contains a magic number: switch (id)              {                  case FunctionId.Abs:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      if (ExpressionNode.IsInteger(storageType))                          return (Math.Abs((long)argumentValues[0]));                      if (ExpressionNode.IsNumeric(storageType))                          return (Math.Abs((double)argumentValues[0]));                        throw ExprException.ArgumentTypeInteger(s_funcs[_info]._name' 1);                    case FunctionId.cBool:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      switch (storageType)                      {                          case StorageType.Boolean:                              return (bool)argumentValues[0];                          case StorageType.Int32:                              return ((int)argumentValues[0] != 0);                          case StorageType.Double:                              return ((double)argumentValues[0] != 0.0);                          case StorageType.String:                              return bool.Parse((string)argumentValues[0]);                          default:                              throw ExprException.DatatypeConvertion(argumentValues[0].GetType()' typeof(bool));                      }                    case FunctionId.cInt:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToInt32(argumentValues[0]' FormatProvider);                    case FunctionId.cDate:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDateTime(argumentValues[0]' FormatProvider);                    case FunctionId.cDbl:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDouble(argumentValues[0]' FormatProvider);                    case FunctionId.cStr:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToString(argumentValues[0]' FormatProvider);                    case FunctionId.Charindex:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        Debug.Assert(argumentValues[0] is string' "Invalid argument type for " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is string' "Invalid argument type for " + s_funcs[_info]._name);                        if (DataStorage.IsObjectNull(argumentValues[0]) || DataStorage.IsObjectNull(argumentValues[1]))                          return DBNull.Value;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        if (argumentValues[1] is SqlString)                          argumentValues[1] = ((SqlString)argumentValues[1]).Value;                        return ((string)argumentValues[1]).IndexOf((string)argumentValues[0]' StringComparison.Ordinal);                    case FunctionId.Iif:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                        object first = _arguments[0].Eval(row' version);                        if (DataExpression.ToBoolean(first) != false)                      {                          return _arguments[1].Eval(row' version);                      }                      else                      {                          return _arguments[2].Eval(row' version);                      }                    case FunctionId.In:                      // we never evaluate IN directly: IN as a binary operator' so evaluation of this should be in                      // BinaryNode class                      throw ExprException.NYI(s_funcs[_info]._name);                    case FunctionId.IsNull:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount: ");                        if (DataStorage.IsObjectNull(argumentValues[0]))                          return argumentValues[1];                      else                          return argumentValues[0];                    case FunctionId.Len:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                        if (argumentValues[0] is SqlString)                      {                          if (((SqlString)argumentValues[0]).IsNull)                          {                              return DBNull.Value;                          }                          else                          {                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                          }                      }                        return ((string)argumentValues[0]).Length;                      case FunctionId.Substring:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name);                        // work around the differences in .NET and VBA implementation of the Substring function                      // 1. The <index> Argument is 0-based in .NET' and 1-based in VBA                      // 2. If the <Length> argument is longer then the string length .NET throws an ArgumentException                      //    but our users still want to get a result.                        int start = (int)argumentValues[1] - 1;                        int length = (int)argumentValues[2];                        if (start < 0)                          throw ExprException.FunctionArgumentOutOfRange("index"' "Substring");                        if (length < 0)                          throw ExprException.FunctionArgumentOutOfRange("length"' "Substring");                        if (length == 0)                          return string.Empty;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        int src_length = ((string)argumentValues[0]).Length;                        if (start > src_length)                      {                          return DBNull.Value;                      }                        if (start + length > src_length)                      {                          length = src_length - start;                      }                        return ((string)argumentValues[0]).Substring(start' length);                    case FunctionId.Trim:                      {                          Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                          Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                            if (DataStorage.IsObjectNull(argumentValues[0]))                              return DBNull.Value;                            if (argumentValues[0] is SqlString)                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                            return (((string)argumentValues[0]).Trim());                      }                    case FunctionId.Convert:                      if (_argumentCount != 2)                          throw ExprException.FunctionArgumentCount(_name);                        if (argumentValues[0] == DBNull.Value)                      {                          return DBNull.Value;                      }                        Type type = (Type)argumentValues[1];                      StorageType mytype = DataStorage.GetStorageType(type);                      storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                        if (mytype == StorageType.DateTimeOffset)                      {                          if (storageType == StorageType.String)                          {                              return SqlConvert.ConvertStringToDateTimeOffset((string)argumentValues[0]' FormatProvider);                          }                      }                        if (StorageType.Object != mytype)                      {                          if ((mytype == StorageType.Guid) && (storageType == StorageType.String))                              return new Guid((string)argumentValues[0]);                            if (ExpressionNode.IsFloatSql(storageType) && ExpressionNode.IsIntegerSql(mytype))                          {                              if (StorageType.Single == storageType)                              {                                  return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Double == storageType)                              {                                  return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Decimal == storageType)                              {                                  return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider);                              }                              return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                          }                            return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                      }                        return argumentValues[0];                    case FunctionId.DateTimeOffset:                      if (argumentValues[0] == DBNull.Value || argumentValues[1] == DBNull.Value || argumentValues[2] == DBNull.Value)                          return DBNull.Value;                      switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }                      if ((int)argumentValues[1] < -14 || (int)argumentValues[1] > 14)                          throw ExprException.InvalidHoursArgument();                      if ((int)argumentValues[2] < -59 || (int)argumentValues[2] > 59)                          throw ExprException.InvalidMinutesArgument();                      // range should be within -14 hours and  +14 hours                      if ((int)argumentValues[1] == 14 && (int)argumentValues[2] > 0)                          throw ExprException.InvalidTimeZoneRange();                      if ((int)argumentValues[1] == -14 && (int)argumentValues[2] < 0)                          throw ExprException.InvalidTimeZoneRange();                        return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0));                    default:                      throw ExprException.UndefinedFunction(s_funcs[_info]._name);              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following statement contains a magic number: switch (id)              {                  case FunctionId.Abs:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      if (ExpressionNode.IsInteger(storageType))                          return (Math.Abs((long)argumentValues[0]));                      if (ExpressionNode.IsNumeric(storageType))                          return (Math.Abs((double)argumentValues[0]));                        throw ExprException.ArgumentTypeInteger(s_funcs[_info]._name' 1);                    case FunctionId.cBool:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      switch (storageType)                      {                          case StorageType.Boolean:                              return (bool)argumentValues[0];                          case StorageType.Int32:                              return ((int)argumentValues[0] != 0);                          case StorageType.Double:                              return ((double)argumentValues[0] != 0.0);                          case StorageType.String:                              return bool.Parse((string)argumentValues[0]);                          default:                              throw ExprException.DatatypeConvertion(argumentValues[0].GetType()' typeof(bool));                      }                    case FunctionId.cInt:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToInt32(argumentValues[0]' FormatProvider);                    case FunctionId.cDate:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDateTime(argumentValues[0]' FormatProvider);                    case FunctionId.cDbl:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDouble(argumentValues[0]' FormatProvider);                    case FunctionId.cStr:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToString(argumentValues[0]' FormatProvider);                    case FunctionId.Charindex:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        Debug.Assert(argumentValues[0] is string' "Invalid argument type for " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is string' "Invalid argument type for " + s_funcs[_info]._name);                        if (DataStorage.IsObjectNull(argumentValues[0]) || DataStorage.IsObjectNull(argumentValues[1]))                          return DBNull.Value;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        if (argumentValues[1] is SqlString)                          argumentValues[1] = ((SqlString)argumentValues[1]).Value;                        return ((string)argumentValues[1]).IndexOf((string)argumentValues[0]' StringComparison.Ordinal);                    case FunctionId.Iif:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                        object first = _arguments[0].Eval(row' version);                        if (DataExpression.ToBoolean(first) != false)                      {                          return _arguments[1].Eval(row' version);                      }                      else                      {                          return _arguments[2].Eval(row' version);                      }                    case FunctionId.In:                      // we never evaluate IN directly: IN as a binary operator' so evaluation of this should be in                      // BinaryNode class                      throw ExprException.NYI(s_funcs[_info]._name);                    case FunctionId.IsNull:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount: ");                        if (DataStorage.IsObjectNull(argumentValues[0]))                          return argumentValues[1];                      else                          return argumentValues[0];                    case FunctionId.Len:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                        if (argumentValues[0] is SqlString)                      {                          if (((SqlString)argumentValues[0]).IsNull)                          {                              return DBNull.Value;                          }                          else                          {                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                          }                      }                        return ((string)argumentValues[0]).Length;                      case FunctionId.Substring:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name);                        // work around the differences in .NET and VBA implementation of the Substring function                      // 1. The <index> Argument is 0-based in .NET' and 1-based in VBA                      // 2. If the <Length> argument is longer then the string length .NET throws an ArgumentException                      //    but our users still want to get a result.                        int start = (int)argumentValues[1] - 1;                        int length = (int)argumentValues[2];                        if (start < 0)                          throw ExprException.FunctionArgumentOutOfRange("index"' "Substring");                        if (length < 0)                          throw ExprException.FunctionArgumentOutOfRange("length"' "Substring");                        if (length == 0)                          return string.Empty;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        int src_length = ((string)argumentValues[0]).Length;                        if (start > src_length)                      {                          return DBNull.Value;                      }                        if (start + length > src_length)                      {                          length = src_length - start;                      }                        return ((string)argumentValues[0]).Substring(start' length);                    case FunctionId.Trim:                      {                          Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                          Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                            if (DataStorage.IsObjectNull(argumentValues[0]))                              return DBNull.Value;                            if (argumentValues[0] is SqlString)                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                            return (((string)argumentValues[0]).Trim());                      }                    case FunctionId.Convert:                      if (_argumentCount != 2)                          throw ExprException.FunctionArgumentCount(_name);                        if (argumentValues[0] == DBNull.Value)                      {                          return DBNull.Value;                      }                        Type type = (Type)argumentValues[1];                      StorageType mytype = DataStorage.GetStorageType(type);                      storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                        if (mytype == StorageType.DateTimeOffset)                      {                          if (storageType == StorageType.String)                          {                              return SqlConvert.ConvertStringToDateTimeOffset((string)argumentValues[0]' FormatProvider);                          }                      }                        if (StorageType.Object != mytype)                      {                          if ((mytype == StorageType.Guid) && (storageType == StorageType.String))                              return new Guid((string)argumentValues[0]);                            if (ExpressionNode.IsFloatSql(storageType) && ExpressionNode.IsIntegerSql(mytype))                          {                              if (StorageType.Single == storageType)                              {                                  return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Double == storageType)                              {                                  return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Decimal == storageType)                              {                                  return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider);                              }                              return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                          }                            return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                      }                        return argumentValues[0];                    case FunctionId.DateTimeOffset:                      if (argumentValues[0] == DBNull.Value || argumentValues[1] == DBNull.Value || argumentValues[2] == DBNull.Value)                          return DBNull.Value;                      switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }                      if ((int)argumentValues[1] < -14 || (int)argumentValues[1] > 14)                          throw ExprException.InvalidHoursArgument();                      if ((int)argumentValues[2] < -59 || (int)argumentValues[2] > 59)                          throw ExprException.InvalidMinutesArgument();                      // range should be within -14 hours and  +14 hours                      if ((int)argumentValues[1] == 14 && (int)argumentValues[2] > 0)                          throw ExprException.InvalidTimeZoneRange();                      if ((int)argumentValues[1] == -14 && (int)argumentValues[2] < 0)                          throw ExprException.InvalidTimeZoneRange();                        return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0));                    default:                      throw ExprException.UndefinedFunction(s_funcs[_info]._name);              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following statement contains a magic number: switch (id)              {                  case FunctionId.Abs:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      if (ExpressionNode.IsInteger(storageType))                          return (Math.Abs((long)argumentValues[0]));                      if (ExpressionNode.IsNumeric(storageType))                          return (Math.Abs((double)argumentValues[0]));                        throw ExprException.ArgumentTypeInteger(s_funcs[_info]._name' 1);                    case FunctionId.cBool:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      switch (storageType)                      {                          case StorageType.Boolean:                              return (bool)argumentValues[0];                          case StorageType.Int32:                              return ((int)argumentValues[0] != 0);                          case StorageType.Double:                              return ((double)argumentValues[0] != 0.0);                          case StorageType.String:                              return bool.Parse((string)argumentValues[0]);                          default:                              throw ExprException.DatatypeConvertion(argumentValues[0].GetType()' typeof(bool));                      }                    case FunctionId.cInt:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToInt32(argumentValues[0]' FormatProvider);                    case FunctionId.cDate:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDateTime(argumentValues[0]' FormatProvider);                    case FunctionId.cDbl:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDouble(argumentValues[0]' FormatProvider);                    case FunctionId.cStr:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToString(argumentValues[0]' FormatProvider);                    case FunctionId.Charindex:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        Debug.Assert(argumentValues[0] is string' "Invalid argument type for " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is string' "Invalid argument type for " + s_funcs[_info]._name);                        if (DataStorage.IsObjectNull(argumentValues[0]) || DataStorage.IsObjectNull(argumentValues[1]))                          return DBNull.Value;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        if (argumentValues[1] is SqlString)                          argumentValues[1] = ((SqlString)argumentValues[1]).Value;                        return ((string)argumentValues[1]).IndexOf((string)argumentValues[0]' StringComparison.Ordinal);                    case FunctionId.Iif:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                        object first = _arguments[0].Eval(row' version);                        if (DataExpression.ToBoolean(first) != false)                      {                          return _arguments[1].Eval(row' version);                      }                      else                      {                          return _arguments[2].Eval(row' version);                      }                    case FunctionId.In:                      // we never evaluate IN directly: IN as a binary operator' so evaluation of this should be in                      // BinaryNode class                      throw ExprException.NYI(s_funcs[_info]._name);                    case FunctionId.IsNull:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount: ");                        if (DataStorage.IsObjectNull(argumentValues[0]))                          return argumentValues[1];                      else                          return argumentValues[0];                    case FunctionId.Len:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                        if (argumentValues[0] is SqlString)                      {                          if (((SqlString)argumentValues[0]).IsNull)                          {                              return DBNull.Value;                          }                          else                          {                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                          }                      }                        return ((string)argumentValues[0]).Length;                      case FunctionId.Substring:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name);                        // work around the differences in .NET and VBA implementation of the Substring function                      // 1. The <index> Argument is 0-based in .NET' and 1-based in VBA                      // 2. If the <Length> argument is longer then the string length .NET throws an ArgumentException                      //    but our users still want to get a result.                        int start = (int)argumentValues[1] - 1;                        int length = (int)argumentValues[2];                        if (start < 0)                          throw ExprException.FunctionArgumentOutOfRange("index"' "Substring");                        if (length < 0)                          throw ExprException.FunctionArgumentOutOfRange("length"' "Substring");                        if (length == 0)                          return string.Empty;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        int src_length = ((string)argumentValues[0]).Length;                        if (start > src_length)                      {                          return DBNull.Value;                      }                        if (start + length > src_length)                      {                          length = src_length - start;                      }                        return ((string)argumentValues[0]).Substring(start' length);                    case FunctionId.Trim:                      {                          Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                          Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                            if (DataStorage.IsObjectNull(argumentValues[0]))                              return DBNull.Value;                            if (argumentValues[0] is SqlString)                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                            return (((string)argumentValues[0]).Trim());                      }                    case FunctionId.Convert:                      if (_argumentCount != 2)                          throw ExprException.FunctionArgumentCount(_name);                        if (argumentValues[0] == DBNull.Value)                      {                          return DBNull.Value;                      }                        Type type = (Type)argumentValues[1];                      StorageType mytype = DataStorage.GetStorageType(type);                      storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                        if (mytype == StorageType.DateTimeOffset)                      {                          if (storageType == StorageType.String)                          {                              return SqlConvert.ConvertStringToDateTimeOffset((string)argumentValues[0]' FormatProvider);                          }                      }                        if (StorageType.Object != mytype)                      {                          if ((mytype == StorageType.Guid) && (storageType == StorageType.String))                              return new Guid((string)argumentValues[0]);                            if (ExpressionNode.IsFloatSql(storageType) && ExpressionNode.IsIntegerSql(mytype))                          {                              if (StorageType.Single == storageType)                              {                                  return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Double == storageType)                              {                                  return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Decimal == storageType)                              {                                  return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider);                              }                              return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                          }                            return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                      }                        return argumentValues[0];                    case FunctionId.DateTimeOffset:                      if (argumentValues[0] == DBNull.Value || argumentValues[1] == DBNull.Value || argumentValues[2] == DBNull.Value)                          return DBNull.Value;                      switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }                      if ((int)argumentValues[1] < -14 || (int)argumentValues[1] > 14)                          throw ExprException.InvalidHoursArgument();                      if ((int)argumentValues[2] < -59 || (int)argumentValues[2] > 59)                          throw ExprException.InvalidMinutesArgument();                      // range should be within -14 hours and  +14 hours                      if ((int)argumentValues[1] == 14 && (int)argumentValues[2] > 0)                          throw ExprException.InvalidTimeZoneRange();                      if ((int)argumentValues[1] == -14 && (int)argumentValues[2] < 0)                          throw ExprException.InvalidTimeZoneRange();                        return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0));                    default:                      throw ExprException.UndefinedFunction(s_funcs[_info]._name);              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following statement contains a magic number: switch (id)              {                  case FunctionId.Abs:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      if (ExpressionNode.IsInteger(storageType))                          return (Math.Abs((long)argumentValues[0]));                      if (ExpressionNode.IsNumeric(storageType))                          return (Math.Abs((double)argumentValues[0]));                        throw ExprException.ArgumentTypeInteger(s_funcs[_info]._name' 1);                    case FunctionId.cBool:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      switch (storageType)                      {                          case StorageType.Boolean:                              return (bool)argumentValues[0];                          case StorageType.Int32:                              return ((int)argumentValues[0] != 0);                          case StorageType.Double:                              return ((double)argumentValues[0] != 0.0);                          case StorageType.String:                              return bool.Parse((string)argumentValues[0]);                          default:                              throw ExprException.DatatypeConvertion(argumentValues[0].GetType()' typeof(bool));                      }                    case FunctionId.cInt:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToInt32(argumentValues[0]' FormatProvider);                    case FunctionId.cDate:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDateTime(argumentValues[0]' FormatProvider);                    case FunctionId.cDbl:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDouble(argumentValues[0]' FormatProvider);                    case FunctionId.cStr:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToString(argumentValues[0]' FormatProvider);                    case FunctionId.Charindex:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        Debug.Assert(argumentValues[0] is string' "Invalid argument type for " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is string' "Invalid argument type for " + s_funcs[_info]._name);                        if (DataStorage.IsObjectNull(argumentValues[0]) || DataStorage.IsObjectNull(argumentValues[1]))                          return DBNull.Value;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        if (argumentValues[1] is SqlString)                          argumentValues[1] = ((SqlString)argumentValues[1]).Value;                        return ((string)argumentValues[1]).IndexOf((string)argumentValues[0]' StringComparison.Ordinal);                    case FunctionId.Iif:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                        object first = _arguments[0].Eval(row' version);                        if (DataExpression.ToBoolean(first) != false)                      {                          return _arguments[1].Eval(row' version);                      }                      else                      {                          return _arguments[2].Eval(row' version);                      }                    case FunctionId.In:                      // we never evaluate IN directly: IN as a binary operator' so evaluation of this should be in                      // BinaryNode class                      throw ExprException.NYI(s_funcs[_info]._name);                    case FunctionId.IsNull:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount: ");                        if (DataStorage.IsObjectNull(argumentValues[0]))                          return argumentValues[1];                      else                          return argumentValues[0];                    case FunctionId.Len:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                        if (argumentValues[0] is SqlString)                      {                          if (((SqlString)argumentValues[0]).IsNull)                          {                              return DBNull.Value;                          }                          else                          {                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                          }                      }                        return ((string)argumentValues[0]).Length;                      case FunctionId.Substring:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name);                        // work around the differences in .NET and VBA implementation of the Substring function                      // 1. The <index> Argument is 0-based in .NET' and 1-based in VBA                      // 2. If the <Length> argument is longer then the string length .NET throws an ArgumentException                      //    but our users still want to get a result.                        int start = (int)argumentValues[1] - 1;                        int length = (int)argumentValues[2];                        if (start < 0)                          throw ExprException.FunctionArgumentOutOfRange("index"' "Substring");                        if (length < 0)                          throw ExprException.FunctionArgumentOutOfRange("length"' "Substring");                        if (length == 0)                          return string.Empty;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        int src_length = ((string)argumentValues[0]).Length;                        if (start > src_length)                      {                          return DBNull.Value;                      }                        if (start + length > src_length)                      {                          length = src_length - start;                      }                        return ((string)argumentValues[0]).Substring(start' length);                    case FunctionId.Trim:                      {                          Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                          Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                            if (DataStorage.IsObjectNull(argumentValues[0]))                              return DBNull.Value;                            if (argumentValues[0] is SqlString)                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                            return (((string)argumentValues[0]).Trim());                      }                    case FunctionId.Convert:                      if (_argumentCount != 2)                          throw ExprException.FunctionArgumentCount(_name);                        if (argumentValues[0] == DBNull.Value)                      {                          return DBNull.Value;                      }                        Type type = (Type)argumentValues[1];                      StorageType mytype = DataStorage.GetStorageType(type);                      storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                        if (mytype == StorageType.DateTimeOffset)                      {                          if (storageType == StorageType.String)                          {                              return SqlConvert.ConvertStringToDateTimeOffset((string)argumentValues[0]' FormatProvider);                          }                      }                        if (StorageType.Object != mytype)                      {                          if ((mytype == StorageType.Guid) && (storageType == StorageType.String))                              return new Guid((string)argumentValues[0]);                            if (ExpressionNode.IsFloatSql(storageType) && ExpressionNode.IsIntegerSql(mytype))                          {                              if (StorageType.Single == storageType)                              {                                  return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Double == storageType)                              {                                  return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Decimal == storageType)                              {                                  return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider);                              }                              return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                          }                            return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                      }                        return argumentValues[0];                    case FunctionId.DateTimeOffset:                      if (argumentValues[0] == DBNull.Value || argumentValues[1] == DBNull.Value || argumentValues[2] == DBNull.Value)                          return DBNull.Value;                      switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }                      if ((int)argumentValues[1] < -14 || (int)argumentValues[1] > 14)                          throw ExprException.InvalidHoursArgument();                      if ((int)argumentValues[2] < -59 || (int)argumentValues[2] > 59)                          throw ExprException.InvalidMinutesArgument();                      // range should be within -14 hours and  +14 hours                      if ((int)argumentValues[1] == 14 && (int)argumentValues[2] > 0)                          throw ExprException.InvalidTimeZoneRange();                      if ((int)argumentValues[1] == -14 && (int)argumentValues[2] < 0)                          throw ExprException.InvalidTimeZoneRange();                        return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0));                    default:                      throw ExprException.UndefinedFunction(s_funcs[_info]._name);              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following statement contains a magic number: switch (id)              {                  case FunctionId.Abs:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      if (ExpressionNode.IsInteger(storageType))                          return (Math.Abs((long)argumentValues[0]));                      if (ExpressionNode.IsNumeric(storageType))                          return (Math.Abs((double)argumentValues[0]));                        throw ExprException.ArgumentTypeInteger(s_funcs[_info]._name' 1);                    case FunctionId.cBool:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      switch (storageType)                      {                          case StorageType.Boolean:                              return (bool)argumentValues[0];                          case StorageType.Int32:                              return ((int)argumentValues[0] != 0);                          case StorageType.Double:                              return ((double)argumentValues[0] != 0.0);                          case StorageType.String:                              return bool.Parse((string)argumentValues[0]);                          default:                              throw ExprException.DatatypeConvertion(argumentValues[0].GetType()' typeof(bool));                      }                    case FunctionId.cInt:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToInt32(argumentValues[0]' FormatProvider);                    case FunctionId.cDate:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDateTime(argumentValues[0]' FormatProvider);                    case FunctionId.cDbl:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDouble(argumentValues[0]' FormatProvider);                    case FunctionId.cStr:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToString(argumentValues[0]' FormatProvider);                    case FunctionId.Charindex:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        Debug.Assert(argumentValues[0] is string' "Invalid argument type for " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is string' "Invalid argument type for " + s_funcs[_info]._name);                        if (DataStorage.IsObjectNull(argumentValues[0]) || DataStorage.IsObjectNull(argumentValues[1]))                          return DBNull.Value;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        if (argumentValues[1] is SqlString)                          argumentValues[1] = ((SqlString)argumentValues[1]).Value;                        return ((string)argumentValues[1]).IndexOf((string)argumentValues[0]' StringComparison.Ordinal);                    case FunctionId.Iif:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                        object first = _arguments[0].Eval(row' version);                        if (DataExpression.ToBoolean(first) != false)                      {                          return _arguments[1].Eval(row' version);                      }                      else                      {                          return _arguments[2].Eval(row' version);                      }                    case FunctionId.In:                      // we never evaluate IN directly: IN as a binary operator' so evaluation of this should be in                      // BinaryNode class                      throw ExprException.NYI(s_funcs[_info]._name);                    case FunctionId.IsNull:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount: ");                        if (DataStorage.IsObjectNull(argumentValues[0]))                          return argumentValues[1];                      else                          return argumentValues[0];                    case FunctionId.Len:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                        if (argumentValues[0] is SqlString)                      {                          if (((SqlString)argumentValues[0]).IsNull)                          {                              return DBNull.Value;                          }                          else                          {                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                          }                      }                        return ((string)argumentValues[0]).Length;                      case FunctionId.Substring:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name);                        // work around the differences in .NET and VBA implementation of the Substring function                      // 1. The <index> Argument is 0-based in .NET' and 1-based in VBA                      // 2. If the <Length> argument is longer then the string length .NET throws an ArgumentException                      //    but our users still want to get a result.                        int start = (int)argumentValues[1] - 1;                        int length = (int)argumentValues[2];                        if (start < 0)                          throw ExprException.FunctionArgumentOutOfRange("index"' "Substring");                        if (length < 0)                          throw ExprException.FunctionArgumentOutOfRange("length"' "Substring");                        if (length == 0)                          return string.Empty;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        int src_length = ((string)argumentValues[0]).Length;                        if (start > src_length)                      {                          return DBNull.Value;                      }                        if (start + length > src_length)                      {                          length = src_length - start;                      }                        return ((string)argumentValues[0]).Substring(start' length);                    case FunctionId.Trim:                      {                          Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                          Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                            if (DataStorage.IsObjectNull(argumentValues[0]))                              return DBNull.Value;                            if (argumentValues[0] is SqlString)                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                            return (((string)argumentValues[0]).Trim());                      }                    case FunctionId.Convert:                      if (_argumentCount != 2)                          throw ExprException.FunctionArgumentCount(_name);                        if (argumentValues[0] == DBNull.Value)                      {                          return DBNull.Value;                      }                        Type type = (Type)argumentValues[1];                      StorageType mytype = DataStorage.GetStorageType(type);                      storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                        if (mytype == StorageType.DateTimeOffset)                      {                          if (storageType == StorageType.String)                          {                              return SqlConvert.ConvertStringToDateTimeOffset((string)argumentValues[0]' FormatProvider);                          }                      }                        if (StorageType.Object != mytype)                      {                          if ((mytype == StorageType.Guid) && (storageType == StorageType.String))                              return new Guid((string)argumentValues[0]);                            if (ExpressionNode.IsFloatSql(storageType) && ExpressionNode.IsIntegerSql(mytype))                          {                              if (StorageType.Single == storageType)                              {                                  return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Double == storageType)                              {                                  return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Decimal == storageType)                              {                                  return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider);                              }                              return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                          }                            return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                      }                        return argumentValues[0];                    case FunctionId.DateTimeOffset:                      if (argumentValues[0] == DBNull.Value || argumentValues[1] == DBNull.Value || argumentValues[2] == DBNull.Value)                          return DBNull.Value;                      switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }                      if ((int)argumentValues[1] < -14 || (int)argumentValues[1] > 14)                          throw ExprException.InvalidHoursArgument();                      if ((int)argumentValues[2] < -59 || (int)argumentValues[2] > 59)                          throw ExprException.InvalidMinutesArgument();                      // range should be within -14 hours and  +14 hours                      if ((int)argumentValues[1] == 14 && (int)argumentValues[2] > 0)                          throw ExprException.InvalidTimeZoneRange();                      if ((int)argumentValues[1] == -14 && (int)argumentValues[2] < 0)                          throw ExprException.InvalidTimeZoneRange();                        return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0));                    default:                      throw ExprException.UndefinedFunction(s_funcs[_info]._name);              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following statement contains a magic number: switch (id)              {                  case FunctionId.Abs:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      if (ExpressionNode.IsInteger(storageType))                          return (Math.Abs((long)argumentValues[0]));                      if (ExpressionNode.IsNumeric(storageType))                          return (Math.Abs((double)argumentValues[0]));                        throw ExprException.ArgumentTypeInteger(s_funcs[_info]._name' 1);                    case FunctionId.cBool:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      switch (storageType)                      {                          case StorageType.Boolean:                              return (bool)argumentValues[0];                          case StorageType.Int32:                              return ((int)argumentValues[0] != 0);                          case StorageType.Double:                              return ((double)argumentValues[0] != 0.0);                          case StorageType.String:                              return bool.Parse((string)argumentValues[0]);                          default:                              throw ExprException.DatatypeConvertion(argumentValues[0].GetType()' typeof(bool));                      }                    case FunctionId.cInt:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToInt32(argumentValues[0]' FormatProvider);                    case FunctionId.cDate:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDateTime(argumentValues[0]' FormatProvider);                    case FunctionId.cDbl:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDouble(argumentValues[0]' FormatProvider);                    case FunctionId.cStr:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToString(argumentValues[0]' FormatProvider);                    case FunctionId.Charindex:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        Debug.Assert(argumentValues[0] is string' "Invalid argument type for " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is string' "Invalid argument type for " + s_funcs[_info]._name);                        if (DataStorage.IsObjectNull(argumentValues[0]) || DataStorage.IsObjectNull(argumentValues[1]))                          return DBNull.Value;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        if (argumentValues[1] is SqlString)                          argumentValues[1] = ((SqlString)argumentValues[1]).Value;                        return ((string)argumentValues[1]).IndexOf((string)argumentValues[0]' StringComparison.Ordinal);                    case FunctionId.Iif:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                        object first = _arguments[0].Eval(row' version);                        if (DataExpression.ToBoolean(first) != false)                      {                          return _arguments[1].Eval(row' version);                      }                      else                      {                          return _arguments[2].Eval(row' version);                      }                    case FunctionId.In:                      // we never evaluate IN directly: IN as a binary operator' so evaluation of this should be in                      // BinaryNode class                      throw ExprException.NYI(s_funcs[_info]._name);                    case FunctionId.IsNull:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount: ");                        if (DataStorage.IsObjectNull(argumentValues[0]))                          return argumentValues[1];                      else                          return argumentValues[0];                    case FunctionId.Len:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                        if (argumentValues[0] is SqlString)                      {                          if (((SqlString)argumentValues[0]).IsNull)                          {                              return DBNull.Value;                          }                          else                          {                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                          }                      }                        return ((string)argumentValues[0]).Length;                      case FunctionId.Substring:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name);                        // work around the differences in .NET and VBA implementation of the Substring function                      // 1. The <index> Argument is 0-based in .NET' and 1-based in VBA                      // 2. If the <Length> argument is longer then the string length .NET throws an ArgumentException                      //    but our users still want to get a result.                        int start = (int)argumentValues[1] - 1;                        int length = (int)argumentValues[2];                        if (start < 0)                          throw ExprException.FunctionArgumentOutOfRange("index"' "Substring");                        if (length < 0)                          throw ExprException.FunctionArgumentOutOfRange("length"' "Substring");                        if (length == 0)                          return string.Empty;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        int src_length = ((string)argumentValues[0]).Length;                        if (start > src_length)                      {                          return DBNull.Value;                      }                        if (start + length > src_length)                      {                          length = src_length - start;                      }                        return ((string)argumentValues[0]).Substring(start' length);                    case FunctionId.Trim:                      {                          Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                          Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                            if (DataStorage.IsObjectNull(argumentValues[0]))                              return DBNull.Value;                            if (argumentValues[0] is SqlString)                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                            return (((string)argumentValues[0]).Trim());                      }                    case FunctionId.Convert:                      if (_argumentCount != 2)                          throw ExprException.FunctionArgumentCount(_name);                        if (argumentValues[0] == DBNull.Value)                      {                          return DBNull.Value;                      }                        Type type = (Type)argumentValues[1];                      StorageType mytype = DataStorage.GetStorageType(type);                      storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                        if (mytype == StorageType.DateTimeOffset)                      {                          if (storageType == StorageType.String)                          {                              return SqlConvert.ConvertStringToDateTimeOffset((string)argumentValues[0]' FormatProvider);                          }                      }                        if (StorageType.Object != mytype)                      {                          if ((mytype == StorageType.Guid) && (storageType == StorageType.String))                              return new Guid((string)argumentValues[0]);                            if (ExpressionNode.IsFloatSql(storageType) && ExpressionNode.IsIntegerSql(mytype))                          {                              if (StorageType.Single == storageType)                              {                                  return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Double == storageType)                              {                                  return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Decimal == storageType)                              {                                  return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider);                              }                              return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                          }                            return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                      }                        return argumentValues[0];                    case FunctionId.DateTimeOffset:                      if (argumentValues[0] == DBNull.Value || argumentValues[1] == DBNull.Value || argumentValues[2] == DBNull.Value)                          return DBNull.Value;                      switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }                      if ((int)argumentValues[1] < -14 || (int)argumentValues[1] > 14)                          throw ExprException.InvalidHoursArgument();                      if ((int)argumentValues[2] < -59 || (int)argumentValues[2] > 59)                          throw ExprException.InvalidMinutesArgument();                      // range should be within -14 hours and  +14 hours                      if ((int)argumentValues[1] == 14 && (int)argumentValues[2] > 0)                          throw ExprException.InvalidTimeZoneRange();                      if ((int)argumentValues[1] == -14 && (int)argumentValues[2] < 0)                          throw ExprException.InvalidTimeZoneRange();                        return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0));                    default:                      throw ExprException.UndefinedFunction(s_funcs[_info]._name);              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following statement contains a magic number: switch (id)              {                  case FunctionId.Abs:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      if (ExpressionNode.IsInteger(storageType))                          return (Math.Abs((long)argumentValues[0]));                      if (ExpressionNode.IsNumeric(storageType))                          return (Math.Abs((double)argumentValues[0]));                        throw ExprException.ArgumentTypeInteger(s_funcs[_info]._name' 1);                    case FunctionId.cBool:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      switch (storageType)                      {                          case StorageType.Boolean:                              return (bool)argumentValues[0];                          case StorageType.Int32:                              return ((int)argumentValues[0] != 0);                          case StorageType.Double:                              return ((double)argumentValues[0] != 0.0);                          case StorageType.String:                              return bool.Parse((string)argumentValues[0]);                          default:                              throw ExprException.DatatypeConvertion(argumentValues[0].GetType()' typeof(bool));                      }                    case FunctionId.cInt:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToInt32(argumentValues[0]' FormatProvider);                    case FunctionId.cDate:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDateTime(argumentValues[0]' FormatProvider);                    case FunctionId.cDbl:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDouble(argumentValues[0]' FormatProvider);                    case FunctionId.cStr:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToString(argumentValues[0]' FormatProvider);                    case FunctionId.Charindex:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        Debug.Assert(argumentValues[0] is string' "Invalid argument type for " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is string' "Invalid argument type for " + s_funcs[_info]._name);                        if (DataStorage.IsObjectNull(argumentValues[0]) || DataStorage.IsObjectNull(argumentValues[1]))                          return DBNull.Value;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        if (argumentValues[1] is SqlString)                          argumentValues[1] = ((SqlString)argumentValues[1]).Value;                        return ((string)argumentValues[1]).IndexOf((string)argumentValues[0]' StringComparison.Ordinal);                    case FunctionId.Iif:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                        object first = _arguments[0].Eval(row' version);                        if (DataExpression.ToBoolean(first) != false)                      {                          return _arguments[1].Eval(row' version);                      }                      else                      {                          return _arguments[2].Eval(row' version);                      }                    case FunctionId.In:                      // we never evaluate IN directly: IN as a binary operator' so evaluation of this should be in                      // BinaryNode class                      throw ExprException.NYI(s_funcs[_info]._name);                    case FunctionId.IsNull:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount: ");                        if (DataStorage.IsObjectNull(argumentValues[0]))                          return argumentValues[1];                      else                          return argumentValues[0];                    case FunctionId.Len:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                        if (argumentValues[0] is SqlString)                      {                          if (((SqlString)argumentValues[0]).IsNull)                          {                              return DBNull.Value;                          }                          else                          {                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                          }                      }                        return ((string)argumentValues[0]).Length;                      case FunctionId.Substring:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name);                        // work around the differences in .NET and VBA implementation of the Substring function                      // 1. The <index> Argument is 0-based in .NET' and 1-based in VBA                      // 2. If the <Length> argument is longer then the string length .NET throws an ArgumentException                      //    but our users still want to get a result.                        int start = (int)argumentValues[1] - 1;                        int length = (int)argumentValues[2];                        if (start < 0)                          throw ExprException.FunctionArgumentOutOfRange("index"' "Substring");                        if (length < 0)                          throw ExprException.FunctionArgumentOutOfRange("length"' "Substring");                        if (length == 0)                          return string.Empty;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        int src_length = ((string)argumentValues[0]).Length;                        if (start > src_length)                      {                          return DBNull.Value;                      }                        if (start + length > src_length)                      {                          length = src_length - start;                      }                        return ((string)argumentValues[0]).Substring(start' length);                    case FunctionId.Trim:                      {                          Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                          Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                            if (DataStorage.IsObjectNull(argumentValues[0]))                              return DBNull.Value;                            if (argumentValues[0] is SqlString)                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                            return (((string)argumentValues[0]).Trim());                      }                    case FunctionId.Convert:                      if (_argumentCount != 2)                          throw ExprException.FunctionArgumentCount(_name);                        if (argumentValues[0] == DBNull.Value)                      {                          return DBNull.Value;                      }                        Type type = (Type)argumentValues[1];                      StorageType mytype = DataStorage.GetStorageType(type);                      storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                        if (mytype == StorageType.DateTimeOffset)                      {                          if (storageType == StorageType.String)                          {                              return SqlConvert.ConvertStringToDateTimeOffset((string)argumentValues[0]' FormatProvider);                          }                      }                        if (StorageType.Object != mytype)                      {                          if ((mytype == StorageType.Guid) && (storageType == StorageType.String))                              return new Guid((string)argumentValues[0]);                            if (ExpressionNode.IsFloatSql(storageType) && ExpressionNode.IsIntegerSql(mytype))                          {                              if (StorageType.Single == storageType)                              {                                  return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Double == storageType)                              {                                  return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Decimal == storageType)                              {                                  return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider);                              }                              return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                          }                            return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                      }                        return argumentValues[0];                    case FunctionId.DateTimeOffset:                      if (argumentValues[0] == DBNull.Value || argumentValues[1] == DBNull.Value || argumentValues[2] == DBNull.Value)                          return DBNull.Value;                      switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }                      if ((int)argumentValues[1] < -14 || (int)argumentValues[1] > 14)                          throw ExprException.InvalidHoursArgument();                      if ((int)argumentValues[2] < -59 || (int)argumentValues[2] > 59)                          throw ExprException.InvalidMinutesArgument();                      // range should be within -14 hours and  +14 hours                      if ((int)argumentValues[1] == 14 && (int)argumentValues[2] > 0)                          throw ExprException.InvalidTimeZoneRange();                      if ((int)argumentValues[1] == -14 && (int)argumentValues[2] < 0)                          throw ExprException.InvalidTimeZoneRange();                        return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0));                    default:                      throw ExprException.UndefinedFunction(s_funcs[_info]._name);              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following statement contains a magic number: switch (id)              {                  case FunctionId.Abs:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      if (ExpressionNode.IsInteger(storageType))                          return (Math.Abs((long)argumentValues[0]));                      if (ExpressionNode.IsNumeric(storageType))                          return (Math.Abs((double)argumentValues[0]));                        throw ExprException.ArgumentTypeInteger(s_funcs[_info]._name' 1);                    case FunctionId.cBool:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      switch (storageType)                      {                          case StorageType.Boolean:                              return (bool)argumentValues[0];                          case StorageType.Int32:                              return ((int)argumentValues[0] != 0);                          case StorageType.Double:                              return ((double)argumentValues[0] != 0.0);                          case StorageType.String:                              return bool.Parse((string)argumentValues[0]);                          default:                              throw ExprException.DatatypeConvertion(argumentValues[0].GetType()' typeof(bool));                      }                    case FunctionId.cInt:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToInt32(argumentValues[0]' FormatProvider);                    case FunctionId.cDate:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDateTime(argumentValues[0]' FormatProvider);                    case FunctionId.cDbl:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDouble(argumentValues[0]' FormatProvider);                    case FunctionId.cStr:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToString(argumentValues[0]' FormatProvider);                    case FunctionId.Charindex:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        Debug.Assert(argumentValues[0] is string' "Invalid argument type for " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is string' "Invalid argument type for " + s_funcs[_info]._name);                        if (DataStorage.IsObjectNull(argumentValues[0]) || DataStorage.IsObjectNull(argumentValues[1]))                          return DBNull.Value;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        if (argumentValues[1] is SqlString)                          argumentValues[1] = ((SqlString)argumentValues[1]).Value;                        return ((string)argumentValues[1]).IndexOf((string)argumentValues[0]' StringComparison.Ordinal);                    case FunctionId.Iif:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                        object first = _arguments[0].Eval(row' version);                        if (DataExpression.ToBoolean(first) != false)                      {                          return _arguments[1].Eval(row' version);                      }                      else                      {                          return _arguments[2].Eval(row' version);                      }                    case FunctionId.In:                      // we never evaluate IN directly: IN as a binary operator' so evaluation of this should be in                      // BinaryNode class                      throw ExprException.NYI(s_funcs[_info]._name);                    case FunctionId.IsNull:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount: ");                        if (DataStorage.IsObjectNull(argumentValues[0]))                          return argumentValues[1];                      else                          return argumentValues[0];                    case FunctionId.Len:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                        if (argumentValues[0] is SqlString)                      {                          if (((SqlString)argumentValues[0]).IsNull)                          {                              return DBNull.Value;                          }                          else                          {                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                          }                      }                        return ((string)argumentValues[0]).Length;                      case FunctionId.Substring:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name);                        // work around the differences in .NET and VBA implementation of the Substring function                      // 1. The <index> Argument is 0-based in .NET' and 1-based in VBA                      // 2. If the <Length> argument is longer then the string length .NET throws an ArgumentException                      //    but our users still want to get a result.                        int start = (int)argumentValues[1] - 1;                        int length = (int)argumentValues[2];                        if (start < 0)                          throw ExprException.FunctionArgumentOutOfRange("index"' "Substring");                        if (length < 0)                          throw ExprException.FunctionArgumentOutOfRange("length"' "Substring");                        if (length == 0)                          return string.Empty;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        int src_length = ((string)argumentValues[0]).Length;                        if (start > src_length)                      {                          return DBNull.Value;                      }                        if (start + length > src_length)                      {                          length = src_length - start;                      }                        return ((string)argumentValues[0]).Substring(start' length);                    case FunctionId.Trim:                      {                          Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                          Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                            if (DataStorage.IsObjectNull(argumentValues[0]))                              return DBNull.Value;                            if (argumentValues[0] is SqlString)                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                            return (((string)argumentValues[0]).Trim());                      }                    case FunctionId.Convert:                      if (_argumentCount != 2)                          throw ExprException.FunctionArgumentCount(_name);                        if (argumentValues[0] == DBNull.Value)                      {                          return DBNull.Value;                      }                        Type type = (Type)argumentValues[1];                      StorageType mytype = DataStorage.GetStorageType(type);                      storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                        if (mytype == StorageType.DateTimeOffset)                      {                          if (storageType == StorageType.String)                          {                              return SqlConvert.ConvertStringToDateTimeOffset((string)argumentValues[0]' FormatProvider);                          }                      }                        if (StorageType.Object != mytype)                      {                          if ((mytype == StorageType.Guid) && (storageType == StorageType.String))                              return new Guid((string)argumentValues[0]);                            if (ExpressionNode.IsFloatSql(storageType) && ExpressionNode.IsIntegerSql(mytype))                          {                              if (StorageType.Single == storageType)                              {                                  return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Double == storageType)                              {                                  return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Decimal == storageType)                              {                                  return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider);                              }                              return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                          }                            return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                      }                        return argumentValues[0];                    case FunctionId.DateTimeOffset:                      if (argumentValues[0] == DBNull.Value || argumentValues[1] == DBNull.Value || argumentValues[2] == DBNull.Value)                          return DBNull.Value;                      switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }                      if ((int)argumentValues[1] < -14 || (int)argumentValues[1] > 14)                          throw ExprException.InvalidHoursArgument();                      if ((int)argumentValues[2] < -59 || (int)argumentValues[2] > 59)                          throw ExprException.InvalidMinutesArgument();                      // range should be within -14 hours and  +14 hours                      if ((int)argumentValues[1] == 14 && (int)argumentValues[2] > 0)                          throw ExprException.InvalidTimeZoneRange();                      if ((int)argumentValues[1] == -14 && (int)argumentValues[2] < 0)                          throw ExprException.InvalidTimeZoneRange();                        return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0));                    default:                      throw ExprException.UndefinedFunction(s_funcs[_info]._name);              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following statement contains a magic number: switch (id)              {                  case FunctionId.Abs:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      if (ExpressionNode.IsInteger(storageType))                          return (Math.Abs((long)argumentValues[0]));                      if (ExpressionNode.IsNumeric(storageType))                          return (Math.Abs((double)argumentValues[0]));                        throw ExprException.ArgumentTypeInteger(s_funcs[_info]._name' 1);                    case FunctionId.cBool:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      switch (storageType)                      {                          case StorageType.Boolean:                              return (bool)argumentValues[0];                          case StorageType.Int32:                              return ((int)argumentValues[0] != 0);                          case StorageType.Double:                              return ((double)argumentValues[0] != 0.0);                          case StorageType.String:                              return bool.Parse((string)argumentValues[0]);                          default:                              throw ExprException.DatatypeConvertion(argumentValues[0].GetType()' typeof(bool));                      }                    case FunctionId.cInt:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToInt32(argumentValues[0]' FormatProvider);                    case FunctionId.cDate:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDateTime(argumentValues[0]' FormatProvider);                    case FunctionId.cDbl:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDouble(argumentValues[0]' FormatProvider);                    case FunctionId.cStr:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToString(argumentValues[0]' FormatProvider);                    case FunctionId.Charindex:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        Debug.Assert(argumentValues[0] is string' "Invalid argument type for " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is string' "Invalid argument type for " + s_funcs[_info]._name);                        if (DataStorage.IsObjectNull(argumentValues[0]) || DataStorage.IsObjectNull(argumentValues[1]))                          return DBNull.Value;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        if (argumentValues[1] is SqlString)                          argumentValues[1] = ((SqlString)argumentValues[1]).Value;                        return ((string)argumentValues[1]).IndexOf((string)argumentValues[0]' StringComparison.Ordinal);                    case FunctionId.Iif:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                        object first = _arguments[0].Eval(row' version);                        if (DataExpression.ToBoolean(first) != false)                      {                          return _arguments[1].Eval(row' version);                      }                      else                      {                          return _arguments[2].Eval(row' version);                      }                    case FunctionId.In:                      // we never evaluate IN directly: IN as a binary operator' so evaluation of this should be in                      // BinaryNode class                      throw ExprException.NYI(s_funcs[_info]._name);                    case FunctionId.IsNull:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount: ");                        if (DataStorage.IsObjectNull(argumentValues[0]))                          return argumentValues[1];                      else                          return argumentValues[0];                    case FunctionId.Len:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                        if (argumentValues[0] is SqlString)                      {                          if (((SqlString)argumentValues[0]).IsNull)                          {                              return DBNull.Value;                          }                          else                          {                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                          }                      }                        return ((string)argumentValues[0]).Length;                      case FunctionId.Substring:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name);                        // work around the differences in .NET and VBA implementation of the Substring function                      // 1. The <index> Argument is 0-based in .NET' and 1-based in VBA                      // 2. If the <Length> argument is longer then the string length .NET throws an ArgumentException                      //    but our users still want to get a result.                        int start = (int)argumentValues[1] - 1;                        int length = (int)argumentValues[2];                        if (start < 0)                          throw ExprException.FunctionArgumentOutOfRange("index"' "Substring");                        if (length < 0)                          throw ExprException.FunctionArgumentOutOfRange("length"' "Substring");                        if (length == 0)                          return string.Empty;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        int src_length = ((string)argumentValues[0]).Length;                        if (start > src_length)                      {                          return DBNull.Value;                      }                        if (start + length > src_length)                      {                          length = src_length - start;                      }                        return ((string)argumentValues[0]).Substring(start' length);                    case FunctionId.Trim:                      {                          Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                          Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                            if (DataStorage.IsObjectNull(argumentValues[0]))                              return DBNull.Value;                            if (argumentValues[0] is SqlString)                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                            return (((string)argumentValues[0]).Trim());                      }                    case FunctionId.Convert:                      if (_argumentCount != 2)                          throw ExprException.FunctionArgumentCount(_name);                        if (argumentValues[0] == DBNull.Value)                      {                          return DBNull.Value;                      }                        Type type = (Type)argumentValues[1];                      StorageType mytype = DataStorage.GetStorageType(type);                      storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                        if (mytype == StorageType.DateTimeOffset)                      {                          if (storageType == StorageType.String)                          {                              return SqlConvert.ConvertStringToDateTimeOffset((string)argumentValues[0]' FormatProvider);                          }                      }                        if (StorageType.Object != mytype)                      {                          if ((mytype == StorageType.Guid) && (storageType == StorageType.String))                              return new Guid((string)argumentValues[0]);                            if (ExpressionNode.IsFloatSql(storageType) && ExpressionNode.IsIntegerSql(mytype))                          {                              if (StorageType.Single == storageType)                              {                                  return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Double == storageType)                              {                                  return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Decimal == storageType)                              {                                  return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider);                              }                              return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                          }                            return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                      }                        return argumentValues[0];                    case FunctionId.DateTimeOffset:                      if (argumentValues[0] == DBNull.Value || argumentValues[1] == DBNull.Value || argumentValues[2] == DBNull.Value)                          return DBNull.Value;                      switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }                      if ((int)argumentValues[1] < -14 || (int)argumentValues[1] > 14)                          throw ExprException.InvalidHoursArgument();                      if ((int)argumentValues[2] < -59 || (int)argumentValues[2] > 59)                          throw ExprException.InvalidMinutesArgument();                      // range should be within -14 hours and  +14 hours                      if ((int)argumentValues[1] == 14 && (int)argumentValues[2] > 0)                          throw ExprException.InvalidTimeZoneRange();                      if ((int)argumentValues[1] == -14 && (int)argumentValues[2] < 0)                          throw ExprException.InvalidTimeZoneRange();                        return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0));                    default:                      throw ExprException.UndefinedFunction(s_funcs[_info]._name);              }
Magic Number,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following statement contains a magic number: switch (id)              {                  case FunctionId.Abs:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      if (ExpressionNode.IsInteger(storageType))                          return (Math.Abs((long)argumentValues[0]));                      if (ExpressionNode.IsNumeric(storageType))                          return (Math.Abs((double)argumentValues[0]));                        throw ExprException.ArgumentTypeInteger(s_funcs[_info]._name' 1);                    case FunctionId.cBool:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                      switch (storageType)                      {                          case StorageType.Boolean:                              return (bool)argumentValues[0];                          case StorageType.Int32:                              return ((int)argumentValues[0] != 0);                          case StorageType.Double:                              return ((double)argumentValues[0] != 0.0);                          case StorageType.String:                              return bool.Parse((string)argumentValues[0]);                          default:                              throw ExprException.DatatypeConvertion(argumentValues[0].GetType()' typeof(bool));                      }                    case FunctionId.cInt:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToInt32(argumentValues[0]' FormatProvider);                    case FunctionId.cDate:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDateTime(argumentValues[0]' FormatProvider);                    case FunctionId.cDbl:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToDouble(argumentValues[0]' FormatProvider);                    case FunctionId.cStr:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      return Convert.ToString(argumentValues[0]' FormatProvider);                    case FunctionId.Charindex:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                        Debug.Assert(argumentValues[0] is string' "Invalid argument type for " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is string' "Invalid argument type for " + s_funcs[_info]._name);                        if (DataStorage.IsObjectNull(argumentValues[0]) || DataStorage.IsObjectNull(argumentValues[1]))                          return DBNull.Value;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        if (argumentValues[1] is SqlString)                          argumentValues[1] = ((SqlString)argumentValues[1]).Value;                        return ((string)argumentValues[1]).IndexOf((string)argumentValues[0]' StringComparison.Ordinal);                    case FunctionId.Iif:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                        object first = _arguments[0].Eval(row' version);                        if (DataExpression.ToBoolean(first) != false)                      {                          return _arguments[1].Eval(row' version);                      }                      else                      {                          return _arguments[2].Eval(row' version);                      }                    case FunctionId.In:                      // we never evaluate IN directly: IN as a binary operator' so evaluation of this should be in                      // BinaryNode class                      throw ExprException.NYI(s_funcs[_info]._name);                    case FunctionId.IsNull:                      Debug.Assert(_argumentCount == 2' "Invalid argument argumentCount: ");                        if (DataStorage.IsObjectNull(argumentValues[0]))                          return argumentValues[1];                      else                          return argumentValues[0];                    case FunctionId.Len:                      Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                        if (argumentValues[0] is SqlString)                      {                          if (((SqlString)argumentValues[0]).IsNull)                          {                              return DBNull.Value;                          }                          else                          {                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                          }                      }                        return ((string)argumentValues[0]).Length;                      case FunctionId.Substring:                      Debug.Assert(_argumentCount == 3' "Invalid argument argumentCount: " + _argumentCount.ToString(FormatProvider));                      Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid first argument " + argumentValues[0].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[1] is int' "Invalid second argument " + argumentValues[1].GetType().FullName + " in " + s_funcs[_info]._name);                      Debug.Assert(argumentValues[2] is int' "Invalid third argument " + argumentValues[2].GetType().FullName + " in " + s_funcs[_info]._name);                        // work around the differences in .NET and VBA implementation of the Substring function                      // 1. The <index> Argument is 0-based in .NET' and 1-based in VBA                      // 2. If the <Length> argument is longer then the string length .NET throws an ArgumentException                      //    but our users still want to get a result.                        int start = (int)argumentValues[1] - 1;                        int length = (int)argumentValues[2];                        if (start < 0)                          throw ExprException.FunctionArgumentOutOfRange("index"' "Substring");                        if (length < 0)                          throw ExprException.FunctionArgumentOutOfRange("length"' "Substring");                        if (length == 0)                          return string.Empty;                        if (argumentValues[0] is SqlString)                          argumentValues[0] = ((SqlString)argumentValues[0]).Value;                        int src_length = ((string)argumentValues[0]).Length;                        if (start > src_length)                      {                          return DBNull.Value;                      }                        if (start + length > src_length)                      {                          length = src_length - start;                      }                        return ((string)argumentValues[0]).Substring(start' length);                    case FunctionId.Trim:                      {                          Debug.Assert(_argumentCount == 1' "Invalid argument argumentCount for " + s_funcs[_info]._name + " : " + _argumentCount.ToString(FormatProvider));                          Debug.Assert((argumentValues[0] is string) || (argumentValues[0] is SqlString)' "Invalid argument type for " + s_funcs[_info]._name);                            if (DataStorage.IsObjectNull(argumentValues[0]))                              return DBNull.Value;                            if (argumentValues[0] is SqlString)                              argumentValues[0] = ((SqlString)argumentValues[0]).Value;                            return (((string)argumentValues[0]).Trim());                      }                    case FunctionId.Convert:                      if (_argumentCount != 2)                          throw ExprException.FunctionArgumentCount(_name);                        if (argumentValues[0] == DBNull.Value)                      {                          return DBNull.Value;                      }                        Type type = (Type)argumentValues[1];                      StorageType mytype = DataStorage.GetStorageType(type);                      storageType = DataStorage.GetStorageType(argumentValues[0].GetType());                        if (mytype == StorageType.DateTimeOffset)                      {                          if (storageType == StorageType.String)                          {                              return SqlConvert.ConvertStringToDateTimeOffset((string)argumentValues[0]' FormatProvider);                          }                      }                        if (StorageType.Object != mytype)                      {                          if ((mytype == StorageType.Guid) && (storageType == StorageType.String))                              return new Guid((string)argumentValues[0]);                            if (ExpressionNode.IsFloatSql(storageType) && ExpressionNode.IsIntegerSql(mytype))                          {                              if (StorageType.Single == storageType)                              {                                  return SqlConvert.ChangeType2((float)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Single' typeof(float)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Double == storageType)                              {                                  return SqlConvert.ChangeType2((double)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Double' typeof(double)' FormatProvider)' mytype' type' FormatProvider);                              }                              else if (StorageType.Decimal == storageType)                              {                                  return SqlConvert.ChangeType2((decimal)SqlConvert.ChangeType2(argumentValues[0]' StorageType.Decimal' typeof(decimal)' FormatProvider)' mytype' type' FormatProvider);                              }                              return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                          }                            return SqlConvert.ChangeType2(argumentValues[0]' mytype' type' FormatProvider);                      }                        return argumentValues[0];                    case FunctionId.DateTimeOffset:                      if (argumentValues[0] == DBNull.Value || argumentValues[1] == DBNull.Value || argumentValues[2] == DBNull.Value)                          return DBNull.Value;                      switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }                      if ((int)argumentValues[1] < -14 || (int)argumentValues[1] > 14)                          throw ExprException.InvalidHoursArgument();                      if ((int)argumentValues[2] < -59 || (int)argumentValues[2] > 59)                          throw ExprException.InvalidMinutesArgument();                      // range should be within -14 hours and  +14 hours                      if ((int)argumentValues[1] == 14 && (int)argumentValues[2] > 0)                          throw ExprException.InvalidTimeZoneRange();                      if ((int)argumentValues[1] == -14 && (int)argumentValues[2] < 0)                          throw ExprException.InvalidTimeZoneRange();                        return new DateTimeOffset((DateTime)argumentValues[0]' new TimeSpan((int)argumentValues[1]' (int)argumentValues[2]' 0));                    default:                      throw ExprException.UndefinedFunction(s_funcs[_info]._name);              }
Magic Number,System.Data,Function,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,Function,The following statement contains a magic number: if (a3 != null)                  _parameters[2] = a3;
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,SqlResultType,The following statement contains a magic number: switch (typeCode)              {                  case 23: return 24;                  case 20: return 21;                  case 18: return 19;                  case 16: return 17;                  case 14: return 15;                  case 12: return 13;                  case 9:                  case 10: return 11;                  case 6:                  case 7: return 8;                  case 3:                  case 4: return 5;                  case 1: return 2;                  case -2: return -1;                  case -5: return -4;                  case -8: return -7;                  default: return typeCode;              }
Magic Number,System.Data,LikeNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,Eval,The following statement contains a magic number: char[] trimChars = new char[2] { (char)0x20' (char)0x3000 };
Magic Number,System.Data,LikeNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,AnalyzePattern,The following statement contains a magic number: while (i < length)              {                  if (patchars[i] == '*' || patchars[i] == '%')                  {                      // replace conseq. * or % with one..                      while ((patchars[i] == '*' || patchars[i] == '%') && i < length)                          i++;                        // we allowing only *str* pattern                      if ((i < length && newLength > 0) || stars >= 2)                      {                          // we have a star inside string constant..                          throw ExprException.InvalidPattern(pat);                      }                      stars++;                  }                  else if (patchars[i] == '[')                  {                      i++;                      if (i >= length)                      {                          throw ExprException.InvalidPattern(pat);                      }                      constchars[newLength++] = patchars[i++];                        if (i >= length)                      {                          throw ExprException.InvalidPattern(pat);                      }                        if (patchars[i] != ']')                      {                          throw ExprException.InvalidPattern(pat);                      }                      i++;                  }                  else                  {                      constchars[newLength++] = patchars[i];                      i++;                  }              }
Magic Number,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,SchemaMapping,The following statement contains a magic number: if (adapter.ShouldSerializeFillLoadOption())              {                  _loadOption = adapter.FillLoadOption;              }              else if (adapter.AcceptChangesDuringFill)              {                  _loadOption = (LoadOption)4; // true              }              else              {                  _loadOption = (LoadOption)5; //false              }
Magic Number,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,SchemaMapping,The following statement contains a magic number: if (adapter.ShouldSerializeFillLoadOption())              {                  _loadOption = adapter.FillLoadOption;              }              else if (adapter.AcceptChangesDuringFill)              {                  _loadOption = (LoadOption)4; // true              }              else              {                  _loadOption = (LoadOption)5; //false              }
Magic Number,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,LoadDataRow,The following statement contains a magic number: try              {                  _dataReader.GetValues(_readerDataValues);                  object[] mapped = GetMappedValues();                    DataRow dataRow;                  switch (_loadOption)                  {                      case LoadOption.OverwriteChanges:                      case LoadOption.PreserveChanges:                      case LoadOption.Upsert:                          dataRow = _dataTable.LoadDataRow(mapped' _loadOption);                          break;                      case (LoadOption)4: // true                          dataRow = _dataTable.LoadDataRow(mapped' true);                          break;                      case (LoadOption)5: // false                          dataRow = _dataTable.LoadDataRow(mapped' false);                          break;                      default:                          Debug.Assert(false' "unexpected LoadOption");                          throw ADP.InvalidLoadOption(_loadOption);                  }                  if ((null != _chapterMap) && (null != _dataSet))                  {                      LoadDataRowChapters(dataRow);                  }              }              finally              {                  if (null != _chapterMap)                  {                      FreeDataRowChapters();                  }              }
Magic Number,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,LoadDataRow,The following statement contains a magic number: try              {                  _dataReader.GetValues(_readerDataValues);                  object[] mapped = GetMappedValues();                    DataRow dataRow;                  switch (_loadOption)                  {                      case LoadOption.OverwriteChanges:                      case LoadOption.PreserveChanges:                      case LoadOption.Upsert:                          dataRow = _dataTable.LoadDataRow(mapped' _loadOption);                          break;                      case (LoadOption)4: // true                          dataRow = _dataTable.LoadDataRow(mapped' true);                          break;                      case (LoadOption)5: // false                          dataRow = _dataTable.LoadDataRow(mapped' false);                          break;                      default:                          Debug.Assert(false' "unexpected LoadOption");                          throw ADP.InvalidLoadOption(_loadOption);                  }                  if ((null != _chapterMap) && (null != _dataSet))                  {                      LoadDataRowChapters(dataRow);                  }              }              finally              {                  if (null != _chapterMap)                  {                      FreeDataRowChapters();                  }              }
Magic Number,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,SetupSchemaWithKeyInfo,The following statement contains a magic number: bool addPrimaryKeys = (((0 == _dataTable.PrimaryKey.Length) && ((4 <= (int)_loadOption) || (0 == _dataTable.Rows.Count)))                                      || (0 == _dataTable.Columns.Count));
Magic Number,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,SetupSchemaWithKeyInfo,The following statement contains a magic number: try              {                  for (int sortedIndex = 0; sortedIndex < schemaRows.Length; ++sortedIndex)                  {                      DbSchemaRow schemaRow = schemaRows[sortedIndex];                        int unsortedIndex = schemaRow.UnsortedIndex;                        bool ischapter = false;                      Type fieldType = schemaRow.DataType;                      if (null == fieldType)                      {                          fieldType = _dataReader.GetFieldType(sortedIndex);                      }                      if (null == fieldType)                      {                          throw ADP.MissingDataReaderFieldType(sortedIndex);                      }                        // if IDataReader' hierarchy exists and we will use an Int32'AutoIncrementColumn in this table                      if (typeof(IDataReader).IsAssignableFrom(fieldType))                      {                          if (null == chapterIndexMap)                          {                              chapterIndexMap = new bool[schemaRows.Length];                          }                          chapterIndexMap[unsortedIndex] = ischapter = true;                          fieldType = typeof(int);                      }                      else if (typeof(System.Data.SqlTypes.SqlXml).IsAssignableFrom(fieldType))                      {                          if (null == _xmlMap)                          {                              _xmlMap = new int[schemaRows.Length];                          }                          _xmlMap[sortedIndex] = SqlXml;                      }                      else if (typeof(System.Xml.XmlReader).IsAssignableFrom(fieldType))                      {                          fieldType = typeof(string);                          if (null == _xmlMap)                          {                              _xmlMap = new int[schemaRows.Length];                          }                          _xmlMap[sortedIndex] = XmlDocument;                      }                        DataColumn dataColumn = null;                      if (!schemaRow.IsHidden)                      {                          dataColumn = _tableMapping.GetDataColumn(_fieldNames[sortedIndex]' fieldType' _dataTable' mappingAction' schemaAction);                      }                        string basetable = /*schemaRow.BaseServerName+schemaRow.BaseCatalogName+schemaRow.BaseSchemaName+*/ schemaRow.BaseTableName;                      if (null == dataColumn)                      {                          if (null == columnIndexMap)                          {                              columnIndexMap = CreateIndexMap(schemaRows.Length' unsortedIndex);                          }                          columnIndexMap[unsortedIndex] = -1;                            // if the column is not mapped and it is a key' then don't add any key information                          if (schemaRow.IsKey)                          {  #if DEBUG                              if (AdapterSwitches.DataSchema.TraceVerbose)                              {                                  Debug.WriteLine("SetupSchema: partial primary key detected");                              }  #endif                              // if the hidden key comes from a different table - don't throw away the primary key                              // example SELECT [T2].[ID]' [T2].[ProdID]' [T2].[VendorName] FROM [Vendor] AS [T2]' [Prod] AS [T1] WHERE (([T1].[ProdID] = [T2].[ProdID]))                              if (keyFromMultiTable || (schemaRow.BaseTableName == keyBaseTable))                              {                                  addPrimaryKeys = false; // don't add any future keys now                                  keys = null; // get rid of any keys we've seen                              }                          }                          continue; // null means ignore (mapped to nothing)                      }                      else if ((null != _xmlMap) && (0 != _xmlMap[sortedIndex]))                      {                          if (typeof(System.Data.SqlTypes.SqlXml) == dataColumn.DataType)                          {                              _xmlMap[sortedIndex] = SqlXml;                          }                          else if (typeof(System.Xml.XmlDocument) == dataColumn.DataType)                          {                              _xmlMap[sortedIndex] = XmlDocument;                          }                          else                          {                              _xmlMap[sortedIndex] = 0; // datacolumn is not a specific Xml dataType' i.e. string                                int total = 0;                              for (int x = 0; x < _xmlMap.Length; ++x)                              {                                  total += _xmlMap[x];                              }                              if (0 == total)                              { // not mapping to a specific Xml datatype' get rid of the map                                  _xmlMap = null;                              }                          }                      }                        if (schemaRow.IsKey)                      {                          if (basetable != keyBaseTable)                          {                              if (null == keyBaseTable)                              {                                  keyBaseTable = basetable;                              }                              else keyFromMultiTable = true;                          }                      }                        if (ischapter)                      {                          if (null == dataColumn.Table)                          {                              dataColumn.AllowDBNull = false;                              dataColumn.AutoIncrement = true;                              dataColumn.ReadOnly = true;                          }                          else if (!dataColumn.AutoIncrement)                          {                              throw ADP.FillChapterAutoIncrement();                          }                      }                      else                      {                          if (!commonFromMultiTable)                          {                              if ((basetable != commonBaseTable) && (!string.IsNullOrEmpty(basetable)))                              {                                  if (null == commonBaseTable)                                  {                                      commonBaseTable = basetable;                                  }                                  else                                  {                                      commonFromMultiTable = true;                                  }                              }                          }                          if (4 <= (int)_loadOption)                          {                              if (schemaRow.IsAutoIncrement && DataColumn.IsAutoIncrementType(fieldType))                              {                                  // CONSIDER: use T-SQL "IDENT_INCR('table_or_view')" and "IDENT_SEED('table_or_view')"                                  //           functions to obtain the actual increment and seed values                                  dataColumn.AutoIncrement = true;                                    if (!schemaRow.AllowDBNull)                                  {                                      dataColumn.AllowDBNull = false;                                  }                              }                                // setup maxLength' only for string columns since this is all the DataSet supports                              if (fieldType == typeof(string))                              {                                  // schemaRow.Size is count of characters for string columns' count of bytes otherwise                                  dataColumn.MaxLength = schemaRow.Size > 0 ? schemaRow.Size : -1;                              }                                if (schemaRow.IsReadOnly)                              {                                  dataColumn.ReadOnly = true;                              }                              if (!schemaRow.AllowDBNull && (!schemaRow.IsReadOnly || schemaRow.IsKey))                              {                                  dataColumn.AllowDBNull = false;                              }                                if (schemaRow.IsUnique && !schemaRow.IsKey && !fieldType.IsArray)                              {                                  // note' arrays are not comparable so only mark non-arrays as unique' ie timestamp columns                                  // are unique' but not comparable                                  dataColumn.Unique = true;                                    if (!schemaRow.AllowDBNull)                                  {                                      dataColumn.AllowDBNull = false;                                  }                              }                          }                          else if (null == dataColumn.Table)                          {                              dataColumn.AutoIncrement = schemaRow.IsAutoIncrement;                              dataColumn.AllowDBNull = schemaRow.AllowDBNull;                              dataColumn.ReadOnly = schemaRow.IsReadOnly;                              dataColumn.Unique = schemaRow.IsUnique;                                if (fieldType == typeof(string) || (fieldType == typeof(SqlTypes.SqlString)))                              {                                  // schemaRow.Size is count of characters for string columns' count of bytes otherwise                                  dataColumn.MaxLength = schemaRow.Size;                              }                          }                      }                      if (null == dataColumn.Table)                      {                          if (4 > (int)_loadOption)                          {                              AddAdditionalProperties(dataColumn' schemaRow.DataRow);                          }                          AddItemToAllowRollback(ref addedItems' dataColumn);                          columnCollection.Add(dataColumn);                      }                        // The server sends us one key per table according to these rules.                      //                      // 1. If the table has a primary key' the server sends us this key.                      // 2. If the table has a primary key and a unique key' it sends us the primary key                      // 3. if the table has no primary key but has a unique key' it sends us the unique key                      //                      // In case 3' we will promote a unique key to a primary key IFF all the columns that compose                      // that key are not nullable since no columns in a primary key can be null.  If one or more                      // of the keys is nullable' then we will add a unique constraint.                      //                      if (addPrimaryKeys && schemaRow.IsKey)                      {                          if (keys == null)                          {                              keys = new DataColumn[schemaRows.Length];                          }                          keys[keyCount++] = dataColumn;  #if DEBUG                          if (AdapterSwitches.DataSchema.TraceVerbose)                          {                              Debug.WriteLine("SetupSchema: building list of " + ((isPrimary) ? "PrimaryKey" : "UniqueConstraint"));                          }  #endif                          // see case 3 above' we do want dataColumn.AllowDBNull not schemaRow.AllowDBNull                          // otherwise adding PrimaryKey will change AllowDBNull to false                          if (isPrimary && dataColumn.AllowDBNull)                          {  #if DEBUG                              if (AdapterSwitches.DataSchema.TraceVerbose)                              {                                  Debug.WriteLine("SetupSchema: changing PrimaryKey into UniqueContraint");                              }  #endif                              isPrimary = false;                          }                      }                        if (null != columnIndexMap)                      {                          columnIndexMap[unsortedIndex] = dataColumn.Ordinal;                      }                      else if (unsortedIndex != dataColumn.Ordinal)                      {                          columnIndexMap = CreateIndexMap(schemaRows.Length' unsortedIndex);                          columnIndexMap[unsortedIndex] = dataColumn.Ordinal;                      }                      mappingCount++;                  }                    bool addDataRelation = false;                  DataColumn chapterColumn = null;                  if (null != chapterValue)                  { // add the extra column in the child table                      Type fieldType = chapterValue.GetType();                      chapterColumn = _tableMapping.GetDataColumn(_tableMapping.SourceTable' fieldType' _dataTable' mappingAction' schemaAction);                      if (null != chapterColumn)                      {                          if (null == chapterColumn.Table)                          {                              chapterColumn.ReadOnly = true;                              chapterColumn.AllowDBNull = false;                                AddItemToAllowRollback(ref addedItems' chapterColumn);                              columnCollection.Add(chapterColumn);                              addDataRelation = (null != parentChapterColumn);                          }                          mappingCount++;                      }                  }                    if (0 < mappingCount)                  {                      if ((null != _dataSet) && null == _dataTable.DataSet)                      {                          AddItemToAllowRollback(ref addedItems' _dataTable);                          _dataSet.Tables.Add(_dataTable);                      }                      // setup the key                      if (addPrimaryKeys && (null != keys))                      {                          if (keyCount < keys.Length)                          {                              keys = ResizeColumnArray(keys' keyCount);                          }                            if (isPrimary)                          {  #if DEBUG                              if (AdapterSwitches.DataSchema.TraceVerbose)                              {                                  Debug.WriteLine("SetupSchema: set_PrimaryKey");                              }  #endif                              _dataTable.PrimaryKey = keys;                          }                          else                          {                              UniqueConstraint unique = new UniqueConstraint(""' keys);                              ConstraintCollection constraints = _dataTable.Constraints;                              int constraintCount = constraints.Count;                              for (int i = 0; i < constraintCount; ++i)                              {                                  if (unique.Equals(constraints[i]))                                  {  #if DEBUG                                      if (AdapterSwitches.DataSchema.TraceVerbose)                                      {                                          Debug.WriteLine("SetupSchema: duplicate Contraint detected");                                      }  #endif                                      unique = null;                                      break;                                  }                              }                              if (null != unique)                              {  #if DEBUG                                  if (AdapterSwitches.DataSchema.TraceVerbose)                                  {                                      Debug.WriteLine("SetupSchema: adding new UniqueConstraint");                                  }  #endif                                  constraints.Add(unique);                              }                          }                      }                      if (!commonFromMultiTable && !string.IsNullOrEmpty(commonBaseTable) && string.IsNullOrEmpty(_dataTable.TableName))                      {                          _dataTable.TableName = commonBaseTable;                      }                      if (gettingData)                      {                          _indexMap = columnIndexMap;                          _chapterMap = chapterIndexMap;                          dataValues = SetupMapping(schemaRows.Length' columnCollection' chapterColumn' chapterValue);                      }                      else                      {                          // debug only' but for retail debug ability                          _mappedMode = -1;                      }                  }                  else                  {                      _dataTable = null;                  }                  if (addDataRelation)                  {                      AddRelation(parentChapterColumn' chapterColumn);                  }              }              catch (Exception e) when (ADP.IsCatchableOrSecurityExceptionType(e))              {                  RollbackAddedItems(addedItems);                  throw;              }
Magic Number,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,SetupSchemaWithKeyInfo,The following statement contains a magic number: try              {                  for (int sortedIndex = 0; sortedIndex < schemaRows.Length; ++sortedIndex)                  {                      DbSchemaRow schemaRow = schemaRows[sortedIndex];                        int unsortedIndex = schemaRow.UnsortedIndex;                        bool ischapter = false;                      Type fieldType = schemaRow.DataType;                      if (null == fieldType)                      {                          fieldType = _dataReader.GetFieldType(sortedIndex);                      }                      if (null == fieldType)                      {                          throw ADP.MissingDataReaderFieldType(sortedIndex);                      }                        // if IDataReader' hierarchy exists and we will use an Int32'AutoIncrementColumn in this table                      if (typeof(IDataReader).IsAssignableFrom(fieldType))                      {                          if (null == chapterIndexMap)                          {                              chapterIndexMap = new bool[schemaRows.Length];                          }                          chapterIndexMap[unsortedIndex] = ischapter = true;                          fieldType = typeof(int);                      }                      else if (typeof(System.Data.SqlTypes.SqlXml).IsAssignableFrom(fieldType))                      {                          if (null == _xmlMap)                          {                              _xmlMap = new int[schemaRows.Length];                          }                          _xmlMap[sortedIndex] = SqlXml;                      }                      else if (typeof(System.Xml.XmlReader).IsAssignableFrom(fieldType))                      {                          fieldType = typeof(string);                          if (null == _xmlMap)                          {                              _xmlMap = new int[schemaRows.Length];                          }                          _xmlMap[sortedIndex] = XmlDocument;                      }                        DataColumn dataColumn = null;                      if (!schemaRow.IsHidden)                      {                          dataColumn = _tableMapping.GetDataColumn(_fieldNames[sortedIndex]' fieldType' _dataTable' mappingAction' schemaAction);                      }                        string basetable = /*schemaRow.BaseServerName+schemaRow.BaseCatalogName+schemaRow.BaseSchemaName+*/ schemaRow.BaseTableName;                      if (null == dataColumn)                      {                          if (null == columnIndexMap)                          {                              columnIndexMap = CreateIndexMap(schemaRows.Length' unsortedIndex);                          }                          columnIndexMap[unsortedIndex] = -1;                            // if the column is not mapped and it is a key' then don't add any key information                          if (schemaRow.IsKey)                          {  #if DEBUG                              if (AdapterSwitches.DataSchema.TraceVerbose)                              {                                  Debug.WriteLine("SetupSchema: partial primary key detected");                              }  #endif                              // if the hidden key comes from a different table - don't throw away the primary key                              // example SELECT [T2].[ID]' [T2].[ProdID]' [T2].[VendorName] FROM [Vendor] AS [T2]' [Prod] AS [T1] WHERE (([T1].[ProdID] = [T2].[ProdID]))                              if (keyFromMultiTable || (schemaRow.BaseTableName == keyBaseTable))                              {                                  addPrimaryKeys = false; // don't add any future keys now                                  keys = null; // get rid of any keys we've seen                              }                          }                          continue; // null means ignore (mapped to nothing)                      }                      else if ((null != _xmlMap) && (0 != _xmlMap[sortedIndex]))                      {                          if (typeof(System.Data.SqlTypes.SqlXml) == dataColumn.DataType)                          {                              _xmlMap[sortedIndex] = SqlXml;                          }                          else if (typeof(System.Xml.XmlDocument) == dataColumn.DataType)                          {                              _xmlMap[sortedIndex] = XmlDocument;                          }                          else                          {                              _xmlMap[sortedIndex] = 0; // datacolumn is not a specific Xml dataType' i.e. string                                int total = 0;                              for (int x = 0; x < _xmlMap.Length; ++x)                              {                                  total += _xmlMap[x];                              }                              if (0 == total)                              { // not mapping to a specific Xml datatype' get rid of the map                                  _xmlMap = null;                              }                          }                      }                        if (schemaRow.IsKey)                      {                          if (basetable != keyBaseTable)                          {                              if (null == keyBaseTable)                              {                                  keyBaseTable = basetable;                              }                              else keyFromMultiTable = true;                          }                      }                        if (ischapter)                      {                          if (null == dataColumn.Table)                          {                              dataColumn.AllowDBNull = false;                              dataColumn.AutoIncrement = true;                              dataColumn.ReadOnly = true;                          }                          else if (!dataColumn.AutoIncrement)                          {                              throw ADP.FillChapterAutoIncrement();                          }                      }                      else                      {                          if (!commonFromMultiTable)                          {                              if ((basetable != commonBaseTable) && (!string.IsNullOrEmpty(basetable)))                              {                                  if (null == commonBaseTable)                                  {                                      commonBaseTable = basetable;                                  }                                  else                                  {                                      commonFromMultiTable = true;                                  }                              }                          }                          if (4 <= (int)_loadOption)                          {                              if (schemaRow.IsAutoIncrement && DataColumn.IsAutoIncrementType(fieldType))                              {                                  // CONSIDER: use T-SQL "IDENT_INCR('table_or_view')" and "IDENT_SEED('table_or_view')"                                  //           functions to obtain the actual increment and seed values                                  dataColumn.AutoIncrement = true;                                    if (!schemaRow.AllowDBNull)                                  {                                      dataColumn.AllowDBNull = false;                                  }                              }                                // setup maxLength' only for string columns since this is all the DataSet supports                              if (fieldType == typeof(string))                              {                                  // schemaRow.Size is count of characters for string columns' count of bytes otherwise                                  dataColumn.MaxLength = schemaRow.Size > 0 ? schemaRow.Size : -1;                              }                                if (schemaRow.IsReadOnly)                              {                                  dataColumn.ReadOnly = true;                              }                              if (!schemaRow.AllowDBNull && (!schemaRow.IsReadOnly || schemaRow.IsKey))                              {                                  dataColumn.AllowDBNull = false;                              }                                if (schemaRow.IsUnique && !schemaRow.IsKey && !fieldType.IsArray)                              {                                  // note' arrays are not comparable so only mark non-arrays as unique' ie timestamp columns                                  // are unique' but not comparable                                  dataColumn.Unique = true;                                    if (!schemaRow.AllowDBNull)                                  {                                      dataColumn.AllowDBNull = false;                                  }                              }                          }                          else if (null == dataColumn.Table)                          {                              dataColumn.AutoIncrement = schemaRow.IsAutoIncrement;                              dataColumn.AllowDBNull = schemaRow.AllowDBNull;                              dataColumn.ReadOnly = schemaRow.IsReadOnly;                              dataColumn.Unique = schemaRow.IsUnique;                                if (fieldType == typeof(string) || (fieldType == typeof(SqlTypes.SqlString)))                              {                                  // schemaRow.Size is count of characters for string columns' count of bytes otherwise                                  dataColumn.MaxLength = schemaRow.Size;                              }                          }                      }                      if (null == dataColumn.Table)                      {                          if (4 > (int)_loadOption)                          {                              AddAdditionalProperties(dataColumn' schemaRow.DataRow);                          }                          AddItemToAllowRollback(ref addedItems' dataColumn);                          columnCollection.Add(dataColumn);                      }                        // The server sends us one key per table according to these rules.                      //                      // 1. If the table has a primary key' the server sends us this key.                      // 2. If the table has a primary key and a unique key' it sends us the primary key                      // 3. if the table has no primary key but has a unique key' it sends us the unique key                      //                      // In case 3' we will promote a unique key to a primary key IFF all the columns that compose                      // that key are not nullable since no columns in a primary key can be null.  If one or more                      // of the keys is nullable' then we will add a unique constraint.                      //                      if (addPrimaryKeys && schemaRow.IsKey)                      {                          if (keys == null)                          {                              keys = new DataColumn[schemaRows.Length];                          }                          keys[keyCount++] = dataColumn;  #if DEBUG                          if (AdapterSwitches.DataSchema.TraceVerbose)                          {                              Debug.WriteLine("SetupSchema: building list of " + ((isPrimary) ? "PrimaryKey" : "UniqueConstraint"));                          }  #endif                          // see case 3 above' we do want dataColumn.AllowDBNull not schemaRow.AllowDBNull                          // otherwise adding PrimaryKey will change AllowDBNull to false                          if (isPrimary && dataColumn.AllowDBNull)                          {  #if DEBUG                              if (AdapterSwitches.DataSchema.TraceVerbose)                              {                                  Debug.WriteLine("SetupSchema: changing PrimaryKey into UniqueContraint");                              }  #endif                              isPrimary = false;                          }                      }                        if (null != columnIndexMap)                      {                          columnIndexMap[unsortedIndex] = dataColumn.Ordinal;                      }                      else if (unsortedIndex != dataColumn.Ordinal)                      {                          columnIndexMap = CreateIndexMap(schemaRows.Length' unsortedIndex);                          columnIndexMap[unsortedIndex] = dataColumn.Ordinal;                      }                      mappingCount++;                  }                    bool addDataRelation = false;                  DataColumn chapterColumn = null;                  if (null != chapterValue)                  { // add the extra column in the child table                      Type fieldType = chapterValue.GetType();                      chapterColumn = _tableMapping.GetDataColumn(_tableMapping.SourceTable' fieldType' _dataTable' mappingAction' schemaAction);                      if (null != chapterColumn)                      {                          if (null == chapterColumn.Table)                          {                              chapterColumn.ReadOnly = true;                              chapterColumn.AllowDBNull = false;                                AddItemToAllowRollback(ref addedItems' chapterColumn);                              columnCollection.Add(chapterColumn);                              addDataRelation = (null != parentChapterColumn);                          }                          mappingCount++;                      }                  }                    if (0 < mappingCount)                  {                      if ((null != _dataSet) && null == _dataTable.DataSet)                      {                          AddItemToAllowRollback(ref addedItems' _dataTable);                          _dataSet.Tables.Add(_dataTable);                      }                      // setup the key                      if (addPrimaryKeys && (null != keys))                      {                          if (keyCount < keys.Length)                          {                              keys = ResizeColumnArray(keys' keyCount);                          }                            if (isPrimary)                          {  #if DEBUG                              if (AdapterSwitches.DataSchema.TraceVerbose)                              {                                  Debug.WriteLine("SetupSchema: set_PrimaryKey");                              }  #endif                              _dataTable.PrimaryKey = keys;                          }                          else                          {                              UniqueConstraint unique = new UniqueConstraint(""' keys);                              ConstraintCollection constraints = _dataTable.Constraints;                              int constraintCount = constraints.Count;                              for (int i = 0; i < constraintCount; ++i)                              {                                  if (unique.Equals(constraints[i]))                                  {  #if DEBUG                                      if (AdapterSwitches.DataSchema.TraceVerbose)                                      {                                          Debug.WriteLine("SetupSchema: duplicate Contraint detected");                                      }  #endif                                      unique = null;                                      break;                                  }                              }                              if (null != unique)                              {  #if DEBUG                                  if (AdapterSwitches.DataSchema.TraceVerbose)                                  {                                      Debug.WriteLine("SetupSchema: adding new UniqueConstraint");                                  }  #endif                                  constraints.Add(unique);                              }                          }                      }                      if (!commonFromMultiTable && !string.IsNullOrEmpty(commonBaseTable) && string.IsNullOrEmpty(_dataTable.TableName))                      {                          _dataTable.TableName = commonBaseTable;                      }                      if (gettingData)                      {                          _indexMap = columnIndexMap;                          _chapterMap = chapterIndexMap;                          dataValues = SetupMapping(schemaRows.Length' columnCollection' chapterColumn' chapterValue);                      }                      else                      {                          // debug only' but for retail debug ability                          _mappedMode = -1;                      }                  }                  else                  {                      _dataTable = null;                  }                  if (addDataRelation)                  {                      AddRelation(parentChapterColumn' chapterColumn);                  }              }              catch (Exception e) when (ADP.IsCatchableOrSecurityExceptionType(e))              {                  RollbackAddedItems(addedItems);                  throw;              }
Magic Number,System.Data.SqlTypes,SqlDateTime,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDateTime.cs,SqlDateTime,The following statement contains a magic number: if (year >= s_minYear && year <= s_maxYear && month >= 1 && month <= 12)              {                  int[] days = IsLeapYear(year) ? s_daysToMonth366 : s_daysToMonth365;                  if (day >= 1 && day <= days[month] - days[month - 1])                  {                      int y = year - 1;                      int dayticks = y * 365 + y / 4 - y / 100 + y / 400 + days[month - 1] + day - 1;                      dayticks -= s_dayBase;                        if (dayticks >= s_minDay && dayticks <= s_maxDay &&                          hour >= 0 && hour < 24 && minute >= 0 && minute < 60 &&                          second >= 0 && second < 60 && millisecond >= 0 && millisecond < 1000.0)                      {                          double ticksForMilisecond = millisecond * s_SQLTicksPerMillisecond + 0.5;                          int timeticks = hour * SQLTicksPerHour + minute * SQLTicksPerMinute + second * SQLTicksPerSecond +                              (int)ticksForMilisecond;                            if (timeticks > s_maxTime)                          {                              // Only rounding up could cause time to become greater than MaxTime.                              Debug.Assert(timeticks == s_maxTime + 1);                                // Make time to be zero' and increment day.                              timeticks = 0;                              dayticks++;                          }                            // Success. Call ctor here which will again check dayticks and timeticks are within range.                          // All other cases will throw exception below.                          this = new SqlDateTime(dayticks' timeticks);                          return;                      }                  }              }
Magic Number,System.Data.SqlTypes,SqlDateTime,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDateTime.cs,SqlDateTime,The following statement contains a magic number: if (year >= s_minYear && year <= s_maxYear && month >= 1 && month <= 12)              {                  int[] days = IsLeapYear(year) ? s_daysToMonth366 : s_daysToMonth365;                  if (day >= 1 && day <= days[month] - days[month - 1])                  {                      int y = year - 1;                      int dayticks = y * 365 + y / 4 - y / 100 + y / 400 + days[month - 1] + day - 1;                      dayticks -= s_dayBase;                        if (dayticks >= s_minDay && dayticks <= s_maxDay &&                          hour >= 0 && hour < 24 && minute >= 0 && minute < 60 &&                          second >= 0 && second < 60 && millisecond >= 0 && millisecond < 1000.0)                      {                          double ticksForMilisecond = millisecond * s_SQLTicksPerMillisecond + 0.5;                          int timeticks = hour * SQLTicksPerHour + minute * SQLTicksPerMinute + second * SQLTicksPerSecond +                              (int)ticksForMilisecond;                            if (timeticks > s_maxTime)                          {                              // Only rounding up could cause time to become greater than MaxTime.                              Debug.Assert(timeticks == s_maxTime + 1);                                // Make time to be zero' and increment day.                              timeticks = 0;                              dayticks++;                          }                            // Success. Call ctor here which will again check dayticks and timeticks are within range.                          // All other cases will throw exception below.                          this = new SqlDateTime(dayticks' timeticks);                          return;                      }                  }              }
Magic Number,System.Data.SqlTypes,SqlDateTime,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDateTime.cs,SqlDateTime,The following statement contains a magic number: if (year >= s_minYear && year <= s_maxYear && month >= 1 && month <= 12)              {                  int[] days = IsLeapYear(year) ? s_daysToMonth366 : s_daysToMonth365;                  if (day >= 1 && day <= days[month] - days[month - 1])                  {                      int y = year - 1;                      int dayticks = y * 365 + y / 4 - y / 100 + y / 400 + days[month - 1] + day - 1;                      dayticks -= s_dayBase;                        if (dayticks >= s_minDay && dayticks <= s_maxDay &&                          hour >= 0 && hour < 24 && minute >= 0 && minute < 60 &&                          second >= 0 && second < 60 && millisecond >= 0 && millisecond < 1000.0)                      {                          double ticksForMilisecond = millisecond * s_SQLTicksPerMillisecond + 0.5;                          int timeticks = hour * SQLTicksPerHour + minute * SQLTicksPerMinute + second * SQLTicksPerSecond +                              (int)ticksForMilisecond;                            if (timeticks > s_maxTime)                          {                              // Only rounding up could cause time to become greater than MaxTime.                              Debug.Assert(timeticks == s_maxTime + 1);                                // Make time to be zero' and increment day.                              timeticks = 0;                              dayticks++;                          }                            // Success. Call ctor here which will again check dayticks and timeticks are within range.                          // All other cases will throw exception below.                          this = new SqlDateTime(dayticks' timeticks);                          return;                      }                  }              }
Magic Number,System.Data.SqlTypes,SqlDateTime,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDateTime.cs,SqlDateTime,The following statement contains a magic number: if (year >= s_minYear && year <= s_maxYear && month >= 1 && month <= 12)              {                  int[] days = IsLeapYear(year) ? s_daysToMonth366 : s_daysToMonth365;                  if (day >= 1 && day <= days[month] - days[month - 1])                  {                      int y = year - 1;                      int dayticks = y * 365 + y / 4 - y / 100 + y / 400 + days[month - 1] + day - 1;                      dayticks -= s_dayBase;                        if (dayticks >= s_minDay && dayticks <= s_maxDay &&                          hour >= 0 && hour < 24 && minute >= 0 && minute < 60 &&                          second >= 0 && second < 60 && millisecond >= 0 && millisecond < 1000.0)                      {                          double ticksForMilisecond = millisecond * s_SQLTicksPerMillisecond + 0.5;                          int timeticks = hour * SQLTicksPerHour + minute * SQLTicksPerMinute + second * SQLTicksPerSecond +                              (int)ticksForMilisecond;                            if (timeticks > s_maxTime)                          {                              // Only rounding up could cause time to become greater than MaxTime.                              Debug.Assert(timeticks == s_maxTime + 1);                                // Make time to be zero' and increment day.                              timeticks = 0;                              dayticks++;                          }                            // Success. Call ctor here which will again check dayticks and timeticks are within range.                          // All other cases will throw exception below.                          this = new SqlDateTime(dayticks' timeticks);                          return;                      }                  }              }
Magic Number,System.Data.SqlTypes,SqlDateTime,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDateTime.cs,SqlDateTime,The following statement contains a magic number: if (year >= s_minYear && year <= s_maxYear && month >= 1 && month <= 12)              {                  int[] days = IsLeapYear(year) ? s_daysToMonth366 : s_daysToMonth365;                  if (day >= 1 && day <= days[month] - days[month - 1])                  {                      int y = year - 1;                      int dayticks = y * 365 + y / 4 - y / 100 + y / 400 + days[month - 1] + day - 1;                      dayticks -= s_dayBase;                        if (dayticks >= s_minDay && dayticks <= s_maxDay &&                          hour >= 0 && hour < 24 && minute >= 0 && minute < 60 &&                          second >= 0 && second < 60 && millisecond >= 0 && millisecond < 1000.0)                      {                          double ticksForMilisecond = millisecond * s_SQLTicksPerMillisecond + 0.5;                          int timeticks = hour * SQLTicksPerHour + minute * SQLTicksPerMinute + second * SQLTicksPerSecond +                              (int)ticksForMilisecond;                            if (timeticks > s_maxTime)                          {                              // Only rounding up could cause time to become greater than MaxTime.                              Debug.Assert(timeticks == s_maxTime + 1);                                // Make time to be zero' and increment day.                              timeticks = 0;                              dayticks++;                          }                            // Success. Call ctor here which will again check dayticks and timeticks are within range.                          // All other cases will throw exception below.                          this = new SqlDateTime(dayticks' timeticks);                          return;                      }                  }              }
Magic Number,System.Data.SqlTypes,SqlDateTime,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDateTime.cs,SqlDateTime,The following statement contains a magic number: if (year >= s_minYear && year <= s_maxYear && month >= 1 && month <= 12)              {                  int[] days = IsLeapYear(year) ? s_daysToMonth366 : s_daysToMonth365;                  if (day >= 1 && day <= days[month] - days[month - 1])                  {                      int y = year - 1;                      int dayticks = y * 365 + y / 4 - y / 100 + y / 400 + days[month - 1] + day - 1;                      dayticks -= s_dayBase;                        if (dayticks >= s_minDay && dayticks <= s_maxDay &&                          hour >= 0 && hour < 24 && minute >= 0 && minute < 60 &&                          second >= 0 && second < 60 && millisecond >= 0 && millisecond < 1000.0)                      {                          double ticksForMilisecond = millisecond * s_SQLTicksPerMillisecond + 0.5;                          int timeticks = hour * SQLTicksPerHour + minute * SQLTicksPerMinute + second * SQLTicksPerSecond +                              (int)ticksForMilisecond;                            if (timeticks > s_maxTime)                          {                              // Only rounding up could cause time to become greater than MaxTime.                              Debug.Assert(timeticks == s_maxTime + 1);                                // Make time to be zero' and increment day.                              timeticks = 0;                              dayticks++;                          }                            // Success. Call ctor here which will again check dayticks and timeticks are within range.                          // All other cases will throw exception below.                          this = new SqlDateTime(dayticks' timeticks);                          return;                      }                  }              }
Magic Number,System.Data.SqlTypes,SqlDateTime,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDateTime.cs,SqlDateTime,The following statement contains a magic number: if (year >= s_minYear && year <= s_maxYear && month >= 1 && month <= 12)              {                  int[] days = IsLeapYear(year) ? s_daysToMonth366 : s_daysToMonth365;                  if (day >= 1 && day <= days[month] - days[month - 1])                  {                      int y = year - 1;                      int dayticks = y * 365 + y / 4 - y / 100 + y / 400 + days[month - 1] + day - 1;                      dayticks -= s_dayBase;                        if (dayticks >= s_minDay && dayticks <= s_maxDay &&                          hour >= 0 && hour < 24 && minute >= 0 && minute < 60 &&                          second >= 0 && second < 60 && millisecond >= 0 && millisecond < 1000.0)                      {                          double ticksForMilisecond = millisecond * s_SQLTicksPerMillisecond + 0.5;                          int timeticks = hour * SQLTicksPerHour + minute * SQLTicksPerMinute + second * SQLTicksPerSecond +                              (int)ticksForMilisecond;                            if (timeticks > s_maxTime)                          {                              // Only rounding up could cause time to become greater than MaxTime.                              Debug.Assert(timeticks == s_maxTime + 1);                                // Make time to be zero' and increment day.                              timeticks = 0;                              dayticks++;                          }                            // Success. Call ctor here which will again check dayticks and timeticks are within range.                          // All other cases will throw exception below.                          this = new SqlDateTime(dayticks' timeticks);                          return;                      }                  }              }
Magic Number,System.Data.SqlTypes,SqlDateTime,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDateTime.cs,SqlDateTime,The following statement contains a magic number: if (year >= s_minYear && year <= s_maxYear && month >= 1 && month <= 12)              {                  int[] days = IsLeapYear(year) ? s_daysToMonth366 : s_daysToMonth365;                  if (day >= 1 && day <= days[month] - days[month - 1])                  {                      int y = year - 1;                      int dayticks = y * 365 + y / 4 - y / 100 + y / 400 + days[month - 1] + day - 1;                      dayticks -= s_dayBase;                        if (dayticks >= s_minDay && dayticks <= s_maxDay &&                          hour >= 0 && hour < 24 && minute >= 0 && minute < 60 &&                          second >= 0 && second < 60 && millisecond >= 0 && millisecond < 1000.0)                      {                          double ticksForMilisecond = millisecond * s_SQLTicksPerMillisecond + 0.5;                          int timeticks = hour * SQLTicksPerHour + minute * SQLTicksPerMinute + second * SQLTicksPerSecond +                              (int)ticksForMilisecond;                            if (timeticks > s_maxTime)                          {                              // Only rounding up could cause time to become greater than MaxTime.                              Debug.Assert(timeticks == s_maxTime + 1);                                // Make time to be zero' and increment day.                              timeticks = 0;                              dayticks++;                          }                            // Success. Call ctor here which will again check dayticks and timeticks are within range.                          // All other cases will throw exception below.                          this = new SqlDateTime(dayticks' timeticks);                          return;                      }                  }              }
Magic Number,System.Data.SqlTypes,SqlDateTime,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDateTime.cs,SqlDateTime,The following statement contains a magic number: if (year >= s_minYear && year <= s_maxYear && month >= 1 && month <= 12)              {                  int[] days = IsLeapYear(year) ? s_daysToMonth366 : s_daysToMonth365;                  if (day >= 1 && day <= days[month] - days[month - 1])                  {                      int y = year - 1;                      int dayticks = y * 365 + y / 4 - y / 100 + y / 400 + days[month - 1] + day - 1;                      dayticks -= s_dayBase;                        if (dayticks >= s_minDay && dayticks <= s_maxDay &&                          hour >= 0 && hour < 24 && minute >= 0 && minute < 60 &&                          second >= 0 && second < 60 && millisecond >= 0 && millisecond < 1000.0)                      {                          double ticksForMilisecond = millisecond * s_SQLTicksPerMillisecond + 0.5;                          int timeticks = hour * SQLTicksPerHour + minute * SQLTicksPerMinute + second * SQLTicksPerSecond +                              (int)ticksForMilisecond;                            if (timeticks > s_maxTime)                          {                              // Only rounding up could cause time to become greater than MaxTime.                              Debug.Assert(timeticks == s_maxTime + 1);                                // Make time to be zero' and increment day.                              timeticks = 0;                              dayticks++;                          }                            // Success. Call ctor here which will again check dayticks and timeticks are within range.                          // All other cases will throw exception below.                          this = new SqlDateTime(dayticks' timeticks);                          return;                      }                  }              }
Magic Number,System.Data.SqlTypes,SqlDateTime,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDateTime.cs,SqlDateTime,The following statement contains a magic number: if (year >= s_minYear && year <= s_maxYear && month >= 1 && month <= 12)              {                  int[] days = IsLeapYear(year) ? s_daysToMonth366 : s_daysToMonth365;                  if (day >= 1 && day <= days[month] - days[month - 1])                  {                      int y = year - 1;                      int dayticks = y * 365 + y / 4 - y / 100 + y / 400 + days[month - 1] + day - 1;                      dayticks -= s_dayBase;                        if (dayticks >= s_minDay && dayticks <= s_maxDay &&                          hour >= 0 && hour < 24 && minute >= 0 && minute < 60 &&                          second >= 0 && second < 60 && millisecond >= 0 && millisecond < 1000.0)                      {                          double ticksForMilisecond = millisecond * s_SQLTicksPerMillisecond + 0.5;                          int timeticks = hour * SQLTicksPerHour + minute * SQLTicksPerMinute + second * SQLTicksPerSecond +                              (int)ticksForMilisecond;                            if (timeticks > s_maxTime)                          {                              // Only rounding up could cause time to become greater than MaxTime.                              Debug.Assert(timeticks == s_maxTime + 1);                                // Make time to be zero' and increment day.                              timeticks = 0;                              dayticks++;                          }                            // Success. Call ctor here which will again check dayticks and timeticks are within range.                          // All other cases will throw exception below.                          this = new SqlDateTime(dayticks' timeticks);                          return;                      }                  }              }
Magic Number,System.Data.SqlTypes,SqlDateTime,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDateTime.cs,ToTimeSpan,The following statement contains a magic number: long millisecond = (long)(value.m_time / s_SQLTicksPerMillisecond + 0.5);
Magic Number,System.Data.SqlTypes,SqlDateTime,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDateTime.cs,ToDateTime,The following statement contains a magic number: long timeticks = ((long)(timepart / s_SQLTicksPerMillisecond + 0.5)) * TimeSpan.TicksPerMillisecond;
Magic Number,System.Data.SqlTypes,SqlDateTime,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDateTime.cs,FromTimeSpan,The following statement contains a magic number: int time = (int)((double)ticks / TimeSpan.TicksPerMillisecond * s_SQLTicksPerMillisecond + 0.5);
Magic Number,System.Data.SqlTypes,SqlDateTime,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDateTime.cs,IsLeapYear,The following statement contains a magic number: return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
Magic Number,System.Data.SqlTypes,SqlDateTime,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDateTime.cs,IsLeapYear,The following statement contains a magic number: return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
Magic Number,System.Data.SqlTypes,SqlDateTime,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDateTime.cs,IsLeapYear,The following statement contains a magic number: return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,CalculatePrecision,The following statement contains a magic number: if (decimalPart < decimalHelpers[tableIndex])              {                  tableIndex -= 2;                  if (decimalPart < decimalHelpers[tableIndex])                  {                      tableIndex -= 2;                      if (decimalPart < decimalHelpers[tableIndex])                      {                          tableIndex -= 1;                      }                      else                      {                          tableIndex += 1;                      }                  }                  else                  {                      tableIndex += 1;                  }              }              else              {                  tableIndex += 2;                  if (decimalPart < decimalHelpers[tableIndex])                  {                      tableIndex -= 1;                  }                  else                  {                      tableIndex += 1;                  }              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,CalculatePrecision,The following statement contains a magic number: if (decimalPart < decimalHelpers[tableIndex])              {                  tableIndex -= 2;                  if (decimalPart < decimalHelpers[tableIndex])                  {                      tableIndex -= 2;                      if (decimalPart < decimalHelpers[tableIndex])                      {                          tableIndex -= 1;                      }                      else                      {                          tableIndex += 1;                      }                  }                  else                  {                      tableIndex += 1;                  }              }              else              {                  tableIndex += 2;                  if (decimalPart < decimalHelpers[tableIndex])                  {                      tableIndex -= 1;                  }                  else                  {                      tableIndex += 1;                  }              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,CalculatePrecision,The following statement contains a magic number: if (decimalPart < decimalHelpers[tableIndex])              {                  tableIndex -= 2;                  if (decimalPart < decimalHelpers[tableIndex])                  {                      tableIndex -= 2;                      if (decimalPart < decimalHelpers[tableIndex])                      {                          tableIndex -= 1;                      }                      else                      {                          tableIndex += 1;                      }                  }                  else                  {                      tableIndex += 1;                  }              }              else              {                  tableIndex += 2;                  if (decimalPart < decimalHelpers[tableIndex])                  {                      tableIndex -= 1;                  }                  else                  {                      tableIndex += 1;                  }              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,CalculatePrecision,The following statement contains a magic number: if (decimalPart >= decimalHelpers[tableIndex])              {                  tableIndex += 1;                  if (tableIndex == 37 && decimalPart >= decimalHelpers[tableIndex])                  {                      // This can happen only if the actual value is greater than 1E+38'                      // in which case' tableIndex starts at 33 and ends at 37.                      // Note that in this case' the actual value will be out of SqlDeicmal's range'                      // and tableIndex is out of the array boudary. We'll throw later in ctors.                      tableIndex += 1;                  }              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The following statement contains a magic number: unchecked              {                  sgnscl = (uint)bits[3];                  _data1 = (uint)bits[0];                  _data2 = (uint)bits[1];                  _data3 = (uint)bits[2];                  _data4 = s_uiZero;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The following statement contains a magic number: unchecked              {                  sgnscl = (uint)bits[3];                  _data1 = (uint)bits[0];                  _data2 = (uint)bits[1];                  _data3 = (uint)bits[2];                  _data4 = s_uiZero;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The following statement contains a magic number: if (_data3 != 0)                  _bLen = 3;              else if (_data2 != 0)                  _bLen = 2;              else                  _bLen = 1;
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The following statement contains a magic number: if (_data3 != 0)                  _bLen = 3;              else if (_data2 != 0)                  _bLen = 2;              else                  _bLen = 1;
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The following statement contains a magic number: _bScale = (byte)((int)(sgnscl & 0xff0000) >> 16);
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The following statement contains a magic number: _data2 = (uint)(dwl >> 32);
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The following statement contains a magic number: _bLen = (byte)((_data2 == 0) ? 1 : 2);
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The following statement contains a magic number: if (bits == null)                  throw new ArgumentNullException(nameof(bits));              else if (bits.Length != 4)                  throw new ArgumentException(SQLResource.InvalidArraySizeMessage' nameof(bits));
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The following statement contains a magic number: _data3 = (uint)bits[2];
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The following statement contains a magic number: _data4 = (uint)bits[3];
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The following statement contains a magic number: for (int i = 3; i >= 0; i--)              {                  if (bits[i] != 0)                  {                      _bLen = (byte)(i + 1);                      break;                  }              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The following statement contains a magic number: if (data4 == 0)                  if (data3 == 0)                      if (data2 == 0)                          _bLen = 1;                      else                          _bLen = 2;                  else                      _bLen = 3;              else                  _bLen = 4;
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The following statement contains a magic number: if (data4 == 0)                  if (data3 == 0)                      if (data2 == 0)                          _bLen = 1;                      else                          _bLen = 2;                  else                      _bLen = 3;              else                  _bLen = 4;
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The following statement contains a magic number: if (data4 == 0)                  if (data3 == 0)                      if (data2 == 0)                          _bLen = 1;                      else                          _bLen = 2;                  else                      _bLen = 3;              else                  _bLen = 4;
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The following statement contains a magic number: if (ulLen > s_DBL_DIG)              {                  // Divide number by 10 while there are more then 17 digits                  uint ulWrk = ulLen - s_DBL_DIG;                  do                  {                      ulTemp = DivByULong(10);                      ulWrk--;                  }                  while (ulWrk > 0);                  ulWrk = ulLen - s_DBL_DIG;                    // Round' if necessary. # of digits can change. Cannot be overflow.                  if (ulTemp >= 5)                  {                      AddULong(1);                      ulLen = CalculatePrecision() + ulWrk;                  }                    // Multiply back                  do                  {                      MultByULong(10);                      ulWrk--;                  }                  while (ulWrk > 0);              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The following statement contains a magic number: if (ulLen > s_DBL_DIG)              {                  // Divide number by 10 while there are more then 17 digits                  uint ulWrk = ulLen - s_DBL_DIG;                  do                  {                      ulTemp = DivByULong(10);                      ulWrk--;                  }                  while (ulWrk > 0);                  ulWrk = ulLen - s_DBL_DIG;                    // Round' if necessary. # of digits can change. Cannot be overflow.                  if (ulTemp >= 5)                  {                      AddULong(1);                      ulLen = CalculatePrecision() + ulWrk;                  }                    // Multiply back                  do                  {                      MultByULong(10);                      ulWrk--;                  }                  while (ulWrk > 0);              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The following statement contains a magic number: if (ulLen > s_DBL_DIG)              {                  // Divide number by 10 while there are more then 17 digits                  uint ulWrk = ulLen - s_DBL_DIG;                  do                  {                      ulTemp = DivByULong(10);                      ulWrk--;                  }                  while (ulWrk > 0);                  ulWrk = ulLen - s_DBL_DIG;                    // Round' if necessary. # of digits can change. Cannot be overflow.                  if (ulTemp >= 5)                  {                      AddULong(1);                      ulLen = CalculatePrecision() + ulWrk;                  }                    // Multiply back                  do                  {                      MultByULong(10);                      ulWrk--;                  }                  while (ulWrk > 0);              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The following statement contains a magic number: if (_bScale > 0)              {                  ulLen = _bScale;                  do                  {                      ulLenDelta = (ulLen >= 9) ? 9 : ulLen;                        dFrac *= s_rgulShiftBase[(int)ulLenDelta - 1];                      ulLen -= ulLenDelta;                      MultByULong(s_rgulShiftBase[(int)ulLenDelta - 1]);                      AddULong((uint)dFrac);                      dFrac -= Math.Floor(dFrac);                  }                  while (ulLen > 0);              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The following statement contains a magic number: if (_bScale > 0)              {                  ulLen = _bScale;                  do                  {                      ulLenDelta = (ulLen >= 9) ? 9 : ulLen;                        dFrac *= s_rgulShiftBase[(int)ulLenDelta - 1];                      ulLen -= ulLenDelta;                      MultByULong(s_rgulShiftBase[(int)ulLenDelta - 1]);                      AddULong((uint)dFrac);                      dFrac -= Math.Floor(dFrac);                  }                  while (ulLen > 0);              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The following statement contains a magic number: if (dFrac >= 0.5)              {                  AddULong(1);              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The following statement contains a magic number: Debug.Assert(rglData.Length >= 4);
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The following statement contains a magic number: _data3 = rglData[2];
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,SqlDecimal,The following statement contains a magic number: _data4 = rglData[3];
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,ToString,The following statement contains a magic number: uint[] rgulNumeric = new uint[4] { _data1' _data2' _data3' _data4 };
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,Parse,The following statement contains a magic number: while ((cwchStr > 2) && (rgwchStr[iCurChar] == '0'))              {                  iCurChar++;                  cwchStr--;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,Parse,The following statement contains a magic number: if (2 == cwchStr && '0' == rgwchStr[iCurChar] && '.' == rgwchStr[iCurChar + 1])              {                  rgwchStr[iCurChar] = '.';                  rgwchStr[iCurChar + 1] = '0';              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,ToDouble,The following statement contains a magic number: dRet /= System.Math.Pow(10.0' _bScale);
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,ToDecimal,The following statement contains a magic number: if ((int)_data4 != 0 || _bScale > 28)                  throw new OverflowException(SQLResource.ConversionOverflowMessage);
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,AssertValid,The following statement contains a magic number: uint[] rglData = new uint[4] { _data1' _data2' _data3' _data4 };
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,ZeroToMaxLen,The following statement contains a magic number: switch (cUI4sCur)              {                  case 1:                      rgulData[1] = rgulData[2] = rgulData[3] = 0;                      break;                    case 2:                      rgulData[2] = rgulData[3] = 0;                      break;                    case 3:                      rgulData[3] = 0;                      break;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,ZeroToMaxLen,The following statement contains a magic number: switch (cUI4sCur)              {                  case 1:                      rgulData[1] = rgulData[2] = rgulData[3] = 0;                      break;                    case 2:                      rgulData[2] = rgulData[3] = 0;                      break;                    case 3:                      rgulData[3] = 0;                      break;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,ZeroToMaxLen,The following statement contains a magic number: switch (cUI4sCur)              {                  case 1:                      rgulData[1] = rgulData[2] = rgulData[3] = 0;                      break;                    case 2:                      rgulData[2] = rgulData[3] = 0;                      break;                    case 3:                      rgulData[3] = 0;                      break;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,ZeroToMaxLen,The following statement contains a magic number: switch (cUI4sCur)              {                  case 1:                      rgulData[1] = rgulData[2] = rgulData[3] = 0;                      break;                    case 2:                      rgulData[2] = rgulData[3] = 0;                      break;                    case 3:                      rgulData[3] = 0;                      break;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,ZeroToMaxLen,The following statement contains a magic number: switch (cUI4sCur)              {                  case 1:                      rgulData[1] = rgulData[2] = rgulData[3] = 0;                      break;                    case 2:                      rgulData[2] = rgulData[3] = 0;                      break;                    case 3:                      rgulData[3] = 0;                      break;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,ZeroToMaxLen,The following statement contains a magic number: switch (cUI4sCur)              {                  case 1:                      rgulData[1] = rgulData[2] = rgulData[3] = 0;                      break;                    case 2:                      rgulData[2] = rgulData[3] = 0;                      break;                    case 3:                      rgulData[3] = 0;                      break;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,ZeroToMaxLen,The following statement contains a magic number: switch (cUI4sCur)              {                  case 1:                      rgulData[1] = rgulData[2] = rgulData[3] = 0;                      break;                    case 2:                      rgulData[2] = rgulData[3] = 0;                      break;                    case 3:                      rgulData[3] = 0;                      break;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,FGt10_38,The following statement contains a magic number: return _data4 >= 0x4b3b4ca8L && _bLen == 4 &&              ((_data4 > 0x4b3b4ca8L) || (_data3 > 0x5a86c47aL) ||               (_data3 == 0x5a86c47aL) && (_data2 >= 0x098a2240L));
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,FGt10_38,The following statement contains a magic number: Debug.Assert(rglData.Length == 4' "rglData.Length == 4"' "Wrong array length: " + rglData.Length.ToString(CultureInfo.InvariantCulture));
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,FGt10_38,The following statement contains a magic number: return rglData[3] >= 0x4b3b4ca8L &&              ((rglData[3] > 0x4b3b4ca8L) || (rglData[2] > 0x5a86c47aL) ||               (rglData[2] == 0x5a86c47aL) && (rglData[1] >= 0x098a2240L));
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,FGt10_38,The following statement contains a magic number: return rglData[3] >= 0x4b3b4ca8L &&              ((rglData[3] > 0x4b3b4ca8L) || (rglData[2] > 0x5a86c47aL) ||               (rglData[2] == 0x5a86c47aL) && (rglData[1] >= 0x098a2240L));
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,FGt10_38,The following statement contains a magic number: return rglData[3] >= 0x4b3b4ca8L &&              ((rglData[3] > 0x4b3b4ca8L) || (rglData[2] > 0x5a86c47aL) ||               (rglData[2] == 0x5a86c47aL) && (rglData[1] >= 0x098a2240L));
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,FGt10_38,The following statement contains a magic number: return rglData[3] >= 0x4b3b4ca8L &&              ((rglData[3] > 0x4b3b4ca8L) || (rglData[2] > 0x5a86c47aL) ||               (rglData[2] == 0x5a86c47aL) && (rglData[1] >= 0x098a2240L));
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI4,The following statement contains a magic number: if (value < s_ulT4)              {                  if (value < s_ulT2)                      ret = value >= s_ulT1 ? 2 : 1;                  else                      ret = value >= s_ulT3 ? 4 : 3;              }              else if (value < s_ulT8)              {                  if (value < s_ulT6)                      ret = value >= s_ulT5 ? 6 : 5;                  else                      ret = value >= s_ulT7 ? 8 : 7;              }              else                  ret = value >= s_ulT9 ? 10 : 9;
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI4,The following statement contains a magic number: if (value < s_ulT4)              {                  if (value < s_ulT2)                      ret = value >= s_ulT1 ? 2 : 1;                  else                      ret = value >= s_ulT3 ? 4 : 3;              }              else if (value < s_ulT8)              {                  if (value < s_ulT6)                      ret = value >= s_ulT5 ? 6 : 5;                  else                      ret = value >= s_ulT7 ? 8 : 7;              }              else                  ret = value >= s_ulT9 ? 10 : 9;
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI4,The following statement contains a magic number: if (value < s_ulT4)              {                  if (value < s_ulT2)                      ret = value >= s_ulT1 ? 2 : 1;                  else                      ret = value >= s_ulT3 ? 4 : 3;              }              else if (value < s_ulT8)              {                  if (value < s_ulT6)                      ret = value >= s_ulT5 ? 6 : 5;                  else                      ret = value >= s_ulT7 ? 8 : 7;              }              else                  ret = value >= s_ulT9 ? 10 : 9;
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI4,The following statement contains a magic number: if (value < s_ulT4)              {                  if (value < s_ulT2)                      ret = value >= s_ulT1 ? 2 : 1;                  else                      ret = value >= s_ulT3 ? 4 : 3;              }              else if (value < s_ulT8)              {                  if (value < s_ulT6)                      ret = value >= s_ulT5 ? 6 : 5;                  else                      ret = value >= s_ulT7 ? 8 : 7;              }              else                  ret = value >= s_ulT9 ? 10 : 9;
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI4,The following statement contains a magic number: if (value < s_ulT4)              {                  if (value < s_ulT2)                      ret = value >= s_ulT1 ? 2 : 1;                  else                      ret = value >= s_ulT3 ? 4 : 3;              }              else if (value < s_ulT8)              {                  if (value < s_ulT6)                      ret = value >= s_ulT5 ? 6 : 5;                  else                      ret = value >= s_ulT7 ? 8 : 7;              }              else                  ret = value >= s_ulT9 ? 10 : 9;
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI4,The following statement contains a magic number: if (value < s_ulT4)              {                  if (value < s_ulT2)                      ret = value >= s_ulT1 ? 2 : 1;                  else                      ret = value >= s_ulT3 ? 4 : 3;              }              else if (value < s_ulT8)              {                  if (value < s_ulT6)                      ret = value >= s_ulT5 ? 6 : 5;                  else                      ret = value >= s_ulT7 ? 8 : 7;              }              else                  ret = value >= s_ulT9 ? 10 : 9;
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI4,The following statement contains a magic number: if (value < s_ulT4)              {                  if (value < s_ulT2)                      ret = value >= s_ulT1 ? 2 : 1;                  else                      ret = value >= s_ulT3 ? 4 : 3;              }              else if (value < s_ulT8)              {                  if (value < s_ulT6)                      ret = value >= s_ulT5 ? 6 : 5;                  else                      ret = value >= s_ulT7 ? 8 : 7;              }              else                  ret = value >= s_ulT9 ? 10 : 9;
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI4,The following statement contains a magic number: if (value < s_ulT4)              {                  if (value < s_ulT2)                      ret = value >= s_ulT1 ? 2 : 1;                  else                      ret = value >= s_ulT3 ? 4 : 3;              }              else if (value < s_ulT8)              {                  if (value < s_ulT6)                      ret = value >= s_ulT5 ? 6 : 5;                  else                      ret = value >= s_ulT7 ? 8 : 7;              }              else                  ret = value >= s_ulT9 ? 10 : 9;
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI4,The following statement contains a magic number: if (value < s_ulT4)              {                  if (value < s_ulT2)                      ret = value >= s_ulT1 ? 2 : 1;                  else                      ret = value >= s_ulT3 ? 4 : 3;              }              else if (value < s_ulT8)              {                  if (value < s_ulT6)                      ret = value >= s_ulT5 ? 6 : 5;                  else                      ret = value >= s_ulT7 ? 8 : 7;              }              else                  ret = value >= s_ulT9 ? 10 : 9;
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI8,The following statement contains a magic number: ulong dwlVal = ulU0 + (((ulong)ulU1) << 32);
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI8,The following statement contains a magic number: if (dwlVal < s_ulT8)              {                  uint ulVal = (uint)dwlVal;                    if (ulVal < s_ulT4)                  {                      if (ulVal < s_ulT2)                          ret = (ulVal >= s_ulT1) ? 2 : 1;                      else                          ret = (ulVal >= s_ulT3) ? 4 : 3;                  }                  else                  {                      if (ulVal < s_ulT6)                          ret = (ulVal >= s_ulT5) ? 6 : 5;                      else                          ret = (ulVal >= s_ulT7) ? 8 : 7;                  }              }              else if (dwlVal < s_dwlT16)              {                  if (dwlVal < s_dwlT12)                  {                      if (dwlVal < s_dwlT10)                          ret = (dwlVal >= s_ulT9) ? 10 : 9;                      else                          ret = (dwlVal >= s_dwlT11) ? 12 : 11;                  }                  else                  {                      if (dwlVal < s_dwlT14)                          ret = (dwlVal >= s_dwlT13) ? 14 : 13;                      else                          ret = (dwlVal >= s_dwlT15) ? 16 : 15;                  }              }              else              {                  if (dwlVal < s_dwlT18)                      ret = (dwlVal >= s_dwlT17) ? 18 : 17;                  else                      ret = (dwlVal >= s_dwlT19) ? 20 : 19;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI8,The following statement contains a magic number: if (dwlVal < s_ulT8)              {                  uint ulVal = (uint)dwlVal;                    if (ulVal < s_ulT4)                  {                      if (ulVal < s_ulT2)                          ret = (ulVal >= s_ulT1) ? 2 : 1;                      else                          ret = (ulVal >= s_ulT3) ? 4 : 3;                  }                  else                  {                      if (ulVal < s_ulT6)                          ret = (ulVal >= s_ulT5) ? 6 : 5;                      else                          ret = (ulVal >= s_ulT7) ? 8 : 7;                  }              }              else if (dwlVal < s_dwlT16)              {                  if (dwlVal < s_dwlT12)                  {                      if (dwlVal < s_dwlT10)                          ret = (dwlVal >= s_ulT9) ? 10 : 9;                      else                          ret = (dwlVal >= s_dwlT11) ? 12 : 11;                  }                  else                  {                      if (dwlVal < s_dwlT14)                          ret = (dwlVal >= s_dwlT13) ? 14 : 13;                      else                          ret = (dwlVal >= s_dwlT15) ? 16 : 15;                  }              }              else              {                  if (dwlVal < s_dwlT18)                      ret = (dwlVal >= s_dwlT17) ? 18 : 17;                  else                      ret = (dwlVal >= s_dwlT19) ? 20 : 19;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI8,The following statement contains a magic number: if (dwlVal < s_ulT8)              {                  uint ulVal = (uint)dwlVal;                    if (ulVal < s_ulT4)                  {                      if (ulVal < s_ulT2)                          ret = (ulVal >= s_ulT1) ? 2 : 1;                      else                          ret = (ulVal >= s_ulT3) ? 4 : 3;                  }                  else                  {                      if (ulVal < s_ulT6)                          ret = (ulVal >= s_ulT5) ? 6 : 5;                      else                          ret = (ulVal >= s_ulT7) ? 8 : 7;                  }              }              else if (dwlVal < s_dwlT16)              {                  if (dwlVal < s_dwlT12)                  {                      if (dwlVal < s_dwlT10)                          ret = (dwlVal >= s_ulT9) ? 10 : 9;                      else                          ret = (dwlVal >= s_dwlT11) ? 12 : 11;                  }                  else                  {                      if (dwlVal < s_dwlT14)                          ret = (dwlVal >= s_dwlT13) ? 14 : 13;                      else                          ret = (dwlVal >= s_dwlT15) ? 16 : 15;                  }              }              else              {                  if (dwlVal < s_dwlT18)                      ret = (dwlVal >= s_dwlT17) ? 18 : 17;                  else                      ret = (dwlVal >= s_dwlT19) ? 20 : 19;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI8,The following statement contains a magic number: if (dwlVal < s_ulT8)              {                  uint ulVal = (uint)dwlVal;                    if (ulVal < s_ulT4)                  {                      if (ulVal < s_ulT2)                          ret = (ulVal >= s_ulT1) ? 2 : 1;                      else                          ret = (ulVal >= s_ulT3) ? 4 : 3;                  }                  else                  {                      if (ulVal < s_ulT6)                          ret = (ulVal >= s_ulT5) ? 6 : 5;                      else                          ret = (ulVal >= s_ulT7) ? 8 : 7;                  }              }              else if (dwlVal < s_dwlT16)              {                  if (dwlVal < s_dwlT12)                  {                      if (dwlVal < s_dwlT10)                          ret = (dwlVal >= s_ulT9) ? 10 : 9;                      else                          ret = (dwlVal >= s_dwlT11) ? 12 : 11;                  }                  else                  {                      if (dwlVal < s_dwlT14)                          ret = (dwlVal >= s_dwlT13) ? 14 : 13;                      else                          ret = (dwlVal >= s_dwlT15) ? 16 : 15;                  }              }              else              {                  if (dwlVal < s_dwlT18)                      ret = (dwlVal >= s_dwlT17) ? 18 : 17;                  else                      ret = (dwlVal >= s_dwlT19) ? 20 : 19;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI8,The following statement contains a magic number: if (dwlVal < s_ulT8)              {                  uint ulVal = (uint)dwlVal;                    if (ulVal < s_ulT4)                  {                      if (ulVal < s_ulT2)                          ret = (ulVal >= s_ulT1) ? 2 : 1;                      else                          ret = (ulVal >= s_ulT3) ? 4 : 3;                  }                  else                  {                      if (ulVal < s_ulT6)                          ret = (ulVal >= s_ulT5) ? 6 : 5;                      else                          ret = (ulVal >= s_ulT7) ? 8 : 7;                  }              }              else if (dwlVal < s_dwlT16)              {                  if (dwlVal < s_dwlT12)                  {                      if (dwlVal < s_dwlT10)                          ret = (dwlVal >= s_ulT9) ? 10 : 9;                      else                          ret = (dwlVal >= s_dwlT11) ? 12 : 11;                  }                  else                  {                      if (dwlVal < s_dwlT14)                          ret = (dwlVal >= s_dwlT13) ? 14 : 13;                      else                          ret = (dwlVal >= s_dwlT15) ? 16 : 15;                  }              }              else              {                  if (dwlVal < s_dwlT18)                      ret = (dwlVal >= s_dwlT17) ? 18 : 17;                  else                      ret = (dwlVal >= s_dwlT19) ? 20 : 19;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI8,The following statement contains a magic number: if (dwlVal < s_ulT8)              {                  uint ulVal = (uint)dwlVal;                    if (ulVal < s_ulT4)                  {                      if (ulVal < s_ulT2)                          ret = (ulVal >= s_ulT1) ? 2 : 1;                      else                          ret = (ulVal >= s_ulT3) ? 4 : 3;                  }                  else                  {                      if (ulVal < s_ulT6)                          ret = (ulVal >= s_ulT5) ? 6 : 5;                      else                          ret = (ulVal >= s_ulT7) ? 8 : 7;                  }              }              else if (dwlVal < s_dwlT16)              {                  if (dwlVal < s_dwlT12)                  {                      if (dwlVal < s_dwlT10)                          ret = (dwlVal >= s_ulT9) ? 10 : 9;                      else                          ret = (dwlVal >= s_dwlT11) ? 12 : 11;                  }                  else                  {                      if (dwlVal < s_dwlT14)                          ret = (dwlVal >= s_dwlT13) ? 14 : 13;                      else                          ret = (dwlVal >= s_dwlT15) ? 16 : 15;                  }              }              else              {                  if (dwlVal < s_dwlT18)                      ret = (dwlVal >= s_dwlT17) ? 18 : 17;                  else                      ret = (dwlVal >= s_dwlT19) ? 20 : 19;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI8,The following statement contains a magic number: if (dwlVal < s_ulT8)              {                  uint ulVal = (uint)dwlVal;                    if (ulVal < s_ulT4)                  {                      if (ulVal < s_ulT2)                          ret = (ulVal >= s_ulT1) ? 2 : 1;                      else                          ret = (ulVal >= s_ulT3) ? 4 : 3;                  }                  else                  {                      if (ulVal < s_ulT6)                          ret = (ulVal >= s_ulT5) ? 6 : 5;                      else                          ret = (ulVal >= s_ulT7) ? 8 : 7;                  }              }              else if (dwlVal < s_dwlT16)              {                  if (dwlVal < s_dwlT12)                  {                      if (dwlVal < s_dwlT10)                          ret = (dwlVal >= s_ulT9) ? 10 : 9;                      else                          ret = (dwlVal >= s_dwlT11) ? 12 : 11;                  }                  else                  {                      if (dwlVal < s_dwlT14)                          ret = (dwlVal >= s_dwlT13) ? 14 : 13;                      else                          ret = (dwlVal >= s_dwlT15) ? 16 : 15;                  }              }              else              {                  if (dwlVal < s_dwlT18)                      ret = (dwlVal >= s_dwlT17) ? 18 : 17;                  else                      ret = (dwlVal >= s_dwlT19) ? 20 : 19;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI8,The following statement contains a magic number: if (dwlVal < s_ulT8)              {                  uint ulVal = (uint)dwlVal;                    if (ulVal < s_ulT4)                  {                      if (ulVal < s_ulT2)                          ret = (ulVal >= s_ulT1) ? 2 : 1;                      else                          ret = (ulVal >= s_ulT3) ? 4 : 3;                  }                  else                  {                      if (ulVal < s_ulT6)                          ret = (ulVal >= s_ulT5) ? 6 : 5;                      else                          ret = (ulVal >= s_ulT7) ? 8 : 7;                  }              }              else if (dwlVal < s_dwlT16)              {                  if (dwlVal < s_dwlT12)                  {                      if (dwlVal < s_dwlT10)                          ret = (dwlVal >= s_ulT9) ? 10 : 9;                      else                          ret = (dwlVal >= s_dwlT11) ? 12 : 11;                  }                  else                  {                      if (dwlVal < s_dwlT14)                          ret = (dwlVal >= s_dwlT13) ? 14 : 13;                      else                          ret = (dwlVal >= s_dwlT15) ? 16 : 15;                  }              }              else              {                  if (dwlVal < s_dwlT18)                      ret = (dwlVal >= s_dwlT17) ? 18 : 17;                  else                      ret = (dwlVal >= s_dwlT19) ? 20 : 19;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI8,The following statement contains a magic number: if (dwlVal < s_ulT8)              {                  uint ulVal = (uint)dwlVal;                    if (ulVal < s_ulT4)                  {                      if (ulVal < s_ulT2)                          ret = (ulVal >= s_ulT1) ? 2 : 1;                      else                          ret = (ulVal >= s_ulT3) ? 4 : 3;                  }                  else                  {                      if (ulVal < s_ulT6)                          ret = (ulVal >= s_ulT5) ? 6 : 5;                      else                          ret = (ulVal >= s_ulT7) ? 8 : 7;                  }              }              else if (dwlVal < s_dwlT16)              {                  if (dwlVal < s_dwlT12)                  {                      if (dwlVal < s_dwlT10)                          ret = (dwlVal >= s_ulT9) ? 10 : 9;                      else                          ret = (dwlVal >= s_dwlT11) ? 12 : 11;                  }                  else                  {                      if (dwlVal < s_dwlT14)                          ret = (dwlVal >= s_dwlT13) ? 14 : 13;                      else                          ret = (dwlVal >= s_dwlT15) ? 16 : 15;                  }              }              else              {                  if (dwlVal < s_dwlT18)                      ret = (dwlVal >= s_dwlT17) ? 18 : 17;                  else                      ret = (dwlVal >= s_dwlT19) ? 20 : 19;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI8,The following statement contains a magic number: if (dwlVal < s_ulT8)              {                  uint ulVal = (uint)dwlVal;                    if (ulVal < s_ulT4)                  {                      if (ulVal < s_ulT2)                          ret = (ulVal >= s_ulT1) ? 2 : 1;                      else                          ret = (ulVal >= s_ulT3) ? 4 : 3;                  }                  else                  {                      if (ulVal < s_ulT6)                          ret = (ulVal >= s_ulT5) ? 6 : 5;                      else                          ret = (ulVal >= s_ulT7) ? 8 : 7;                  }              }              else if (dwlVal < s_dwlT16)              {                  if (dwlVal < s_dwlT12)                  {                      if (dwlVal < s_dwlT10)                          ret = (dwlVal >= s_ulT9) ? 10 : 9;                      else                          ret = (dwlVal >= s_dwlT11) ? 12 : 11;                  }                  else                  {                      if (dwlVal < s_dwlT14)                          ret = (dwlVal >= s_dwlT13) ? 14 : 13;                      else                          ret = (dwlVal >= s_dwlT15) ? 16 : 15;                  }              }              else              {                  if (dwlVal < s_dwlT18)                      ret = (dwlVal >= s_dwlT17) ? 18 : 17;                  else                      ret = (dwlVal >= s_dwlT19) ? 20 : 19;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI8,The following statement contains a magic number: if (dwlVal < s_ulT8)              {                  uint ulVal = (uint)dwlVal;                    if (ulVal < s_ulT4)                  {                      if (ulVal < s_ulT2)                          ret = (ulVal >= s_ulT1) ? 2 : 1;                      else                          ret = (ulVal >= s_ulT3) ? 4 : 3;                  }                  else                  {                      if (ulVal < s_ulT6)                          ret = (ulVal >= s_ulT5) ? 6 : 5;                      else                          ret = (ulVal >= s_ulT7) ? 8 : 7;                  }              }              else if (dwlVal < s_dwlT16)              {                  if (dwlVal < s_dwlT12)                  {                      if (dwlVal < s_dwlT10)                          ret = (dwlVal >= s_ulT9) ? 10 : 9;                      else                          ret = (dwlVal >= s_dwlT11) ? 12 : 11;                  }                  else                  {                      if (dwlVal < s_dwlT14)                          ret = (dwlVal >= s_dwlT13) ? 14 : 13;                      else                          ret = (dwlVal >= s_dwlT15) ? 16 : 15;                  }              }              else              {                  if (dwlVal < s_dwlT18)                      ret = (dwlVal >= s_dwlT17) ? 18 : 17;                  else                      ret = (dwlVal >= s_dwlT19) ? 20 : 19;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI8,The following statement contains a magic number: if (dwlVal < s_ulT8)              {                  uint ulVal = (uint)dwlVal;                    if (ulVal < s_ulT4)                  {                      if (ulVal < s_ulT2)                          ret = (ulVal >= s_ulT1) ? 2 : 1;                      else                          ret = (ulVal >= s_ulT3) ? 4 : 3;                  }                  else                  {                      if (ulVal < s_ulT6)                          ret = (ulVal >= s_ulT5) ? 6 : 5;                      else                          ret = (ulVal >= s_ulT7) ? 8 : 7;                  }              }              else if (dwlVal < s_dwlT16)              {                  if (dwlVal < s_dwlT12)                  {                      if (dwlVal < s_dwlT10)                          ret = (dwlVal >= s_ulT9) ? 10 : 9;                      else                          ret = (dwlVal >= s_dwlT11) ? 12 : 11;                  }                  else                  {                      if (dwlVal < s_dwlT14)                          ret = (dwlVal >= s_dwlT13) ? 14 : 13;                      else                          ret = (dwlVal >= s_dwlT15) ? 16 : 15;                  }              }              else              {                  if (dwlVal < s_dwlT18)                      ret = (dwlVal >= s_dwlT17) ? 18 : 17;                  else                      ret = (dwlVal >= s_dwlT19) ? 20 : 19;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI8,The following statement contains a magic number: if (dwlVal < s_ulT8)              {                  uint ulVal = (uint)dwlVal;                    if (ulVal < s_ulT4)                  {                      if (ulVal < s_ulT2)                          ret = (ulVal >= s_ulT1) ? 2 : 1;                      else                          ret = (ulVal >= s_ulT3) ? 4 : 3;                  }                  else                  {                      if (ulVal < s_ulT6)                          ret = (ulVal >= s_ulT5) ? 6 : 5;                      else                          ret = (ulVal >= s_ulT7) ? 8 : 7;                  }              }              else if (dwlVal < s_dwlT16)              {                  if (dwlVal < s_dwlT12)                  {                      if (dwlVal < s_dwlT10)                          ret = (dwlVal >= s_ulT9) ? 10 : 9;                      else                          ret = (dwlVal >= s_dwlT11) ? 12 : 11;                  }                  else                  {                      if (dwlVal < s_dwlT14)                          ret = (dwlVal >= s_dwlT13) ? 14 : 13;                      else                          ret = (dwlVal >= s_dwlT15) ? 16 : 15;                  }              }              else              {                  if (dwlVal < s_dwlT18)                      ret = (dwlVal >= s_dwlT17) ? 18 : 17;                  else                      ret = (dwlVal >= s_dwlT19) ? 20 : 19;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI8,The following statement contains a magic number: if (dwlVal < s_ulT8)              {                  uint ulVal = (uint)dwlVal;                    if (ulVal < s_ulT4)                  {                      if (ulVal < s_ulT2)                          ret = (ulVal >= s_ulT1) ? 2 : 1;                      else                          ret = (ulVal >= s_ulT3) ? 4 : 3;                  }                  else                  {                      if (ulVal < s_ulT6)                          ret = (ulVal >= s_ulT5) ? 6 : 5;                      else                          ret = (ulVal >= s_ulT7) ? 8 : 7;                  }              }              else if (dwlVal < s_dwlT16)              {                  if (dwlVal < s_dwlT12)                  {                      if (dwlVal < s_dwlT10)                          ret = (dwlVal >= s_ulT9) ? 10 : 9;                      else                          ret = (dwlVal >= s_dwlT11) ? 12 : 11;                  }                  else                  {                      if (dwlVal < s_dwlT14)                          ret = (dwlVal >= s_dwlT13) ? 14 : 13;                      else                          ret = (dwlVal >= s_dwlT15) ? 16 : 15;                  }              }              else              {                  if (dwlVal < s_dwlT18)                      ret = (dwlVal >= s_dwlT17) ? 18 : 17;                  else                      ret = (dwlVal >= s_dwlT19) ? 20 : 19;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI8,The following statement contains a magic number: if (dwlVal < s_ulT8)              {                  uint ulVal = (uint)dwlVal;                    if (ulVal < s_ulT4)                  {                      if (ulVal < s_ulT2)                          ret = (ulVal >= s_ulT1) ? 2 : 1;                      else                          ret = (ulVal >= s_ulT3) ? 4 : 3;                  }                  else                  {                      if (ulVal < s_ulT6)                          ret = (ulVal >= s_ulT5) ? 6 : 5;                      else                          ret = (ulVal >= s_ulT7) ? 8 : 7;                  }              }              else if (dwlVal < s_dwlT16)              {                  if (dwlVal < s_dwlT12)                  {                      if (dwlVal < s_dwlT10)                          ret = (dwlVal >= s_ulT9) ? 10 : 9;                      else                          ret = (dwlVal >= s_dwlT11) ? 12 : 11;                  }                  else                  {                      if (dwlVal < s_dwlT14)                          ret = (dwlVal >= s_dwlT13) ? 14 : 13;                      else                          ret = (dwlVal >= s_dwlT15) ? 16 : 15;                  }              }              else              {                  if (dwlVal < s_dwlT18)                      ret = (dwlVal >= s_dwlT17) ? 18 : 17;                  else                      ret = (dwlVal >= s_dwlT19) ? 20 : 19;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI8,The following statement contains a magic number: if (dwlVal < s_ulT8)              {                  uint ulVal = (uint)dwlVal;                    if (ulVal < s_ulT4)                  {                      if (ulVal < s_ulT2)                          ret = (ulVal >= s_ulT1) ? 2 : 1;                      else                          ret = (ulVal >= s_ulT3) ? 4 : 3;                  }                  else                  {                      if (ulVal < s_ulT6)                          ret = (ulVal >= s_ulT5) ? 6 : 5;                      else                          ret = (ulVal >= s_ulT7) ? 8 : 7;                  }              }              else if (dwlVal < s_dwlT16)              {                  if (dwlVal < s_dwlT12)                  {                      if (dwlVal < s_dwlT10)                          ret = (dwlVal >= s_ulT9) ? 10 : 9;                      else                          ret = (dwlVal >= s_dwlT11) ? 12 : 11;                  }                  else                  {                      if (dwlVal < s_dwlT14)                          ret = (dwlVal >= s_dwlT13) ? 14 : 13;                      else                          ret = (dwlVal >= s_dwlT15) ? 16 : 15;                  }              }              else              {                  if (dwlVal < s_dwlT18)                      ret = (dwlVal >= s_dwlT17) ? 18 : 17;                  else                      ret = (dwlVal >= s_dwlT19) ? 20 : 19;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI8,The following statement contains a magic number: if (dwlVal < s_ulT8)              {                  uint ulVal = (uint)dwlVal;                    if (ulVal < s_ulT4)                  {                      if (ulVal < s_ulT2)                          ret = (ulVal >= s_ulT1) ? 2 : 1;                      else                          ret = (ulVal >= s_ulT3) ? 4 : 3;                  }                  else                  {                      if (ulVal < s_ulT6)                          ret = (ulVal >= s_ulT5) ? 6 : 5;                      else                          ret = (ulVal >= s_ulT7) ? 8 : 7;                  }              }              else if (dwlVal < s_dwlT16)              {                  if (dwlVal < s_dwlT12)                  {                      if (dwlVal < s_dwlT10)                          ret = (dwlVal >= s_ulT9) ? 10 : 9;                      else                          ret = (dwlVal >= s_dwlT11) ? 12 : 11;                  }                  else                  {                      if (dwlVal < s_dwlT14)                          ret = (dwlVal >= s_dwlT13) ? 14 : 13;                      else                          ret = (dwlVal >= s_dwlT15) ? 16 : 15;                  }              }              else              {                  if (dwlVal < s_dwlT18)                      ret = (dwlVal >= s_dwlT17) ? 18 : 17;                  else                      ret = (dwlVal >= s_dwlT19) ? 20 : 19;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI8,The following statement contains a magic number: if (dwlVal < s_ulT8)              {                  uint ulVal = (uint)dwlVal;                    if (ulVal < s_ulT4)                  {                      if (ulVal < s_ulT2)                          ret = (ulVal >= s_ulT1) ? 2 : 1;                      else                          ret = (ulVal >= s_ulT3) ? 4 : 3;                  }                  else                  {                      if (ulVal < s_ulT6)                          ret = (ulVal >= s_ulT5) ? 6 : 5;                      else                          ret = (ulVal >= s_ulT7) ? 8 : 7;                  }              }              else if (dwlVal < s_dwlT16)              {                  if (dwlVal < s_dwlT12)                  {                      if (dwlVal < s_dwlT10)                          ret = (dwlVal >= s_ulT9) ? 10 : 9;                      else                          ret = (dwlVal >= s_dwlT11) ? 12 : 11;                  }                  else                  {                      if (dwlVal < s_dwlT14)                          ret = (dwlVal >= s_dwlT13) ? 14 : 13;                      else                          ret = (dwlVal >= s_dwlT15) ? 16 : 15;                  }              }              else              {                  if (dwlVal < s_dwlT18)                      ret = (dwlVal >= s_dwlT17) ? 18 : 17;                  else                      ret = (dwlVal >= s_dwlT19) ? 20 : 19;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BGetPrecUI8,The following statement contains a magic number: if (dwlVal < s_ulT8)              {                  uint ulVal = (uint)dwlVal;                    if (ulVal < s_ulT4)                  {                      if (ulVal < s_ulT2)                          ret = (ulVal >= s_ulT1) ? 2 : 1;                      else                          ret = (ulVal >= s_ulT3) ? 4 : 3;                  }                  else                  {                      if (ulVal < s_ulT6)                          ret = (ulVal >= s_ulT5) ? 6 : 5;                      else                          ret = (ulVal >= s_ulT7) ? 8 : 7;                  }              }              else if (dwlVal < s_dwlT16)              {                  if (dwlVal < s_dwlT12)                  {                      if (dwlVal < s_dwlT10)                          ret = (dwlVal >= s_ulT9) ? 10 : 9;                      else                          ret = (dwlVal >= s_dwlT11) ? 12 : 11;                  }                  else                  {                      if (dwlVal < s_dwlT14)                          ret = (dwlVal >= s_dwlT13) ? 14 : 13;                      else                          ret = (dwlVal >= s_dwlT15) ? 16 : 15;                  }              }              else              {                  if (dwlVal < s_dwlT18)                      ret = (dwlVal >= s_dwlT17) ? 18 : 17;                  else                      ret = (dwlVal >= s_dwlT19) ? 20 : 19;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BActualPrec,The following statement contains a magic number: if (ciulU == 1)              {                  Prec = BGetPrecUI4(_data1);              }              else if (ciulU == 2)              {                  Prec = BGetPrecUI8(_data1' _data2);              }              else              {                  uint[] rgulU = new uint[4] { _data1' _data2' _data3' _data4 };                  Prec = 0;                  do                  {                      MpDiv1(rgulU' ref ciulU' 1000000000' out ulRem);                      Prec += 9;                  }                  while (ciulU > 2);                  Debug.Assert(Prec == 9 || Prec == 18 || Prec == 27);                  Prec += BGetPrecUI8(rgulU[0]' rgulU[1]);              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BActualPrec,The following statement contains a magic number: if (ciulU == 1)              {                  Prec = BGetPrecUI4(_data1);              }              else if (ciulU == 2)              {                  Prec = BGetPrecUI8(_data1' _data2);              }              else              {                  uint[] rgulU = new uint[4] { _data1' _data2' _data3' _data4 };                  Prec = 0;                  do                  {                      MpDiv1(rgulU' ref ciulU' 1000000000' out ulRem);                      Prec += 9;                  }                  while (ciulU > 2);                  Debug.Assert(Prec == 9 || Prec == 18 || Prec == 27);                  Prec += BGetPrecUI8(rgulU[0]' rgulU[1]);              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BActualPrec,The following statement contains a magic number: if (ciulU == 1)              {                  Prec = BGetPrecUI4(_data1);              }              else if (ciulU == 2)              {                  Prec = BGetPrecUI8(_data1' _data2);              }              else              {                  uint[] rgulU = new uint[4] { _data1' _data2' _data3' _data4 };                  Prec = 0;                  do                  {                      MpDiv1(rgulU' ref ciulU' 1000000000' out ulRem);                      Prec += 9;                  }                  while (ciulU > 2);                  Debug.Assert(Prec == 9 || Prec == 18 || Prec == 27);                  Prec += BGetPrecUI8(rgulU[0]' rgulU[1]);              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BActualPrec,The following statement contains a magic number: if (ciulU == 1)              {                  Prec = BGetPrecUI4(_data1);              }              else if (ciulU == 2)              {                  Prec = BGetPrecUI8(_data1' _data2);              }              else              {                  uint[] rgulU = new uint[4] { _data1' _data2' _data3' _data4 };                  Prec = 0;                  do                  {                      MpDiv1(rgulU' ref ciulU' 1000000000' out ulRem);                      Prec += 9;                  }                  while (ciulU > 2);                  Debug.Assert(Prec == 9 || Prec == 18 || Prec == 27);                  Prec += BGetPrecUI8(rgulU[0]' rgulU[1]);              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BActualPrec,The following statement contains a magic number: if (ciulU == 1)              {                  Prec = BGetPrecUI4(_data1);              }              else if (ciulU == 2)              {                  Prec = BGetPrecUI8(_data1' _data2);              }              else              {                  uint[] rgulU = new uint[4] { _data1' _data2' _data3' _data4 };                  Prec = 0;                  do                  {                      MpDiv1(rgulU' ref ciulU' 1000000000' out ulRem);                      Prec += 9;                  }                  while (ciulU > 2);                  Debug.Assert(Prec == 9 || Prec == 18 || Prec == 27);                  Prec += BGetPrecUI8(rgulU[0]' rgulU[1]);              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BActualPrec,The following statement contains a magic number: if (ciulU == 1)              {                  Prec = BGetPrecUI4(_data1);              }              else if (ciulU == 2)              {                  Prec = BGetPrecUI8(_data1' _data2);              }              else              {                  uint[] rgulU = new uint[4] { _data1' _data2' _data3' _data4 };                  Prec = 0;                  do                  {                      MpDiv1(rgulU' ref ciulU' 1000000000' out ulRem);                      Prec += 9;                  }                  while (ciulU > 2);                  Debug.Assert(Prec == 9 || Prec == 18 || Prec == 27);                  Prec += BGetPrecUI8(rgulU[0]' rgulU[1]);              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BActualPrec,The following statement contains a magic number: if (ciulU == 1)              {                  Prec = BGetPrecUI4(_data1);              }              else if (ciulU == 2)              {                  Prec = BGetPrecUI8(_data1' _data2);              }              else              {                  uint[] rgulU = new uint[4] { _data1' _data2' _data3' _data4 };                  Prec = 0;                  do                  {                      MpDiv1(rgulU' ref ciulU' 1000000000' out ulRem);                      Prec += 9;                  }                  while (ciulU > 2);                  Debug.Assert(Prec == 9 || Prec == 18 || Prec == 27);                  Prec += BGetPrecUI8(rgulU[0]' rgulU[1]);              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,BActualPrec,The following statement contains a magic number: if (ciulU == 1)              {                  Prec = BGetPrecUI4(_data1);              }              else if (ciulU == 2)              {                  Prec = BGetPrecUI8(_data1' _data2);              }              else              {                  uint[] rgulU = new uint[4] { _data1' _data2' _data3' _data4 };                  Prec = 0;                  do                  {                      MpDiv1(rgulU' ref ciulU' 1000000000' out ulRem);                      Prec += 9;                  }                  while (ciulU > 2);                  Debug.Assert(Prec == 9 || Prec == 18 || Prec == 27);                  Prec += BGetPrecUI8(rgulU[0]' rgulU[1]);              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,AddULong,The following statement contains a magic number: uint[] rguiData = new uint[4] { _data1' _data2' _data3' _data4 };
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,AddULong,The following statement contains a magic number: do              {                  dwlAccum += rguiData[iData];                  rguiData[iData] = (uint)dwlAccum;       // equivalent to mod x_dwlBaseUI4                  dwlAccum >>= 32;                        // equivalent to dwlAccum /= x_dwlBaseUI4;                  if (0 == dwlAccum)                  {                      StoreFromWorkingArray(rguiData);                      return;                  }                  iData++;              }              while (iData < iDataMax);
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,MultByULong,The following statement contains a magic number: uint[] rguiData = new uint[4] { _data1' _data2' _data3' _data4 };
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,MultByULong,The following statement contains a magic number: for (iData = 0; iData < iDataMax; iData++)              {                  Debug.Assert(dwlAccum < s_ulInt32Base);                    ulong ulTemp = rguiData[iData];                  dwlNextAccum = ulTemp * uiMultiplier;                  dwlAccum += dwlNextAccum;                  if (dwlAccum < dwlNextAccum)        // Overflow of int64 add                      dwlNextAccum = s_ulInt32Base;   // how much to add to dwlAccum after div x_dwlBaseUI4                  else                      dwlNextAccum = 0;                  rguiData[iData] = unchecked((uint)dwlAccum); // equivalent to mod x_dwlBaseUI4                  dwlAccum = (dwlAccum >> 32) + dwlNextAccum;  // equivalent to div x_dwlBaseUI4              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,DivByULong,The following statement contains a magic number: uint[] rguiData = new uint[4] { _data1' _data2' _data3' _data4 };
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,DivByULong,The following statement contains a magic number: for (iData = _bLen; iData > 0; iData--)              {                  Debug.Assert(dwlAccum < dwlDivisor);                  dwlAccum = (dwlAccum << 32) + rguiData[iData - 1]; // dwlA*x_dwlBaseUI4 + rglData                  Debug.Assert((dwlAccum / dwlDivisor) < s_ulInt32Base);                  //Update dividend to the quotient.                  ulQuotientCur = (uint)(dwlAccum / dwlDivisor);                  rguiData[iData - 1] = ulQuotientCur;                  //Remainder to be carried to the next lower significant byte.                  dwlAccum = dwlAccum % dwlDivisor;                    // While current part of quotient still 0' reduce length                  if (fAllZero && (ulQuotientCur == 0))                  {                      _bLen--;                  }                  else                  {                      fAllZero = false;                  }              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,AdjustScale,The following statement contains a magic number: if (lAdjust > 0)              {                  _bScale = bNewScale;                  _bPrec = bNewPrec;                    while (lAdjust > 0)                  {                      //if lAdjust>=9' downshift by 10^9 each time' otherwise by the full amount                      if (lAdjust >= 9)                      {                          ulShiftBase = s_rgulShiftBase[8];                          lAdjust -= 9;                      }                      else                      {                          ulShiftBase = s_rgulShiftBase[lAdjust - 1];                          lAdjust = 0;                      }                      MultByULong(ulShiftBase);                  }              }              else if (lAdjust < 0)              {                  do                  {                      if (lAdjust <= -9)                      {                          ulShiftBase = s_rgulShiftBase[8];                          lAdjust += 9;                      }                      else                      {                          ulShiftBase = s_rgulShiftBase[-lAdjust - 1];                          lAdjust = 0;                      }                      ulRem = DivByULong(ulShiftBase);                  }                  while (lAdjust < 0);                    // Do we really need to round?                  fNeedRound = (ulRem >= ulShiftBase / 2);                    _bScale = bNewScale;                  _bPrec = bNewPrec;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,AdjustScale,The following statement contains a magic number: if (lAdjust > 0)              {                  _bScale = bNewScale;                  _bPrec = bNewPrec;                    while (lAdjust > 0)                  {                      //if lAdjust>=9' downshift by 10^9 each time' otherwise by the full amount                      if (lAdjust >= 9)                      {                          ulShiftBase = s_rgulShiftBase[8];                          lAdjust -= 9;                      }                      else                      {                          ulShiftBase = s_rgulShiftBase[lAdjust - 1];                          lAdjust = 0;                      }                      MultByULong(ulShiftBase);                  }              }              else if (lAdjust < 0)              {                  do                  {                      if (lAdjust <= -9)                      {                          ulShiftBase = s_rgulShiftBase[8];                          lAdjust += 9;                      }                      else                      {                          ulShiftBase = s_rgulShiftBase[-lAdjust - 1];                          lAdjust = 0;                      }                      ulRem = DivByULong(ulShiftBase);                  }                  while (lAdjust < 0);                    // Do we really need to round?                  fNeedRound = (ulRem >= ulShiftBase / 2);                    _bScale = bNewScale;                  _bPrec = bNewPrec;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,AdjustScale,The following statement contains a magic number: if (lAdjust > 0)              {                  _bScale = bNewScale;                  _bPrec = bNewPrec;                    while (lAdjust > 0)                  {                      //if lAdjust>=9' downshift by 10^9 each time' otherwise by the full amount                      if (lAdjust >= 9)                      {                          ulShiftBase = s_rgulShiftBase[8];                          lAdjust -= 9;                      }                      else                      {                          ulShiftBase = s_rgulShiftBase[lAdjust - 1];                          lAdjust = 0;                      }                      MultByULong(ulShiftBase);                  }              }              else if (lAdjust < 0)              {                  do                  {                      if (lAdjust <= -9)                      {                          ulShiftBase = s_rgulShiftBase[8];                          lAdjust += 9;                      }                      else                      {                          ulShiftBase = s_rgulShiftBase[-lAdjust - 1];                          lAdjust = 0;                      }                      ulRem = DivByULong(ulShiftBase);                  }                  while (lAdjust < 0);                    // Do we really need to round?                  fNeedRound = (ulRem >= ulShiftBase / 2);                    _bScale = bNewScale;                  _bPrec = bNewPrec;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,AdjustScale,The following statement contains a magic number: if (lAdjust > 0)              {                  _bScale = bNewScale;                  _bPrec = bNewPrec;                    while (lAdjust > 0)                  {                      //if lAdjust>=9' downshift by 10^9 each time' otherwise by the full amount                      if (lAdjust >= 9)                      {                          ulShiftBase = s_rgulShiftBase[8];                          lAdjust -= 9;                      }                      else                      {                          ulShiftBase = s_rgulShiftBase[lAdjust - 1];                          lAdjust = 0;                      }                      MultByULong(ulShiftBase);                  }              }              else if (lAdjust < 0)              {                  do                  {                      if (lAdjust <= -9)                      {                          ulShiftBase = s_rgulShiftBase[8];                          lAdjust += 9;                      }                      else                      {                          ulShiftBase = s_rgulShiftBase[-lAdjust - 1];                          lAdjust = 0;                      }                      ulRem = DivByULong(ulShiftBase);                  }                  while (lAdjust < 0);                    // Do we really need to round?                  fNeedRound = (ulRem >= ulShiftBase / 2);                    _bScale = bNewScale;                  _bPrec = bNewPrec;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,AdjustScale,The following statement contains a magic number: if (lAdjust > 0)              {                  _bScale = bNewScale;                  _bPrec = bNewPrec;                    while (lAdjust > 0)                  {                      //if lAdjust>=9' downshift by 10^9 each time' otherwise by the full amount                      if (lAdjust >= 9)                      {                          ulShiftBase = s_rgulShiftBase[8];                          lAdjust -= 9;                      }                      else                      {                          ulShiftBase = s_rgulShiftBase[lAdjust - 1];                          lAdjust = 0;                      }                      MultByULong(ulShiftBase);                  }              }              else if (lAdjust < 0)              {                  do                  {                      if (lAdjust <= -9)                      {                          ulShiftBase = s_rgulShiftBase[8];                          lAdjust += 9;                      }                      else                      {                          ulShiftBase = s_rgulShiftBase[-lAdjust - 1];                          lAdjust = 0;                      }                      ulRem = DivByULong(ulShiftBase);                  }                  while (lAdjust < 0);                    // Do we really need to round?                  fNeedRound = (ulRem >= ulShiftBase / 2);                    _bScale = bNewScale;                  _bPrec = bNewPrec;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,AdjustScale,The following statement contains a magic number: if (lAdjust > 0)              {                  _bScale = bNewScale;                  _bPrec = bNewPrec;                    while (lAdjust > 0)                  {                      //if lAdjust>=9' downshift by 10^9 each time' otherwise by the full amount                      if (lAdjust >= 9)                      {                          ulShiftBase = s_rgulShiftBase[8];                          lAdjust -= 9;                      }                      else                      {                          ulShiftBase = s_rgulShiftBase[lAdjust - 1];                          lAdjust = 0;                      }                      MultByULong(ulShiftBase);                  }              }              else if (lAdjust < 0)              {                  do                  {                      if (lAdjust <= -9)                      {                          ulShiftBase = s_rgulShiftBase[8];                          lAdjust += 9;                      }                      else                      {                          ulShiftBase = s_rgulShiftBase[-lAdjust - 1];                          lAdjust = 0;                      }                      ulRem = DivByULong(ulShiftBase);                  }                  while (lAdjust < 0);                    // Do we really need to round?                  fNeedRound = (ulRem >= ulShiftBase / 2);                    _bScale = bNewScale;                  _bPrec = bNewPrec;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,AdjustScale,The following statement contains a magic number: if (lAdjust > 0)              {                  _bScale = bNewScale;                  _bPrec = bNewPrec;                    while (lAdjust > 0)                  {                      //if lAdjust>=9' downshift by 10^9 each time' otherwise by the full amount                      if (lAdjust >= 9)                      {                          ulShiftBase = s_rgulShiftBase[8];                          lAdjust -= 9;                      }                      else                      {                          ulShiftBase = s_rgulShiftBase[lAdjust - 1];                          lAdjust = 0;                      }                      MultByULong(ulShiftBase);                  }              }              else if (lAdjust < 0)              {                  do                  {                      if (lAdjust <= -9)                      {                          ulShiftBase = s_rgulShiftBase[8];                          lAdjust += 9;                      }                      else                      {                          ulShiftBase = s_rgulShiftBase[-lAdjust - 1];                          lAdjust = 0;                      }                      ulRem = DivByULong(ulShiftBase);                  }                  while (lAdjust < 0);                    // Do we really need to round?                  fNeedRound = (ulRem >= ulShiftBase / 2);                    _bScale = bNewScale;                  _bPrec = bNewPrec;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,LAbsCmp,The following statement contains a magic number: uint[] rglData1 = new uint[4] { _data1' _data2' _data3' _data4 };
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,LAbsCmp,The following statement contains a magic number: uint[] rglData2 = new uint[4] { snumOp._data1' snumOp._data2' snumOp._data3' snumOp._data4 };
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,MpDiv1,The following statement contains a magic number: while (idU > 0)              {                  idU--;                  dwlAccum = (((ulong)ulCarry) << 32) + rgulU[idU];                  rgulU[idU] = (uint)(dwlAccum / ulD);                  ulCarry = (uint)(dwlAccum - rgulU[idU] * ulD);  // (ULONG) (dwlAccum % iulD)              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,DWL,The following statement contains a magic number: return lo + (((ulong)hi) << 32);
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,HI,The following statement contains a magic number: return (uint)(x >> 32);
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,MpDiv,The following statement contains a magic number: if (ciulD == 1 && rgulD[0] == 0)              {                  ciulQ = ciulR = 0;              }                // Check for simplest case' so it'll be fast              else if (ciulU == 1 && ciulD == 1)              {                  MpSet(rgulQ' out ciulQ' rgulU[0] / rgulD[0]);                  MpSet(rgulR' out ciulR' rgulU[0] % rgulD[0]);              }                // If D > U then do not divide at all              else if (ciulD > ciulU)              {                  MpMove(rgulU' ciulU' rgulR' out ciulR);        // R = U                  MpSet(rgulQ' out ciulQ' 0);                    // Q = 0              }                // Try to divide faster - check for remaining good sizes (8 / 4' 8 / 8)              else if (ciulU <= 2)              {                  ulong dwlU' dwlD' dwlT;                    dwlU = DWL(rgulU[0]' rgulU[1]);                  dwlD = rgulD[0];                  if (ciulD > 1)                      dwlD += (((ulong)rgulD[1]) << 32);                  dwlT = dwlU / dwlD;                  rgulQ[0] = LO(dwlT);                  rgulQ[1] = HI(dwlT);                  ciulQ = (HI(dwlT) != 0) ? 2 : 1;                  dwlT = dwlU % dwlD;                  rgulR[0] = LO(dwlT);                  rgulR[1] = HI(dwlT);                  ciulR = (HI(dwlT) != 0) ? 2 : 1;              }                // If we are dividing by one digit - use simpler routine              else if (ciulD == 1)              {                  MpMove(rgulU' ciulU' rgulQ' out ciulQ);        // Q = U                  uint remainder;                  MpDiv1(rgulQ' ref ciulQ' rgulD[0]' out remainder);     // Q = Q / D' R = Q % D                  rgulR[0] = remainder;                  ciulR = 1;              }                // Worst case. Knuth' "The Art of Computer Programming"' 3rd edition' vol.II' Alg.D' pg 272              else              {                  ciulQ = ciulR = 0;                    uint D1' ulDHigh' ulDSecond;                  int iulRindex;                    if (rgulU != rgulR)                      MpMove(rgulU' ciulU' rgulR' out ciulR);        // R = U                    ciulQ = ciulU - ciulD + 1;                  ulDHigh = rgulD[ciulD - 1];                    // D1.    Normalize so high digit of D >= BASE/2 - that guarantee                  //        that QH will not be too far from the correct digit later in D3                  rgulR[ciulU] = 0;                  iulRindex = ciulU;                  D1 = (uint)(s_ulInt32Base / ((ulong)ulDHigh + 1));                  if (D1 > 1)                  {                      MpMul1(rgulD' ref ciulD' D1);                      ulDHigh = rgulD[ciulD - 1];                      MpMul1(rgulR' ref ciulR' D1);                  }                  ulDSecond = rgulD[ciulD - 2];                  // D2 already done - iulRindex initialized before normalization of R.                  // D3-D7. Loop on iulRindex - obtaining digits one-by-one' as "in paper"                  do                  {                      uint QH' RH;                      int iulDindex' iulRwork;                      ulong dwlAccum' dwlMulAccum;                        // D3. Calculate Q hat - estimation of the next digit                      dwlAccum = DWL(rgulR[iulRindex - 1]' rgulR[iulRindex]);                      if (ulDHigh == rgulR[iulRindex])                          QH = (uint)(s_ulInt32Base - 1);                      else                          QH = (uint)(dwlAccum / ulDHigh);                      ulong ulTemp = QH;                      RH = (uint)(dwlAccum - ulTemp * ulDHigh);                        while (ulDSecond * ulTemp > DWL(rgulR[iulRindex - 2]' RH))                      {                          QH--;                          if (RH >= (uint)-((int)ulDHigh))                              break;                          RH += ulDHigh;                          ulTemp = QH;                      }                        // D4. Multiply and subtract: (some digits of) R -= D * QH                      for (dwlAccum = s_ulInt32Base' dwlMulAccum = 0' iulDindex = 0' iulRwork = iulRindex - ciulD;                          iulDindex < ciulD; iulDindex++' iulRwork++)                      {                          ulong ulTemp2 = rgulD[iulDindex];                          dwlMulAccum += QH * ulTemp2;                          dwlAccum += (ulong)rgulR[iulRwork] - LO(dwlMulAccum);                          dwlMulAccum = HI(dwlMulAccum);                          rgulR[iulRwork] = LO(dwlAccum);                          dwlAccum = HI(dwlAccum) + s_ulInt32Base - 1;                      }                      dwlAccum += rgulR[iulRwork] - dwlMulAccum;                      rgulR[iulRwork] = LO(dwlAccum);                      rgulQ[iulRindex - ciulD] = QH;                        // D5. Test remainder. Carry indicates result<0' therefore QH 1 too large                      if (HI(dwlAccum) == 0)                      {                          // D6. Add back - probabilty is 2**(-31). R += D. Q[digit] -= 1                          uint ulCarry;                            rgulQ[iulRindex - ciulD] = QH - 1;                          for (ulCarry = 0' iulDindex = 0' iulRwork = iulRindex - ciulD;                              iulDindex < ciulD; iulDindex++' iulRwork++)                          {                              dwlAccum = rgulD[iulDindex] + (ulong)rgulR[iulRwork] + ulCarry;                              ulCarry = HI(dwlAccum);                              rgulR[iulRwork] = LO(dwlAccum);                          }                          rgulR[iulRwork] += ulCarry;                      }                      // D7. Loop on iulRindex                      iulRindex--;                  }                  while (iulRindex >= ciulD);                  // Normalize results                  MpNormalize(rgulQ' ref ciulQ);                  ciulR = ciulD;                  MpNormalize(rgulR' ref ciulR);                  // D8. Unnormalize: Divide D and R to get result                  if (D1 > 1)                  {                      uint ret;                      MpDiv1(rgulD' ref ciulD' D1' out ret);                      MpDiv1(rgulR' ref ciulR' D1' out ret);                  }              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,MpDiv,The following statement contains a magic number: if (ciulD == 1 && rgulD[0] == 0)              {                  ciulQ = ciulR = 0;              }                // Check for simplest case' so it'll be fast              else if (ciulU == 1 && ciulD == 1)              {                  MpSet(rgulQ' out ciulQ' rgulU[0] / rgulD[0]);                  MpSet(rgulR' out ciulR' rgulU[0] % rgulD[0]);              }                // If D > U then do not divide at all              else if (ciulD > ciulU)              {                  MpMove(rgulU' ciulU' rgulR' out ciulR);        // R = U                  MpSet(rgulQ' out ciulQ' 0);                    // Q = 0              }                // Try to divide faster - check for remaining good sizes (8 / 4' 8 / 8)              else if (ciulU <= 2)              {                  ulong dwlU' dwlD' dwlT;                    dwlU = DWL(rgulU[0]' rgulU[1]);                  dwlD = rgulD[0];                  if (ciulD > 1)                      dwlD += (((ulong)rgulD[1]) << 32);                  dwlT = dwlU / dwlD;                  rgulQ[0] = LO(dwlT);                  rgulQ[1] = HI(dwlT);                  ciulQ = (HI(dwlT) != 0) ? 2 : 1;                  dwlT = dwlU % dwlD;                  rgulR[0] = LO(dwlT);                  rgulR[1] = HI(dwlT);                  ciulR = (HI(dwlT) != 0) ? 2 : 1;              }                // If we are dividing by one digit - use simpler routine              else if (ciulD == 1)              {                  MpMove(rgulU' ciulU' rgulQ' out ciulQ);        // Q = U                  uint remainder;                  MpDiv1(rgulQ' ref ciulQ' rgulD[0]' out remainder);     // Q = Q / D' R = Q % D                  rgulR[0] = remainder;                  ciulR = 1;              }                // Worst case. Knuth' "The Art of Computer Programming"' 3rd edition' vol.II' Alg.D' pg 272              else              {                  ciulQ = ciulR = 0;                    uint D1' ulDHigh' ulDSecond;                  int iulRindex;                    if (rgulU != rgulR)                      MpMove(rgulU' ciulU' rgulR' out ciulR);        // R = U                    ciulQ = ciulU - ciulD + 1;                  ulDHigh = rgulD[ciulD - 1];                    // D1.    Normalize so high digit of D >= BASE/2 - that guarantee                  //        that QH will not be too far from the correct digit later in D3                  rgulR[ciulU] = 0;                  iulRindex = ciulU;                  D1 = (uint)(s_ulInt32Base / ((ulong)ulDHigh + 1));                  if (D1 > 1)                  {                      MpMul1(rgulD' ref ciulD' D1);                      ulDHigh = rgulD[ciulD - 1];                      MpMul1(rgulR' ref ciulR' D1);                  }                  ulDSecond = rgulD[ciulD - 2];                  // D2 already done - iulRindex initialized before normalization of R.                  // D3-D7. Loop on iulRindex - obtaining digits one-by-one' as "in paper"                  do                  {                      uint QH' RH;                      int iulDindex' iulRwork;                      ulong dwlAccum' dwlMulAccum;                        // D3. Calculate Q hat - estimation of the next digit                      dwlAccum = DWL(rgulR[iulRindex - 1]' rgulR[iulRindex]);                      if (ulDHigh == rgulR[iulRindex])                          QH = (uint)(s_ulInt32Base - 1);                      else                          QH = (uint)(dwlAccum / ulDHigh);                      ulong ulTemp = QH;                      RH = (uint)(dwlAccum - ulTemp * ulDHigh);                        while (ulDSecond * ulTemp > DWL(rgulR[iulRindex - 2]' RH))                      {                          QH--;                          if (RH >= (uint)-((int)ulDHigh))                              break;                          RH += ulDHigh;                          ulTemp = QH;                      }                        // D4. Multiply and subtract: (some digits of) R -= D * QH                      for (dwlAccum = s_ulInt32Base' dwlMulAccum = 0' iulDindex = 0' iulRwork = iulRindex - ciulD;                          iulDindex < ciulD; iulDindex++' iulRwork++)                      {                          ulong ulTemp2 = rgulD[iulDindex];                          dwlMulAccum += QH * ulTemp2;                          dwlAccum += (ulong)rgulR[iulRwork] - LO(dwlMulAccum);                          dwlMulAccum = HI(dwlMulAccum);                          rgulR[iulRwork] = LO(dwlAccum);                          dwlAccum = HI(dwlAccum) + s_ulInt32Base - 1;                      }                      dwlAccum += rgulR[iulRwork] - dwlMulAccum;                      rgulR[iulRwork] = LO(dwlAccum);                      rgulQ[iulRindex - ciulD] = QH;                        // D5. Test remainder. Carry indicates result<0' therefore QH 1 too large                      if (HI(dwlAccum) == 0)                      {                          // D6. Add back - probabilty is 2**(-31). R += D. Q[digit] -= 1                          uint ulCarry;                            rgulQ[iulRindex - ciulD] = QH - 1;                          for (ulCarry = 0' iulDindex = 0' iulRwork = iulRindex - ciulD;                              iulDindex < ciulD; iulDindex++' iulRwork++)                          {                              dwlAccum = rgulD[iulDindex] + (ulong)rgulR[iulRwork] + ulCarry;                              ulCarry = HI(dwlAccum);                              rgulR[iulRwork] = LO(dwlAccum);                          }                          rgulR[iulRwork] += ulCarry;                      }                      // D7. Loop on iulRindex                      iulRindex--;                  }                  while (iulRindex >= ciulD);                  // Normalize results                  MpNormalize(rgulQ' ref ciulQ);                  ciulR = ciulD;                  MpNormalize(rgulR' ref ciulR);                  // D8. Unnormalize: Divide D and R to get result                  if (D1 > 1)                  {                      uint ret;                      MpDiv1(rgulD' ref ciulD' D1' out ret);                      MpDiv1(rgulR' ref ciulR' D1' out ret);                  }              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,MpDiv,The following statement contains a magic number: if (ciulD == 1 && rgulD[0] == 0)              {                  ciulQ = ciulR = 0;              }                // Check for simplest case' so it'll be fast              else if (ciulU == 1 && ciulD == 1)              {                  MpSet(rgulQ' out ciulQ' rgulU[0] / rgulD[0]);                  MpSet(rgulR' out ciulR' rgulU[0] % rgulD[0]);              }                // If D > U then do not divide at all              else if (ciulD > ciulU)              {                  MpMove(rgulU' ciulU' rgulR' out ciulR);        // R = U                  MpSet(rgulQ' out ciulQ' 0);                    // Q = 0              }                // Try to divide faster - check for remaining good sizes (8 / 4' 8 / 8)              else if (ciulU <= 2)              {                  ulong dwlU' dwlD' dwlT;                    dwlU = DWL(rgulU[0]' rgulU[1]);                  dwlD = rgulD[0];                  if (ciulD > 1)                      dwlD += (((ulong)rgulD[1]) << 32);                  dwlT = dwlU / dwlD;                  rgulQ[0] = LO(dwlT);                  rgulQ[1] = HI(dwlT);                  ciulQ = (HI(dwlT) != 0) ? 2 : 1;                  dwlT = dwlU % dwlD;                  rgulR[0] = LO(dwlT);                  rgulR[1] = HI(dwlT);                  ciulR = (HI(dwlT) != 0) ? 2 : 1;              }                // If we are dividing by one digit - use simpler routine              else if (ciulD == 1)              {                  MpMove(rgulU' ciulU' rgulQ' out ciulQ);        // Q = U                  uint remainder;                  MpDiv1(rgulQ' ref ciulQ' rgulD[0]' out remainder);     // Q = Q / D' R = Q % D                  rgulR[0] = remainder;                  ciulR = 1;              }                // Worst case. Knuth' "The Art of Computer Programming"' 3rd edition' vol.II' Alg.D' pg 272              else              {                  ciulQ = ciulR = 0;                    uint D1' ulDHigh' ulDSecond;                  int iulRindex;                    if (rgulU != rgulR)                      MpMove(rgulU' ciulU' rgulR' out ciulR);        // R = U                    ciulQ = ciulU - ciulD + 1;                  ulDHigh = rgulD[ciulD - 1];                    // D1.    Normalize so high digit of D >= BASE/2 - that guarantee                  //        that QH will not be too far from the correct digit later in D3                  rgulR[ciulU] = 0;                  iulRindex = ciulU;                  D1 = (uint)(s_ulInt32Base / ((ulong)ulDHigh + 1));                  if (D1 > 1)                  {                      MpMul1(rgulD' ref ciulD' D1);                      ulDHigh = rgulD[ciulD - 1];                      MpMul1(rgulR' ref ciulR' D1);                  }                  ulDSecond = rgulD[ciulD - 2];                  // D2 already done - iulRindex initialized before normalization of R.                  // D3-D7. Loop on iulRindex - obtaining digits one-by-one' as "in paper"                  do                  {                      uint QH' RH;                      int iulDindex' iulRwork;                      ulong dwlAccum' dwlMulAccum;                        // D3. Calculate Q hat - estimation of the next digit                      dwlAccum = DWL(rgulR[iulRindex - 1]' rgulR[iulRindex]);                      if (ulDHigh == rgulR[iulRindex])                          QH = (uint)(s_ulInt32Base - 1);                      else                          QH = (uint)(dwlAccum / ulDHigh);                      ulong ulTemp = QH;                      RH = (uint)(dwlAccum - ulTemp * ulDHigh);                        while (ulDSecond * ulTemp > DWL(rgulR[iulRindex - 2]' RH))                      {                          QH--;                          if (RH >= (uint)-((int)ulDHigh))                              break;                          RH += ulDHigh;                          ulTemp = QH;                      }                        // D4. Multiply and subtract: (some digits of) R -= D * QH                      for (dwlAccum = s_ulInt32Base' dwlMulAccum = 0' iulDindex = 0' iulRwork = iulRindex - ciulD;                          iulDindex < ciulD; iulDindex++' iulRwork++)                      {                          ulong ulTemp2 = rgulD[iulDindex];                          dwlMulAccum += QH * ulTemp2;                          dwlAccum += (ulong)rgulR[iulRwork] - LO(dwlMulAccum);                          dwlMulAccum = HI(dwlMulAccum);                          rgulR[iulRwork] = LO(dwlAccum);                          dwlAccum = HI(dwlAccum) + s_ulInt32Base - 1;                      }                      dwlAccum += rgulR[iulRwork] - dwlMulAccum;                      rgulR[iulRwork] = LO(dwlAccum);                      rgulQ[iulRindex - ciulD] = QH;                        // D5. Test remainder. Carry indicates result<0' therefore QH 1 too large                      if (HI(dwlAccum) == 0)                      {                          // D6. Add back - probabilty is 2**(-31). R += D. Q[digit] -= 1                          uint ulCarry;                            rgulQ[iulRindex - ciulD] = QH - 1;                          for (ulCarry = 0' iulDindex = 0' iulRwork = iulRindex - ciulD;                              iulDindex < ciulD; iulDindex++' iulRwork++)                          {                              dwlAccum = rgulD[iulDindex] + (ulong)rgulR[iulRwork] + ulCarry;                              ulCarry = HI(dwlAccum);                              rgulR[iulRwork] = LO(dwlAccum);                          }                          rgulR[iulRwork] += ulCarry;                      }                      // D7. Loop on iulRindex                      iulRindex--;                  }                  while (iulRindex >= ciulD);                  // Normalize results                  MpNormalize(rgulQ' ref ciulQ);                  ciulR = ciulD;                  MpNormalize(rgulR' ref ciulR);                  // D8. Unnormalize: Divide D and R to get result                  if (D1 > 1)                  {                      uint ret;                      MpDiv1(rgulD' ref ciulD' D1' out ret);                      MpDiv1(rgulR' ref ciulR' D1' out ret);                  }              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,MpDiv,The following statement contains a magic number: if (ciulD == 1 && rgulD[0] == 0)              {                  ciulQ = ciulR = 0;              }                // Check for simplest case' so it'll be fast              else if (ciulU == 1 && ciulD == 1)              {                  MpSet(rgulQ' out ciulQ' rgulU[0] / rgulD[0]);                  MpSet(rgulR' out ciulR' rgulU[0] % rgulD[0]);              }                // If D > U then do not divide at all              else if (ciulD > ciulU)              {                  MpMove(rgulU' ciulU' rgulR' out ciulR);        // R = U                  MpSet(rgulQ' out ciulQ' 0);                    // Q = 0              }                // Try to divide faster - check for remaining good sizes (8 / 4' 8 / 8)              else if (ciulU <= 2)              {                  ulong dwlU' dwlD' dwlT;                    dwlU = DWL(rgulU[0]' rgulU[1]);                  dwlD = rgulD[0];                  if (ciulD > 1)                      dwlD += (((ulong)rgulD[1]) << 32);                  dwlT = dwlU / dwlD;                  rgulQ[0] = LO(dwlT);                  rgulQ[1] = HI(dwlT);                  ciulQ = (HI(dwlT) != 0) ? 2 : 1;                  dwlT = dwlU % dwlD;                  rgulR[0] = LO(dwlT);                  rgulR[1] = HI(dwlT);                  ciulR = (HI(dwlT) != 0) ? 2 : 1;              }                // If we are dividing by one digit - use simpler routine              else if (ciulD == 1)              {                  MpMove(rgulU' ciulU' rgulQ' out ciulQ);        // Q = U                  uint remainder;                  MpDiv1(rgulQ' ref ciulQ' rgulD[0]' out remainder);     // Q = Q / D' R = Q % D                  rgulR[0] = remainder;                  ciulR = 1;              }                // Worst case. Knuth' "The Art of Computer Programming"' 3rd edition' vol.II' Alg.D' pg 272              else              {                  ciulQ = ciulR = 0;                    uint D1' ulDHigh' ulDSecond;                  int iulRindex;                    if (rgulU != rgulR)                      MpMove(rgulU' ciulU' rgulR' out ciulR);        // R = U                    ciulQ = ciulU - ciulD + 1;                  ulDHigh = rgulD[ciulD - 1];                    // D1.    Normalize so high digit of D >= BASE/2 - that guarantee                  //        that QH will not be too far from the correct digit later in D3                  rgulR[ciulU] = 0;                  iulRindex = ciulU;                  D1 = (uint)(s_ulInt32Base / ((ulong)ulDHigh + 1));                  if (D1 > 1)                  {                      MpMul1(rgulD' ref ciulD' D1);                      ulDHigh = rgulD[ciulD - 1];                      MpMul1(rgulR' ref ciulR' D1);                  }                  ulDSecond = rgulD[ciulD - 2];                  // D2 already done - iulRindex initialized before normalization of R.                  // D3-D7. Loop on iulRindex - obtaining digits one-by-one' as "in paper"                  do                  {                      uint QH' RH;                      int iulDindex' iulRwork;                      ulong dwlAccum' dwlMulAccum;                        // D3. Calculate Q hat - estimation of the next digit                      dwlAccum = DWL(rgulR[iulRindex - 1]' rgulR[iulRindex]);                      if (ulDHigh == rgulR[iulRindex])                          QH = (uint)(s_ulInt32Base - 1);                      else                          QH = (uint)(dwlAccum / ulDHigh);                      ulong ulTemp = QH;                      RH = (uint)(dwlAccum - ulTemp * ulDHigh);                        while (ulDSecond * ulTemp > DWL(rgulR[iulRindex - 2]' RH))                      {                          QH--;                          if (RH >= (uint)-((int)ulDHigh))                              break;                          RH += ulDHigh;                          ulTemp = QH;                      }                        // D4. Multiply and subtract: (some digits of) R -= D * QH                      for (dwlAccum = s_ulInt32Base' dwlMulAccum = 0' iulDindex = 0' iulRwork = iulRindex - ciulD;                          iulDindex < ciulD; iulDindex++' iulRwork++)                      {                          ulong ulTemp2 = rgulD[iulDindex];                          dwlMulAccum += QH * ulTemp2;                          dwlAccum += (ulong)rgulR[iulRwork] - LO(dwlMulAccum);                          dwlMulAccum = HI(dwlMulAccum);                          rgulR[iulRwork] = LO(dwlAccum);                          dwlAccum = HI(dwlAccum) + s_ulInt32Base - 1;                      }                      dwlAccum += rgulR[iulRwork] - dwlMulAccum;                      rgulR[iulRwork] = LO(dwlAccum);                      rgulQ[iulRindex - ciulD] = QH;                        // D5. Test remainder. Carry indicates result<0' therefore QH 1 too large                      if (HI(dwlAccum) == 0)                      {                          // D6. Add back - probabilty is 2**(-31). R += D. Q[digit] -= 1                          uint ulCarry;                            rgulQ[iulRindex - ciulD] = QH - 1;                          for (ulCarry = 0' iulDindex = 0' iulRwork = iulRindex - ciulD;                              iulDindex < ciulD; iulDindex++' iulRwork++)                          {                              dwlAccum = rgulD[iulDindex] + (ulong)rgulR[iulRwork] + ulCarry;                              ulCarry = HI(dwlAccum);                              rgulR[iulRwork] = LO(dwlAccum);                          }                          rgulR[iulRwork] += ulCarry;                      }                      // D7. Loop on iulRindex                      iulRindex--;                  }                  while (iulRindex >= ciulD);                  // Normalize results                  MpNormalize(rgulQ' ref ciulQ);                  ciulR = ciulD;                  MpNormalize(rgulR' ref ciulR);                  // D8. Unnormalize: Divide D and R to get result                  if (D1 > 1)                  {                      uint ret;                      MpDiv1(rgulD' ref ciulD' D1' out ret);                      MpDiv1(rgulR' ref ciulR' D1' out ret);                  }              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,MpDiv,The following statement contains a magic number: if (ciulD == 1 && rgulD[0] == 0)              {                  ciulQ = ciulR = 0;              }                // Check for simplest case' so it'll be fast              else if (ciulU == 1 && ciulD == 1)              {                  MpSet(rgulQ' out ciulQ' rgulU[0] / rgulD[0]);                  MpSet(rgulR' out ciulR' rgulU[0] % rgulD[0]);              }                // If D > U then do not divide at all              else if (ciulD > ciulU)              {                  MpMove(rgulU' ciulU' rgulR' out ciulR);        // R = U                  MpSet(rgulQ' out ciulQ' 0);                    // Q = 0              }                // Try to divide faster - check for remaining good sizes (8 / 4' 8 / 8)              else if (ciulU <= 2)              {                  ulong dwlU' dwlD' dwlT;                    dwlU = DWL(rgulU[0]' rgulU[1]);                  dwlD = rgulD[0];                  if (ciulD > 1)                      dwlD += (((ulong)rgulD[1]) << 32);                  dwlT = dwlU / dwlD;                  rgulQ[0] = LO(dwlT);                  rgulQ[1] = HI(dwlT);                  ciulQ = (HI(dwlT) != 0) ? 2 : 1;                  dwlT = dwlU % dwlD;                  rgulR[0] = LO(dwlT);                  rgulR[1] = HI(dwlT);                  ciulR = (HI(dwlT) != 0) ? 2 : 1;              }                // If we are dividing by one digit - use simpler routine              else if (ciulD == 1)              {                  MpMove(rgulU' ciulU' rgulQ' out ciulQ);        // Q = U                  uint remainder;                  MpDiv1(rgulQ' ref ciulQ' rgulD[0]' out remainder);     // Q = Q / D' R = Q % D                  rgulR[0] = remainder;                  ciulR = 1;              }                // Worst case. Knuth' "The Art of Computer Programming"' 3rd edition' vol.II' Alg.D' pg 272              else              {                  ciulQ = ciulR = 0;                    uint D1' ulDHigh' ulDSecond;                  int iulRindex;                    if (rgulU != rgulR)                      MpMove(rgulU' ciulU' rgulR' out ciulR);        // R = U                    ciulQ = ciulU - ciulD + 1;                  ulDHigh = rgulD[ciulD - 1];                    // D1.    Normalize so high digit of D >= BASE/2 - that guarantee                  //        that QH will not be too far from the correct digit later in D3                  rgulR[ciulU] = 0;                  iulRindex = ciulU;                  D1 = (uint)(s_ulInt32Base / ((ulong)ulDHigh + 1));                  if (D1 > 1)                  {                      MpMul1(rgulD' ref ciulD' D1);                      ulDHigh = rgulD[ciulD - 1];                      MpMul1(rgulR' ref ciulR' D1);                  }                  ulDSecond = rgulD[ciulD - 2];                  // D2 already done - iulRindex initialized before normalization of R.                  // D3-D7. Loop on iulRindex - obtaining digits one-by-one' as "in paper"                  do                  {                      uint QH' RH;                      int iulDindex' iulRwork;                      ulong dwlAccum' dwlMulAccum;                        // D3. Calculate Q hat - estimation of the next digit                      dwlAccum = DWL(rgulR[iulRindex - 1]' rgulR[iulRindex]);                      if (ulDHigh == rgulR[iulRindex])                          QH = (uint)(s_ulInt32Base - 1);                      else                          QH = (uint)(dwlAccum / ulDHigh);                      ulong ulTemp = QH;                      RH = (uint)(dwlAccum - ulTemp * ulDHigh);                        while (ulDSecond * ulTemp > DWL(rgulR[iulRindex - 2]' RH))                      {                          QH--;                          if (RH >= (uint)-((int)ulDHigh))                              break;                          RH += ulDHigh;                          ulTemp = QH;                      }                        // D4. Multiply and subtract: (some digits of) R -= D * QH                      for (dwlAccum = s_ulInt32Base' dwlMulAccum = 0' iulDindex = 0' iulRwork = iulRindex - ciulD;                          iulDindex < ciulD; iulDindex++' iulRwork++)                      {                          ulong ulTemp2 = rgulD[iulDindex];                          dwlMulAccum += QH * ulTemp2;                          dwlAccum += (ulong)rgulR[iulRwork] - LO(dwlMulAccum);                          dwlMulAccum = HI(dwlMulAccum);                          rgulR[iulRwork] = LO(dwlAccum);                          dwlAccum = HI(dwlAccum) + s_ulInt32Base - 1;                      }                      dwlAccum += rgulR[iulRwork] - dwlMulAccum;                      rgulR[iulRwork] = LO(dwlAccum);                      rgulQ[iulRindex - ciulD] = QH;                        // D5. Test remainder. Carry indicates result<0' therefore QH 1 too large                      if (HI(dwlAccum) == 0)                      {                          // D6. Add back - probabilty is 2**(-31). R += D. Q[digit] -= 1                          uint ulCarry;                            rgulQ[iulRindex - ciulD] = QH - 1;                          for (ulCarry = 0' iulDindex = 0' iulRwork = iulRindex - ciulD;                              iulDindex < ciulD; iulDindex++' iulRwork++)                          {                              dwlAccum = rgulD[iulDindex] + (ulong)rgulR[iulRwork] + ulCarry;                              ulCarry = HI(dwlAccum);                              rgulR[iulRwork] = LO(dwlAccum);                          }                          rgulR[iulRwork] += ulCarry;                      }                      // D7. Loop on iulRindex                      iulRindex--;                  }                  while (iulRindex >= ciulD);                  // Normalize results                  MpNormalize(rgulQ' ref ciulQ);                  ciulR = ciulD;                  MpNormalize(rgulR' ref ciulR);                  // D8. Unnormalize: Divide D and R to get result                  if (D1 > 1)                  {                      uint ret;                      MpDiv1(rgulD' ref ciulD' D1' out ret);                      MpDiv1(rgulR' ref ciulR' D1' out ret);                  }              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,MpDiv,The following statement contains a magic number: if (ciulD == 1 && rgulD[0] == 0)              {                  ciulQ = ciulR = 0;              }                // Check for simplest case' so it'll be fast              else if (ciulU == 1 && ciulD == 1)              {                  MpSet(rgulQ' out ciulQ' rgulU[0] / rgulD[0]);                  MpSet(rgulR' out ciulR' rgulU[0] % rgulD[0]);              }                // If D > U then do not divide at all              else if (ciulD > ciulU)              {                  MpMove(rgulU' ciulU' rgulR' out ciulR);        // R = U                  MpSet(rgulQ' out ciulQ' 0);                    // Q = 0              }                // Try to divide faster - check for remaining good sizes (8 / 4' 8 / 8)              else if (ciulU <= 2)              {                  ulong dwlU' dwlD' dwlT;                    dwlU = DWL(rgulU[0]' rgulU[1]);                  dwlD = rgulD[0];                  if (ciulD > 1)                      dwlD += (((ulong)rgulD[1]) << 32);                  dwlT = dwlU / dwlD;                  rgulQ[0] = LO(dwlT);                  rgulQ[1] = HI(dwlT);                  ciulQ = (HI(dwlT) != 0) ? 2 : 1;                  dwlT = dwlU % dwlD;                  rgulR[0] = LO(dwlT);                  rgulR[1] = HI(dwlT);                  ciulR = (HI(dwlT) != 0) ? 2 : 1;              }                // If we are dividing by one digit - use simpler routine              else if (ciulD == 1)              {                  MpMove(rgulU' ciulU' rgulQ' out ciulQ);        // Q = U                  uint remainder;                  MpDiv1(rgulQ' ref ciulQ' rgulD[0]' out remainder);     // Q = Q / D' R = Q % D                  rgulR[0] = remainder;                  ciulR = 1;              }                // Worst case. Knuth' "The Art of Computer Programming"' 3rd edition' vol.II' Alg.D' pg 272              else              {                  ciulQ = ciulR = 0;                    uint D1' ulDHigh' ulDSecond;                  int iulRindex;                    if (rgulU != rgulR)                      MpMove(rgulU' ciulU' rgulR' out ciulR);        // R = U                    ciulQ = ciulU - ciulD + 1;                  ulDHigh = rgulD[ciulD - 1];                    // D1.    Normalize so high digit of D >= BASE/2 - that guarantee                  //        that QH will not be too far from the correct digit later in D3                  rgulR[ciulU] = 0;                  iulRindex = ciulU;                  D1 = (uint)(s_ulInt32Base / ((ulong)ulDHigh + 1));                  if (D1 > 1)                  {                      MpMul1(rgulD' ref ciulD' D1);                      ulDHigh = rgulD[ciulD - 1];                      MpMul1(rgulR' ref ciulR' D1);                  }                  ulDSecond = rgulD[ciulD - 2];                  // D2 already done - iulRindex initialized before normalization of R.                  // D3-D7. Loop on iulRindex - obtaining digits one-by-one' as "in paper"                  do                  {                      uint QH' RH;                      int iulDindex' iulRwork;                      ulong dwlAccum' dwlMulAccum;                        // D3. Calculate Q hat - estimation of the next digit                      dwlAccum = DWL(rgulR[iulRindex - 1]' rgulR[iulRindex]);                      if (ulDHigh == rgulR[iulRindex])                          QH = (uint)(s_ulInt32Base - 1);                      else                          QH = (uint)(dwlAccum / ulDHigh);                      ulong ulTemp = QH;                      RH = (uint)(dwlAccum - ulTemp * ulDHigh);                        while (ulDSecond * ulTemp > DWL(rgulR[iulRindex - 2]' RH))                      {                          QH--;                          if (RH >= (uint)-((int)ulDHigh))                              break;                          RH += ulDHigh;                          ulTemp = QH;                      }                        // D4. Multiply and subtract: (some digits of) R -= D * QH                      for (dwlAccum = s_ulInt32Base' dwlMulAccum = 0' iulDindex = 0' iulRwork = iulRindex - ciulD;                          iulDindex < ciulD; iulDindex++' iulRwork++)                      {                          ulong ulTemp2 = rgulD[iulDindex];                          dwlMulAccum += QH * ulTemp2;                          dwlAccum += (ulong)rgulR[iulRwork] - LO(dwlMulAccum);                          dwlMulAccum = HI(dwlMulAccum);                          rgulR[iulRwork] = LO(dwlAccum);                          dwlAccum = HI(dwlAccum) + s_ulInt32Base - 1;                      }                      dwlAccum += rgulR[iulRwork] - dwlMulAccum;                      rgulR[iulRwork] = LO(dwlAccum);                      rgulQ[iulRindex - ciulD] = QH;                        // D5. Test remainder. Carry indicates result<0' therefore QH 1 too large                      if (HI(dwlAccum) == 0)                      {                          // D6. Add back - probabilty is 2**(-31). R += D. Q[digit] -= 1                          uint ulCarry;                            rgulQ[iulRindex - ciulD] = QH - 1;                          for (ulCarry = 0' iulDindex = 0' iulRwork = iulRindex - ciulD;                              iulDindex < ciulD; iulDindex++' iulRwork++)                          {                              dwlAccum = rgulD[iulDindex] + (ulong)rgulR[iulRwork] + ulCarry;                              ulCarry = HI(dwlAccum);                              rgulR[iulRwork] = LO(dwlAccum);                          }                          rgulR[iulRwork] += ulCarry;                      }                      // D7. Loop on iulRindex                      iulRindex--;                  }                  while (iulRindex >= ciulD);                  // Normalize results                  MpNormalize(rgulQ' ref ciulQ);                  ciulR = ciulD;                  MpNormalize(rgulR' ref ciulR);                  // D8. Unnormalize: Divide D and R to get result                  if (D1 > 1)                  {                      uint ret;                      MpDiv1(rgulD' ref ciulD' D1' out ret);                      MpDiv1(rgulR' ref ciulR' D1' out ret);                  }              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,ChFromDigit,The following statement contains a magic number: Debug.Assert(uiDigit < 10);
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,StoreFromWorkingArray,The following statement contains a magic number: Debug.Assert(rguiData.Length == 4);
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,StoreFromWorkingArray,The following statement contains a magic number: _data3 = rguiData[2];
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,StoreFromWorkingArray,The following statement contains a magic number: _data4 = rguiData[3];
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,MakeInteger,The following statement contains a magic number: while (iAdjust > 0)              {                  if (iAdjust >= 9)                  {                      ulRem = DivByULong(s_rgulShiftBase[8]);                      iAdjust -= 9;                  }                  else                  {                      ulRem = DivByULong(s_rgulShiftBase[iAdjust - 1]);                      iAdjust = 0;                  }                    // Check for remainder and set fFraction flag.                  if (ulRem != 0)                      fFraction = true;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,MakeInteger,The following statement contains a magic number: while (iAdjust > 0)              {                  if (iAdjust >= 9)                  {                      ulRem = DivByULong(s_rgulShiftBase[8]);                      iAdjust -= 9;                  }                  else                  {                      ulRem = DivByULong(s_rgulShiftBase[iAdjust - 1]);                      iAdjust = 0;                  }                    // Check for remainder and set fFraction flag.                  if (ulRem != 0)                      fFraction = true;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,MakeInteger,The following statement contains a magic number: while (iAdjust > 0)              {                  if (iAdjust >= 9)                  {                      ulRem = DivByULong(s_rgulShiftBase[8]);                      iAdjust -= 9;                  }                  else                  {                      ulRem = DivByULong(s_rgulShiftBase[iAdjust - 1]);                      iAdjust = 0;                  }                    // Check for remainder and set fFraction flag.                  if (ulRem != 0)                      fFraction = true;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,Round,The following statement contains a magic number: while (lAdjust > 0)              {                  if (lAdjust >= 9)                  {                      ulRem = n.DivByULong(s_rgulShiftBase[8]);                      ulLastDivBase = s_rgulShiftBase[8];                      lAdjust -= 9;                  }                  else                  {                      ulRem = n.DivByULong(s_rgulShiftBase[lAdjust - 1]);                      ulLastDivBase = s_rgulShiftBase[lAdjust - 1];                      lAdjust = 0;                  }              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,Round,The following statement contains a magic number: while (lAdjust > 0)              {                  if (lAdjust >= 9)                  {                      ulRem = n.DivByULong(s_rgulShiftBase[8]);                      ulLastDivBase = s_rgulShiftBase[8];                      lAdjust -= 9;                  }                  else                  {                      ulRem = n.DivByULong(s_rgulShiftBase[lAdjust - 1]);                      ulLastDivBase = s_rgulShiftBase[lAdjust - 1];                      lAdjust = 0;                  }              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,Round,The following statement contains a magic number: while (lAdjust > 0)              {                  if (lAdjust >= 9)                  {                      ulRem = n.DivByULong(s_rgulShiftBase[8]);                      ulLastDivBase = s_rgulShiftBase[8];                      lAdjust -= 9;                  }                  else                  {                      ulRem = n.DivByULong(s_rgulShiftBase[lAdjust - 1]);                      ulLastDivBase = s_rgulShiftBase[lAdjust - 1];                      lAdjust = 0;                  }              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,Round,The following statement contains a magic number: while (lAdjust > 0)              {                  if (lAdjust >= 9)                  {                      ulRem = n.DivByULong(s_rgulShiftBase[8]);                      ulLastDivBase = s_rgulShiftBase[8];                      lAdjust -= 9;                  }                  else                  {                      ulRem = n.DivByULong(s_rgulShiftBase[lAdjust - 1]);                      ulLastDivBase = s_rgulShiftBase[lAdjust - 1];                      lAdjust = 0;                  }              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,Round,The following statement contains a magic number: if (ulLastDivBase > 1)              {                  ulRem /= (ulLastDivBase / 10);              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,Round,The following statement contains a magic number: if (n.FZero() && (fTruncate || ulRem < 5))              {                  n.SetPositive();                  n.AssertValid();                  return n;              }
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,Round,The following statement contains a magic number: if (ulRem >= 5 && !fTruncate)                  n.AddULong(1);
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,GetHashCode,The following statement contains a magic number: const int x_cbCrcWindow = 4;
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,GetHashCode,The following statement contains a magic number: const int iShiftVal = 4 * 8 - x_cbCrcWindow;
Magic Number,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,GetHashCode,The following statement contains a magic number: const int iShiftVal = 4 * 8 - x_cbCrcWindow;
Magic Number,System.Data.SqlTypes,SqlMoney,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLMoney.cs,SqlMoney,The following statement contains a magic number: ulong ulValue = snum._data1 + (((ulong)snum._data2) << 32);
Magic Number,System.Data.SqlTypes,SqlMoney,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLMoney.cs,ToDecimal,The following statement contains a magic number: return new decimal(unchecked((int)value)' unchecked((int)(value >> 32))' 0' fNegative' (byte)s_iMoneyScale);
Magic Number,System.Data.SqlTypes,SqlMoney,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLMoney.cs,ToInt64,The following statement contains a magic number: long ret = _value / (s_lTickBase / 10);
Magic Number,System.Data.SqlTypes,SqlMoney,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLMoney.cs,ToInt64,The following statement contains a magic number: long remainder = ret % 10;
Magic Number,System.Data.SqlTypes,SqlMoney,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLMoney.cs,ToInt64,The following statement contains a magic number: ret = ret / 10;
Magic Number,System.Data.SqlTypes,SqlMoney,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLMoney.cs,ToInt64,The following statement contains a magic number: if (remainder >= 5)              {                  if (fPositive)                      ret++;                  else                      ret--;              }
Magic Number,System.Data.SqlTypes,SqlString,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLString.cs,CompareBinary,The following statement contains a magic number: Debug.Assert(cbX % 2 == 0);
Magic Number,System.Data.SqlTypes,SqlString,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLString.cs,CompareBinary,The following statement contains a magic number: Debug.Assert(cbY % 2 == 0);
Magic Number,System.Data.SqlTypes,SqlString,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLString.cs,CompareBinary,The following statement contains a magic number: if (cbX < cbY)              {                  for (; i < cbY; i += 2)                  {                      iCh = rgDataY[i + 1] << 8 + rgDataY[i];                      if (iCh != iSpace)                          return (iSpace > iCh) ? 1 : -1;                  }              }              else              {                  for (; i < cbX; i += 2)                  {                      iCh = rgDataX[i + 1] << 8 + rgDataX[i];                      if (iCh != iSpace)                          return (iCh > iSpace) ? 1 : -1;                  }              }
Magic Number,System.Data.SqlTypes,SqlString,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLString.cs,CompareBinary,The following statement contains a magic number: if (cbX < cbY)              {                  for (; i < cbY; i += 2)                  {                      iCh = rgDataY[i + 1] << 8 + rgDataY[i];                      if (iCh != iSpace)                          return (iSpace > iCh) ? 1 : -1;                  }              }              else              {                  for (; i < cbX; i += 2)                  {                      iCh = rgDataX[i + 1] << 8 + rgDataX[i];                      if (iCh != iSpace)                          return (iCh > iSpace) ? 1 : -1;                  }              }
Magic Number,System.Data.SqlTypes,SqlString,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLString.cs,CompareBinary,The following statement contains a magic number: if (cbX < cbY)              {                  for (; i < cbY; i += 2)                  {                      iCh = rgDataY[i + 1] << 8 + rgDataY[i];                      if (iCh != iSpace)                          return (iSpace > iCh) ? 1 : -1;                  }              }              else              {                  for (; i < cbX; i += 2)                  {                      iCh = rgDataX[i + 1] << 8 + rgDataX[i];                      if (iCh != iSpace)                          return (iCh > iSpace) ? 1 : -1;                  }              }
Magic Number,System.Data.SqlTypes,SqlString,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLString.cs,CompareBinary,The following statement contains a magic number: if (cbX < cbY)              {                  for (; i < cbY; i += 2)                  {                      iCh = rgDataY[i + 1] << 8 + rgDataY[i];                      if (iCh != iSpace)                          return (iSpace > iCh) ? 1 : -1;                  }              }              else              {                  for (; i < cbX; i += 2)                  {                      iCh = rgDataX[i + 1] << 8 + rgDataX[i];                      if (iCh != iSpace)                          return (iCh > iSpace) ? 1 : -1;                  }              }
Magic Number,System.Data.SqlTypes,SqlBinary,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLBinary.cs,HashByteArray,The following statement contains a magic number: const int x_cbCrcWindow = 4;
Magic Number,System.Data.SqlTypes,SqlBinary,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLBinary.cs,HashByteArray,The following statement contains a magic number: const int iShiftVal = 4 * 8 - x_cbCrcWindow;
Magic Number,System.Data.SqlTypes,SqlBinary,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLBinary.cs,HashByteArray,The following statement contains a magic number: const int iShiftVal = 4 * 8 - x_cbCrcWindow;
Duplicate Code,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleTable,The method contains a code clone-set at the following line numbers (starting from the method definition): ((304' 337)' (372' 405))
Duplicate Code,System.Data,XmlTreeGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,HandleTable,The method contains a code clone-set at the following line numbers (starting from the method definition): ((304' 335)' (456' 487)' (372' 403))
Duplicate Code,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,ReadXmlSchema,The method contains a code clone-set at the following line numbers (starting from the method definition): ((27' 47)' (71' 91))
Duplicate Code,System.Data,ConstNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\ConstNode.cs,SmallestNumeric,The method contains a code clone-set at the following line numbers (starting from the method definition): ((35' 54)' (56' 75))
Missing Default,System.Data.Common,UInt64Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\UInt64Storage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Sum:                          ulong sum = s_defaultValue;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { sum += _values[record]; }                                  hasData = true;                              }                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          decimal meanSum = s_defaultValue;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { meanSum += _values[record]; }                                  meanCount++;                                  hasData = true;                              }                          }                          if (hasData)                          {                              ulong mean;                              checked { mean = (ulong)(meanSum / (decimal)meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          double var = 0.0f;                          double prec = 0.0f;                          double dsum = 0.0f;                          double sqrsum = 0.0f;                            foreach (int record in records)                          {                              if (HasValue(record))                              {                                  dsum += _values[record];                                  sqrsum += _values[record] * (double)_values[record];                                  count++;                              }                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                              // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          ulong min = ulong.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  min = Math.Min(_values[record]' min);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          ulong max = ulong.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  max = Math.Max(_values[record]' max);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          return base.Aggregate(records' kind);                  }
Missing Default,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,InvalidAcceptRejectRule,The following switch statement is missing a default case: switch (value)              {                  case AcceptRejectRule.None:                  case AcceptRejectRule.Cascade:                      Debug.Assert(false' "valid AcceptRejectRule " + value.ToString());                      break;              }
Missing Default,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,InvalidCatalogLocation,The following switch statement is missing a default case: switch (value)              {                  case CatalogLocation.Start:                  case CatalogLocation.End:                      Debug.Assert(false' "valid CatalogLocation " + value.ToString());                      break;              }
Missing Default,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,InvalidConflictOptions,The following switch statement is missing a default case: switch (value)              {                  case ConflictOption.CompareAllSearchableValues:                  case ConflictOption.CompareRowVersion:                  case ConflictOption.OverwriteChanges:                      Debug.Assert(false' "valid ConflictOption " + value.ToString());                      break;              }
Missing Default,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,InvalidDataRowState,The following switch statement is missing a default case: switch (value)              {                  case DataRowState.Detached:                  case DataRowState.Unchanged:                  case DataRowState.Added:                  case DataRowState.Deleted:                  case DataRowState.Modified:                      Debug.Assert(false' "valid DataRowState " + value.ToString());                      break;              }
Missing Default,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,InvalidKeyRestrictionBehavior,The following switch statement is missing a default case: switch (value)              {                  case KeyRestrictionBehavior.PreventUsage:                  case KeyRestrictionBehavior.AllowOnly:                      Debug.Assert(false' "valid KeyRestrictionBehavior " + value.ToString());                      break;              }
Missing Default,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,InvalidLoadOption,The following switch statement is missing a default case: switch (value)              {                  case LoadOption.OverwriteChanges:                  case LoadOption.PreserveChanges:                  case LoadOption.Upsert:                      Debug.Assert(false' "valid LoadOption " + value.ToString());                      break;              }
Missing Default,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,InvalidMissingMappingAction,The following switch statement is missing a default case: switch (value)              {                  case MissingMappingAction.Passthrough:                  case MissingMappingAction.Ignore:                  case MissingMappingAction.Error:                      Debug.Assert(false' "valid MissingMappingAction " + value.ToString());                      break;              }
Missing Default,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,InvalidMissingSchemaAction,The following switch statement is missing a default case: switch (value)              {                  case MissingSchemaAction.Add:                  case MissingSchemaAction.Ignore:                  case MissingSchemaAction.Error:                  case MissingSchemaAction.AddWithKey:                      Debug.Assert(false' "valid MissingSchemaAction " + value.ToString());                      break;              }
Missing Default,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,InvalidRule,The following switch statement is missing a default case: switch (value)              {                  case Rule.None:                  case Rule.Cascade:                  case Rule.SetNull:                  case Rule.SetDefault:                      Debug.Assert(false' "valid Rule " + value.ToString());                      break;              }
Missing Default,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,InvalidSchemaType,The following switch statement is missing a default case: switch (value)              {                  case SchemaType.Source:                  case SchemaType.Mapped:                      Debug.Assert(false' "valid SchemaType " + value.ToString());                      break;              }
Missing Default,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,InvalidStatementType,The following switch statement is missing a default case: switch (value)              {                  case StatementType.Select:                  case StatementType.Insert:                  case StatementType.Update:                  case StatementType.Delete:                  case StatementType.Batch:                      Debug.Assert(false' "valid StatementType " + value.ToString());                      break;              }
Missing Default,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\AdapterUtil.Common.cs,InvalidUpdateStatus,The following switch statement is missing a default case: switch (value)              {                  case UpdateStatus.Continue:                  case UpdateStatus.ErrorsOccurred:                  case UpdateStatus.SkipAllRemainingRows:                  case UpdateStatus.SkipCurrentRow:                      Debug.Assert(false' "valid UpdateStatus " + value.ToString());                      break;              }
Missing Default,System.Data.Common,BooleanStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\BooleanStorage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Min:                          bool min = true;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              min = _values[record] && min;                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          bool max = false;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              max = _values[record] || max;                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          return base.Aggregate(records' kind);                  }
Missing Default,System.Data.Common,ByteStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\ByteStorage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Sum:                          ulong sum = defaultValue;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          long meanSum = defaultValue;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { meanSum += _values[record]; }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              byte mean;                              checked { mean = (byte)(meanSum / meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          double var = defaultValue;                          double prec = defaultValue;                          double dsum = defaultValue;                          double sqrsum = defaultValue;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += _values[record];                              sqrsum += _values[record] * (double)_values[record];                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                              // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          byte min = byte.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              min = Math.Min(_values[record]' min);                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          byte max = byte.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              max = Math.Max(_values[record]' max);                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          return base.Aggregate(records' kind);                  }
Missing Default,System.Data.Common,CharStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\CharStorage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Min:                          char min = char.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              min = (_values[record] < min) ? _values[record] : min;                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          char max = char.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              max = (_values[record] > max) ? _values[record] : max;                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          return base.Aggregate(records' kind);                  }
Missing Default,System.Data.Common,DataColumnMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataColumnMapping.cs,CreateDataColumnBySchemaAction,The following switch statement is missing a default case: switch (schemaAction)              {                  case MissingSchemaAction.Add:                  case MissingSchemaAction.AddWithKey:  #if DEBUG                      if (AdapterSwitches.DataSchema.TraceInfo)                      {                          Debug.WriteLine("schema add of DataColumn \"" + dataSetColumn + "\" <" + Convert.ToString(dataType' CultureInfo.InvariantCulture) + ">");                      }  #endif                      return new DataColumn(dataSetColumn' dataType);                    case MissingSchemaAction.Ignore:  #if DEBUG                      if (AdapterSwitches.DataSchema.TraceWarning)                      {                          Debug.WriteLine("schema filter of DataColumn \"" + dataSetColumn + "\" <" + Convert.ToString(dataType' CultureInfo.InvariantCulture) + ">");                      }  #endif                      return null;                    case MissingSchemaAction.Error:  #if DEBUG                      if (AdapterSwitches.DataSchema.TraceError)                      {                          Debug.WriteLine("schema error on DataColumn \"" + dataSetColumn + "\" <" + Convert.ToString(dataType' CultureInfo.InvariantCulture) + ">");                      }  #endif                      throw ADP.ColumnSchemaMissing(dataSetColumn' dataTable.TableName' sourceColumn);              }
Missing Default,System.Data.Common,DataColumnMappingCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataColumnMappingCollection.cs,GetDataColumn,The following switch statement is missing a default case: switch (mappingAction)              {                  case MissingMappingAction.Passthrough:  #if DEBUG                      if (AdapterSwitches.DataSchema.TraceInfo)                      {                          Debug.WriteLine($"mapping passthrough of SourceColumn \"{sourceColumn}\"");                      }  #endif                      return DataColumnMapping.GetDataColumnBySchemaAction(sourceColumn' sourceColumn' dataTable' dataType' schemaAction);                    case MissingMappingAction.Ignore:  #if DEBUG                      if (AdapterSwitches.DataSchema.TraceWarning)                      {                          Debug.WriteLine($"mapping filter of SourceColumn \"{sourceColumn}\"");                      }  #endif                      return null;                    case MissingMappingAction.Error:  #if DEBUG                      if (AdapterSwitches.DataSchema.TraceError)                      {                          Debug.WriteLine($"mapping error on SourceColumn \"{sourceColumn}\"");                      }  #endif                      throw ADP.MissingColumnMapping(sourceColumn);              }
Missing Default,System.Data.Common,DataColumnMappingCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataColumnMappingCollection.cs,GetColumnMappingBySchemaAction,The following switch statement is missing a default case: switch (mappingAction)              {                  case MissingMappingAction.Passthrough:  #if DEBUG                      if (AdapterSwitches.DataSchema.TraceInfo)                      {                          Debug.WriteLine($"mapping passthrough of SourceColumn \"{sourceColumn}\"");                      }  #endif                      return new DataColumnMapping(sourceColumn' sourceColumn);                    case MissingMappingAction.Ignore:  #if DEBUG                      if (AdapterSwitches.DataSchema.TraceWarning)                      {                          Debug.WriteLine($"mapping filter of SourceColumn \"{sourceColumn}\"");                      }  #endif                      return null;                    case MissingMappingAction.Error:  #if DEBUG                      if (AdapterSwitches.DataSchema.TraceError)                      {                          Debug.WriteLine($"mapping error on SourceColumn \"{sourceColumn}\"");                      }  #endif                      throw ADP.MissingColumnMapping(sourceColumn);              }
Missing Default,System.Data.Common,DataTableMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DataTableMapping.cs,GetDataTableBySchemaAction,The following switch statement is missing a default case: switch (schemaAction)              {                  case MissingSchemaAction.Add:                  case MissingSchemaAction.AddWithKey:  #if DEBUG                      if (AdapterSwitches.DataSchema.TraceInfo)                      {                          Debug.WriteLine("schema add of DataTable \"" + dataSetTable + "\"");                      }  #endif                      return new DataTable(dataSetTable);                    case MissingSchemaAction.Ignore:  #if DEBUG                      if (AdapterSwitches.DataSchema.TraceWarning)                      {                          Debug.WriteLine("schema filter of DataTable \"" + dataSetTable + "\"");                      }  #endif                      return null;                    case MissingSchemaAction.Error:  #if DEBUG                      if (AdapterSwitches.DataSchema.TraceError)                      {                          Debug.WriteLine("schema error on DataTable \"" + dataSetTable + "\"");                      }  #endif                      throw ADP.MissingTableSchema(dataSetTable' SourceTable);              }
Missing Default,System.Data.Common,DateTimeOffsetStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DateTimeOffsetStorage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Min:                          DateTimeOffset min = DateTimeOffset.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  min = (DateTimeOffset.Compare(_values[record]' min) < 0) ? _values[record] : min;                                  hasData = true;                              }                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          DateTimeOffset max = DateTimeOffset.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  max = (DateTimeOffset.Compare(_values[record]' max) >= 0) ? _values[record] : max;                                  hasData = true;                              }                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          int count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (HasValue(records[i]))                              {                                  count++;                              }                          }                          return count;                  }
Missing Default,System.Data.Common,DateTimeStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DateTimeStorage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Min:                          DateTime min = DateTime.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  min = (DateTime.Compare(_values[record]' min) < 0) ? _values[record] : min;                                  hasData = true;                              }                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          DateTime max = DateTime.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  max = (DateTime.Compare(_values[record]' max) >= 0) ? _values[record] : max;                                  hasData = true;                              }                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          int count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (HasValue(records[i]))                              {                                  count++;                              }                          }                          return count;                  }
Missing Default,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,UpdateRowExecute,The following switch statement is missing a default case: switch (rowUpdatedEvent.Status)              {                  case UpdateStatus.Continue:                      switch (cmdIndex)                      {                          case StatementType.Update:                          case StatementType.Delete:                              if (0 == rowUpdatedEvent.RecordsAffected)                              {                                  Debug.Assert(null == rowUpdatedEvent.Errors' "Continue - but contains an exception");                                  rowUpdatedEvent.Errors = ADP.UpdateConcurrencyViolation(cmdIndex' rowUpdatedEvent.RecordsAffected' 1' new DataRow[] { rowUpdatedEvent.Row });                                  rowUpdatedEvent.Status = UpdateStatus.ErrorsOccurred;                              }                              break;                      }                      break;              }
Missing Default,System.Data.Common,DbDataAdapter,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DbDataAdapter.cs,UpdateRowExecute,The following switch statement is missing a default case: switch (cmdIndex)                      {                          case StatementType.Update:                          case StatementType.Delete:                              if (0 == rowUpdatedEvent.RecordsAffected)                              {                                  Debug.Assert(null == rowUpdatedEvent.Errors' "Continue - but contains an exception");                                  rowUpdatedEvent.Errors = ADP.UpdateConcurrencyViolation(cmdIndex' rowUpdatedEvent.RecordsAffected' 1' new DataRow[] { rowUpdatedEvent.Row });                                  rowUpdatedEvent.Status = UpdateStatus.ErrorsOccurred;                              }                              break;                      }
Missing Default,System.Data.Common,DecimalStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DecimalStorage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Sum:                          decimal sum = s_defaultValue;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { sum += _values[record]; }                                  hasData = true;                              }                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          decimal meanSum = s_defaultValue;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { meanSum += _values[record]; }                                  meanCount++;                                  hasData = true;                              }                          }                          if (hasData)                          {                              decimal mean;                              checked { mean = (meanSum / meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          double var = (double)s_defaultValue;                          double prec = (double)s_defaultValue;                          double dsum = (double)s_defaultValue;                          double sqrsum = (double)s_defaultValue;                            foreach (int record in records)                          {                              if (HasValue(record))                              {                                  dsum += (double)_values[record];                                  sqrsum += (double)_values[record] * (double)_values[record];                                  count++;                              }                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                              // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          decimal min = decimal.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  min = Math.Min(_values[record]' min);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          decimal max = decimal.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  max = Math.Max(_values[record]' max);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          return base.Aggregate(records' kind);                  }
Missing Default,System.Data.Common,DoubleStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\DoubleStorage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Sum:                          double sum = defaultValue;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          double meanSum = defaultValue;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { meanSum += _values[record]; }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              double mean;                              checked { mean = meanSum / meanCount; }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          double var = defaultValue;                          double prec = defaultValue;                          double dsum = defaultValue;                          double sqrsum = defaultValue;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += _values[record];                              sqrsum += _values[record] * _values[record];                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                              // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          double min = double.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              min = Math.Min(_values[record]' min);                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          double max = double.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              max = Math.Max(_values[record]' max);                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          return base.Aggregate(records' kind);                  }
Missing Default,System.Data.Common,Int16Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\Int16Storage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Sum:                          long sum = defaultValue;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { sum += _values[record]; }                                  hasData = true;                              }                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          long meanSum = defaultValue;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { meanSum += _values[record]; }                                  meanCount++;                                  hasData = true;                              }                          }                          if (hasData)                          {                              short mean;                              checked { mean = (short)(meanSum / meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          double var = 0.0f;                          double prec = 0.0f;                          double dsum = 0.0f;                          double sqrsum = 0.0f;                            foreach (int record in records)                          {                              if (HasValue(record))                              {                                  dsum += _values[record];                                  sqrsum += _values[record] * (double)_values[record];                                  count++;                              }                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                              // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var);                              }                              return var;                          }                          return _nullValue;                          case AggregateType.Min:                          short min = short.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  min = Math.Min(_values[record]' min);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          short max = short.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  max = Math.Max(_values[record]' max);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (HasValue(records[i]))                              {                                  count++;                              }                          }                          return count;                  }
Missing Default,System.Data.Common,Int32Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\Int32Storage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Sum:                          long sum = 0;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { sum += _values[record]; }                                  hasData = true;                              }                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          long meanSum = 0;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { meanSum += _values[record]; }                                  meanCount++;                                  hasData = true;                              }                          }                          if (hasData)                          {                              int mean;                              checked { mean = (int)(meanSum / meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          double var = 0.0f;                          double prec = 0.0f;                          double dsum = 0.0f;                          double sqrsum = 0.0f;                            foreach (int record in records)                          {                              if (HasValue(record))                              {                                  dsum += _values[record];                                  sqrsum += _values[record] * (double)_values[record];                                  count++;                              }                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                              // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          int min = int.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  min = Math.Min(_values[record]' min);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          int max = int.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  max = Math.Max(_values[record]' max);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (HasValue(records[i]))                              {                                  count++;                              }                          }                          return count;                  }
Missing Default,System.Data.Common,Int64Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\Int64Storage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Sum:                          long sum = defaultValue;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { sum += _values[record]; }                                  hasData = true;                              }                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          decimal meanSum = defaultValue;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { meanSum += _values[record]; }                                  meanCount++;                                  hasData = true;                              }                          }                          if (hasData)                          {                              long mean;                              checked { mean = (long)(meanSum / (decimal)meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          double var = 0.0f;                          double prec = 0.0f;                          double dsum = 0.0f;                          double sqrsum = 0.0f;                            foreach (int record in records)                          {                              if (HasValue(record))                              {                                  dsum += _values[record];                                  sqrsum += _values[record] * (double)_values[record];                                  count++;                              }                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                              // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          long min = long.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  min = Math.Min(_values[record]' min);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          long max = long.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  max = Math.Max(_values[record]' max);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          return base.Aggregate(records' kind);                  }
Missing Default,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The following switch statement is missing a default case: switch (state)                  {                      case MPIState.MPI_Value:                          {                              int quoteIndex;                              if (IsWhitespace(testchar))                              {    // Is White Space then skip the whitespace                                  continue;                              }                              else                              if (testchar == separator)                              {  // If we found a separator' no string was found' initialize the string we are parsing to Empty and the next one to Empty.                                 // This is NOT a redundant setting of string.Empty it solves the case where we are parsing ".foo" and we should be returning null' null' empty' foo                                  parsedNames[stringCount] = string.Empty;                                  IncrementStringCount(name' parsedNames' ref stringCount' property);                              }                              else                              if (-1 != (quoteIndex = leftQuote.IndexOf(testchar)))                              { // If we are a left quote                                                                                                                                                            rightQuoteChar = rightQuote[quoteIndex]; // record the corresponding right quote for the left quote                                  sb.Length = 0;                                  if (!removequotes)                                  {                                      sb.Append(testchar);                                  }                                  state = MPIState.MPI_ParseQuote;                              }                              else                              if (-1 != rightQuote.IndexOf(testchar))                              { // If we shouldn't see a right quote                                  throw ADP.InvalidMultipartNameIncorrectUsageOfQuotes(property' name);                              }                              else                              {                                  sb.Length = 0;                                  sb.Append(testchar);                                  state = MPIState.MPI_ParseNonQuote;                              }                              break;                          }                        case MPIState.MPI_ParseNonQuote:                          {                              if (testchar == separator)                              {                                  parsedNames[stringCount] = sb.ToString(); // set the currently parsed string                                  IncrementStringCount(name' parsedNames' ref stringCount' property);                                  state = MPIState.MPI_Value;                              }                              else // Quotes are not valid inside a non-quoted name                              if (-1 != rightQuote.IndexOf(testchar))                              {                                  throw ADP.InvalidMultipartNameIncorrectUsageOfQuotes(property' name);                              }                              else                              if (-1 != leftQuote.IndexOf(testchar))                              {                                  throw ADP.InvalidMultipartNameIncorrectUsageOfQuotes(property' name);                              }                              else                              if (IsWhitespace(testchar))                              { // If it is Whitespace                                   parsedNames[stringCount] = sb.ToString(); // Set the currently parsed string                                  if (null == whitespaceSB)                                  {                                      whitespaceSB = new StringBuilder();                                  }                                  whitespaceSB.Length = 0;                                  whitespaceSB.Append(testchar);  // start to record the whitespace' if we are parsing a name like "foo bar" we should return "foo bar"                                  state = MPIState.MPI_LookForNextCharOrSeparator;                              }                              else                              {                                  sb.Append(testchar);                              }                              break;                          }                        case MPIState.MPI_LookForNextCharOrSeparator:                          {                              if (!IsWhitespace(testchar))                              { // If it is not whitespace                                  if (testchar == separator)                                  {                                      IncrementStringCount(name' parsedNames' ref stringCount' property);                                      state = MPIState.MPI_Value;                                  }                                  else                                  { // If its not a separator and not whitespace                                      sb.Append(whitespaceSB);                                      sb.Append(testchar);                                      parsedNames[stringCount] = sb.ToString(); // Need to set the name here in case the string ends here.                                      state = MPIState.MPI_ParseNonQuote;                                  }                              }                              else                              {                                  whitespaceSB.Append(testchar);                              }                              break;                          }                        case MPIState.MPI_ParseQuote:                          {                              if (testchar == rightQuoteChar)                              {    // if se are on a right quote see if we are escaping the right quote or ending the quoted string                                                              if (!removequotes)                                  {                                      sb.Append(testchar);                                  }                                  state = MPIState.MPI_RightQuote;                              }                              else                              {                                  sb.Append(testchar); // Append what we are currently parsing                              }                              break;                          }                        case MPIState.MPI_RightQuote:                          {                              if (testchar == rightQuoteChar)                              { // If the next char is another right quote then we were escaping the right quote                                  sb.Append(testchar);                                  state = MPIState.MPI_ParseQuote;                              }                              else                              if (testchar == separator)                              {      // If its a separator then record what we've parsed                                  parsedNames[stringCount] = sb.ToString();                                  IncrementStringCount(name' parsedNames' ref stringCount' property);                                  state = MPIState.MPI_Value;                              }                              else                              if (!IsWhitespace(testchar))                              { // If it is not whitespace we got problems                                  throw ADP.InvalidMultipartNameIncorrectUsageOfQuotes(property' name);                              }                              else                              {                          // It is a whitespace character so the following char should be whitespace' separator' or end of string anything else is bad                                  parsedNames[stringCount] = sb.ToString();                                  state = MPIState.MPI_LookForSeparator;                              }                              break;                          }                        case MPIState.MPI_LookForSeparator:                          {                              if (!IsWhitespace(testchar))                              { // If it is not whitespace                                  if (testchar == separator)                                  { // If it is a separator                                       IncrementStringCount(name' parsedNames' ref stringCount' property);                                      state = MPIState.MPI_Value;                                  }                                  else                                  { // Otherwise not a separator                                      throw ADP.InvalidMultipartNameIncorrectUsageOfQuotes(property' name);                                  }                              }                              break;                          }                  }
Missing Default,System.Data.Common,SByteStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SByteStorage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Sum:                          long sum = defaultValue;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          long meanSum = defaultValue;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { meanSum += _values[record]; }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              sbyte mean;                              checked { mean = (sbyte)(meanSum / meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          double var = defaultValue;                          double prec = defaultValue;                          double dsum = defaultValue;                          double sqrsum = defaultValue;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += _values[record];                              sqrsum += _values[record] * (double)_values[record];                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                              // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          sbyte min = sbyte.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              min = Math.Min(_values[record]' min);                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          sbyte max = sbyte.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              max = Math.Max(_values[record]' max);                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          return base.Aggregate(records' kind);                  }
Missing Default,System.Data.Common,SingleStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SingleStorage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Sum:                          float sum = defaultValue;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          double meanSum = defaultValue;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { meanSum += _values[record]; }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              float mean;                              checked { mean = (float)(meanSum / meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          double var = defaultValue;                          double prec = defaultValue;                          double dsum = defaultValue;                          double sqrsum = defaultValue;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += _values[record];                              sqrsum += _values[record] * (double)_values[record];                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                              // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var);                              }                              return var;                          }                          return _nullValue;                          case AggregateType.Min:                          float min = float.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              min = Math.Min(_values[record]' min);                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          float max = float.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              max = Math.Max(_values[record]' max);                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          return base.Aggregate(records' kind);                  }
Missing Default,System.Data.Common,StringStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\StringStorage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)              {                  case AggregateType.Min:                      int min = -1;                      for (i = 0; i < recordNos.Length; i++)                      {                          if (IsNull(recordNos[i]))                              continue;                          min = recordNos[i];                          break;                      }                      if (min >= 0)                      {                          for (i = i + 1; i < recordNos.Length; i++)                          {                              if (IsNull(recordNos[i]))                                  continue;                              if (Compare(min' recordNos[i]) > 0)                              {                                  min = recordNos[i];                              }                          }                          return Get(min);                      }                      return _nullValue;                    case AggregateType.Max:                      int max = -1;                      for (i = 0; i < recordNos.Length; i++)                      {                          if (IsNull(recordNos[i]))                              continue;                          max = recordNos[i];                          break;                      }                      if (max >= 0)                      {                          for (i = i + 1; i < recordNos.Length; i++)                          {                              if (Compare(max' recordNos[i]) < 0)                              {                                  max = recordNos[i];                              }                          }                          return Get(max);                      }                      return _nullValue;                    case AggregateType.Count:                      int count = 0;                      for (i = 0; i < recordNos.Length; i++)                      {                          object value = _values[recordNos[i]];                          if (value != null)                              count++;                      }                      return count;              }
Missing Default,System.Data.Common,TimeSpanStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\TimeSpanStorage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Min:                          TimeSpan min = TimeSpan.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              min = (TimeSpan.Compare(_values[record]' min) < 0) ? _values[record] : min;                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          TimeSpan max = TimeSpan.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              max = (TimeSpan.Compare(_values[record]' max) >= 0) ? _values[record] : max;                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          return base.Aggregate(records' kind);                        case AggregateType.Sum:                          {                              decimal sum = 0;                              foreach (int record in records)                              {                                  if (IsNull(record))                                      continue;                                  sum += _values[record].Ticks;                                  hasData = true;                              }                              if (hasData)                              {                                  return TimeSpan.FromTicks((long)Math.Round(sum));                              }                              return null;                          }                        case AggregateType.Mean:                          {                              decimal meanSum = 0;                              int meanCount = 0;                              foreach (int record in records)                              {                                  if (IsNull(record))                                      continue;                                  meanSum += _values[record].Ticks;                                  meanCount++;                              }                              if (meanCount > 0)                              {                                  return TimeSpan.FromTicks((long)Math.Round(meanSum / meanCount));                              }                              return null;                          }                        case AggregateType.StDev:                          {                              int count = 0;                              decimal meanSum = 0;                                foreach (int record in records)                              {                                  if (IsNull(record))                                      continue;                                  meanSum += _values[record].Ticks;                                  count++;                              }                                if (count > 1)                              {                                  double varSum = 0;                                  decimal mean = meanSum / count;                                  foreach (int record in records)                                  {                                      if (IsNull(record))                                          continue;                                      double x = (double)(_values[record].Ticks - mean);                                      varSum += x * x;                                  }                                  ulong stDev = (ulong)Math.Round(Math.Sqrt(varSum / (count - 1)));                                  if (stDev > long.MaxValue)                                  {                                      stDev = long.MaxValue;                                  }                                  return TimeSpan.FromTicks((long)stDev);                              }                              return null;                          }                  }
Missing Default,System.Data.Common,UInt16Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\UInt16Storage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Sum:                          ulong sum = s_defaultValue;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { sum += _values[record]; }                                  hasData = true;                              }                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          long meanSum = s_defaultValue;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { meanSum += _values[record]; }                                  meanCount++;                                  hasData = true;                              }                          }                          if (hasData)                          {                              ushort mean;                              checked { mean = (ushort)(meanSum / meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          double var = 0.0f;                          double prec = 0.0f;                          double dsum = 0.0f;                          double sqrsum = 0.0f;                            foreach (int record in records)                          {                              if (HasValue(record))                              {                                  dsum += _values[record];                                  sqrsum += _values[record] * (double)_values[record];                                  count++;                              }                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                              // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          ushort min = ushort.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  min = Math.Min(_values[record]' min);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          ushort max = ushort.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  max = Math.Max(_values[record]' max);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (HasValue(records[i]))                              {                                  count++;                              }                          }                          return count;                  }
Missing Default,System.Data.Common,UInt32Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\UInt32Storage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Sum:                          ulong sum = s_defaultValue;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { sum += _values[record]; }                                  hasData = true;                              }                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          long meanSum = s_defaultValue;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (HasValue(record))                              {                                  checked { meanSum += _values[record]; }                                  meanCount++;                                  hasData = true;                              }                          }                          if (hasData)                          {                              uint mean;                              checked { mean = (uint)(meanSum / meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          double var = 0.0f;                          double prec = 0.0f;                          double dsum = 0.0f;                          double sqrsum = 0.0f;                            foreach (int record in records)                          {                              if (HasValue(record))                              {                                  dsum += _values[record];                                  sqrsum += _values[record] * (double)_values[record];                                  count++;                              }                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                              // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          uint min = uint.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  min = Math.Min(_values[record]' min);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          uint max = uint.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (HasValue(record))                              {                                  max = Math.Max(_values[record]' max);                                  hasData = true;                              }                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (HasValue(records[i]))                                  count++;                          }                          return count;                  }
Missing Default,System.Data.Common,SqlCharsStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLCharsStorage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;// no data => null                        case AggregateType.Count:                          int count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (!IsNull(records[i]))                                  count++;                          }                          return count;                  }
Missing Default,System.Data.Common,SqlDateTimeStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLDateTimeStorage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Min:                          SqlDateTime min = SqlDateTime.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlDateTime.LessThan(_values[record]' min)).IsTrue)                                  min = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          SqlDateTime max = SqlDateTime.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlDateTime.GreaterThan(_values[record]' max)).IsTrue)                                  max = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;// no data => null                        case AggregateType.Count:                          int count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (!IsNull(records[i]))                                  count++;                          }                          return count;                  }
Missing Default,System.Data.Common,SqlDecimalStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLDecimalStorage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Sum:                          SqlDecimal sum = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          SqlDecimal meanSum = 0;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { meanSum += _values[record]; }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              SqlDecimal mean = 0;                              checked { mean = (meanSum / meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          SqlDouble var = 0;                          SqlDouble prec = 0;                          SqlDouble dsum = 0;                          SqlDouble sqrsum = 0;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += _values[record].ToSqlDouble();                              sqrsum += (_values[record]).ToSqlDouble() * (_values[record]).ToSqlDouble();                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                               // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var.Value);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          SqlDecimal min = SqlDecimal.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlDecimal.LessThan(_values[record]' min)).IsTrue)                                  min = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          SqlDecimal max = SqlDecimal.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlDecimal.GreaterThan(_values[record]' max)).IsTrue)                                  max = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                      case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (!IsNull(records[i]))                                  count++;                          }                          return count;                  }
Missing Default,System.Data.Common,SqlDoubleStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLDoubleStorage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Sum:                          SqlDouble sum = 0.0d;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          SqlDouble meanSum = 0.0d;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { meanSum += _values[record]; }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              SqlDouble mean = 0.0d;                              checked { mean = (meanSum / meanCount); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          SqlDouble var = 0.0d;                          SqlDouble prec = 0.0d;                          SqlDouble dsum = 0.0d;                          SqlDouble sqrsum = 0.0d;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += _values[record];                              sqrsum += _values[record] * _values[record];                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                               // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var.Value);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          SqlDouble min = SqlDouble.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlDouble.LessThan(_values[record]' min)).IsTrue)                                  min = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          SqlDouble max = SqlDouble.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlDouble.GreaterThan(_values[record]' max)).IsTrue)                                  max = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;// no data => null                        case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (!IsNull(records[i]))                                  count++;                          }                          return count;                  }
Missing Default,System.Data.Common,SqlGuidStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLGuidStorage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          int count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (!IsNull(records[i]))                                  count++;                          }                          return count;                  }
Missing Default,System.Data.Common,SqlInt16Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLInt16Storage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Sum:                          SqlInt64 sum = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          SqlInt64 meanSum = 0;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { meanSum += (_values[record]).ToSqlInt64(); }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              SqlInt16 mean = 0;                              checked { mean = (meanSum / meanCount).ToSqlInt16(); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          SqlDouble var = 0;                          SqlDouble prec = 0;                          SqlDouble dsum = 0;                          SqlDouble sqrsum = 0;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += (_values[record]).ToSqlDouble();                              sqrsum += (_values[record]).ToSqlDouble() * (_values[record]).ToSqlDouble();                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                               // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var.Value);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          SqlInt16 min = SqlInt16.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlInt16.LessThan(_values[record]' min)).IsTrue)                                  min = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          SqlInt16 max = SqlInt16.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlInt16.GreaterThan(_values[record]' max)).IsTrue)                                  max = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;// no data => null                        case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (!IsNull(records[i]))                                  count++;                          }                          return count;                  }
Missing Default,System.Data.Common,SqlInt32Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLInt32Storage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Sum:                          SqlInt64 sum = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          SqlInt64 meanSum = 0;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { meanSum += (_values[record]).ToSqlInt64(); }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              SqlInt32 mean = 0;                              checked { mean = (meanSum / meanCount).ToSqlInt32(); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          SqlDouble var = 0;                          SqlDouble prec = 0;                          SqlDouble dsum = 0;                          SqlDouble sqrsum = 0;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += (_values[record]).ToSqlDouble();                              sqrsum += (_values[record]).ToSqlDouble() * (_values[record]).ToSqlDouble();                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                               // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var.Value);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          SqlInt32 min = SqlInt32.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlInt32.LessThan(_values[record]' min)).IsTrue)                                  min = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          SqlInt32 max = SqlInt32.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlInt32.GreaterThan(_values[record]' max)).IsTrue)                                  max = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (!IsNull(records[i]))                                  count++;                          }                          return count;                  }
Missing Default,System.Data.Common,SqlInt64Storage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLInt64Storage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Sum:                          SqlInt64 sum = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          SqlDecimal meanSum = 0;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { meanSum += _values[record].ToSqlDecimal(); }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              SqlInt64 mean = 0;                              checked { mean = (meanSum / meanCount).ToSqlInt64(); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          SqlDouble var = 0;                          SqlDouble prec = 0;                          SqlDouble dsum = 0;                          SqlDouble sqrsum = 0;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += (_values[record]).ToSqlDouble();                              sqrsum += (_values[record]).ToSqlDouble() * (_values[record]).ToSqlDouble();                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                               // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var.Value);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          SqlInt64 min = SqlInt64.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlInt64.LessThan(_values[record]' min)).IsTrue)                                  min = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          SqlInt64 max = SqlInt64.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                                if ((SqlInt64.GreaterThan(_values[record]' max)).IsTrue)                                  max = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;// no data => null                        case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (!IsNull(records[i]))                                  count++;                          }                          return count;                  }
Missing Default,System.Data.Common,SqlMoneyStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLMoneyStorage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Sum:                          SqlDecimal sum = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          SqlDecimal meanSum = 0;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { meanSum += (_values[record]).ToSqlDecimal(); }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              SqlMoney mean = 0;                              checked { mean = (meanSum / meanCount).ToSqlMoney(); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          SqlDouble var = 0;                          SqlDouble prec = 0;                          SqlDouble dsum = 0;                          SqlDouble sqrsum = 0;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += _values[record].ToSqlDouble();                              sqrsum += (_values[record]).ToSqlDouble() * (_values[record]).ToSqlDouble();                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                               // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var.Value);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          SqlMoney min = SqlMoney.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlMoney.LessThan(_values[record]' min)).IsTrue)                                  min = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          SqlMoney max = SqlMoney.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlMoney.GreaterThan(_values[record]' max)).IsTrue)                                  max = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (!IsNull(records[i]))                                  count++;                          }                          return count;                  }
Missing Default,System.Data.Common,SqlSingleStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLSingleStorage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Sum:                          SqlSingle sum = 0.0f;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                              return sum;                            return _nullValue;                        case AggregateType.Mean:                          SqlDouble meanSum = 0.0f;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                                checked { meanSum += _values[record].ToSqlDouble(); }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              SqlSingle mean = 0;                              checked { mean = (meanSum / meanCount).ToSqlSingle(); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          SqlDouble var = 0;                          SqlDouble prec = 0;                          SqlDouble dsum = 0;                          SqlDouble sqrsum = 0;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += _values[record].ToSqlDouble();                              sqrsum += (_values[record]).ToSqlDouble() * (_values[record]).ToSqlDouble();                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                               // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var.Value);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          SqlSingle min = SqlSingle.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                                if ((SqlSingle.LessThan(_values[record]' min)).IsTrue)                                  min = _values[record];                              hasData = true;                          }                          if (hasData)                              return min;                          return _nullValue;                        case AggregateType.Max:                          SqlSingle max = SqlSingle.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                                if ((SqlSingle.GreaterThan(_values[record]' max)).IsTrue)                                  max = _values[record];                              hasData = true;                          }                          if (hasData)                              return max;                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (!IsNull(records[i]))                                  count++;                          }                          return count;                  }
Missing Default,System.Data.Common,SqlStringStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLStringStorage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Min:                          int min = -1;                          for (i = 0; i < recordNos.Length; i++)                          {                              if (IsNull(recordNos[i]))                                  continue;                              min = recordNos[i];                              break;                          }                          if (min >= 0)                          {                              for (i = i + 1; i < recordNos.Length; i++)                              {                                  if (IsNull(recordNos[i]))                                      continue;                                  if (Compare(min' recordNos[i]) > 0)                                  {                                      min = recordNos[i];                                  }                              }                              return Get(min);                          }                          return _nullValue;                          case AggregateType.Max:                          int max = -1;                          for (i = 0; i < recordNos.Length; i++)                          {                              if (IsNull(recordNos[i]))                                  continue;                              max = recordNos[i];                              break;                          }                          if (max >= 0)                          {                              for (i = i + 1; i < recordNos.Length; i++)                              {                                  if (Compare(max' recordNos[i]) < 0)                                  {                                      max = recordNos[i];                                  }                              }                              return Get(max);                          }                          return _nullValue;                        case AggregateType.Count:                          int count = 0;                          for (i = 0; i < recordNos.Length; i++)                          {                              if (!IsNull(recordNos[i]))                                  count++;                          }                          return count;                  }
Missing Default,System.Data.Common,SqlBinaryStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLBinaryStorage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;                        case AggregateType.Count:                          int count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (!IsNull(records[i]))                                  count++;                          }                          return count;                  }
Missing Default,System.Data.Common,SqlBooleanStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQlBooleanStorage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Min:                          SqlBoolean min = true;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              min = SqlBoolean.And(_values[record]' min);                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          SqlBoolean max = false;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              max = SqlBoolean.Or(_values[record]' max);                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return _nullValue;                        case AggregateType.Count:                          int count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (!IsNull(records[i]))                                  count++;                          }                          return count;                  }
Missing Default,System.Data.Common,SqlBytesStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLBytesStorage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;// no data => null                        case AggregateType.Count:                          int count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (!IsNull(records[i]))                                  count++;                          }                          return count;                  }
Missing Default,System.Data.Common,SqlByteStorage,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Common\SQLTypes\SQLByteStorage.cs,Aggregate,The following switch statement is missing a default case: switch (kind)                  {                      case AggregateType.Sum:                          SqlInt64 sum = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { sum += _values[record]; }                              hasData = true;                          }                          if (hasData)                          {                              return sum;                          }                          return _nullValue;                        case AggregateType.Mean:                          SqlInt64 meanSum = 0;                          int meanCount = 0;                          foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              checked { meanSum += _values[record].ToSqlInt64(); }                              meanCount++;                              hasData = true;                          }                          if (hasData)                          {                              SqlByte mean = 0;                              checked { mean = (meanSum / meanCount).ToSqlByte(); }                              return mean;                          }                          return _nullValue;                        case AggregateType.Var:                      case AggregateType.StDev:                          int count = 0;                          SqlDouble var = 0;                          SqlDouble prec = 0;                          SqlDouble dsum = 0;                          SqlDouble sqrsum = 0;                            foreach (int record in records)                          {                              if (IsNull(record))                                  continue;                              dsum += _values[record].ToSqlDouble();                              sqrsum += _values[record].ToSqlDouble() * _values[record].ToSqlDouble();                              count++;                          }                            if (count > 1)                          {                              var = count * sqrsum - (dsum * dsum);                              prec = var / (dsum * dsum);                                // we are dealing with the risk of a cancellation error                              // double is guaranteed only for 15 digits so a difference                               // with a result less than 1e-15 should be considered as zero                                if ((prec < 1e-15) || (var < 0))                                  var = 0;                              else                                  var = var / (count * (count - 1));                                if (kind == AggregateType.StDev)                              {                                  return Math.Sqrt(var.Value);                              }                              return var;                          }                          return _nullValue;                        case AggregateType.Min:                          SqlByte min = SqlByte.MaxValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlByte.LessThan(_values[record]' min)).IsTrue)                                  min = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return min;                          }                          return _nullValue;                        case AggregateType.Max:                          SqlByte max = SqlByte.MinValue;                          for (int i = 0; i < records.Length; i++)                          {                              int record = records[i];                              if (IsNull(record))                                  continue;                              if ((SqlByte.GreaterThan(_values[record]' max)).IsTrue)                                  max = _values[record];                              hasData = true;                          }                          if (hasData)                          {                              return max;                          }                          return _nullValue;                        case AggregateType.First:                          if (records.Length > 0)                          {                              return _values[records[0]];                          }                          return null;// no data => null                        case AggregateType.Count:                          count = 0;                          for (int i = 0; i < records.Length; i++)                          {                              if (!IsNull(records[i]))                                  count++;                          }                          return count;                  }
Missing Default,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,CloneNode,The following switch statement is missing a default case: switch (dp.NodeType)              {                  //for the nodes without value and have no children                  case XmlNodeType.DocumentFragment:                      return CreateDocumentFragment();                  case XmlNodeType.DocumentType:                      return CreateDocumentType(dp.Name' dp.PublicId' dp.SystemId' dp.InternalSubset);                  case XmlNodeType.XmlDeclaration:                      return CreateXmlDeclaration(dp.Version' dp.Encoding' dp.Standalone);                    //for the nodes with value but no children                  case XmlNodeType.Text:                      return CreateTextNode(dp.Value);                  case XmlNodeType.CDATA:                      return CreateCDataSection(dp.Value);                  case XmlNodeType.ProcessingInstruction:                      return CreateProcessingInstruction(dp.Name' dp.Value);                  case XmlNodeType.Comment:                      return CreateComment(dp.Value);                  case XmlNodeType.Whitespace:                      return CreateWhitespace(dp.Value);                  case XmlNodeType.SignificantWhitespace:                      return CreateSignificantWhitespace(dp.Value);                  //for the nodes that don't have values' but might have children -- only clone the node and leave the children untouched                  case XmlNodeType.Element:                      return CreateElement(dp.Prefix' dp.LocalName' dp.NamespaceURI);                  case XmlNodeType.Attribute:                      return CreateAttribute(dp.Prefix' dp.LocalName' dp.NamespaceURI);                  case XmlNodeType.EntityReference:                      return CreateEntityReference(dp.Name);              }
Missing Default,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,OnRowChanged,The following switch statement is missing a default case: switch (_rollbackState)                          {                              case DataRowState.Deleted:                                  OnUndeleteRow(row' rowElement);                                  UpdateAllColumns(row' rowElement);                                  break;                                case DataRowState.Added:                                  rowElement.ParentNode.RemoveChild(rowElement);                                  break;                                case DataRowState.Modified:                                  OnColumnValuesChanged(row' rowElement);                                  break;                          }
Missing Default,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,OnRowChanging,The following switch statement is missing a default case: switch (args.Action)                      {                          case DataRowAction.Add:                              // DataRow is beeing added to the table (Table.Rows.Add is beeing called)                              break;                            case DataRowAction.Delete:                              // DataRow is beeing deleted                              //    - state transition from New (AKA PendingInsert) to Detached (AKA Created)                              //    - state transition from Unchanged to Deleted (AKA PendingDelete)                              //    - state transition from Modified (AKA PendingChange) to Delete (AKA PendingDelete)                              Debug.Assert(false);  // This should have been handled above' irrespective of ignoreDataSetEvents value (true or false)                              break;                            case DataRowAction.Rollback:                              // DataRow gets reverted to previous values (by calling DataRow.RejectChanges):                              //    - state transition from Detached (AKA Created) to Detached (AKA Created)                              //    - state transition from New (AKA PendingInsert) to Detached (AKA Created)                              //    - state transition from Modified (AKA PendingChange) to Unchanged                              //    - state transition from Deleted (AKA PendingDelete) to Unchanged                              _rollbackState = row.RowState;                              switch (_rollbackState)                              {                                  case DataRowState.Deleted:                                      break;                                    case DataRowState.Detached:                                      break;                                    case DataRowState.Added:                                      break;                                    case DataRowState.Modified:                                      _columnChangeList.Clear();                                      nRec1 = row.GetRecordFromVersion(DataRowVersion.Original);                                      nRec2 = row.GetRecordFromVersion(DataRowVersion.Current);                                      foreach (DataColumn c in row.Table.Columns)                                      {                                          if (!IsSame(c' nRec1' nRec2))                                              _columnChangeList.Add(c);                                      }                                      break;                              }                              break;                            case DataRowAction.Change:                              // A DataRow field is beeing changed                              //    - state transition from New (AKA PendingInsert) to New (AKA PendingInsert)                              //    - state transition from Unchanged to Modified (AKA PendingChange)                              //    - state transition from Modified (AKA PendingChange) to Modified (AKA PendingChange)                              _columnChangeList.Clear();                              nRec1 = row.GetRecordFromVersion(DataRowVersion.Proposed);                              nRec2 = row.GetRecordFromVersion(DataRowVersion.Current);                              foreach (DataColumn c in row.Table.Columns)                              {                                  object proposedValue = row[c' DataRowVersion.Proposed];                                  object currentValue = row[c' DataRowVersion.Current];                                  // Foliate if proposedValue is DBNull; this way the DataPointer objects will point to a disconnected fragment after                                  // the DBNull value is beeing set                                  if (Convert.IsDBNull(proposedValue) && !Convert.IsDBNull(currentValue))                                  {                                      // Foliate only for non-hidden columns (since hidden cols are not represented in XML)                                      if (c.ColumnMapping != MappingType.Hidden)                                          FoliateIfDataPointers(row' rowElement);                                  }                                  if (!IsSame(c' nRec1' nRec2))                                      _columnChangeList.Add(c);                              }                              break;                            case DataRowAction.Commit:                              break;                      }
Missing Default,System.Xml,XmlDataDocument,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Xml\XmlDataDocument.cs,OnRowChanging,The following switch statement is missing a default case: switch (_rollbackState)                              {                                  case DataRowState.Deleted:                                      break;                                    case DataRowState.Detached:                                      break;                                    case DataRowState.Added:                                      break;                                    case DataRowState.Modified:                                      _columnChangeList.Clear();                                      nRec1 = row.GetRecordFromVersion(DataRowVersion.Original);                                      nRec2 = row.GetRecordFromVersion(DataRowVersion.Current);                                      foreach (DataColumn c in row.Table.Columns)                                      {                                          if (!IsSame(c' nRec1' nRec2))                                              _columnChangeList.Add(c);                                      }                                      break;                              }
Missing Default,System.Data,XmlDataLoader,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\XmlDataLoader.cs,LoadTable,The following switch statement is missing a default case: switch (_dataReader.LocalName)                          {                              case Keywords.DIFFID:                   // Is it a diffgeam ID ?                                  diffId = _dataReader.Value;          // Store ID                                  break;                              case Keywords.HASCHANGES:               // Has changes attribute ?                                  hasChanges = _dataReader.Value;      // Store value                                  break;                              case Keywords.HASERRORS:                // Has errors attribute ?                                  hasErrors = (bool)Convert.ChangeType(_dataReader.Value' typeof(bool)' CultureInfo.InvariantCulture);                                  // Store value                                  break;                          }
Missing Default,System.Data,NewDiffgramGen,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\xmlsaver.cs,GenerateColumn,The following switch statement is missing a default case: switch (col.ColumnMapping)              {                  case MappingType.Attribute:                      _xmlw.WriteAttributeString(colPrefix' col.EncodedColumnName' col.Namespace' value);                      break;                    case MappingType.Hidden:                      _xmlw.WriteAttributeString(Keywords.MSD' "hidden" + col.EncodedColumnName' Keywords.MSDNS' value);                      break;                    case MappingType.SimpleContent:                      _xmlw.WriteString(value);                      break;                    case MappingType.Element:                      bool startElementSkipped = true;                      object columnValue = row[col' version];                      // if the object is built in type or if it implements IXMLSerializable' write the start Element' otherwise                      //(if CDT and does not implement IXmlSerializable) skip it                      if (!col.IsCustomType || !col.IsValueCustomTypeInstance(columnValue) || (typeof(IXmlSerializable).IsAssignableFrom(columnValue.GetType())))                      {                          _xmlw.WriteStartElement(colPrefix' col.EncodedColumnName' col.Namespace);                          startElementSkipped = false;                      }                      Type valuesType = columnValue.GetType();                      if (!col.IsCustomType)                      { // if column's type is built in type CLR or SQLType                          if (valuesType == typeof(char) || valuesType == typeof(string))                          {                              if (XmlDataTreeWriter.PreserveSpace(value))                              {                                  _xmlw.WriteAttributeString(Keywords.XML' Keywords.SPACE' Keywords.XML_XMLNS' Keywords.PRESERVE);                              }                          }                          _xmlw.WriteString(value);                      }                      else                      { // Columns type is CDT                          if ((columnValue != DBNull.Value) && (!col.ImplementsINullable || !DataStorage.IsObjectSqlNull(columnValue)))                          {                              if (col.IsValueCustomTypeInstance(columnValue)/* && valuesType != typeof(Type)*/)                              {// value is also CDT                                  // if SkippedElement' ie does not implement IXMLSerializable: so No Polymorphysm Support.                                  if (!startElementSkipped && columnValue.GetType() != col.DataType)                                  {                                      _xmlw.WriteAttributeString(Keywords.MSD' Keywords.MSD_INSTANCETYPE' Keywords.MSDNS' DataStorage.GetQualifiedName(valuesType));                                  }                                  if (!startElementSkipped)                                  {                                      col.ConvertObjectToXml(columnValue' _xmlw' null); // XmlRootAttribute MUST be passed null                                  }                                  else                                  {                                      // this guy does not implement IXmlSerializable' so we need to handle serialization via XmlSerializer                                      if (columnValue.GetType() != col.DataType)                                      { // throw if polymorphism; not supported                                          throw ExceptionBuilder.PolymorphismNotSupported(valuesType.AssemblyQualifiedName);                                      }                                      // therefore we are skipping the start element' but by passing XmlRootAttribute with the same name as                                      // we open the start element (column's name)' XmlSerializer will open and close it for us                                      XmlRootAttribute xmlAttrib = new XmlRootAttribute(col.EncodedColumnName);                                      xmlAttrib.Namespace = col.Namespace;                                      col.ConvertObjectToXml(columnValue' _xmlw' xmlAttrib);                                  }                              }                              else                              { // value is built in CLR type (eg: string' int etc.)                                // these basic clr types do not have direct xsd type mappings                                  if (valuesType == typeof(Type) || valuesType == typeof(Guid) || valuesType == typeof(char) ||                                      DataStorage.IsSqlType(valuesType))                                  { // if unmapped type or SQL type write msdata:Datatype=typeofinstance                                      _xmlw.WriteAttributeString(Keywords.MSD' Keywords.MSD_INSTANCETYPE' Keywords.MSDNS' valuesType.FullName);                                  }                                  else if (columnValue is Type)                                  {                                      _xmlw.WriteAttributeString(Keywords.MSD' Keywords.MSD_INSTANCETYPE' Keywords.MSDNS' Keywords.TYPEINSTANCE);                                  }                                  else                                  {                                      string xsdTypeName = Keywords.XSD_PREFIXCOLON + XmlTreeGen.XmlDataTypeName(valuesType);                                      _xmlw.WriteAttributeString(Keywords.XSI' Keywords.TYPE' Keywords.XSINS' xsdTypeName);                                      _xmlw.WriteAttributeString(Keywords.XMLNS_XSD' Keywords.XSDNS);                                  }                                  if (!DataStorage.IsSqlType(valuesType))                                  {                                      _xmlw.WriteString(col.ConvertObjectToXml(columnValue));                                  }                                  else                                  {                                      col.ConvertObjectToXml(columnValue' _xmlw' null);                                  }                              }                          }                      }                        if (!startElementSkipped)                      {                          _xmlw.WriteEndElement();                      }                      break;              }
Missing Default,System.Data,DataSet,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataSet.cs,DataSet,The following switch statement is missing a default case: switch (e.Name)                  {                      case "DataSet.RemotingFormat": //DataSet.RemotingFormat does not exist in V1/V1.1 versions                          remotingFormat = (SerializationFormat)e.Value;                          break;                      case "SchemaSerializationMode.DataSet": //SchemaSerializationMode.DataSet does not exist in V1/V1.1 versions                          schemaSerializationMode = (SchemaSerializationMode)e.Value;                          break;                  }
Missing Default,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DataTable,The following switch statement is missing a default case: switch (e.Name)                  {                      case "DataTable.RemotingFormat": //DataTable.RemotingFormat does not exist in V1/V1.1 versions                          remotingFormat = (SerializationFormat)e.Value;                          break;                  }
Missing Default,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,DeserializeTableData,The following switch statement is missing a default case: switch (ConvertToRowState(rowStates' bitIndex))                      {                          case DataRowState.Unchanged:                              row._oldRecord = recordIndex;                              row._newRecord = recordIndex;                              recordIndex += 1;                              break;                          case DataRowState.Added:                              row._oldRecord = -1;                              row._newRecord = recordIndex;                              recordIndex += 1;                              break;                          case DataRowState.Modified:                              row._oldRecord = recordIndex;                              row._newRecord = recordIndex + 1;                              rowArr[recordIndex + 1] = row;                              recordIndex += 2;                              break;                          case DataRowState.Deleted:                              row._oldRecord = recordIndex;                              row._newRecord = -1;                              recordIndex += 1;                              break;                      }
Missing Default,System.Data,DataTable,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataTable.cs,SetDataRowWithLoadOption,The following switch statement is missing a default case: switch (loadOption)                          {                              case LoadOption.OverwriteChanges:                                  if ((dataRow[dc' DataRowVersion.Current] != dc[recordNo]) || (dataRow[dc' DataRowVersion.Original] != dc[recordNo]))                                      hasError = true;                                  break;                              case LoadOption.Upsert:                                  if (dataRow[dc' DataRowVersion.Current] != dc[recordNo])                                      hasError = true;                                  break;                              case LoadOption.PreserveChanges:                                  if (dataRow[dc' DataRowVersion.Original] != dc[recordNo])                                      hasError = true;                                  break;                          }
Missing Default,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,MaintainDataView,The following switch statement is missing a default case: switch (changedType)              {                  case ListChangedType.ItemAdded:                      Debug.Assert(null != row' "MaintainDataView.ItemAdded with null DataRow");                      if (trackAddRemove)                      {                          if (_rowViewBuffer.TryGetValue(row' out buffer))                          {                              // help turn expression add/remove into a changed/move                              bool flag = _rowViewBuffer.Remove(row);                              Debug.Assert(flag' "row actually removed");                          }                      }                      if (row == _addNewRow)                      {                          // DataView.AddNew().Row was added to DataRowCollection                          int index = IndexOfDataRowView(_rowViewCache[_addNewRow]);                          Debug.Assert(0 <= index' "ItemAdded was actually deleted");                            _addNewRow = null;                          _addNewMoved = new ListChangedEventArgs(ListChangedType.ItemMoved' index' Count - 1);                      }                      else if (!_rowViewCache.ContainsKey(row))                      {                          _rowViewCache.Add(row' buffer ?? new DataRowView(this' row));                      }                      else                      {                          Debug.Assert(false' "ItemAdded DataRow already in view");                      }                      break;                  case ListChangedType.ItemDeleted:                      Debug.Assert(null != row' "MaintainDataView.ItemDeleted with null DataRow");                      Debug.Assert(row != _addNewRow' "addNewRow being deleted");                        if (trackAddRemove)                      {                          // help turn expression add/remove into a changed/move                          _rowViewCache.TryGetValue(row' out buffer);                          if (null != buffer)                          {                              _rowViewBuffer.Add(row' buffer);                          }                          else                          {                              Debug.Assert(false' "ItemDeleted DataRow not in view tracking");                          }                      }                      if (!_rowViewCache.Remove(row))                      {                          Debug.Assert(false' "ItemDeleted DataRow not in view");                      }                      break;                  case ListChangedType.Reset:                      Debug.Assert(null == row' "MaintainDataView.Reset with non-null DataRow");                      ResetRowViewCache();                      break;                  case ListChangedType.ItemChanged:                  case ListChangedType.ItemMoved:                      break;                  case ListChangedType.PropertyDescriptorAdded:                  case ListChangedType.PropertyDescriptorChanged:                  case ListChangedType.PropertyDescriptorDeleted:                      Debug.Assert(false' "unexpected");                      break;              }
Missing Default,System.Data,DataView,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\DataView.cs,OnListChanged,The following switch statement is missing a default case: switch (e.ListChangedType)                  {                      case ListChangedType.ItemChanged:                      // ItemChanged - a column value changed (0 <= e.OldIndex)                      // ItemChanged - a DataRow.RowError changed (-1 == e.OldIndex)                      // ItemChanged - RowState changed (e.NewIndex == e.OldIndex)                        case ListChangedType.ItemMoved:                          // ItemMoved - a column value affecting sort order changed                          // ItemMoved - a state change in equivalent fields                          Debug.Assert(((ListChangedType.ItemChanged == e.ListChangedType) && ((e.NewIndex == e.OldIndex) || (-1 == e.OldIndex))) ||                                       (ListChangedType.ItemMoved == e.ListChangedType && (e.NewIndex != e.OldIndex) && (0 <= e.OldIndex))'                                       "unexpected ItemChanged|ItemMoved");                            Debug.Assert(0 <= e.NewIndex' "negative NewIndex");                          if (0 <= e.NewIndex)                          {                              DataRow dr = GetRow(e.NewIndex);                              if (dr.HasPropertyChanged)                              {                                  col = dr.LastChangedColumn;                                  propertyName = (null != col) ? col.ColumnName : string.Empty;                              }                          }                            break;                        case ListChangedType.ItemAdded:                      case ListChangedType.ItemDeleted:                      case ListChangedType.PropertyDescriptorAdded:                      case ListChangedType.PropertyDescriptorChanged:                      case ListChangedType.PropertyDescriptorDeleted:                      case ListChangedType.Reset:                          break;                  }
Missing Default,System.Data,Index,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Selection.cs,GetIndex,The following switch statement is missing a default case: switch (changeRecord)                  {                      case ReplaceNewRecordForCompare:                          row._newRecord = record;                          break;                      case ReplaceOldRecordForCompare:                          row._oldRecord = record;                          break;                  }
Missing Default,System.Data,Index,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Selection.cs,GetIndex,The following switch statement is missing a default case: switch (changeRecord)                  {                      case ReplaceNewRecordForCompare:                          Debug.Assert(record == row._newRecord' "newRecord has change during GetIndex");                          row._newRecord = a;                          break;                      case ReplaceOldRecordForCompare:                          Debug.Assert(record == row._oldRecord' "oldRecord has change during GetIndex");                          row._oldRecord = b;                          break;                  }
Missing Default,System.Data,ExpressionParser,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\ExpressionParser.cs,BuildExpression,The following switch statement is missing a default case: switch (opInfo._op)                          {                              case Operators.Not:                                  break;                                case Operators.BitwiseNot:                                  throw ExprException.UnsupportedOperator(opInfo._op);                                case Operators.Negative:                                  break;                          }
Missing Default,System.Data,FunctionNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\FunctionNode.cs,EvalFunction,The following switch statement is missing a default case: switch (((DateTime)argumentValues[0]).Kind)                      {                          case DateTimeKind.Utc:                              if ((int)argumentValues[1] != 0 && (int)argumentValues[2] != 0)                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Local:                              if (DateTimeOffset.Now.Offset.Hours != (int)argumentValues[1] && DateTimeOffset.Now.Offset.Minutes != (int)argumentValues[2])                              {                                  throw ExprException.MismatchKindandTimeSpan();                              }                              break;                          case DateTimeKind.Unspecified: break;                      }
Missing Default,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,BinaryCompare,The following switch statement is missing a default case: switch (resultType)                      {                          case StorageType.SByte:                          case StorageType.Int16:                          case StorageType.Int32:                          case StorageType.Byte:                          case StorageType.UInt16:                              return Convert.ToInt32(vLeft' FormatProvider).CompareTo(Convert.ToInt32(vRight' FormatProvider));                          case StorageType.Int64:                          case StorageType.UInt32:                          case StorageType.UInt64:                          case StorageType.Decimal:                              return decimal.Compare(Convert.ToDecimal(vLeft' FormatProvider)' Convert.ToDecimal(vRight' FormatProvider));                          case StorageType.Char:                              return Convert.ToInt32(vLeft' FormatProvider).CompareTo(Convert.ToInt32(vRight' FormatProvider));                          case StorageType.Double:                              return Convert.ToDouble(vLeft' FormatProvider).CompareTo(Convert.ToDouble(vRight' FormatProvider));                          case StorageType.Single:                              return Convert.ToSingle(vLeft' FormatProvider).CompareTo(Convert.ToSingle(vRight' FormatProvider));                          case StorageType.DateTime:                              return DateTime.Compare(Convert.ToDateTime(vLeft' FormatProvider)' Convert.ToDateTime(vRight' FormatProvider));                          case StorageType.DateTimeOffset:                              // DTO can only be compared to DTO' other cases: cast Exception                              return DateTimeOffset.Compare((DateTimeOffset)vLeft' (DateTimeOffset)vRight);                          case StorageType.String:                              return table.Compare(Convert.ToString(vLeft' FormatProvider)' Convert.ToString(vRight' FormatProvider)' comparer);                          case StorageType.Guid:                              return ((Guid)vLeft).CompareTo((Guid)vRight);                          case StorageType.Boolean:                              if (op == Operators.EqualTo || op == Operators.NotEqual)                              {                                  return Convert.ToInt32(DataExpression.ToBoolean(vLeft)' FormatProvider) -                                         Convert.ToInt32(DataExpression.ToBoolean(vRight)' FormatProvider);                              }                              break;                      }
Missing Default,System.Data,BinaryNode,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\Filter\BinaryNode.cs,BinaryCompare,The following switch statement is missing a default case: switch (resultType)                      {                          case StorageType.SByte:                          case StorageType.Int16:                          case StorageType.Int32:                          case StorageType.Byte:                          case StorageType.UInt16:                          case StorageType.SqlByte:                          case StorageType.SqlInt16:                          case StorageType.SqlInt32:                              return SqlConvert.ConvertToSqlInt32(vLeft).CompareTo(SqlConvert.ConvertToSqlInt32(vRight));                          case StorageType.Int64:                          case StorageType.UInt32:                          case StorageType.SqlInt64:                              return SqlConvert.ConvertToSqlInt64(vLeft).CompareTo(SqlConvert.ConvertToSqlInt64(vRight));                          case StorageType.UInt64:                          case StorageType.SqlDecimal:                              return SqlConvert.ConvertToSqlDecimal(vLeft).CompareTo(SqlConvert.ConvertToSqlDecimal(vRight));                          case StorageType.SqlDouble:                              return SqlConvert.ConvertToSqlDouble(vLeft).CompareTo(SqlConvert.ConvertToSqlDouble(vRight));                          case StorageType.SqlSingle:                              return SqlConvert.ConvertToSqlSingle(vLeft).CompareTo(SqlConvert.ConvertToSqlSingle(vRight));                          case StorageType.SqlString:                              return table.Compare(vLeft.ToString()' vRight.ToString());                          case StorageType.SqlGuid:                              return ((SqlGuid)vLeft).CompareTo(vRight);                          case StorageType.SqlBoolean:                              if (op == Operators.EqualTo || op == Operators.NotEqual)                              {                                  result = 1;                                  if (((vLeft.GetType() == typeof(SqlBoolean)) && ((vRight.GetType() == typeof(SqlBoolean)) || (vRight.GetType() == typeof(bool)))) ||                                      ((vRight.GetType() == typeof(SqlBoolean)) && ((vLeft.GetType() == typeof(SqlBoolean)) || (vLeft.GetType() == typeof(bool)))))                                  {                                      return SqlConvert.ConvertToSqlBoolean(vLeft).CompareTo(SqlConvert.ConvertToSqlBoolean(vRight));                                  }                              }                              break;                          case StorageType.SqlBinary:                              return SqlConvert.ConvertToSqlBinary(vLeft).CompareTo(SqlConvert.ConvertToSqlBinary(vRight));                          case StorageType.SqlDateTime:                              return SqlConvert.ConvertToSqlDateTime(vLeft).CompareTo(SqlConvert.ConvertToSqlDateTime(vRight));                          case StorageType.SqlMoney:                              return SqlConvert.ConvertToSqlMoney(vLeft).CompareTo(SqlConvert.ConvertToSqlMoney(vRight));                      }
Missing Default,System.Data.ProviderBase,SchemaMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\ProviderBase\SchemaMapping.cs,GetMappedValues,The following switch statement is missing a default case: switch (_xmlMap[i])                              {                                  case SqlXml: // turn string into a SqlXml value for DataColumn                                      System.Xml.XmlReaderSettings settings = new System.Xml.XmlReaderSettings();                                      settings.ConformanceLevel = System.Xml.ConformanceLevel.Fragment;                                      System.Xml.XmlReader reader = System.Xml.XmlReader.Create(new System.IO.StringReader(xml)' settings' (string)null);                                      _readerDataValues[i] = new System.Data.SqlTypes.SqlXml(reader);                                      break;                                  case XmlDocument: // turn string into XmlDocument value for DataColumn                                      System.Xml.XmlDocument document = new System.Xml.XmlDocument();                                      document.LoadXml(xml);                                      _readerDataValues[i] = document;                                      break;                              }
Missing Default,System.Data.SqlTypes,SqlDecimal,C:\selectedRepos\dotnet_corefx\src\System.Data.Common\src\System\Data\SQLTypes\SQLDecimal.cs,ZeroToMaxLen,The following switch statement is missing a default case: switch (cUI4sCur)              {                  case 1:                      rgulData[1] = rgulData[2] = rgulData[3] = 0;                      break;                    case 2:                      rgulData[2] = rgulData[3] = 0;                      break;                    case 3:                      rgulData[3] = 0;                      break;              }
