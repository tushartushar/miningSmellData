Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\NTAuthentication.Common.cs,GetOutgoingBlob,The method has 103 lines of code.
Long Method,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,DecodeBytes,The method has 102 lines of code.
Long Method,System.Net.Mime,QEncodedStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QEncodedStream.cs,DecodeBytes,The method has 110 lines of code.
Long Method,System.Net.Mail,MailMessage,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\MailMessage.cs,SetContent,The method has 108 lines of code.
Long Method,System.Net.Mail,SmtpClient,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpClient.cs,Send,The method has 130 lines of code.
Long Method,System.Net.Mail,SmtpClient,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpClient.cs,SendAsync,The method has 120 lines of code.
Long Method,System.Net.Mail,SmtpReplyReaderFactory,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpReplyReaderFactory.cs,ProcessRead,The method has 147 lines of code.
Complex Method,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,Format,Cyclomatic complexity of the method is 8
Complex Method,System.Net,ContextAwareResult,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\ContextAwareResult.cs,CaptureOrComplete,Cyclomatic complexity of the method is 12
Complex Method,System.Net,DebugThreadTracking,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\DebugThreadTracking.cs,SetThreadKind,Cyclomatic complexity of the method is 9
Complex Method,System.Net,DebugThreadTracking,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\DebugThreadTracking.cs,SetThreadSource,Cyclomatic complexity of the method is 9
Complex Method,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\NTAuthentication.Common.cs,GetOutgoingBlob,Cyclomatic complexity of the method is 16
Complex Method,System.Net.Mime,ContentDisposition,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\ContentDisposition.cs,ParseValue,Cyclomatic complexity of the method is 9
Complex Method,System.Net.Mime,ContentType,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\ContentType.cs,ParseValue,Cyclomatic complexity of the method is 13
Complex Method,System.Net.Mail,AttachmentBase,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\Attachment.cs,SetContentFromString,Cyclomatic complexity of the method is 9
Complex Method,System.Net.Mail,MailMessage,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\MailMessage.cs,BuildDeliveryStatusNotificationString,Cyclomatic complexity of the method is 8
Complex Method,System.Net.Mail,Message,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\MailPriority.cs,PrepareHeaders,Cyclomatic complexity of the method is 9
Complex Method,System.Net.Mail,SmtpClient,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpClient.cs,Initialize,Cyclomatic complexity of the method is 9
Complex Method,System.Net.Mail,SmtpClient,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpClient.cs,Send,Cyclomatic complexity of the method is 17
Complex Method,System.Net.Mail,SmtpClient,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpClient.cs,SendAsync,Cyclomatic complexity of the method is 15
Complex Method,System.Net.Mail,SmtpConnection,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,GetConnection,Cyclomatic complexity of the method is 15
Complex Method,System.Net.Mail,ConnectAndHandshakeAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,Authenticate,Cyclomatic complexity of the method is 9
Complex Method,System.Net.Mail,SmtpReplyReaderFactory,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpReplyReaderFactory.cs,ReadLines,Cyclomatic complexity of the method is 9
Complex Method,System.Net.Mail,SmtpTransport,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpTransport.cs,SendMail,Cyclomatic complexity of the method is 8
Long Parameter List,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The method has 5 parameters. Parameters: buffer' offset' count' dontDeferFinalBytes' shouldAppendSpaceToCRLF
Long Parameter List,System.Net,ReadAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,ReadAsyncResult,The method has 6 parameters. Parameters: parent' buffer' offset' count' callback' state
Long Parameter List,System.Net,WriteAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,WriteAsyncResult,The method has 6 parameters. Parameters: parent' buffer' offset' count' callback' state
Long Parameter List,System.Net,BufferedReadStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\BufferedReadStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.Net,BufferedReadStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\BufferedReadStream.cs,ReadMoreAsync,The method has 5 parameters. Parameters: bytesAlreadyRead' buffer' offset' count' cancellationToken
Long Parameter List,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,Enter,The method has 5 parameters. Parameters: thisOrContextObject' arg0' arg1' arg2' memberName
Long Parameter List,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,DumpBuffer,The method has 5 parameters. Parameters: thisOrContextObject' buffer' offset' count' memberName
Long Parameter List,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The method has 5 parameters. Parameters: eventId' arg1' arg2' arg3' arg4
Long Parameter List,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The method has 5 parameters. Parameters: eventId' arg1' arg2' arg3' arg4
Long Parameter List,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The method has 5 parameters. Parameters: eventId' arg1' arg2' arg3' arg4
Long Parameter List,System.Net,DelegatedStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\DelegatedStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.Net,DelegatedStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\DelegatedStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.Net,TlsStream,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\TlsStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' size' callback' state
Long Parameter List,System.Net,TlsStream,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\TlsStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.Net,ContextAwareResult,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\ContextAwareResult.cs,ContextAwareResult,The method has 5 parameters. Parameters: captureIdentity' forceCaptureContext' myObject' myState' myCallBack
Long Parameter List,System.Net,ContextAwareResult,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\ContextAwareResult.cs,ContextAwareResult,The method has 6 parameters. Parameters: captureIdentity' forceCaptureContext' threadSafeContextCopy' myObject' myState' myCallBack
Long Parameter List,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\NTAuthentication.Common.cs,NTAuthentication,The method has 6 parameters. Parameters: isServer' package' credential' spn' requestedContextFlags' channelBinding
Long Parameter List,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\NTAuthentication.Common.cs,Initialize,The method has 6 parameters. Parameters: isServer' package' credential' spn' requestedContextFlags' channelBinding
Long Parameter List,System.Net.Mime,Base64WriteStateInfo,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\Base64WriteStateInfo.cs,Base64WriteStateInfo,The method has 5 parameters. Parameters: bufferSize' header' footer' maxLineLength' mimeHeaderLength
Long Parameter List,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.Net.Mime,WriteAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,WriteAsyncResult,The method has 6 parameters. Parameters: parent' buffer' offset' count' callback' state
Long Parameter List,System.Net.Mime,WriteAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,WriteAsyncResult,The method has 6 parameters. Parameters: parent' buffer' offset' count' callback' state
Long Parameter List,System.Net.Mime,EightBitStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\EightBitStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.Net.Mime,QEncodedStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QEncodedStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.Net.Mime,WriteStateInfoBase,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\WriteStateInfoBase.cs,WriteStateInfoBase,The method has 5 parameters. Parameters: bufferSize' header' footer' maxLineLength' mimeHeaderLength
Long Parameter List,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,ReadQuotedString,The method has 5 parameters. Parameters: data' offset' builder' doesntRequireQuotes' permitUnicodeInDisplayName
Long Parameter List,System.Net.Mail,HeaderInfo,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\MailHeaderInfo.cs,HeaderInfo,The method has 5 parameters. Parameters: id' name' isSingleton' isUserSettable' allowsUnicode
Long Parameter List,System.Net.Mail,ISmtpAuthenticationModule,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\ISmtpAuthenticationModule.cs,Authenticate,The method has 5 parameters. Parameters: challenge' credentials' sessionCookie' spn' channelBindingToken
Long Parameter List,System.Net.Mail,MailMessage,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\MailMessage.cs,BeginSend,The method has 5 parameters. Parameters: writer' sendEnvelope' allowUnicode' callback' state
Long Parameter List,System.Net.Mail,Message,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\MailPriority.cs,BeginSend,The method has 5 parameters. Parameters: writer' sendEnvelope' allowUnicode' callback' state
Long Parameter List,System.Net.Mail,SmtpClient,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpClient.cs,SendAsync,The method has 5 parameters. Parameters: from' recipients' subject' body' userToken
Long Parameter List,System.Net.Mail,AuthCommand,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpCommands.cs,BeginSend,The method has 5 parameters. Parameters: conn' type' message' callback' state
Long Parameter List,System.Net.Mail,MailCommand,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpCommands.cs,BeginSend,The method has 6 parameters. Parameters: conn' command' from' allowUnicode' callback' state
Long Parameter List,System.Net.Mail,SmtpConnection,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,BeginGetConnection,The method has 5 parameters. Parameters: outerResult' callback' state' host' port
Long Parameter List,System.Net.Mail,AuthenticateCallbackContext,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,AuthenticateCallbackContext,The method has 5 parameters. Parameters: thisPtr' module' credential' spn' Token
Long Parameter List,System.Net.Mail,ConnectAndHandshakeAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,ConnectAndHandshakeAsyncResult,The method has 6 parameters. Parameters: connection' host' port' outerResult' callback' state
Long Parameter List,System.Net.Mail,SmtpTransport,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpTransport.cs,BeginGetConnection,The method has 5 parameters. Parameters: outerResult' callback' state' host' port
Long Parameter List,System.Net.Mail,SmtpTransport,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpTransport.cs,BeginSendMail,The method has 6 parameters. Parameters: sender' recipients' deliveryNotify' allowUnicode' callback' state
Long Parameter List,System.Net.Mail,SmtpTransport,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpTransport.cs,SendMail,The method has 5 parameters. Parameters: sender' recipients' deliveryNotify' allowUnicode' exception
Long Parameter List,System.Net.Mail,SendMailAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpTransport.cs,SendMailAsyncResult,The method has 7 parameters. Parameters: connection' from' toCollection' allowUnicode' deliveryNotify' callback' state
Long Parameter List,System.Net.Mail,SmtpLoginAuthenticationModule,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpLoginAuthenticationModule.cs,Authenticate,The method has 5 parameters. Parameters: challenge' credential' sessionCookie' spn' channelBindingToken
Long Parameter List,System.Net.Mail,SmtpNegotiateAuthenticationModule,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpNegotiateAuthenticationModule.cs,Authenticate,The method has 5 parameters. Parameters: challenge' credential' sessionCookie' spn' channelBindingToken
Long Parameter List,System.Net.Mail,SmtpNtlmAuthenticationModule,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpNtlmAuthenticationModule.cs,Authenticate,The method has 5 parameters. Parameters: challenge' credential' sessionCookie' spn' channelBindingToken
Long Identifier,System.Net,SecurityProtocol,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\SecurityProtocol.cs,,The length of the parameter SystemDefaultSecurityProtocols is 30.
Long Identifier,System.Net.Mime,SmtpDateTime,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\SmtpDateTime.cs,,The length of the parameter DateFormatWithDayOfWeekAndNoSeconds is 35.
Long Identifier,System.Net.Mime,SmtpDateTime,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\SmtpDateTime.cs,,The length of the parameter DateFormatWithoutDayOfWeekAndNoSeconds is 38.
Long Identifier,System.Net.Mail,ConnectAndHandshakeAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,,The length of the parameter s_authenticateContinueCallback is 30.
Long Statement,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The length of the statement  "                if ((_lineLength != -1) && (WriteState.CurrentLineLength + SizeOfBase64EncodedChar + _writeState.FooterLength > _lineLength)) " is 125.
Long Statement,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The length of the statement  "            if ((count % 3 != 0) && (_lineLength != -1) && (WriteState.CurrentLineLength + SizeOfBase64EncodedChar + _writeState.FooterLength >= _lineLength)) " is 146.
Long Statement,System.Net,WriteAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,Write,The length of the statement  "                        IAsyncResult result = _parent.BaseStream.BeginWrite(_parent.WriteState.Buffer' 0' _parent.WriteState.Length' s_onWrite' this); " is 126.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,Enter,The length of the statement  "            if (IsEnabled) Log.Enter(IdOf(thisOrContextObject)' memberName' formattableString != null ? Format(formattableString) : NoParameters); " is 134.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,Exit,The length of the statement  "            if (IsEnabled) Log.Exit(IdOf(thisOrContextObject)' memberName' formattableString != null ? Format(formattableString) : NoParameters); " is 133.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,Info,The length of the statement  "            if (IsEnabled) Log.Info(IdOf(thisOrContextObject)' memberName' formattableString != null ? Format(formattableString) : NoParameters); " is 133.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,DumpBuffer,The length of the statement  "                    Fail(thisOrContextObject' $"Invalid {nameof(DumpBuffer)} Args. Length={buffer.Length}' Offset={offset}' Count={count}"' memberName); " is 132.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,DebugValidateArg,The length of the statement  "                Debug.Assert(!(arg is ValueType)' $"Should not be passing value type {arg?.GetType()} to logging without IsEnabled check"); " is 123.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,DebugValidateArg,The length of the statement  "                Debug.Assert(!(arg is FormattableString)' $"Should not be formatting FormattableString \"{arg}\" if tracing isn't enabled"); " is 124.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,DebugValidateArg,The length of the statement  "            Debug.Assert(IsEnabled || arg == null' $"Should not be formatting FormattableString \"{arg}\" if tracing isn't enabled"); " is 121.
Long Statement,System.Net,ContextAwareResult,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\ContextAwareResult.cs,Complete,The length of the statement  "            // the completion for the CaptureOrComplete() call to avoid the context flow.  If not' we know CaptureOrComplete() has completed. " is 129.
Long Statement,System.Net,DebugThreadTracking,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\DebugThreadTracking.cs,SetThreadKind,The length of the statement  "                if (NetEventSource.IsEnabled) NetEventSource.Error(null' "Thread changed from User to System; user's thread shouldn't be hijacked."); " is 133.
Long Statement,System.Net,DebugThreadTracking,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\DebugThreadTracking.cs,SetThreadKind,The length of the statement  "                if (NetEventSource.IsEnabled) NetEventSource.Error(null' "Thread changed from Async to Sync' may block an Async thread."); " is 122.
Long Statement,System.Net,DebugThreadTracking,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\DebugThreadTracking.cs,SetThreadKind,The length of the statement  "                if (NetEventSource.IsEnabled) NetEventSource.Error(null' "Thread from a limited resource changed to Sync' may deadlock or bottleneck."); " is 136.
Long Statement,System.Net,DebugThreadTracking,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\DebugThreadTracking.cs,SetThreadSource,The length of the statement  "                if (NetEventSource.IsEnabled) NetEventSource.Error(null' "SetThreadSource must be called at the base of the stack' or the stack has been corrupted."); " is 150.
Long Statement,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\NTAuthentication.Common.cs,GetOutgoingBlob,The length of the statement  "                    if (NetEventSource.IsEnabled) NetEventSource.Info(this' $"SSPIWrapper.InitializeSecurityContext() returns statusCode:0x{((int)statusCode.ErrorCode):x8} ({statusCode})"); " is 169.
Long Statement,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\NTAuthentication.Common.cs,GetOutgoingBlob,The length of the statement  "                        if (NetEventSource.IsEnabled) NetEventSource.Info(this' $"SSPIWrapper.CompleteAuthToken() returns statusCode:0x{((int)statusCode.ErrorCode):x8} ({statusCode})"); " is 161.
Long Statement,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\NTAuthentication.Common.cs,GetOutgoingBlob,The length of the statement  "                    if (NetEventSource.IsEnabled) NetEventSource.Info(this' $"SSPIWrapper.AcceptSecurityContext() returns statusCode:0x{((int)statusCode.ErrorCode):x8} ({statusCode})"); " is 165.
Long Statement,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\NTAuthentication.Common.cs,GetOutgoingBlob,The length of the statement  "                if (NetEventSource.IsEnabled) NetEventSource.Exit(this' $"null statusCode:0x{((int)statusCode.ErrorCode):x8} ({statusCode})"); " is 126.
Long Statement,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\NTAuthentication.Common.cs,GetOutgoingBlob,The length of the statement  "                if (NetEventSource.IsEnabled) NetEventSource.Info(this' $"need continue statusCode:0x{((int)statusCode.ErrorCode):x8} ({statusCode}) _securityContext:{_securityContext}"); " is 171.
Long Statement,System.Net.Mime,MimePart,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\MimePart.cs,ReadCallbackHandler,The length of the statement  "                IAsyncResult writeResult = context._outputStream.BeginWrite(context._buffer' 0' context._bytesLeft' _writeCallback' context); " is 125.
Long Statement,System.Net.Mime,WriteAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,Write,The length of the statement  "                        IAsyncResult result = _parent.BaseStream.BeginWrite(_parent.WriteState.Buffer' 0' _parent.WriteState.Length' s_onWrite' this); " is 126.
Long Statement,System.Net.Mime,WriteAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,Write,The length of the statement  "                        IAsyncResult result = _parent.BaseStream.BeginWrite(_parent.WriteState.Buffer' 0' _parent.WriteState.Length' s_onWrite' this); " is 126.
Long Statement,System.Net.Mime,ContentDisposition,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\ContentDisposition.cs,EncodeToBuffer,The length of the statement  "                builder.Append('"').Append(MimeBasePart.EncodeHeaderValue(value' encoding' MimeBasePart.ShouldUseBase64Encoding(encoding))).Append('"'); " is 136.
Long Statement,System.Net.Mime,ContentType,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\ContentType.cs,EncodeToBuffer,The length of the statement  "                builder.Append('"').Append(MimeBasePart.EncodeHeaderValue(value' encoding' MimeBasePart.ShouldUseBase64Encoding(encoding))).Append('"'); " is 136.
Long Statement,System.Net.Mime,MimeBasePart,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\MimeBasePart.cs,PrepareHeaders,The length of the statement  "                _headers.InternalSet(MailHeaderInfo.GetString(MailHeaderID.ContentDisposition)' _contentDisposition.Encode(allowUnicode)); " is 122.
Long Statement,System.Net.Mime,SmtpDateTime,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\SmtpDateTime.cs,ParseValue,The length of the statement  "            if (!DateTime.TryParseExact(date' s_validDateTimeFormats' CultureInfo.InvariantCulture' DateTimeStyles.AllowWhiteSpaces' out dateValue)) " is 136.
Long Statement,System.Net.Mime,MimeMultiPart,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\MimeMultiPart.cs,MimePartSentCallbackHandler,The length of the statement  "                IAsyncResult closeResult = ((MimeWriter)context._writer).BeginClose(new AsyncCallback(MimeWriterCloseCallback)' context); " is 121.
Long Statement,System.Net.Mime,MimeMultiPart,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\MimeMultiPart.cs,ContentStreamCallbackHandler,The length of the statement  "                IAsyncResult closeResult = ((MimeWriter)context._writer).BeginClose(new AsyncCallback(MimeWriterCloseCallback)' context); " is 121.
Long Statement,System.Net.Mime,MimeMultiPart,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\MimeMultiPart.cs,GetNextBoundary,The length of the statement  "            string boundaryString = "--boundary_" + b.ToString(CultureInfo.InvariantCulture) + "_" + Guid.NewGuid().ToString(null' CultureInfo.InvariantCulture); " is 149.
Long Statement,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInAtoms,The length of the statement  "            // atext = ALPHA / DIGIT / "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "/" / "=" / "?" / "^" / "_" / "`" / "{" / "|" / "}" / "~" " is 138.
Long Statement,System.Net.Mail,BufferBuilder,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\BufferBuilder.cs,EnsureBuffer,The length of the statement  "                byte[] newBuffer = new byte[((_buffer.Length * 2) > (_buffer.Length + count)) ? (_buffer.Length * 2) : (_buffer.Length + count)]; " is 129.
Long Statement,System.Net.Mail,Attachment,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\Attachment.cs,SetContentTypeName,The length of the statement  "                MimePart.ContentType.Name = MimeBasePart.EncodeHeaderValue(_name' encoding' MimeBasePart.ShouldUseBase64Encoding(encoding)); " is 124.
Long Statement,System.Net.Mail,MailMessage,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\MailMessage.cs,SetContent,The length of the statement  "                    _bodyView = AlternateView.CreateAlternateViewFromString(_body' _bodyEncoding' (_isBodyHtml ? MediaTypeNames.Text.Html : null)); " is 127.
Long Statement,System.Net.Mail,MailMessage,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\MailMessage.cs,SetContent,The length of the statement  "                    _bodyView = AlternateView.CreateAlternateViewFromString(_body' _bodyEncoding' (_isBodyHtml ? MediaTypeNames.Text.Html : null)); " is 127.
Long Statement,System.Net.Mail,SmtpClient,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpClient.cs,SendAsync,The length of the statement  "                    // Also do capture the token if ICredential is not of CredentialCache type so we don't know what the exact credential response will be. " is 135.
Long Statement,System.Net.Mail,SmtpClient,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpClient.cs,SendAsync,The length of the statement  "                    _transport.IdentityRequired = Credentials != null && (ReferenceEquals(Credentials' CredentialCache.DefaultNetworkCredentials) || (cache = Credentials as CredentialCache) == null || IsSystemNetworkCredentialInCache(cache)); " is 222.
Long Statement,System.Net.Mail,SmtpClient,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpClient.cs,SendAsync,The length of the statement  "                            _operationCompletedResult = new ContextAwareResult(_transport.IdentityRequired' true' null' this' s_contextSafeCompleteCallback); " is 129.
Long Statement,System.Net.Mail,SmtpClient,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpClient.cs,Complete,The length of the statement  "                else if (exception != null && (!(exception is SmtpFailedRecipientException) || ((SmtpFailedRecipientException)exception).fatal)) " is 128.
Long Statement,System.Net.Mail,SmtpClient,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpClient.cs,ContextSafeCompleteCallback,The length of the statement  "            AsyncCompletedEventArgs eventArgs = new AsyncCompletedEventArgs(exception' client._cancelled' asyncOp.UserSuppliedState); " is 121.
Long Statement,System.Net.Mail,SmtpConnection,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,BeginGetConnection,The length of the statement  "            ConnectAndHandshakeAsyncResult result = new ConnectAndHandshakeAsyncResult(this' host' port' outerResult' callback' state); " is 123.
Long Statement,System.Net.Mail,SmtpConnection,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,SetContextAndTryAuthenticate,The length of the statement  "                    NetEventSource.Fail(this' "Authentication required when it wasn't expected.  (Maybe Credentials was changed on another thread?)"); " is 130.
Long Statement,System.Net.Mail,SmtpConnection,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,AuthenticateCallback,The length of the statement  "            context._result = context._module.Authenticate(null' context._credential' context._thisPtr' context._spn' context._token); " is 122.
Long Statement,System.Net.Mail,SmtpConnection,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,ParseExtensions,The length of the statement  "                    string[] authTypes = extension.Remove(0' SizeOfAuthExtension).Split(s_authExtensionSplitters' StringSplitOptions.RemoveEmptyEntries); " is 133.
Long Statement,System.Net.Mail,ConnectAndHandshakeAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,SendEHello,The length of the statement  "                IAsyncResult result = EHelloCommand.BeginSend(_connection' _connection._client.clientDomain' s_sendEHelloCallback' this); " is 121.
Long Statement,System.Net.Mail,ConnectAndHandshakeAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,TlsStreamAuthenticate,The length of the statement  "                _connection._networkStream = new TlsStream(_connection._networkStream' _connection._tcpClient.Client' _host' _connection._clientCertificates); " is 142.
Long Statement,System.Net.Mail,ConnectAndHandshakeAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,TlsStreamAuthenticate,The length of the statement  "                IAsyncResult result = (_connection._networkStream as TlsStream).BeginAuthenticateAsClient(TlsStreamAuthenticateCallback' this); " is 127.
Long Statement,System.Net.Mail,ConnectAndHandshakeAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,Authenticate,The length of the statement  "                            IAsyncResult result = AuthCommand.BeginSend(_connection' _connection._authenticationModules[_currentModule].AuthenticationType' auth.Message' s_authenticateCallback' this); " is 172.
Long Statement,System.Net.Mail,ConnectAndHandshakeAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,AuthenticateContinue,The length of the statement  "                    Authorization auth = _connection._authenticationModules[_currentModule].Authenticate(_authResponse' null' _connection' _connection._client.TargetName' _connection._channelBindingToken); " is 185.
Long Statement,System.Net.Mail,ReadLinesAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpReplyReaderFactory.cs,Read,The length of the statement  "                    IAsyncResult result = _parent._bufferedStream.BeginRead(_parent._byteBuffer' 0' _parent._byteBuffer.Length' s_readCallback' this); " is 130.
Long Statement,System.Net.Mail,ReadLinesAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpReplyReaderFactory.cs,ProcessRead,The length of the statement  "                        _lines.Add(new LineInfo(_parent._statusCode' _builder.ToString(0' _builder.Length - 2))); // return everything except CRLF " is 122.
Long Statement,System.Net.Mail,ReadLinesAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpReplyReaderFactory.cs,ProcessRead,The length of the statement  "                        _lines.Add(new LineInfo(_parent._statusCode' _builder.ToString(0' _builder.Length - 2))); // return everything except CRLF " is 122.
Long Statement,System.Net.Mail,SmtpTransport,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpTransport.cs,SendMail,The length of the statement  "                    exception = new SmtpFailedRecipientsException(_failedRecipientExceptions' _failedRecipientExceptions.Count == recipients.Count); " is 128.
Long Statement,System.Net.Mail,SendMailAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpTransport.cs,SendData,The length of the statement  "                InvokeCallback(new SmtpFailedRecipientsException(_failedRecipientExceptions' _failedRecipientExceptions.Count == _toCollection.Count)); " is 135.
Long Statement,System.Net.Mail,SendMailAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpTransport.cs,SendDataCompleted,The length of the statement  "                        thisPtr.InvokeCallback(new SmtpFailedRecipientsException(thisPtr._failedRecipientExceptions' thisPtr._failedRecipientExceptions.Count == thisPtr._toCollection.Count)); " is 167.
Complex Conditional,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,DecodeBytes,The conditional expression  "*source == '\r' || *source == '\n' || *source == '=' || *source == ' ' || *source == '\t'"  is complex.
Complex Conditional,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,EncodeBytes,The conditional expression  "(_lineLength != -1 && WriteState.CurrentLineLength + SizeOfEncodedChar + 2 >= _lineLength && (buffer[cur] == ' ' ||                      buffer[cur] == '\t' || buffer[cur] == '\r' || buffer[cur] == '\n')) ||                      _writeState.CurrentLineLength + SizeOfEncodedChar + 2 >= EncodedStreamFactory.DefaultMaxLineLength"  is complex.
Complex Conditional,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,EncodeBytes,The conditional expression  "(buffer[cur] < 32 && buffer[cur] != '\t') ||                      buffer[cur] == '=' ||                      buffer[cur] > 126"  is complex.
Complex Conditional,System.Net.Mime,QEncodedStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QEncodedStream.cs,EncodeBytes,The conditional expression  "((WriteState.CurrentLineLength + SizeOfFoldingCRLF + WriteState.FooterLength >= WriteState.MaxLineLength)                          && (buffer[cur] == ' ' || buffer[cur] == '\t' || buffer[cur] == '\r' || buffer[cur] == '\n'))                      // Or just adding the footer would be too long.                      || (WriteState.CurrentLineLength + _writeState.FooterLength >= WriteState.MaxLineLength)"  is complex.
Complex Conditional,System.Net.Mime,ContentDisposition,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\ContentDisposition.cs,ToString,The conditional expression  "_disposition == null || _isChanged || _parameters != null && _parameters.IsChanged"  is complex.
Complex Conditional,System.Net.Mime,ContentType,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\ContentType.cs,ParseValue,The conditional expression  "_mediaType == null || _mediaType.Length == 0 || offset >= _type.Length || _type[offset++] != '/'"  is complex.
Complex Conditional,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,ReadQuotedString,The conditional expression  "data[offset] == '=' &&                      data.Length > offset + 3 &&                      data[offset + 1] == '\r' &&                      data[offset + 2] == '\n' &&                      (data[offset + 3] == ' ' || data[offset + 3] == '\t')"  is complex.
Complex Conditional,System.Net.Mail,Attachment,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\Attachment.cs,SetContentTypeName,The conditional expression  "!allowUnicode && _name != null && _name.Length != 0 && !MimeBasePart.IsAscii(_name' false)"  is complex.
Complex Conditional,System.Net.Mail,Message,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\MailPriority.cs,EncodeHeaders,The conditional expression  "MimeBasePart.IsAscii(values[j]' false)                           || (allowUnicode && MailHeaderInfo.AllowsUnicode(headerName) // EAI                              && !MailBnfHelper.HasCROrLF(values[j]))"  is complex.
Complex Conditional,System.Net.Mail,SmtpNegotiateAuthenticationModule,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpNegotiateAuthenticationModule.cs,GetSecurityLayerOutgoingBlob,The conditional expression  "len < 4 ||          // expect 4 bytes                  input[0] != 1 ||    // first value 1                  input[1] != 0 ||    // rest value 0                  input[2] != 0 ||                  input[3] != 0"  is complex.
Complex Conditional,System.Net.Mail,MailAddressParser,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailAddressParser.cs,ParseLocalPart,The conditional expression  "index >= 0 &&                          !(                              MailBnfHelper.IsAllowedWhiteSpace(data[index]) // < local@domain >                              || data[index] == MailBnfHelper.EndComment // <(comment)local@domain>                              || (expectAngleBracket && data[index] == MailBnfHelper.StartAngleBracket) // <local@domain>                              || (expectMultipleAddresses && data[index] == MailBnfHelper.Comma) // local@dom'local@dom                                                                                                 // Note: The following condition is more lax than the RFC.  This is done so we could support                                                                                                  // a common invalid formats as shown below.                              || data[index] == MailBnfHelper.Quote // "display"local@domain                          )"  is complex.
Empty Catch Block,System.Net,LazyAsyncResult,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\LazyAsyncResult.cs,ProtectedInvokeCallback,The method has an empty catch block.
Empty Catch Block,System.Net,LazyAsyncResult,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\LazyAsyncResult.cs,WaitForCompletion,The method has an empty catch block.
Empty Catch Block,System.Net.Mail,SmtpClient,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpClient.cs,Initialize,The method has an empty catch block.
Empty Catch Block,System.Net.Mail,SmtpClient,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpClient.cs,Abort,The method has an empty catch block.
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,Close,The following statement contains a magic number: if (_writeState != null && WriteState.Length > 0)              {                  switch (WriteState.Padding)                  {                      case 1:                          WriteState.Append(s_base64EncodeMap[WriteState.LastBits]' s_base64EncodeMap[64]);                          break;                      case 2:                          WriteState.Append(s_base64EncodeMap[WriteState.LastBits]' s_base64EncodeMap[64]' s_base64EncodeMap[64]);                          break;                  }                  WriteState.Padding = 0;                  FlushInternal();              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,Close,The following statement contains a magic number: if (_writeState != null && WriteState.Length > 0)              {                  switch (WriteState.Padding)                  {                      case 1:                          WriteState.Append(s_base64EncodeMap[WriteState.LastBits]' s_base64EncodeMap[64]);                          break;                      case 2:                          WriteState.Append(s_base64EncodeMap[WriteState.LastBits]' s_base64EncodeMap[64]' s_base64EncodeMap[64]);                          break;                  }                  WriteState.Padding = 0;                  FlushInternal();              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,Close,The following statement contains a magic number: if (_writeState != null && WriteState.Length > 0)              {                  switch (WriteState.Padding)                  {                      case 1:                          WriteState.Append(s_base64EncodeMap[WriteState.LastBits]' s_base64EncodeMap[64]);                          break;                      case 2:                          WriteState.Append(s_base64EncodeMap[WriteState.LastBits]' s_base64EncodeMap[64]' s_base64EncodeMap[64]);                          break;                  }                  WriteState.Padding = 0;                  FlushInternal();              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,Close,The following statement contains a magic number: if (_writeState != null && WriteState.Length > 0)              {                  switch (WriteState.Padding)                  {                      case 1:                          WriteState.Append(s_base64EncodeMap[WriteState.LastBits]' s_base64EncodeMap[64]);                          break;                      case 2:                          WriteState.Append(s_base64EncodeMap[WriteState.LastBits]' s_base64EncodeMap[64]' s_base64EncodeMap[64]);                          break;                  }                  WriteState.Padding = 0;                  FlushInternal();              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    while (source < end)                  {                      //space and tab are ok because folding must include a whitespace char.                      if (*source == '\r' || *source == '\n' || *source == '=' || *source == ' ' || *source == '\t')                      {                          source++;                          continue;                      }                        byte s = s_base64DecodeMap[*source];                        if (s == InvalidBase64Value)                      {                          throw new FormatException(SR.MailBase64InvalidCharacter);                      }                        switch (ReadState.Pos)                      {                          case 0:                              ReadState.Val = (byte)(s << 2);                              ReadState.Pos++;                              break;                          case 1:                              *dest++ = (byte)(ReadState.Val + (s >> 4));                              ReadState.Val = unchecked((byte)(s << 4));                              ReadState.Pos++;                              break;                          case 2:                              *dest++ = (byte)(ReadState.Val + (s >> 2));                              ReadState.Val = unchecked((byte)(s << 6));                              ReadState.Pos++;                              break;                          case 3:                              *dest++ = (byte)(ReadState.Val + s);                              ReadState.Pos = 0;                              break;                      }                      source++;                  }                    return (int)(dest - start);              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    while (source < end)                  {                      //space and tab are ok because folding must include a whitespace char.                      if (*source == '\r' || *source == '\n' || *source == '=' || *source == ' ' || *source == '\t')                      {                          source++;                          continue;                      }                        byte s = s_base64DecodeMap[*source];                        if (s == InvalidBase64Value)                      {                          throw new FormatException(SR.MailBase64InvalidCharacter);                      }                        switch (ReadState.Pos)                      {                          case 0:                              ReadState.Val = (byte)(s << 2);                              ReadState.Pos++;                              break;                          case 1:                              *dest++ = (byte)(ReadState.Val + (s >> 4));                              ReadState.Val = unchecked((byte)(s << 4));                              ReadState.Pos++;                              break;                          case 2:                              *dest++ = (byte)(ReadState.Val + (s >> 2));                              ReadState.Val = unchecked((byte)(s << 6));                              ReadState.Pos++;                              break;                          case 3:                              *dest++ = (byte)(ReadState.Val + s);                              ReadState.Pos = 0;                              break;                      }                      source++;                  }                    return (int)(dest - start);              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    while (source < end)                  {                      //space and tab are ok because folding must include a whitespace char.                      if (*source == '\r' || *source == '\n' || *source == '=' || *source == ' ' || *source == '\t')                      {                          source++;                          continue;                      }                        byte s = s_base64DecodeMap[*source];                        if (s == InvalidBase64Value)                      {                          throw new FormatException(SR.MailBase64InvalidCharacter);                      }                        switch (ReadState.Pos)                      {                          case 0:                              ReadState.Val = (byte)(s << 2);                              ReadState.Pos++;                              break;                          case 1:                              *dest++ = (byte)(ReadState.Val + (s >> 4));                              ReadState.Val = unchecked((byte)(s << 4));                              ReadState.Pos++;                              break;                          case 2:                              *dest++ = (byte)(ReadState.Val + (s >> 2));                              ReadState.Val = unchecked((byte)(s << 6));                              ReadState.Pos++;                              break;                          case 3:                              *dest++ = (byte)(ReadState.Val + s);                              ReadState.Pos = 0;                              break;                      }                      source++;                  }                    return (int)(dest - start);              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    while (source < end)                  {                      //space and tab are ok because folding must include a whitespace char.                      if (*source == '\r' || *source == '\n' || *source == '=' || *source == ' ' || *source == '\t')                      {                          source++;                          continue;                      }                        byte s = s_base64DecodeMap[*source];                        if (s == InvalidBase64Value)                      {                          throw new FormatException(SR.MailBase64InvalidCharacter);                      }                        switch (ReadState.Pos)                      {                          case 0:                              ReadState.Val = (byte)(s << 2);                              ReadState.Pos++;                              break;                          case 1:                              *dest++ = (byte)(ReadState.Val + (s >> 4));                              ReadState.Val = unchecked((byte)(s << 4));                              ReadState.Pos++;                              break;                          case 2:                              *dest++ = (byte)(ReadState.Val + (s >> 2));                              ReadState.Val = unchecked((byte)(s << 6));                              ReadState.Pos++;                              break;                          case 3:                              *dest++ = (byte)(ReadState.Val + s);                              ReadState.Pos = 0;                              break;                      }                      source++;                  }                    return (int)(dest - start);              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    while (source < end)                  {                      //space and tab are ok because folding must include a whitespace char.                      if (*source == '\r' || *source == '\n' || *source == '=' || *source == ' ' || *source == '\t')                      {                          source++;                          continue;                      }                        byte s = s_base64DecodeMap[*source];                        if (s == InvalidBase64Value)                      {                          throw new FormatException(SR.MailBase64InvalidCharacter);                      }                        switch (ReadState.Pos)                      {                          case 0:                              ReadState.Val = (byte)(s << 2);                              ReadState.Pos++;                              break;                          case 1:                              *dest++ = (byte)(ReadState.Val + (s >> 4));                              ReadState.Val = unchecked((byte)(s << 4));                              ReadState.Pos++;                              break;                          case 2:                              *dest++ = (byte)(ReadState.Val + (s >> 2));                              ReadState.Val = unchecked((byte)(s << 6));                              ReadState.Pos++;                              break;                          case 3:                              *dest++ = (byte)(ReadState.Val + s);                              ReadState.Pos = 0;                              break;                      }                      source++;                  }                    return (int)(dest - start);              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    while (source < end)                  {                      //space and tab are ok because folding must include a whitespace char.                      if (*source == '\r' || *source == '\n' || *source == '=' || *source == ' ' || *source == '\t')                      {                          source++;                          continue;                      }                        byte s = s_base64DecodeMap[*source];                        if (s == InvalidBase64Value)                      {                          throw new FormatException(SR.MailBase64InvalidCharacter);                      }                        switch (ReadState.Pos)                      {                          case 0:                              ReadState.Val = (byte)(s << 2);                              ReadState.Pos++;                              break;                          case 1:                              *dest++ = (byte)(ReadState.Val + (s >> 4));                              ReadState.Val = unchecked((byte)(s << 4));                              ReadState.Pos++;                              break;                          case 2:                              *dest++ = (byte)(ReadState.Val + (s >> 2));                              ReadState.Val = unchecked((byte)(s << 6));                              ReadState.Pos++;                              break;                          case 3:                              *dest++ = (byte)(ReadState.Val + s);                              ReadState.Pos = 0;                              break;                      }                      source++;                  }                    return (int)(dest - start);              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    while (source < end)                  {                      //space and tab are ok because folding must include a whitespace char.                      if (*source == '\r' || *source == '\n' || *source == '=' || *source == ' ' || *source == '\t')                      {                          source++;                          continue;                      }                        byte s = s_base64DecodeMap[*source];                        if (s == InvalidBase64Value)                      {                          throw new FormatException(SR.MailBase64InvalidCharacter);                      }                        switch (ReadState.Pos)                      {                          case 0:                              ReadState.Val = (byte)(s << 2);                              ReadState.Pos++;                              break;                          case 1:                              *dest++ = (byte)(ReadState.Val + (s >> 4));                              ReadState.Val = unchecked((byte)(s << 4));                              ReadState.Pos++;                              break;                          case 2:                              *dest++ = (byte)(ReadState.Val + (s >> 2));                              ReadState.Val = unchecked((byte)(s << 6));                              ReadState.Pos++;                              break;                          case 3:                              *dest++ = (byte)(ReadState.Val + s);                              ReadState.Pos = 0;                              break;                      }                      source++;                  }                    return (int)(dest - start);              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: switch (WriteState.Padding)              {                  case 2:                      WriteState.Append(s_base64EncodeMap[WriteState.LastBits | ((buffer[cur] & 0xf0) >> 4)]);                      if (count == 1)                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x0f) << 2);                          WriteState.Padding = 1;                          return cur - offset;                      }                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x0f) << 2) | ((buffer[cur + 1] & 0xc0) >> 6)]);                      WriteState.Append(s_base64EncodeMap[(buffer[cur + 1] & 0x3f)]);                      cur += 2;                      count -= 2;                      WriteState.Padding = 0;                      break;                  case 1:                      WriteState.Append(s_base64EncodeMap[WriteState.LastBits | ((buffer[cur] & 0xc0) >> 6)]);                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0x3f)]);                      cur++;                      count--;                      WriteState.Padding = 0;                      break;              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: switch (WriteState.Padding)              {                  case 2:                      WriteState.Append(s_base64EncodeMap[WriteState.LastBits | ((buffer[cur] & 0xf0) >> 4)]);                      if (count == 1)                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x0f) << 2);                          WriteState.Padding = 1;                          return cur - offset;                      }                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x0f) << 2) | ((buffer[cur + 1] & 0xc0) >> 6)]);                      WriteState.Append(s_base64EncodeMap[(buffer[cur + 1] & 0x3f)]);                      cur += 2;                      count -= 2;                      WriteState.Padding = 0;                      break;                  case 1:                      WriteState.Append(s_base64EncodeMap[WriteState.LastBits | ((buffer[cur] & 0xc0) >> 6)]);                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0x3f)]);                      cur++;                      count--;                      WriteState.Padding = 0;                      break;              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: switch (WriteState.Padding)              {                  case 2:                      WriteState.Append(s_base64EncodeMap[WriteState.LastBits | ((buffer[cur] & 0xf0) >> 4)]);                      if (count == 1)                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x0f) << 2);                          WriteState.Padding = 1;                          return cur - offset;                      }                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x0f) << 2) | ((buffer[cur + 1] & 0xc0) >> 6)]);                      WriteState.Append(s_base64EncodeMap[(buffer[cur + 1] & 0x3f)]);                      cur += 2;                      count -= 2;                      WriteState.Padding = 0;                      break;                  case 1:                      WriteState.Append(s_base64EncodeMap[WriteState.LastBits | ((buffer[cur] & 0xc0) >> 6)]);                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0x3f)]);                      cur++;                      count--;                      WriteState.Padding = 0;                      break;              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: switch (WriteState.Padding)              {                  case 2:                      WriteState.Append(s_base64EncodeMap[WriteState.LastBits | ((buffer[cur] & 0xf0) >> 4)]);                      if (count == 1)                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x0f) << 2);                          WriteState.Padding = 1;                          return cur - offset;                      }                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x0f) << 2) | ((buffer[cur + 1] & 0xc0) >> 6)]);                      WriteState.Append(s_base64EncodeMap[(buffer[cur + 1] & 0x3f)]);                      cur += 2;                      count -= 2;                      WriteState.Padding = 0;                      break;                  case 1:                      WriteState.Append(s_base64EncodeMap[WriteState.LastBits | ((buffer[cur] & 0xc0) >> 6)]);                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0x3f)]);                      cur++;                      count--;                      WriteState.Padding = 0;                      break;              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: switch (WriteState.Padding)              {                  case 2:                      WriteState.Append(s_base64EncodeMap[WriteState.LastBits | ((buffer[cur] & 0xf0) >> 4)]);                      if (count == 1)                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x0f) << 2);                          WriteState.Padding = 1;                          return cur - offset;                      }                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x0f) << 2) | ((buffer[cur + 1] & 0xc0) >> 6)]);                      WriteState.Append(s_base64EncodeMap[(buffer[cur + 1] & 0x3f)]);                      cur += 2;                      count -= 2;                      WriteState.Padding = 0;                      break;                  case 1:                      WriteState.Append(s_base64EncodeMap[WriteState.LastBits | ((buffer[cur] & 0xc0) >> 6)]);                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0x3f)]);                      cur++;                      count--;                      WriteState.Padding = 0;                      break;              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: switch (WriteState.Padding)              {                  case 2:                      WriteState.Append(s_base64EncodeMap[WriteState.LastBits | ((buffer[cur] & 0xf0) >> 4)]);                      if (count == 1)                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x0f) << 2);                          WriteState.Padding = 1;                          return cur - offset;                      }                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x0f) << 2) | ((buffer[cur + 1] & 0xc0) >> 6)]);                      WriteState.Append(s_base64EncodeMap[(buffer[cur + 1] & 0x3f)]);                      cur += 2;                      count -= 2;                      WriteState.Padding = 0;                      break;                  case 1:                      WriteState.Append(s_base64EncodeMap[WriteState.LastBits | ((buffer[cur] & 0xc0) >> 6)]);                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0x3f)]);                      cur++;                      count--;                      WriteState.Padding = 0;                      break;              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: switch (WriteState.Padding)              {                  case 2:                      WriteState.Append(s_base64EncodeMap[WriteState.LastBits | ((buffer[cur] & 0xf0) >> 4)]);                      if (count == 1)                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x0f) << 2);                          WriteState.Padding = 1;                          return cur - offset;                      }                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x0f) << 2) | ((buffer[cur + 1] & 0xc0) >> 6)]);                      WriteState.Append(s_base64EncodeMap[(buffer[cur + 1] & 0x3f)]);                      cur += 2;                      count -= 2;                      WriteState.Padding = 0;                      break;                  case 1:                      WriteState.Append(s_base64EncodeMap[WriteState.LastBits | ((buffer[cur] & 0xc0) >> 6)]);                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0x3f)]);                      cur++;                      count--;                      WriteState.Padding = 0;                      break;              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: switch (WriteState.Padding)              {                  case 2:                      WriteState.Append(s_base64EncodeMap[WriteState.LastBits | ((buffer[cur] & 0xf0) >> 4)]);                      if (count == 1)                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x0f) << 2);                          WriteState.Padding = 1;                          return cur - offset;                      }                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x0f) << 2) | ((buffer[cur + 1] & 0xc0) >> 6)]);                      WriteState.Append(s_base64EncodeMap[(buffer[cur + 1] & 0x3f)]);                      cur += 2;                      count -= 2;                      WriteState.Padding = 0;                      break;                  case 1:                      WriteState.Append(s_base64EncodeMap[WriteState.LastBits | ((buffer[cur] & 0xc0) >> 6)]);                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0x3f)]);                      cur++;                      count--;                      WriteState.Padding = 0;                      break;              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: int calcLength = cur + (count - (count % 3));
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: for (; cur < calcLength; cur += 3)              {                  if ((_lineLength != -1) && (WriteState.CurrentLineLength + SizeOfBase64EncodedChar + _writeState.FooterLength > _lineLength))                  {                      WriteState.AppendCRLF(shouldAppendSpaceToCRLF);                  }                    //how we actually encode: get three bytes in the                  //buffer to be encoded.  Then' extract six bits at a time and encode each six bit chunk as a base-64 character.                  //this means that three bytes of data will be encoded as four base64 characters.  It also means that to encode                  //a character' we must have three bytes to encode so if the number of bytes is not divisible by three' we                   //must pad the buffer (this happens below)                  WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xfc) >> 2]);                  WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                  WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2) | ((buffer[cur + 2] & 0xc0) >> 6)]);                  WriteState.Append(s_base64EncodeMap[(buffer[cur + 2] & 0x3f)]);              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: for (; cur < calcLength; cur += 3)              {                  if ((_lineLength != -1) && (WriteState.CurrentLineLength + SizeOfBase64EncodedChar + _writeState.FooterLength > _lineLength))                  {                      WriteState.AppendCRLF(shouldAppendSpaceToCRLF);                  }                    //how we actually encode: get three bytes in the                  //buffer to be encoded.  Then' extract six bits at a time and encode each six bit chunk as a base-64 character.                  //this means that three bytes of data will be encoded as four base64 characters.  It also means that to encode                  //a character' we must have three bytes to encode so if the number of bytes is not divisible by three' we                   //must pad the buffer (this happens below)                  WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xfc) >> 2]);                  WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                  WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2) | ((buffer[cur + 2] & 0xc0) >> 6)]);                  WriteState.Append(s_base64EncodeMap[(buffer[cur + 2] & 0x3f)]);              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: for (; cur < calcLength; cur += 3)              {                  if ((_lineLength != -1) && (WriteState.CurrentLineLength + SizeOfBase64EncodedChar + _writeState.FooterLength > _lineLength))                  {                      WriteState.AppendCRLF(shouldAppendSpaceToCRLF);                  }                    //how we actually encode: get three bytes in the                  //buffer to be encoded.  Then' extract six bits at a time and encode each six bit chunk as a base-64 character.                  //this means that three bytes of data will be encoded as four base64 characters.  It also means that to encode                  //a character' we must have three bytes to encode so if the number of bytes is not divisible by three' we                   //must pad the buffer (this happens below)                  WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xfc) >> 2]);                  WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                  WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2) | ((buffer[cur + 2] & 0xc0) >> 6)]);                  WriteState.Append(s_base64EncodeMap[(buffer[cur + 2] & 0x3f)]);              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: for (; cur < calcLength; cur += 3)              {                  if ((_lineLength != -1) && (WriteState.CurrentLineLength + SizeOfBase64EncodedChar + _writeState.FooterLength > _lineLength))                  {                      WriteState.AppendCRLF(shouldAppendSpaceToCRLF);                  }                    //how we actually encode: get three bytes in the                  //buffer to be encoded.  Then' extract six bits at a time and encode each six bit chunk as a base-64 character.                  //this means that three bytes of data will be encoded as four base64 characters.  It also means that to encode                  //a character' we must have three bytes to encode so if the number of bytes is not divisible by three' we                   //must pad the buffer (this happens below)                  WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xfc) >> 2]);                  WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                  WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2) | ((buffer[cur + 2] & 0xc0) >> 6)]);                  WriteState.Append(s_base64EncodeMap[(buffer[cur + 2] & 0x3f)]);              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: for (; cur < calcLength; cur += 3)              {                  if ((_lineLength != -1) && (WriteState.CurrentLineLength + SizeOfBase64EncodedChar + _writeState.FooterLength > _lineLength))                  {                      WriteState.AppendCRLF(shouldAppendSpaceToCRLF);                  }                    //how we actually encode: get three bytes in the                  //buffer to be encoded.  Then' extract six bits at a time and encode each six bit chunk as a base-64 character.                  //this means that three bytes of data will be encoded as four base64 characters.  It also means that to encode                  //a character' we must have three bytes to encode so if the number of bytes is not divisible by three' we                   //must pad the buffer (this happens below)                  WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xfc) >> 2]);                  WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                  WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2) | ((buffer[cur + 2] & 0xc0) >> 6)]);                  WriteState.Append(s_base64EncodeMap[(buffer[cur + 2] & 0x3f)]);              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: for (; cur < calcLength; cur += 3)              {                  if ((_lineLength != -1) && (WriteState.CurrentLineLength + SizeOfBase64EncodedChar + _writeState.FooterLength > _lineLength))                  {                      WriteState.AppendCRLF(shouldAppendSpaceToCRLF);                  }                    //how we actually encode: get three bytes in the                  //buffer to be encoded.  Then' extract six bits at a time and encode each six bit chunk as a base-64 character.                  //this means that three bytes of data will be encoded as four base64 characters.  It also means that to encode                  //a character' we must have three bytes to encode so if the number of bytes is not divisible by three' we                   //must pad the buffer (this happens below)                  WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xfc) >> 2]);                  WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                  WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2) | ((buffer[cur + 2] & 0xc0) >> 6)]);                  WriteState.Append(s_base64EncodeMap[(buffer[cur + 2] & 0x3f)]);              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: for (; cur < calcLength; cur += 3)              {                  if ((_lineLength != -1) && (WriteState.CurrentLineLength + SizeOfBase64EncodedChar + _writeState.FooterLength > _lineLength))                  {                      WriteState.AppendCRLF(shouldAppendSpaceToCRLF);                  }                    //how we actually encode: get three bytes in the                  //buffer to be encoded.  Then' extract six bits at a time and encode each six bit chunk as a base-64 character.                  //this means that three bytes of data will be encoded as four base64 characters.  It also means that to encode                  //a character' we must have three bytes to encode so if the number of bytes is not divisible by three' we                   //must pad the buffer (this happens below)                  WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xfc) >> 2]);                  WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                  WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2) | ((buffer[cur + 2] & 0xc0) >> 6)]);                  WriteState.Append(s_base64EncodeMap[(buffer[cur + 2] & 0x3f)]);              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: for (; cur < calcLength; cur += 3)              {                  if ((_lineLength != -1) && (WriteState.CurrentLineLength + SizeOfBase64EncodedChar + _writeState.FooterLength > _lineLength))                  {                      WriteState.AppendCRLF(shouldAppendSpaceToCRLF);                  }                    //how we actually encode: get three bytes in the                  //buffer to be encoded.  Then' extract six bits at a time and encode each six bit chunk as a base-64 character.                  //this means that three bytes of data will be encoded as four base64 characters.  It also means that to encode                  //a character' we must have three bytes to encode so if the number of bytes is not divisible by three' we                   //must pad the buffer (this happens below)                  WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xfc) >> 2]);                  WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                  WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2) | ((buffer[cur + 2] & 0xc0) >> 6)]);                  WriteState.Append(s_base64EncodeMap[(buffer[cur + 2] & 0x3f)]);              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: if ((count % 3 != 0) && (_lineLength != -1) && (WriteState.CurrentLineLength + SizeOfBase64EncodedChar + _writeState.FooterLength >= _lineLength))              {                  WriteState.AppendCRLF(shouldAppendSpaceToCRLF);              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: switch (count % 3)              {                  case 2: //One character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur + 1] & 0x0F) << 2);                          WriteState.Padding = 1;                      }                      cur += 2;                      break;                    case 1: // Two character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[(byte)((buffer[cur] & 0x03) << 4)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x03) << 4);                          WriteState.Padding = 2;                      }                      cur++;                      break;              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: switch (count % 3)              {                  case 2: //One character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur + 1] & 0x0F) << 2);                          WriteState.Padding = 1;                      }                      cur += 2;                      break;                    case 1: // Two character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[(byte)((buffer[cur] & 0x03) << 4)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x03) << 4);                          WriteState.Padding = 2;                      }                      cur++;                      break;              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: switch (count % 3)              {                  case 2: //One character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur + 1] & 0x0F) << 2);                          WriteState.Padding = 1;                      }                      cur += 2;                      break;                    case 1: // Two character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[(byte)((buffer[cur] & 0x03) << 4)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x03) << 4);                          WriteState.Padding = 2;                      }                      cur++;                      break;              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: switch (count % 3)              {                  case 2: //One character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur + 1] & 0x0F) << 2);                          WriteState.Padding = 1;                      }                      cur += 2;                      break;                    case 1: // Two character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[(byte)((buffer[cur] & 0x03) << 4)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x03) << 4);                          WriteState.Padding = 2;                      }                      cur++;                      break;              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: switch (count % 3)              {                  case 2: //One character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur + 1] & 0x0F) << 2);                          WriteState.Padding = 1;                      }                      cur += 2;                      break;                    case 1: // Two character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[(byte)((buffer[cur] & 0x03) << 4)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x03) << 4);                          WriteState.Padding = 2;                      }                      cur++;                      break;              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: switch (count % 3)              {                  case 2: //One character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur + 1] & 0x0F) << 2);                          WriteState.Padding = 1;                      }                      cur += 2;                      break;                    case 1: // Two character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[(byte)((buffer[cur] & 0x03) << 4)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x03) << 4);                          WriteState.Padding = 2;                      }                      cur++;                      break;              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: switch (count % 3)              {                  case 2: //One character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur + 1] & 0x0F) << 2);                          WriteState.Padding = 1;                      }                      cur += 2;                      break;                    case 1: // Two character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[(byte)((buffer[cur] & 0x03) << 4)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x03) << 4);                          WriteState.Padding = 2;                      }                      cur++;                      break;              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: switch (count % 3)              {                  case 2: //One character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur + 1] & 0x0F) << 2);                          WriteState.Padding = 1;                      }                      cur += 2;                      break;                    case 1: // Two character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[(byte)((buffer[cur] & 0x03) << 4)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x03) << 4);                          WriteState.Padding = 2;                      }                      cur++;                      break;              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: switch (count % 3)              {                  case 2: //One character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur + 1] & 0x0F) << 2);                          WriteState.Padding = 1;                      }                      cur += 2;                      break;                    case 1: // Two character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[(byte)((buffer[cur] & 0x03) << 4)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x03) << 4);                          WriteState.Padding = 2;                      }                      cur++;                      break;              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: switch (count % 3)              {                  case 2: //One character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur + 1] & 0x0F) << 2);                          WriteState.Padding = 1;                      }                      cur += 2;                      break;                    case 1: // Two character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[(byte)((buffer[cur] & 0x03) << 4)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x03) << 4);                          WriteState.Padding = 2;                      }                      cur++;                      break;              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: switch (count % 3)              {                  case 2: //One character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur + 1] & 0x0F) << 2);                          WriteState.Padding = 1;                      }                      cur += 2;                      break;                    case 1: // Two character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[(byte)((buffer[cur] & 0x03) << 4)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x03) << 4);                          WriteState.Padding = 2;                      }                      cur++;                      break;              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: switch (count % 3)              {                  case 2: //One character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur + 1] & 0x0F) << 2);                          WriteState.Padding = 1;                      }                      cur += 2;                      break;                    case 1: // Two character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[(byte)((buffer[cur] & 0x03) << 4)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x03) << 4);                          WriteState.Padding = 2;                      }                      cur++;                      break;              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: switch (count % 3)              {                  case 2: //One character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur + 1] & 0x0F) << 2);                          WriteState.Padding = 1;                      }                      cur += 2;                      break;                    case 1: // Two character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[(byte)((buffer[cur] & 0x03) << 4)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x03) << 4);                          WriteState.Padding = 2;                      }                      cur++;                      break;              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: switch (count % 3)              {                  case 2: //One character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur + 1] & 0x0F) << 2);                          WriteState.Padding = 1;                      }                      cur += 2;                      break;                    case 1: // Two character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[(byte)((buffer[cur] & 0x03) << 4)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x03) << 4);                          WriteState.Padding = 2;                      }                      cur++;                      break;              }
Magic Number,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following statement contains a magic number: switch (count % 3)              {                  case 2: //One character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur + 1] & 0x0F) << 2);                          WriteState.Padding = 1;                      }                      cur += 2;                      break;                    case 1: // Two character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[(byte)((buffer[cur] & 0x03) << 4)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x03) << 4);                          WriteState.Padding = 2;                      }                      cur++;                      break;              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,Format,The following statement contains a magic number: switch (s.ArgumentCount)              {                  case 0: return s.Format;                  case 1: return string.Format(s.Format' Format(s.GetArgument(0)));                  case 2: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1)));                  case 3: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1))' Format(s.GetArgument(2)));                  default:                      object[] args = s.GetArguments();                      object[] formattedArgs = new object[args.Length];                      for (int i = 0; i < args.Length; i++)                      {                          formattedArgs[i] = Format(args[i]);                      }                      return string.Format(s.Format' formattedArgs);              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,Format,The following statement contains a magic number: switch (s.ArgumentCount)              {                  case 0: return s.Format;                  case 1: return string.Format(s.Format' Format(s.GetArgument(0)));                  case 2: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1)));                  case 3: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1))' Format(s.GetArgument(2)));                  default:                      object[] args = s.GetArguments();                      object[] formattedArgs = new object[args.Length];                      for (int i = 0; i < args.Length; i++)                      {                          formattedArgs[i] = Format(args[i]);                      }                      return string.Format(s.Format' formattedArgs);              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,Format,The following statement contains a magic number: switch (s.ArgumentCount)              {                  case 0: return s.Format;                  case 1: return string.Format(s.Format' Format(s.GetArgument(0)));                  case 2: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1)));                  case 3: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1))' Format(s.GetArgument(2)));                  default:                      object[] args = s.GetArguments();                      object[] formattedArgs = new object[args.Length];                      for (int i = 0; i < args.Length; i++)                      {                          formattedArgs[i] = Format(args[i]);                      }                      return string.Format(s.Format' formattedArgs);              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\NetEventSource.Mail.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\NTAuthentication.Common.cs,GetOutgoingBlob,The following statement contains a magic number: var list = new List<SecurityBuffer>(2);
Magic Number,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          *dest++ = *source++;                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          *dest++ = *source++;                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          *dest++ = *source++;                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          *dest++ = *source++;                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          *dest++ = *source++;                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          *dest++ = *source++;                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          *dest++ = *source++;                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          *dest++ = *source++;                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          *dest++ = *source++;                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          *dest++ = *source++;                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          *dest++ = *source++;                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          *dest++ = *source++;                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          *dest++ = *source++;                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          *dest++ = *source++;                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,EncodeBytes,The following statement contains a magic number: for (; cur < count + offset; cur++)              {                  //only fold if we're before a whitespace or if we're at the line limit                  //add two to the encoded Byte Length to be conservative so that we guarantee that the line length is acceptable                                  if ((_lineLength != -1 && WriteState.CurrentLineLength + SizeOfEncodedChar + 2 >= _lineLength && (buffer[cur] == ' ' ||                      buffer[cur] == '\t' || buffer[cur] == '\r' || buffer[cur] == '\n')) ||                      _writeState.CurrentLineLength + SizeOfEncodedChar + 2 >= EncodedStreamFactory.DefaultMaxLineLength)                  {                      if (WriteState.Buffer.Length - WriteState.Length < SizeOfSoftCRLF)                      {                          return cur - offset;  //ok because folding happens externally                      }                        WriteState.Append((byte)'=');                      WriteState.AppendCRLF(false);                  }                    // We don't need to worry about RFC 2821 4.5.2 (encoding first dot on a line)'                  // it is done by the underlying 7BitStream                    //detect a CRLF in the input and encode it.                  if (buffer[cur] == '\r' && cur + 1 < count + offset && buffer[cur + 1] == '\n')                  {                      if (WriteState.Buffer.Length - WriteState.Length < (_encodeCRLF ? SizeOfEncodedCRLF : SizeOfNonEncodedCRLF))                      {                          return cur - offset;                      }                      cur++;                        if (_encodeCRLF)                      {                          // The encoding for CRLF is =0D=0A                          WriteState.Append((byte)'='' (byte)'0'' (byte)'D'' (byte)'='' (byte)'0'' (byte)'A');                      }                      else                      {                          WriteState.AppendCRLF(false);                      }                  }                  //ascii chars less than 32 (control chars) and greater than 126 (non-ascii) are not allowed so we have to encode                  else if ((buffer[cur] < 32 && buffer[cur] != '\t') ||                      buffer[cur] == '=' ||                      buffer[cur] > 126)                  {                      if (WriteState.Buffer.Length - WriteState.Length < SizeOfSoftCRLF)                      {                          return cur - offset;                      }                        //append an = to indicate an encoded character                      WriteState.Append((byte)'=');                      //shift 4 to get the first four bytes only and look up the hex digit                      WriteState.Append(s_hexEncodeMap[buffer[cur] >> 4]);                      //clear the first four bytes to get the last four and look up the hex digit                      WriteState.Append(s_hexEncodeMap[buffer[cur] & 0xF]);                  }                  else                  {                      if (WriteState.Buffer.Length - WriteState.Length < 1)                      {                          return cur - offset;                      }                        //detect special case:  is whitespace at end of line?  we must encode it if it is                      if ((buffer[cur] == (byte)'\t' || buffer[cur] == (byte)' ') &&                          (cur + 1 >= count + offset))                      {                          if (WriteState.Buffer.Length - WriteState.Length < SizeOfEncodedChar)                          {                              return cur - offset;                          }                            //append an = to indicate an encoded character                          WriteState.Append((byte)'=');                          //shift 4 to get the first four bytes only and look up the hex digit                          WriteState.Append(s_hexEncodeMap[buffer[cur] >> 4]);                          //clear the first four bytes to get the last four and look up the hex digit                          WriteState.Append(s_hexEncodeMap[buffer[cur] & 0xF]);                      }                      else                      {                          WriteState.Append(buffer[cur]);                      }                  }              }
Magic Number,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,EncodeBytes,The following statement contains a magic number: for (; cur < count + offset; cur++)              {                  //only fold if we're before a whitespace or if we're at the line limit                  //add two to the encoded Byte Length to be conservative so that we guarantee that the line length is acceptable                                  if ((_lineLength != -1 && WriteState.CurrentLineLength + SizeOfEncodedChar + 2 >= _lineLength && (buffer[cur] == ' ' ||                      buffer[cur] == '\t' || buffer[cur] == '\r' || buffer[cur] == '\n')) ||                      _writeState.CurrentLineLength + SizeOfEncodedChar + 2 >= EncodedStreamFactory.DefaultMaxLineLength)                  {                      if (WriteState.Buffer.Length - WriteState.Length < SizeOfSoftCRLF)                      {                          return cur - offset;  //ok because folding happens externally                      }                        WriteState.Append((byte)'=');                      WriteState.AppendCRLF(false);                  }                    // We don't need to worry about RFC 2821 4.5.2 (encoding first dot on a line)'                  // it is done by the underlying 7BitStream                    //detect a CRLF in the input and encode it.                  if (buffer[cur] == '\r' && cur + 1 < count + offset && buffer[cur + 1] == '\n')                  {                      if (WriteState.Buffer.Length - WriteState.Length < (_encodeCRLF ? SizeOfEncodedCRLF : SizeOfNonEncodedCRLF))                      {                          return cur - offset;                      }                      cur++;                        if (_encodeCRLF)                      {                          // The encoding for CRLF is =0D=0A                          WriteState.Append((byte)'='' (byte)'0'' (byte)'D'' (byte)'='' (byte)'0'' (byte)'A');                      }                      else                      {                          WriteState.AppendCRLF(false);                      }                  }                  //ascii chars less than 32 (control chars) and greater than 126 (non-ascii) are not allowed so we have to encode                  else if ((buffer[cur] < 32 && buffer[cur] != '\t') ||                      buffer[cur] == '=' ||                      buffer[cur] > 126)                  {                      if (WriteState.Buffer.Length - WriteState.Length < SizeOfSoftCRLF)                      {                          return cur - offset;                      }                        //append an = to indicate an encoded character                      WriteState.Append((byte)'=');                      //shift 4 to get the first four bytes only and look up the hex digit                      WriteState.Append(s_hexEncodeMap[buffer[cur] >> 4]);                      //clear the first four bytes to get the last four and look up the hex digit                      WriteState.Append(s_hexEncodeMap[buffer[cur] & 0xF]);                  }                  else                  {                      if (WriteState.Buffer.Length - WriteState.Length < 1)                      {                          return cur - offset;                      }                        //detect special case:  is whitespace at end of line?  we must encode it if it is                      if ((buffer[cur] == (byte)'\t' || buffer[cur] == (byte)' ') &&                          (cur + 1 >= count + offset))                      {                          if (WriteState.Buffer.Length - WriteState.Length < SizeOfEncodedChar)                          {                              return cur - offset;                          }                            //append an = to indicate an encoded character                          WriteState.Append((byte)'=');                          //shift 4 to get the first four bytes only and look up the hex digit                          WriteState.Append(s_hexEncodeMap[buffer[cur] >> 4]);                          //clear the first four bytes to get the last four and look up the hex digit                          WriteState.Append(s_hexEncodeMap[buffer[cur] & 0xF]);                      }                      else                      {                          WriteState.Append(buffer[cur]);                      }                  }              }
Magic Number,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,EncodeBytes,The following statement contains a magic number: for (; cur < count + offset; cur++)              {                  //only fold if we're before a whitespace or if we're at the line limit                  //add two to the encoded Byte Length to be conservative so that we guarantee that the line length is acceptable                                  if ((_lineLength != -1 && WriteState.CurrentLineLength + SizeOfEncodedChar + 2 >= _lineLength && (buffer[cur] == ' ' ||                      buffer[cur] == '\t' || buffer[cur] == '\r' || buffer[cur] == '\n')) ||                      _writeState.CurrentLineLength + SizeOfEncodedChar + 2 >= EncodedStreamFactory.DefaultMaxLineLength)                  {                      if (WriteState.Buffer.Length - WriteState.Length < SizeOfSoftCRLF)                      {                          return cur - offset;  //ok because folding happens externally                      }                        WriteState.Append((byte)'=');                      WriteState.AppendCRLF(false);                  }                    // We don't need to worry about RFC 2821 4.5.2 (encoding first dot on a line)'                  // it is done by the underlying 7BitStream                    //detect a CRLF in the input and encode it.                  if (buffer[cur] == '\r' && cur + 1 < count + offset && buffer[cur + 1] == '\n')                  {                      if (WriteState.Buffer.Length - WriteState.Length < (_encodeCRLF ? SizeOfEncodedCRLF : SizeOfNonEncodedCRLF))                      {                          return cur - offset;                      }                      cur++;                        if (_encodeCRLF)                      {                          // The encoding for CRLF is =0D=0A                          WriteState.Append((byte)'='' (byte)'0'' (byte)'D'' (byte)'='' (byte)'0'' (byte)'A');                      }                      else                      {                          WriteState.AppendCRLF(false);                      }                  }                  //ascii chars less than 32 (control chars) and greater than 126 (non-ascii) are not allowed so we have to encode                  else if ((buffer[cur] < 32 && buffer[cur] != '\t') ||                      buffer[cur] == '=' ||                      buffer[cur] > 126)                  {                      if (WriteState.Buffer.Length - WriteState.Length < SizeOfSoftCRLF)                      {                          return cur - offset;                      }                        //append an = to indicate an encoded character                      WriteState.Append((byte)'=');                      //shift 4 to get the first four bytes only and look up the hex digit                      WriteState.Append(s_hexEncodeMap[buffer[cur] >> 4]);                      //clear the first four bytes to get the last four and look up the hex digit                      WriteState.Append(s_hexEncodeMap[buffer[cur] & 0xF]);                  }                  else                  {                      if (WriteState.Buffer.Length - WriteState.Length < 1)                      {                          return cur - offset;                      }                        //detect special case:  is whitespace at end of line?  we must encode it if it is                      if ((buffer[cur] == (byte)'\t' || buffer[cur] == (byte)' ') &&                          (cur + 1 >= count + offset))                      {                          if (WriteState.Buffer.Length - WriteState.Length < SizeOfEncodedChar)                          {                              return cur - offset;                          }                            //append an = to indicate an encoded character                          WriteState.Append((byte)'=');                          //shift 4 to get the first four bytes only and look up the hex digit                          WriteState.Append(s_hexEncodeMap[buffer[cur] >> 4]);                          //clear the first four bytes to get the last four and look up the hex digit                          WriteState.Append(s_hexEncodeMap[buffer[cur] & 0xF]);                      }                      else                      {                          WriteState.Append(buffer[cur]);                      }                  }              }
Magic Number,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,EncodeBytes,The following statement contains a magic number: for (; cur < count + offset; cur++)              {                  //only fold if we're before a whitespace or if we're at the line limit                  //add two to the encoded Byte Length to be conservative so that we guarantee that the line length is acceptable                                  if ((_lineLength != -1 && WriteState.CurrentLineLength + SizeOfEncodedChar + 2 >= _lineLength && (buffer[cur] == ' ' ||                      buffer[cur] == '\t' || buffer[cur] == '\r' || buffer[cur] == '\n')) ||                      _writeState.CurrentLineLength + SizeOfEncodedChar + 2 >= EncodedStreamFactory.DefaultMaxLineLength)                  {                      if (WriteState.Buffer.Length - WriteState.Length < SizeOfSoftCRLF)                      {                          return cur - offset;  //ok because folding happens externally                      }                        WriteState.Append((byte)'=');                      WriteState.AppendCRLF(false);                  }                    // We don't need to worry about RFC 2821 4.5.2 (encoding first dot on a line)'                  // it is done by the underlying 7BitStream                    //detect a CRLF in the input and encode it.                  if (buffer[cur] == '\r' && cur + 1 < count + offset && buffer[cur + 1] == '\n')                  {                      if (WriteState.Buffer.Length - WriteState.Length < (_encodeCRLF ? SizeOfEncodedCRLF : SizeOfNonEncodedCRLF))                      {                          return cur - offset;                      }                      cur++;                        if (_encodeCRLF)                      {                          // The encoding for CRLF is =0D=0A                          WriteState.Append((byte)'='' (byte)'0'' (byte)'D'' (byte)'='' (byte)'0'' (byte)'A');                      }                      else                      {                          WriteState.AppendCRLF(false);                      }                  }                  //ascii chars less than 32 (control chars) and greater than 126 (non-ascii) are not allowed so we have to encode                  else if ((buffer[cur] < 32 && buffer[cur] != '\t') ||                      buffer[cur] == '=' ||                      buffer[cur] > 126)                  {                      if (WriteState.Buffer.Length - WriteState.Length < SizeOfSoftCRLF)                      {                          return cur - offset;                      }                        //append an = to indicate an encoded character                      WriteState.Append((byte)'=');                      //shift 4 to get the first four bytes only and look up the hex digit                      WriteState.Append(s_hexEncodeMap[buffer[cur] >> 4]);                      //clear the first four bytes to get the last four and look up the hex digit                      WriteState.Append(s_hexEncodeMap[buffer[cur] & 0xF]);                  }                  else                  {                      if (WriteState.Buffer.Length - WriteState.Length < 1)                      {                          return cur - offset;                      }                        //detect special case:  is whitespace at end of line?  we must encode it if it is                      if ((buffer[cur] == (byte)'\t' || buffer[cur] == (byte)' ') &&                          (cur + 1 >= count + offset))                      {                          if (WriteState.Buffer.Length - WriteState.Length < SizeOfEncodedChar)                          {                              return cur - offset;                          }                            //append an = to indicate an encoded character                          WriteState.Append((byte)'=');                          //shift 4 to get the first four bytes only and look up the hex digit                          WriteState.Append(s_hexEncodeMap[buffer[cur] >> 4]);                          //clear the first four bytes to get the last four and look up the hex digit                          WriteState.Append(s_hexEncodeMap[buffer[cur] & 0xF]);                      }                      else                      {                          WriteState.Append(buffer[cur]);                      }                  }              }
Magic Number,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,EncodeBytes,The following statement contains a magic number: for (; cur < count + offset; cur++)              {                  //only fold if we're before a whitespace or if we're at the line limit                  //add two to the encoded Byte Length to be conservative so that we guarantee that the line length is acceptable                                  if ((_lineLength != -1 && WriteState.CurrentLineLength + SizeOfEncodedChar + 2 >= _lineLength && (buffer[cur] == ' ' ||                      buffer[cur] == '\t' || buffer[cur] == '\r' || buffer[cur] == '\n')) ||                      _writeState.CurrentLineLength + SizeOfEncodedChar + 2 >= EncodedStreamFactory.DefaultMaxLineLength)                  {                      if (WriteState.Buffer.Length - WriteState.Length < SizeOfSoftCRLF)                      {                          return cur - offset;  //ok because folding happens externally                      }                        WriteState.Append((byte)'=');                      WriteState.AppendCRLF(false);                  }                    // We don't need to worry about RFC 2821 4.5.2 (encoding first dot on a line)'                  // it is done by the underlying 7BitStream                    //detect a CRLF in the input and encode it.                  if (buffer[cur] == '\r' && cur + 1 < count + offset && buffer[cur + 1] == '\n')                  {                      if (WriteState.Buffer.Length - WriteState.Length < (_encodeCRLF ? SizeOfEncodedCRLF : SizeOfNonEncodedCRLF))                      {                          return cur - offset;                      }                      cur++;                        if (_encodeCRLF)                      {                          // The encoding for CRLF is =0D=0A                          WriteState.Append((byte)'='' (byte)'0'' (byte)'D'' (byte)'='' (byte)'0'' (byte)'A');                      }                      else                      {                          WriteState.AppendCRLF(false);                      }                  }                  //ascii chars less than 32 (control chars) and greater than 126 (non-ascii) are not allowed so we have to encode                  else if ((buffer[cur] < 32 && buffer[cur] != '\t') ||                      buffer[cur] == '=' ||                      buffer[cur] > 126)                  {                      if (WriteState.Buffer.Length - WriteState.Length < SizeOfSoftCRLF)                      {                          return cur - offset;                      }                        //append an = to indicate an encoded character                      WriteState.Append((byte)'=');                      //shift 4 to get the first four bytes only and look up the hex digit                      WriteState.Append(s_hexEncodeMap[buffer[cur] >> 4]);                      //clear the first four bytes to get the last four and look up the hex digit                      WriteState.Append(s_hexEncodeMap[buffer[cur] & 0xF]);                  }                  else                  {                      if (WriteState.Buffer.Length - WriteState.Length < 1)                      {                          return cur - offset;                      }                        //detect special case:  is whitespace at end of line?  we must encode it if it is                      if ((buffer[cur] == (byte)'\t' || buffer[cur] == (byte)' ') &&                          (cur + 1 >= count + offset))                      {                          if (WriteState.Buffer.Length - WriteState.Length < SizeOfEncodedChar)                          {                              return cur - offset;                          }                            //append an = to indicate an encoded character                          WriteState.Append((byte)'=');                          //shift 4 to get the first four bytes only and look up the hex digit                          WriteState.Append(s_hexEncodeMap[buffer[cur] >> 4]);                          //clear the first four bytes to get the last four and look up the hex digit                          WriteState.Append(s_hexEncodeMap[buffer[cur] & 0xF]);                      }                      else                      {                          WriteState.Append(buffer[cur]);                      }                  }              }
Magic Number,System.Net.Mime,QuotedPrintableStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QuotedPrintableStream.cs,EncodeBytes,The following statement contains a magic number: for (; cur < count + offset; cur++)              {                  //only fold if we're before a whitespace or if we're at the line limit                  //add two to the encoded Byte Length to be conservative so that we guarantee that the line length is acceptable                                  if ((_lineLength != -1 && WriteState.CurrentLineLength + SizeOfEncodedChar + 2 >= _lineLength && (buffer[cur] == ' ' ||                      buffer[cur] == '\t' || buffer[cur] == '\r' || buffer[cur] == '\n')) ||                      _writeState.CurrentLineLength + SizeOfEncodedChar + 2 >= EncodedStreamFactory.DefaultMaxLineLength)                  {                      if (WriteState.Buffer.Length - WriteState.Length < SizeOfSoftCRLF)                      {                          return cur - offset;  //ok because folding happens externally                      }                        WriteState.Append((byte)'=');                      WriteState.AppendCRLF(false);                  }                    // We don't need to worry about RFC 2821 4.5.2 (encoding first dot on a line)'                  // it is done by the underlying 7BitStream                    //detect a CRLF in the input and encode it.                  if (buffer[cur] == '\r' && cur + 1 < count + offset && buffer[cur + 1] == '\n')                  {                      if (WriteState.Buffer.Length - WriteState.Length < (_encodeCRLF ? SizeOfEncodedCRLF : SizeOfNonEncodedCRLF))                      {                          return cur - offset;                      }                      cur++;                        if (_encodeCRLF)                      {                          // The encoding for CRLF is =0D=0A                          WriteState.Append((byte)'='' (byte)'0'' (byte)'D'' (byte)'='' (byte)'0'' (byte)'A');                      }                      else                      {                          WriteState.AppendCRLF(false);                      }                  }                  //ascii chars less than 32 (control chars) and greater than 126 (non-ascii) are not allowed so we have to encode                  else if ((buffer[cur] < 32 && buffer[cur] != '\t') ||                      buffer[cur] == '=' ||                      buffer[cur] > 126)                  {                      if (WriteState.Buffer.Length - WriteState.Length < SizeOfSoftCRLF)                      {                          return cur - offset;                      }                        //append an = to indicate an encoded character                      WriteState.Append((byte)'=');                      //shift 4 to get the first four bytes only and look up the hex digit                      WriteState.Append(s_hexEncodeMap[buffer[cur] >> 4]);                      //clear the first four bytes to get the last four and look up the hex digit                      WriteState.Append(s_hexEncodeMap[buffer[cur] & 0xF]);                  }                  else                  {                      if (WriteState.Buffer.Length - WriteState.Length < 1)                      {                          return cur - offset;                      }                        //detect special case:  is whitespace at end of line?  we must encode it if it is                      if ((buffer[cur] == (byte)'\t' || buffer[cur] == (byte)' ') &&                          (cur + 1 >= count + offset))                      {                          if (WriteState.Buffer.Length - WriteState.Length < SizeOfEncodedChar)                          {                              return cur - offset;                          }                            //append an = to indicate an encoded character                          WriteState.Append((byte)'=');                          //shift 4 to get the first four bytes only and look up the hex digit                          WriteState.Append(s_hexEncodeMap[buffer[cur] >> 4]);                          //clear the first four bytes to get the last four and look up the hex digit                          WriteState.Append(s_hexEncodeMap[buffer[cur] & 0xF]);                      }                      else                      {                          WriteState.Append(buffer[cur]);                      }                  }              }
Magic Number,System.Net.Mime,QEncodedStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QEncodedStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          if (*source == '_')                          {                              *dest++ = (byte)' ';                              source++;                          }                          else                          {                              *dest++ = *source++;                          }                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QEncodedStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QEncodedStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          if (*source == '_')                          {                              *dest++ = (byte)' ';                              source++;                          }                          else                          {                              *dest++ = *source++;                          }                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QEncodedStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QEncodedStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          if (*source == '_')                          {                              *dest++ = (byte)' ';                              source++;                          }                          else                          {                              *dest++ = *source++;                          }                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QEncodedStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QEncodedStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          if (*source == '_')                          {                              *dest++ = (byte)' ';                              source++;                          }                          else                          {                              *dest++ = *source++;                          }                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QEncodedStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QEncodedStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          if (*source == '_')                          {                              *dest++ = (byte)' ';                              source++;                          }                          else                          {                              *dest++ = *source++;                          }                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QEncodedStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QEncodedStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          if (*source == '_')                          {                              *dest++ = (byte)' ';                              source++;                          }                          else                          {                              *dest++ = *source++;                          }                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QEncodedStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QEncodedStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          if (*source == '_')                          {                              *dest++ = (byte)' ';                              source++;                          }                          else                          {                              *dest++ = *source++;                          }                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QEncodedStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QEncodedStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          if (*source == '_')                          {                              *dest++ = (byte)' ';                              source++;                          }                          else                          {                              *dest++ = *source++;                          }                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QEncodedStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QEncodedStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          if (*source == '_')                          {                              *dest++ = (byte)' ';                              source++;                          }                          else                          {                              *dest++ = *source++;                          }                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QEncodedStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QEncodedStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          if (*source == '_')                          {                              *dest++ = (byte)' ';                              source++;                          }                          else                          {                              *dest++ = *source++;                          }                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QEncodedStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QEncodedStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          if (*source == '_')                          {                              *dest++ = (byte)' ';                              source++;                          }                          else                          {                              *dest++ = *source++;                          }                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QEncodedStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QEncodedStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          if (*source == '_')                          {                              *dest++ = (byte)' ';                              source++;                          }                          else                          {                              *dest++ = *source++;                          }                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QEncodedStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QEncodedStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          if (*source == '_')                          {                              *dest++ = (byte)' ';                              source++;                          }                          else                          {                              *dest++ = *source++;                          }                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QEncodedStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QEncodedStream.cs,DecodeBytes,The following statement contains a magic number: fixed (byte* pBuffer = buffer)              {                  byte* start = pBuffer + offset;                  byte* source = start;                  byte* dest = start;                  byte* end = start + count;                    // if the last read ended in a partially decoded                  // sequence' pick up where we left off.                  if (ReadState.IsEscaped)                  {                      // this will be -1 if the previous read ended                      // with an escape character.                      if (ReadState.Byte == -1)                      {                          // if we only read one byte from the underlying                          // stream' we'll need to save the byte and                          // ask for more.                          if (count == 1)                          {                              ReadState.Byte = *source;                              return 0;                          }                            // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (source[0] != '\r' || source[1] != '\n')                          {                              byte b1 = s_hexDecodeMap[source[0]];                              byte b2 = s_hexDecodeMap[source[1]];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                *dest++ = (byte)((b1 << 4) + b2);                          }                            source += 2;                      }                      else                      {                          // '=\r\n' means a soft (aka. invisible) CRLF sequence...                          if (ReadState.Byte != '\r' || *source != '\n')                          {                              byte b1 = s_hexDecodeMap[ReadState.Byte];                              byte b2 = s_hexDecodeMap[*source];                              if (b1 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                              if (b2 == 255)                                  throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                              *dest++ = (byte)((b1 << 4) + b2);                          }                          source++;                      }                      // reset state for next read.                      ReadState.IsEscaped = false;                      ReadState.Byte = -1;                  }                    // Here's where most of the decoding takes place.                  // We'll loop around until we've inspected all the                  // bytes read.                  while (source < end)                  {                      // if the source is not an escape character' then                      // just copy as-is.                      if (*source != '=')                      {                          if (*source == '_')                          {                              *dest++ = (byte)' ';                              source++;                          }                          else                          {                              *dest++ = *source++;                          }                      }                      else                      {                          // determine where we are relative to the end                          // of the data.  If we don't have enough data to                           // decode the escape sequence' save off what we                          // have and continue the decoding in the next                          // read.  Otherwise' decode the data and copy                          // into dest.                          switch (end - source)                          {                              case 2:                                  ReadState.Byte = source[1];                                  goto case 1;                              case 1:                                  ReadState.IsEscaped = true;                                  goto EndWhile;                              default:                                  if (source[1] != '\r' || source[2] != '\n')                                  {                                      byte b1 = s_hexDecodeMap[source[1]];                                      byte b2 = s_hexDecodeMap[source[2]];                                      if (b1 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b1));                                      if (b2 == 255)                                          throw new FormatException(SR.Format(SR.InvalidHexDigit' b2));                                        *dest++ = (byte)((b1 << 4) + b2);                                  }                                  source += 3;                                  break;                          }                      }                  }              EndWhile:                  return (int)(dest - start);              }
Magic Number,System.Net.Mime,QEncodedStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\QEncodedStream.cs,EncodeBytes,The following statement contains a magic number: for (; cur < count + offset; cur++)              {                  if ( // Fold if we're before a whitespace and encoding another character would be too long                      ((WriteState.CurrentLineLength + SizeOfFoldingCRLF + WriteState.FooterLength >= WriteState.MaxLineLength)                          && (buffer[cur] == ' ' || buffer[cur] == '\t' || buffer[cur] == '\r' || buffer[cur] == '\n'))                      // Or just adding the footer would be too long.                      || (WriteState.CurrentLineLength + _writeState.FooterLength >= WriteState.MaxLineLength)                     )                  {                      WriteState.AppendCRLF(true);                  }                    // We don't need to worry about RFC 2821 4.5.2 (encoding first dot on a line)'                  // it is done by the underlying 7BitStream                    //always encode CRLF                  if (buffer[cur] == '\r' && cur + 1 < count + offset && buffer[cur + 1] == '\n')                  {                      cur++;                        //the encoding for CRLF is =0D=0A                      WriteState.Append((byte)'='' (byte)'0'' (byte)'D'' (byte)'='' (byte)'0'' (byte)'A');                  }                  else if (buffer[cur] == ' ')                  {                      //spaces should be escaped as either '_' or '=20' and                      //we have chosen '_' for parity with other email client                      //behavior                      WriteState.Append((byte)'_');                  }                  // RFC 2047 Section 5 part 3 also allows for !*+-/ but these arn't required in headers.                  // Conservatively encode anything but letters or digits.                  else if (IsAsciiLetterOrDigit((char)buffer[cur]))                  {                      // Just a regular printable ascii char.                      WriteState.Append(buffer[cur]);                  }                  else                  {                      //append an = to indicate an encoded character                      WriteState.Append((byte)'=');                      //shift 4 to get the first four bytes only and look up the hex digit                      WriteState.Append(s_hexEncodeMap[buffer[cur] >> 4]);                      //clear the first four bytes to get the last four and look up the hex digit                      WriteState.Append(s_hexEncodeMap[buffer[cur] & 0xF]);                  }              }
Magic Number,System.Net.Mime,WriteStateInfoBase,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\WriteStateInfoBase.cs,EnsureSpaceInBuffer,The following statement contains a magic number: while (_currentBufferUsed + moreBytes >= newsize)              {                  newsize *= 2;              }
Magic Number,System.Net.Mime,BaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\BaseWriter.cs,WriteHeader,The following statement contains a magic number: WriteAndFold(value' name.Length + 2' allowUnicode);
Magic Number,System.Net.Mime,BaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\BaseWriter.cs,WriteAndFold,The following statement contains a magic number: for (int index = 0; index < value.Length; index++)              {                  // When we find a FWS (CRLF) copy it as is.                  if (MailBnfHelper.IsFWSAt(value' index)) // At the first char of "\r\n " or "\r\n\t"                  {                      index += 2; // Skip the FWS                      _bufferBuilder.Append(value' startOfLine' index - startOfLine' allowUnicode);                      // Reset for the next line                      startOfLine = index;                      lastSpace = index;                      charsAlreadyOnLine = 0;                  }                  // When we pass the line length limit' and know where there was a space to fold at' fold there                  else if (((index - startOfLine) > (_lineLength - charsAlreadyOnLine)) && lastSpace != startOfLine)                  {                      _bufferBuilder.Append(value' startOfLine' lastSpace - startOfLine' allowUnicode);                      _bufferBuilder.Append(s_crlf);                      startOfLine = lastSpace;                      charsAlreadyOnLine = 0;                  }                  // Mark a foldable space.  If we go over the line length limit' fold here.                  else if (value[index] == MailBnfHelper.Space || value[index] == MailBnfHelper.Tab)                  {                      lastSpace = index;                  }              }
Magic Number,System.Net.Mime,MimeBasePart,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\MimeBasePart.cs,DecodeHeaderValue,The following statement contains a magic number: foreach (string foldedSubString in substringsToDecode)              {                  //an encoded string has as specific format in that it must start and end with an                  //'=' char and contains five parts' separated by '?' chars.                  //the first and last part are therefore '='' the second part is the byte encoding (B or Q)                  //the third is the unicode encoding type' and the fourth is encoded message itself.  '?' is not valid inside of                  //an encoded string other than as a separator for these five parts.                  //If this check fails' the string is either not encoded or cannot be decoded by this method                  string[] subStrings = foldedSubString.Split(s_questionMarkSplitChars);                  if ((subStrings.Length != 5 || subStrings[0] != "=" || subStrings[4] != "="))                  {                      return value;                  }                    string charSet = subStrings[1];                  bool base64Encoding = (subStrings[2] == "B");                  byte[] buffer = Encoding.ASCII.GetBytes(subStrings[3]);                  int newLength;                    EncodedStreamFactory encoderFactory = new EncodedStreamFactory();                  IEncodableStream s = encoderFactory.GetEncoderForHeader(Encoding.GetEncoding(charSet)' base64Encoding' 0);                    newLength = s.DecodeBytes(buffer' 0' buffer.Length);                    Encoding encoding = Encoding.GetEncoding(charSet);                  newValue += encoding.GetString(buffer' 0' newLength);              }
Magic Number,System.Net.Mime,MimeBasePart,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\MimeBasePart.cs,DecodeHeaderValue,The following statement contains a magic number: foreach (string foldedSubString in substringsToDecode)              {                  //an encoded string has as specific format in that it must start and end with an                  //'=' char and contains five parts' separated by '?' chars.                  //the first and last part are therefore '='' the second part is the byte encoding (B or Q)                  //the third is the unicode encoding type' and the fourth is encoded message itself.  '?' is not valid inside of                  //an encoded string other than as a separator for these five parts.                  //If this check fails' the string is either not encoded or cannot be decoded by this method                  string[] subStrings = foldedSubString.Split(s_questionMarkSplitChars);                  if ((subStrings.Length != 5 || subStrings[0] != "=" || subStrings[4] != "="))                  {                      return value;                  }                    string charSet = subStrings[1];                  bool base64Encoding = (subStrings[2] == "B");                  byte[] buffer = Encoding.ASCII.GetBytes(subStrings[3]);                  int newLength;                    EncodedStreamFactory encoderFactory = new EncodedStreamFactory();                  IEncodableStream s = encoderFactory.GetEncoderForHeader(Encoding.GetEncoding(charSet)' base64Encoding' 0);                    newLength = s.DecodeBytes(buffer' 0' buffer.Length);                    Encoding encoding = Encoding.GetEncoding(charSet);                  newValue += encoding.GetString(buffer' 0' newLength);              }
Magic Number,System.Net.Mime,MimeBasePart,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\MimeBasePart.cs,DecodeHeaderValue,The following statement contains a magic number: foreach (string foldedSubString in substringsToDecode)              {                  //an encoded string has as specific format in that it must start and end with an                  //'=' char and contains five parts' separated by '?' chars.                  //the first and last part are therefore '='' the second part is the byte encoding (B or Q)                  //the third is the unicode encoding type' and the fourth is encoded message itself.  '?' is not valid inside of                  //an encoded string other than as a separator for these five parts.                  //If this check fails' the string is either not encoded or cannot be decoded by this method                  string[] subStrings = foldedSubString.Split(s_questionMarkSplitChars);                  if ((subStrings.Length != 5 || subStrings[0] != "=" || subStrings[4] != "="))                  {                      return value;                  }                    string charSet = subStrings[1];                  bool base64Encoding = (subStrings[2] == "B");                  byte[] buffer = Encoding.ASCII.GetBytes(subStrings[3]);                  int newLength;                    EncodedStreamFactory encoderFactory = new EncodedStreamFactory();                  IEncodableStream s = encoderFactory.GetEncoderForHeader(Encoding.GetEncoding(charSet)' base64Encoding' 0);                    newLength = s.DecodeBytes(buffer' 0' buffer.Length);                    Encoding encoding = Encoding.GetEncoding(charSet);                  newValue += encoding.GetString(buffer' 0' newLength);              }
Magic Number,System.Net.Mime,MimeBasePart,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\MimeBasePart.cs,DecodeHeaderValue,The following statement contains a magic number: foreach (string foldedSubString in substringsToDecode)              {                  //an encoded string has as specific format in that it must start and end with an                  //'=' char and contains five parts' separated by '?' chars.                  //the first and last part are therefore '='' the second part is the byte encoding (B or Q)                  //the third is the unicode encoding type' and the fourth is encoded message itself.  '?' is not valid inside of                  //an encoded string other than as a separator for these five parts.                  //If this check fails' the string is either not encoded or cannot be decoded by this method                  string[] subStrings = foldedSubString.Split(s_questionMarkSplitChars);                  if ((subStrings.Length != 5 || subStrings[0] != "=" || subStrings[4] != "="))                  {                      return value;                  }                    string charSet = subStrings[1];                  bool base64Encoding = (subStrings[2] == "B");                  byte[] buffer = Encoding.ASCII.GetBytes(subStrings[3]);                  int newLength;                    EncodedStreamFactory encoderFactory = new EncodedStreamFactory();                  IEncodableStream s = encoderFactory.GetEncoderForHeader(Encoding.GetEncoding(charSet)' base64Encoding' 0);                    newLength = s.DecodeBytes(buffer' 0' buffer.Length);                    Encoding encoding = Encoding.GetEncoding(charSet);                  newValue += encoding.GetString(buffer' 0' newLength);              }
Magic Number,System.Net.Mime,MimeBasePart,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\MimeBasePart.cs,DecodeEncoding,The following statement contains a magic number: if ((subStrings.Length < 5 || subStrings[0] != "=" || subStrings[4] != "="))              {                  return null;              }
Magic Number,System.Net.Mime,MimeBasePart,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\MimeBasePart.cs,DecodeEncoding,The following statement contains a magic number: if ((subStrings.Length < 5 || subStrings[0] != "=" || subStrings[4] != "="))              {                  return null;              }
Magic Number,System.Net.Mime,SmtpDateTime,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\SmtpDateTime.cs,InitializeShortHandLookups,The following statement contains a magic number: tempTimeZoneOffsetLookup.Add("EDT"' new TimeSpan(-4' 0' 0));
Magic Number,System.Net.Mime,SmtpDateTime,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\SmtpDateTime.cs,InitializeShortHandLookups,The following statement contains a magic number: tempTimeZoneOffsetLookup.Add("EST"' new TimeSpan(-5' 0' 0));
Magic Number,System.Net.Mime,SmtpDateTime,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\SmtpDateTime.cs,InitializeShortHandLookups,The following statement contains a magic number: tempTimeZoneOffsetLookup.Add("CDT"' new TimeSpan(-5' 0' 0));
Magic Number,System.Net.Mime,SmtpDateTime,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\SmtpDateTime.cs,InitializeShortHandLookups,The following statement contains a magic number: tempTimeZoneOffsetLookup.Add("CST"' new TimeSpan(-6' 0' 0));
Magic Number,System.Net.Mime,SmtpDateTime,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\SmtpDateTime.cs,InitializeShortHandLookups,The following statement contains a magic number: tempTimeZoneOffsetLookup.Add("MDT"' new TimeSpan(-6' 0' 0));
Magic Number,System.Net.Mime,SmtpDateTime,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\SmtpDateTime.cs,InitializeShortHandLookups,The following statement contains a magic number: tempTimeZoneOffsetLookup.Add("MST"' new TimeSpan(-7' 0' 0));
Magic Number,System.Net.Mime,SmtpDateTime,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\SmtpDateTime.cs,InitializeShortHandLookups,The following statement contains a magic number: tempTimeZoneOffsetLookup.Add("PDT"' new TimeSpan(-7' 0' 0));
Magic Number,System.Net.Mime,SmtpDateTime,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\SmtpDateTime.cs,InitializeShortHandLookups,The following statement contains a magic number: tempTimeZoneOffsetLookup.Add("PST"' new TimeSpan(-8' 0' 0));
Magic Number,System.Net.Mime,SmtpDateTime,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\SmtpDateTime.cs,ValidateAndGetTimeZoneOffsetValues,The following statement contains a magic number: if (!int.TryParse(offset.Substring(1' 2)' NumberStyles.None' CultureInfo.InvariantCulture' out hours))              {                  throw new FormatException(SR.MailDateInvalidFormat);              }
Magic Number,System.Net.Mime,SmtpDateTime,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\SmtpDateTime.cs,ValidateAndGetTimeZoneOffsetValues,The following statement contains a magic number: if (!int.TryParse(offset.Substring(3' 2)' NumberStyles.None' CultureInfo.InvariantCulture' out minutes))              {                  throw new FormatException(SR.MailDateInvalidFormat);              }
Magic Number,System.Net.Mime,SmtpDateTime,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\SmtpDateTime.cs,ValidateAndGetTimeZoneOffsetValues,The following statement contains a magic number: if (!int.TryParse(offset.Substring(3' 2)' NumberStyles.None' CultureInfo.InvariantCulture' out minutes))              {                  throw new FormatException(SR.MailDateInvalidFormat);              }
Magic Number,System.Net.Mime,SmtpDateTime,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\SmtpDateTime.cs,TimeSpanToOffset,The following statement contains a magic number: if (span.Ticks == 0)              {                  return UtcDefaultTimeZoneOffset;              }              else              {                  // get the total number of hours since TimeSpan.Hours won't go beyond 24                  // ensure that it's a whole number since the fractional part represents minutes                  uint hours = (uint)Math.Abs(Math.Floor(span.TotalHours));                  uint minutes = (uint)Math.Abs(span.Minutes);                    Debug.Assert((hours != 0) || (minutes != 0)' "Input validation ensures hours or minutes isn't zero");                    string output = span.Ticks > 0 ? "+" : "-";                    // hours and minutes must be two digits                  if (hours < 10)                  {                      output += "0";                  }                    output += hours.ToString();                    if (minutes < 10)                  {                      output += "0";                  }                    output += minutes.ToString();                    return output;              }
Magic Number,System.Net.Mime,SmtpDateTime,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\SmtpDateTime.cs,TimeSpanToOffset,The following statement contains a magic number: if (span.Ticks == 0)              {                  return UtcDefaultTimeZoneOffset;              }              else              {                  // get the total number of hours since TimeSpan.Hours won't go beyond 24                  // ensure that it's a whole number since the fractional part represents minutes                  uint hours = (uint)Math.Abs(Math.Floor(span.TotalHours));                  uint minutes = (uint)Math.Abs(span.Minutes);                    Debug.Assert((hours != 0) || (minutes != 0)' "Input validation ensures hours or minutes isn't zero");                    string output = span.Ticks > 0 ? "+" : "-";                    // hours and minutes must be two digits                  if (hours < 10)                  {                      output += "0";                  }                    output += hours.ToString();                    if (minutes < 10)                  {                      output += "0";                  }                    output += minutes.ToString();                    return output;              }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInAtoms,The following statement contains a magic number: var atext = new bool[128];
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInQuotedStrings,The following statement contains a magic number: var qtext = new bool[128];
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInQuotedStrings,The following statement contains a magic number: for (int i = 1; i <= 9; i++) { qtext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInQuotedStrings,The following statement contains a magic number: qtext[11] = true;
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInQuotedStrings,The following statement contains a magic number: qtext[12] = true;
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInQuotedStrings,The following statement contains a magic number: for (int i = 14; i <= 33; i++) { qtext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInQuotedStrings,The following statement contains a magic number: for (int i = 14; i <= 33; i++) { qtext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInQuotedStrings,The following statement contains a magic number: for (int i = 35; i <= 91; i++) { qtext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInQuotedStrings,The following statement contains a magic number: for (int i = 35; i <= 91; i++) { qtext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInQuotedStrings,The following statement contains a magic number: for (int i = 93; i <= 127; i++) { qtext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInQuotedStrings,The following statement contains a magic number: for (int i = 93; i <= 127; i++) { qtext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInDomainLiterals,The following statement contains a magic number: var dtext = new bool[128];
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInDomainLiterals,The following statement contains a magic number: for (int i = 1; i <= 8; i++) { dtext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInDomainLiterals,The following statement contains a magic number: dtext[11] = true;
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInDomainLiterals,The following statement contains a magic number: dtext[12] = true;
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInDomainLiterals,The following statement contains a magic number: for (int i = 14; i <= 31; i++) { dtext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInDomainLiterals,The following statement contains a magic number: for (int i = 14; i <= 31; i++) { dtext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInDomainLiterals,The following statement contains a magic number: for (int i = 33; i <= 90; i++) { dtext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInDomainLiterals,The following statement contains a magic number: for (int i = 33; i <= 90; i++) { dtext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInDomainLiterals,The following statement contains a magic number: for (int i = 94; i <= 127; i++) { dtext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInDomainLiterals,The following statement contains a magic number: for (int i = 94; i <= 127; i++) { dtext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInHeaderNames,The following statement contains a magic number: var ftext = new bool[128];
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInHeaderNames,The following statement contains a magic number: for (int i = 33; i <= 57; i++) { ftext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInHeaderNames,The following statement contains a magic number: for (int i = 33; i <= 57; i++) { ftext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInHeaderNames,The following statement contains a magic number: for (int i = 59; i <= 126; i++) { ftext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInHeaderNames,The following statement contains a magic number: for (int i = 59; i <= 126; i++) { ftext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInTokens,The following statement contains a magic number: var ttext = new bool[128];
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInTokens,The following statement contains a magic number: for (int i = 33; i <= 126; i++) { ttext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInTokens,The following statement contains a magic number: for (int i = 33; i <= 126; i++) { ttext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInComments,The following statement contains a magic number: var ctext = new bool[128];
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInComments,The following statement contains a magic number: for (int i = 1; i <= 8; i++) { ctext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInComments,The following statement contains a magic number: ctext[11] = true;
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInComments,The following statement contains a magic number: ctext[12] = true;
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInComments,The following statement contains a magic number: for (int i = 14; i <= 31; i++) { ctext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInComments,The following statement contains a magic number: for (int i = 14; i <= 31; i++) { ctext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInComments,The following statement contains a magic number: for (int i = 33; i <= 39; i++) { ctext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInComments,The following statement contains a magic number: for (int i = 33; i <= 39; i++) { ctext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInComments,The following statement contains a magic number: for (int i = 42; i <= 91; i++) { ctext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInComments,The following statement contains a magic number: for (int i = 42; i <= 91; i++) { ctext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInComments,The following statement contains a magic number: for (int i = 93; i <= 127; i++) { ctext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,CreateCharactersAllowedInComments,The following statement contains a magic number: for (int i = 93; i <= 127; i++) { ctext[i] = true; }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,SkipCFWS,The following statement contains a magic number: for (; offset < data.Length; offset++)              {                  if (data[offset] > 127)                      throw new FormatException(SR.Format(SR.MailHeaderFieldInvalidCharacter' data[offset]));                  else if (data[offset] == '\\' && comments > 0)                      offset += 2;                  else if (data[offset] == '(')                      comments++;                  else if (data[offset] == ')')                      comments--;                  else if (data[offset] != ' ' && data[offset] != '\t' && comments == 0)                      return true;                    if (comments < 0)                  {                      throw new FormatException(SR.Format(SR.MailHeaderFieldInvalidCharacter' data[offset]));                  }              }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,SkipCFWS,The following statement contains a magic number: for (; offset < data.Length; offset++)              {                  if (data[offset] > 127)                      throw new FormatException(SR.Format(SR.MailHeaderFieldInvalidCharacter' data[offset]));                  else if (data[offset] == '\\' && comments > 0)                      offset += 2;                  else if (data[offset] == '(')                      comments++;                  else if (data[offset] == ')')                      comments--;                  else if (data[offset] != ' ' && data[offset] != '\t' && comments == 0)                      return true;                    if (comments < 0)                  {                      throw new FormatException(SR.Format(SR.MailHeaderFieldInvalidCharacter' data[offset]));                  }              }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,ReadQuotedString,The following statement contains a magic number: for (; offset < data.Length; offset++)              {                  if (data[offset] == '\\')                  {                      localBuilder.Append(data' start' offset - start);                      start = ++offset;                  }                  else if (data[offset] == '"')                  {                      localBuilder.Append(data' start' offset - start);                      offset++;                      return (builder != null ? null : localBuilder.ToString());                  }                  else if (data[offset] == '=' &&                      data.Length > offset + 3 &&                      data[offset + 1] == '\r' &&                      data[offset + 2] == '\n' &&                      (data[offset + 3] == ' ' || data[offset + 3] == '\t'))                  {                      //it's a soft crlf so it's ok                      offset += 3;                  }                  else if (permitUnicodeInDisplayName)                  {                      //if data contains Unicode and Unicode is permitted' then                       //it is valid in a quoted string in a header.                      if (data[offset] <= Ascii7bitMaxValue && !Qtext[data[offset]])                          throw new FormatException(SR.Format(SR.MailHeaderFieldInvalidCharacter' data[offset]));                  }                  //not permitting Unicode' in which case Unicode is a formatting error                  else if (data[offset] > Ascii7bitMaxValue || !Qtext[data[offset]])                  {                      throw new FormatException(SR.Format(SR.MailHeaderFieldInvalidCharacter' data[offset]));                  }              }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,ReadQuotedString,The following statement contains a magic number: for (; offset < data.Length; offset++)              {                  if (data[offset] == '\\')                  {                      localBuilder.Append(data' start' offset - start);                      start = ++offset;                  }                  else if (data[offset] == '"')                  {                      localBuilder.Append(data' start' offset - start);                      offset++;                      return (builder != null ? null : localBuilder.ToString());                  }                  else if (data[offset] == '=' &&                      data.Length > offset + 3 &&                      data[offset + 1] == '\r' &&                      data[offset + 2] == '\n' &&                      (data[offset + 3] == ' ' || data[offset + 3] == '\t'))                  {                      //it's a soft crlf so it's ok                      offset += 3;                  }                  else if (permitUnicodeInDisplayName)                  {                      //if data contains Unicode and Unicode is permitted' then                       //it is valid in a quoted string in a header.                      if (data[offset] <= Ascii7bitMaxValue && !Qtext[data[offset]])                          throw new FormatException(SR.Format(SR.MailHeaderFieldInvalidCharacter' data[offset]));                  }                  //not permitting Unicode' in which case Unicode is a formatting error                  else if (data[offset] > Ascii7bitMaxValue || !Qtext[data[offset]])                  {                      throw new FormatException(SR.Format(SR.MailHeaderFieldInvalidCharacter' data[offset]));                  }              }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,ReadQuotedString,The following statement contains a magic number: for (; offset < data.Length; offset++)              {                  if (data[offset] == '\\')                  {                      localBuilder.Append(data' start' offset - start);                      start = ++offset;                  }                  else if (data[offset] == '"')                  {                      localBuilder.Append(data' start' offset - start);                      offset++;                      return (builder != null ? null : localBuilder.ToString());                  }                  else if (data[offset] == '=' &&                      data.Length > offset + 3 &&                      data[offset + 1] == '\r' &&                      data[offset + 2] == '\n' &&                      (data[offset + 3] == ' ' || data[offset + 3] == '\t'))                  {                      //it's a soft crlf so it's ok                      offset += 3;                  }                  else if (permitUnicodeInDisplayName)                  {                      //if data contains Unicode and Unicode is permitted' then                       //it is valid in a quoted string in a header.                      if (data[offset] <= Ascii7bitMaxValue && !Qtext[data[offset]])                          throw new FormatException(SR.Format(SR.MailHeaderFieldInvalidCharacter' data[offset]));                  }                  //not permitting Unicode' in which case Unicode is a formatting error                  else if (data[offset] > Ascii7bitMaxValue || !Qtext[data[offset]])                  {                      throw new FormatException(SR.Format(SR.MailHeaderFieldInvalidCharacter' data[offset]));                  }              }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,ReadQuotedString,The following statement contains a magic number: for (; offset < data.Length; offset++)              {                  if (data[offset] == '\\')                  {                      localBuilder.Append(data' start' offset - start);                      start = ++offset;                  }                  else if (data[offset] == '"')                  {                      localBuilder.Append(data' start' offset - start);                      offset++;                      return (builder != null ? null : localBuilder.ToString());                  }                  else if (data[offset] == '=' &&                      data.Length > offset + 3 &&                      data[offset + 1] == '\r' &&                      data[offset + 2] == '\n' &&                      (data[offset + 3] == ' ' || data[offset + 3] == '\t'))                  {                      //it's a soft crlf so it's ok                      offset += 3;                  }                  else if (permitUnicodeInDisplayName)                  {                      //if data contains Unicode and Unicode is permitted' then                       //it is valid in a quoted string in a header.                      if (data[offset] <= Ascii7bitMaxValue && !Qtext[data[offset]])                          throw new FormatException(SR.Format(SR.MailHeaderFieldInvalidCharacter' data[offset]));                  }                  //not permitting Unicode' in which case Unicode is a formatting error                  else if (data[offset] > Ascii7bitMaxValue || !Qtext[data[offset]])                  {                      throw new FormatException(SR.Format(SR.MailHeaderFieldInvalidCharacter' data[offset]));                  }              }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,ReadQuotedString,The following statement contains a magic number: for (; offset < data.Length; offset++)              {                  if (data[offset] == '\\')                  {                      localBuilder.Append(data' start' offset - start);                      start = ++offset;                  }                  else if (data[offset] == '"')                  {                      localBuilder.Append(data' start' offset - start);                      offset++;                      return (builder != null ? null : localBuilder.ToString());                  }                  else if (data[offset] == '=' &&                      data.Length > offset + 3 &&                      data[offset + 1] == '\r' &&                      data[offset + 2] == '\n' &&                      (data[offset + 3] == ' ' || data[offset + 3] == '\t'))                  {                      //it's a soft crlf so it's ok                      offset += 3;                  }                  else if (permitUnicodeInDisplayName)                  {                      //if data contains Unicode and Unicode is permitted' then                       //it is valid in a quoted string in a header.                      if (data[offset] <= Ascii7bitMaxValue && !Qtext[data[offset]])                          throw new FormatException(SR.Format(SR.MailHeaderFieldInvalidCharacter' data[offset]));                  }                  //not permitting Unicode' in which case Unicode is a formatting error                  else if (data[offset] > Ascii7bitMaxValue || !Qtext[data[offset]])                  {                      throw new FormatException(SR.Format(SR.MailHeaderFieldInvalidCharacter' data[offset]));                  }              }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,GetDateTimeString,The following statement contains a magic number: if (value.Hour <= 9)              {                  localBuilder.Append('0');              }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,GetDateTimeString,The following statement contains a magic number: if (value.Minute <= 9)              {                  localBuilder.Append('0');              }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,GetDateTimeString,The following statement contains a magic number: if (value.Second <= 9)              {                  localBuilder.Append('0');              }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,GetTokenOrQuotedString,The following statement contains a magic number: for (; offset < data.Length; offset++)              {                  if (CheckForUnicode(data[offset]' allowUnicode))                  {                      continue;                  }                    if (!Ttext[data[offset]] || data[offset] == ' ')                  {                      builder.Append('"');                      for (; offset < data.Length; offset++)                      {                          if (CheckForUnicode(data[offset]' allowUnicode))                          {                              continue;                          }                          else if (IsFWSAt(data' offset)) // Allow FWS == "\r\n "                          {                              // No-op' skip these three chars                              offset += 2;                          }                          else if (!Qtext[data[offset]])                          {                              builder.Append(data' start' offset - start);                              builder.Append('\\');                              start = offset;                          }                      }                      builder.Append(data' start' offset - start);                      builder.Append('"');                      return;                  }              }
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,IsFWSAt,The following statement contains a magic number: return (data[index] == MailBnfHelper.CR                      && index + 2 < data.Length                      && data[index + 1] == MailBnfHelper.LF                      && (data[index + 2] == MailBnfHelper.Space                          || data[index + 2] == MailBnfHelper.Tab));
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,IsFWSAt,The following statement contains a magic number: return (data[index] == MailBnfHelper.CR                      && index + 2 < data.Length                      && data[index + 1] == MailBnfHelper.LF                      && (data[index + 2] == MailBnfHelper.Space                          || data[index + 2] == MailBnfHelper.Tab));
Magic Number,System.Net.Mime,MailBnfHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailBnfHelper.cs,IsFWSAt,The following statement contains a magic number: return (data[index] == MailBnfHelper.CR                      && index + 2 < data.Length                      && data[index + 1] == MailBnfHelper.LF                      && (data[index + 2] == MailBnfHelper.Space                          || data[index + 2] == MailBnfHelper.Tab));
Magic Number,System.Net.Mail,BufferBuilder,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\BufferBuilder.cs,EnsureBuffer,The following statement contains a magic number: if (count > _buffer.Length - _offset)              {                  byte[] newBuffer = new byte[((_buffer.Length * 2) > (_buffer.Length + count)) ? (_buffer.Length * 2) : (_buffer.Length + count)];                  Buffer.BlockCopy(_buffer' 0' newBuffer' 0' _offset);                  _buffer = newBuffer;              }
Magic Number,System.Net.Mail,BufferBuilder,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\BufferBuilder.cs,EnsureBuffer,The following statement contains a magic number: if (count > _buffer.Length - _offset)              {                  byte[] newBuffer = new byte[((_buffer.Length * 2) > (_buffer.Length + count)) ? (_buffer.Length * 2) : (_buffer.Length + count)];                  Buffer.BlockCopy(_buffer' 0' newBuffer' 0' _offset);                  _buffer = newBuffer;              }
Magic Number,System.Net.Mail,MailAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\MailAddress.cs,MailAddress,The following statement contains a magic number: if (!string.IsNullOrEmpty(_displayName))              {                  _displayName = MailAddressParser.NormalizeOrThrow(_displayName);                    if (_displayName.Length >= 2 && _displayName[0] == '\"'                      && _displayName[_displayName.Length - 1] == '\"')                  {                      // Peal bounding quotes' they'll get re-added later.                      _displayName = _displayName.Substring(1' _displayName.Length - 2);                  }              }
Magic Number,System.Net.Mail,MailAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\MailAddress.cs,MailAddress,The following statement contains a magic number: if (!string.IsNullOrEmpty(_displayName))              {                  _displayName = MailAddressParser.NormalizeOrThrow(_displayName);                    if (_displayName.Length >= 2 && _displayName[0] == '\"'                      && _displayName[_displayName.Length - 1] == '\"')                  {                      // Peal bounding quotes' they'll get re-added later.                      _displayName = _displayName.Substring(1' _displayName.Length - 2);                  }              }
Magic Number,System.Net.Mail,DataCommand,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpCommands.cs,CheckResponse,The following statement contains a magic number: switch (statusCode)              {                  case SmtpStatusCode.StartMailInput:                      {                          return;                      }                  case SmtpStatusCode.LocalErrorInProcessing:                  case SmtpStatusCode.TransactionFailed:                  default:                      {                          if ((int)statusCode < 400)                          {                              throw new SmtpException(SR.net_webstatus_ServerProtocolViolation' serverResponse);                          }                            throw new SmtpException(statusCode' serverResponse' true);                      }              }
Magic Number,System.Net.Mail,DataStopCommand,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpCommands.cs,CheckResponse,The following statement contains a magic number: switch (statusCode)              {                  case SmtpStatusCode.Ok:                      {                          return;                      }                  case SmtpStatusCode.ExceededStorageAllocation:                  case SmtpStatusCode.TransactionFailed:                  case SmtpStatusCode.LocalErrorInProcessing:                  case SmtpStatusCode.InsufficientStorage:                  default:                      {                          if ((int)statusCode < 400)                          {                              throw new SmtpException(SR.net_webstatus_ServerProtocolViolation' serverResponse);                          }                            throw new SmtpException(statusCode' serverResponse' true);                      }              }
Magic Number,System.Net.Mail,EHelloCommand,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpCommands.cs,CheckResponse,The following statement contains a magic number: if (lines[0].StatusCode != SmtpStatusCode.Ok)              {                  if ((int)lines[0].StatusCode < 400)                  {                      throw new SmtpException(SR.net_webstatus_ServerProtocolViolation' lines[0].Line);                  }                    throw new SmtpException(lines[0].StatusCode' lines[0].Line' true);              }
Magic Number,System.Net.Mail,HelloCommand,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpCommands.cs,CheckResponse,The following statement contains a magic number: switch (statusCode)              {                  case SmtpStatusCode.Ok:                      {                          return;                      }                  default:                      {                          if ((int)statusCode < 400)                          {                              throw new SmtpException(SR.net_webstatus_ServerProtocolViolation' serverResponse);                          }                            throw new SmtpException(statusCode' serverResponse' true);                      }              }
Magic Number,System.Net.Mail,StartTlsCommand,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpCommands.cs,CheckResponse,The following statement contains a magic number: switch (statusCode)              {                  case SmtpStatusCode.ServiceReady:                      {                          return;                      }                    case SmtpStatusCode.ClientNotPermitted:                  default:                      {                          if ((int)statusCode < 400)                          {                              throw new SmtpException(SR.net_webstatus_ServerProtocolViolation' response);                          }                            throw new SmtpException(statusCode' response' true);                      }              }
Magic Number,System.Net.Mail,MailCommand,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpCommands.cs,CheckResponse,The following statement contains a magic number: switch (statusCode)              {                  case SmtpStatusCode.Ok:                      {                          return;                      }                  case SmtpStatusCode.ExceededStorageAllocation:                  case SmtpStatusCode.LocalErrorInProcessing:                  case SmtpStatusCode.InsufficientStorage:                  default:                      {                          if ((int)statusCode < 400)                          {                              throw new SmtpException(SR.net_webstatus_ServerProtocolViolation' response);                          }                            throw new SmtpException(statusCode' response' true);                      }              }
Magic Number,System.Net.Mail,RecipientCommand,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpCommands.cs,CheckResponse,The following statement contains a magic number: switch (statusCode)              {                  case SmtpStatusCode.Ok:                  case SmtpStatusCode.UserNotLocalWillForward:                      {                          return true;                      }                  case SmtpStatusCode.MailboxUnavailable:                  case SmtpStatusCode.UserNotLocalTryAlternatePath:                  case SmtpStatusCode.ExceededStorageAllocation:                  case SmtpStatusCode.MailboxNameNotAllowed:                  case SmtpStatusCode.MailboxBusy:                  case SmtpStatusCode.InsufficientStorage:                      {                          return false;                      }                  default:                      {                          if ((int)statusCode < 400)                          {                              throw new SmtpException(SR.net_webstatus_ServerProtocolViolation' response);                          }                            throw new SmtpException(statusCode' response' true);                      }              }
Magic Number,System.Net.Mail,SmtpConnection,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,GetConnection,The following statement contains a magic number: if (_credentials != null)              {                  for (int i = 0; i < _authenticationModules.Length; i++)                  {                      //only authenticate if the auth protocol is supported  - chadmu                      if (!AuthSupported(_authenticationModules[i]))                      {                          continue;                      }                        NetworkCredential credential = _credentials.GetCredential(host' port' _authenticationModules[i].AuthenticationType);                      if (credential == null)                          continue;                        Authorization auth = SetContextAndTryAuthenticate(_authenticationModules[i]' credential' null);                        if (auth != null && auth.Message != null)                      {                          info = AuthCommand.Send(this' _authenticationModules[i].AuthenticationType' auth.Message);                            if (info.StatusCode == SmtpStatusCode.CommandParameterNotImplemented)                          {                              continue;                          }                            while ((int)info.StatusCode == 334)                          {                              auth = _authenticationModules[i].Authenticate(info.Line' null' this' _client.TargetName' _channelBindingToken);                              if (auth == null)                              {                                  throw new SmtpException(SR.SmtpAuthenticationFailed);                              }                              info = AuthCommand.Send(this' auth.Message);                                if ((int)info.StatusCode == 235)                              {                                  _authenticationModules[i].CloseContext(this);                                  _isConnected = true;                                  return;                              }                          }                      }                  }              }
Magic Number,System.Net.Mail,SmtpConnection,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,GetConnection,The following statement contains a magic number: if (_credentials != null)              {                  for (int i = 0; i < _authenticationModules.Length; i++)                  {                      //only authenticate if the auth protocol is supported  - chadmu                      if (!AuthSupported(_authenticationModules[i]))                      {                          continue;                      }                        NetworkCredential credential = _credentials.GetCredential(host' port' _authenticationModules[i].AuthenticationType);                      if (credential == null)                          continue;                        Authorization auth = SetContextAndTryAuthenticate(_authenticationModules[i]' credential' null);                        if (auth != null && auth.Message != null)                      {                          info = AuthCommand.Send(this' _authenticationModules[i].AuthenticationType' auth.Message);                            if (info.StatusCode == SmtpStatusCode.CommandParameterNotImplemented)                          {                              continue;                          }                            while ((int)info.StatusCode == 334)                          {                              auth = _authenticationModules[i].Authenticate(info.Line' null' this' _client.TargetName' _channelBindingToken);                              if (auth == null)                              {                                  throw new SmtpException(SR.SmtpAuthenticationFailed);                              }                              info = AuthCommand.Send(this' auth.Message);                                if ((int)info.StatusCode == 235)                              {                                  _authenticationModules[i].CloseContext(this);                                  _isConnected = true;                                  return;                              }                          }                      }                  }              }
Magic Number,System.Net.Mail,SmtpConnection,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,ParseExtensions,The following statement contains a magic number: foreach (string extension in extensions)              {                  if (string.Compare(extension' 0' AuthExtension' 0'                      SizeOfAuthExtension' StringComparison.OrdinalIgnoreCase) == 0)                  {                      // remove the AUTH text including the following character                       // to ensure that split only gets the modules supported                      string[] authTypes = extension.Remove(0' SizeOfAuthExtension).Split(s_authExtensionSplitters' StringSplitOptions.RemoveEmptyEntries);                      foreach (string authType in authTypes)                      {                          if (string.Equals(authType' AuthLogin' StringComparison.OrdinalIgnoreCase))                          {                              _supportedAuth |= SupportedAuth.Login;                          }                          else if (string.Equals(authType' AuthNtlm' StringComparison.OrdinalIgnoreCase))                          {                              _supportedAuth |= SupportedAuth.NTLM;                          }                          else if (string.Equals(authType' AuthGssapi' StringComparison.OrdinalIgnoreCase))                          {                              _supportedAuth |= SupportedAuth.GSSAPI;                          }                      }                  }                  else if (string.Compare(extension' 0' "dsn "' 0' 3' StringComparison.OrdinalIgnoreCase) == 0)                  {                      _dsnEnabled = true;                  }                  else if (string.Compare(extension' 0' "STARTTLS"' 0' 8' StringComparison.OrdinalIgnoreCase) == 0)                  {                      _serverSupportsStartTls = true;                  }                  else if (string.Compare(extension' 0' "SMTPUTF8"' 0' 8' StringComparison.OrdinalIgnoreCase) == 0)                  {                      _serverSupportsEai = true;                  }              }
Magic Number,System.Net.Mail,SmtpConnection,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,ParseExtensions,The following statement contains a magic number: foreach (string extension in extensions)              {                  if (string.Compare(extension' 0' AuthExtension' 0'                      SizeOfAuthExtension' StringComparison.OrdinalIgnoreCase) == 0)                  {                      // remove the AUTH text including the following character                       // to ensure that split only gets the modules supported                      string[] authTypes = extension.Remove(0' SizeOfAuthExtension).Split(s_authExtensionSplitters' StringSplitOptions.RemoveEmptyEntries);                      foreach (string authType in authTypes)                      {                          if (string.Equals(authType' AuthLogin' StringComparison.OrdinalIgnoreCase))                          {                              _supportedAuth |= SupportedAuth.Login;                          }                          else if (string.Equals(authType' AuthNtlm' StringComparison.OrdinalIgnoreCase))                          {                              _supportedAuth |= SupportedAuth.NTLM;                          }                          else if (string.Equals(authType' AuthGssapi' StringComparison.OrdinalIgnoreCase))                          {                              _supportedAuth |= SupportedAuth.GSSAPI;                          }                      }                  }                  else if (string.Compare(extension' 0' "dsn "' 0' 3' StringComparison.OrdinalIgnoreCase) == 0)                  {                      _dsnEnabled = true;                  }                  else if (string.Compare(extension' 0' "STARTTLS"' 0' 8' StringComparison.OrdinalIgnoreCase) == 0)                  {                      _serverSupportsStartTls = true;                  }                  else if (string.Compare(extension' 0' "SMTPUTF8"' 0' 8' StringComparison.OrdinalIgnoreCase) == 0)                  {                      _serverSupportsEai = true;                  }              }
Magic Number,System.Net.Mail,SmtpConnection,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,ParseExtensions,The following statement contains a magic number: foreach (string extension in extensions)              {                  if (string.Compare(extension' 0' AuthExtension' 0'                      SizeOfAuthExtension' StringComparison.OrdinalIgnoreCase) == 0)                  {                      // remove the AUTH text including the following character                       // to ensure that split only gets the modules supported                      string[] authTypes = extension.Remove(0' SizeOfAuthExtension).Split(s_authExtensionSplitters' StringSplitOptions.RemoveEmptyEntries);                      foreach (string authType in authTypes)                      {                          if (string.Equals(authType' AuthLogin' StringComparison.OrdinalIgnoreCase))                          {                              _supportedAuth |= SupportedAuth.Login;                          }                          else if (string.Equals(authType' AuthNtlm' StringComparison.OrdinalIgnoreCase))                          {                              _supportedAuth |= SupportedAuth.NTLM;                          }                          else if (string.Equals(authType' AuthGssapi' StringComparison.OrdinalIgnoreCase))                          {                              _supportedAuth |= SupportedAuth.GSSAPI;                          }                      }                  }                  else if (string.Compare(extension' 0' "dsn "' 0' 3' StringComparison.OrdinalIgnoreCase) == 0)                  {                      _dsnEnabled = true;                  }                  else if (string.Compare(extension' 0' "STARTTLS"' 0' 8' StringComparison.OrdinalIgnoreCase) == 0)                  {                      _serverSupportsStartTls = true;                  }                  else if (string.Compare(extension' 0' "SMTPUTF8"' 0' 8' StringComparison.OrdinalIgnoreCase) == 0)                  {                      _serverSupportsEai = true;                  }              }
Magic Number,System.Net.Mail,ConnectAndHandshakeAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,Authenticate,The following statement contains a magic number: if (_connection._credentials != null)                  {                      while (++_currentModule < _connection._authenticationModules.Length)                      {                          //only authenticate if the auth protocol is supported                          ISmtpAuthenticationModule module = _connection._authenticationModules[_currentModule];                          if (!_connection.AuthSupported(module))                          {                              continue;                          }                            NetworkCredential credential = _connection._credentials.GetCredential(_host' _port' module.AuthenticationType);                          if (credential == null)                              continue;                          Authorization auth = _connection.SetContextAndTryAuthenticate(module' credential' _outerResult);                            if (auth != null && auth.Message != null)                          {                              IAsyncResult result = AuthCommand.BeginSend(_connection' _connection._authenticationModules[_currentModule].AuthenticationType' auth.Message' s_authenticateCallback' this);                              if (!result.CompletedSynchronously)                              {                                  return;                              }                                LineInfo info = AuthCommand.EndSend(result);                                if ((int)info.StatusCode == 334)                              {                                  _authResponse = info.Line;                                  if (!AuthenticateContinue())                                  {                                      return;                                  }                              }                              else if ((int)info.StatusCode == 235)                              {                                  module.CloseContext(_connection);                                  _connection._isConnected = true;                                  break;                              }                          }                      }                  }
Magic Number,System.Net.Mail,ConnectAndHandshakeAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,Authenticate,The following statement contains a magic number: if (_connection._credentials != null)                  {                      while (++_currentModule < _connection._authenticationModules.Length)                      {                          //only authenticate if the auth protocol is supported                          ISmtpAuthenticationModule module = _connection._authenticationModules[_currentModule];                          if (!_connection.AuthSupported(module))                          {                              continue;                          }                            NetworkCredential credential = _connection._credentials.GetCredential(_host' _port' module.AuthenticationType);                          if (credential == null)                              continue;                          Authorization auth = _connection.SetContextAndTryAuthenticate(module' credential' _outerResult);                            if (auth != null && auth.Message != null)                          {                              IAsyncResult result = AuthCommand.BeginSend(_connection' _connection._authenticationModules[_currentModule].AuthenticationType' auth.Message' s_authenticateCallback' this);                              if (!result.CompletedSynchronously)                              {                                  return;                              }                                LineInfo info = AuthCommand.EndSend(result);                                if ((int)info.StatusCode == 334)                              {                                  _authResponse = info.Line;                                  if (!AuthenticateContinue())                                  {                                      return;                                  }                              }                              else if ((int)info.StatusCode == 235)                              {                                  module.CloseContext(_connection);                                  _connection._isConnected = true;                                  break;                              }                          }                      }                  }
Magic Number,System.Net.Mail,ConnectAndHandshakeAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,AuthenticateCallback,The following statement contains a magic number: if (!result.CompletedSynchronously)                  {                      ConnectAndHandshakeAsyncResult thisPtr = (ConnectAndHandshakeAsyncResult)result.AsyncState;                      try                      {                          LineInfo info = AuthCommand.EndSend(result);                            if ((int)info.StatusCode == 334)                          {                              thisPtr._authResponse = info.Line;                              if (!thisPtr.AuthenticateContinue())                              {                                  return;                              }                          }                          else if ((int)info.StatusCode == 235)                          {                              thisPtr._connection._authenticationModules[thisPtr._currentModule].CloseContext(thisPtr._connection);                              thisPtr._connection._isConnected = true;                              thisPtr.InvokeCallback();                              return;                          }                            thisPtr.Authenticate();                      }                      catch (Exception e)                      {                          thisPtr.InvokeCallback(e);                      }                  }
Magic Number,System.Net.Mail,ConnectAndHandshakeAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,AuthenticateCallback,The following statement contains a magic number: if (!result.CompletedSynchronously)                  {                      ConnectAndHandshakeAsyncResult thisPtr = (ConnectAndHandshakeAsyncResult)result.AsyncState;                      try                      {                          LineInfo info = AuthCommand.EndSend(result);                            if ((int)info.StatusCode == 334)                          {                              thisPtr._authResponse = info.Line;                              if (!thisPtr.AuthenticateContinue())                              {                                  return;                              }                          }                          else if ((int)info.StatusCode == 235)                          {                              thisPtr._connection._authenticationModules[thisPtr._currentModule].CloseContext(thisPtr._connection);                              thisPtr._connection._isConnected = true;                              thisPtr.InvokeCallback();                              return;                          }                            thisPtr.Authenticate();                      }                      catch (Exception e)                      {                          thisPtr.InvokeCallback(e);                      }                  }
Magic Number,System.Net.Mail,ConnectAndHandshakeAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,AuthenticateContinue,The following statement contains a magic number: for (;;)                  {                      // We don't need credential on the continued auth assuming they were captured on the first call.                      // That should always work' otherwise what if a new credential has been returned?                      Authorization auth = _connection._authenticationModules[_currentModule].Authenticate(_authResponse' null' _connection' _connection._client.TargetName' _connection._channelBindingToken);                      if (auth == null)                      {                          throw new SmtpException(SR.Format(SR.SmtpAuthenticationFailed));                      }                        IAsyncResult result = AuthCommand.BeginSend(_connection' auth.Message' s_authenticateContinueCallback' this);                      if (!result.CompletedSynchronously)                      {                          return false;                      }                        LineInfo info = AuthCommand.EndSend(result);                      if ((int)info.StatusCode == 235)                      {                          _connection._authenticationModules[_currentModule].CloseContext(_connection);                          _connection._isConnected = true;                          InvokeCallback();                          return false;                      }                      else if ((int)info.StatusCode != 334)                      {                          return true;                      }                      _authResponse = info.Line;                  }
Magic Number,System.Net.Mail,ConnectAndHandshakeAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,AuthenticateContinue,The following statement contains a magic number: for (;;)                  {                      // We don't need credential on the continued auth assuming they were captured on the first call.                      // That should always work' otherwise what if a new credential has been returned?                      Authorization auth = _connection._authenticationModules[_currentModule].Authenticate(_authResponse' null' _connection' _connection._client.TargetName' _connection._channelBindingToken);                      if (auth == null)                      {                          throw new SmtpException(SR.Format(SR.SmtpAuthenticationFailed));                      }                        IAsyncResult result = AuthCommand.BeginSend(_connection' auth.Message' s_authenticateContinueCallback' this);                      if (!result.CompletedSynchronously)                      {                          return false;                      }                        LineInfo info = AuthCommand.EndSend(result);                      if ((int)info.StatusCode == 235)                      {                          _connection._authenticationModules[_currentModule].CloseContext(_connection);                          _connection._isConnected = true;                          InvokeCallback();                          return false;                      }                      else if ((int)info.StatusCode != 334)                      {                          return true;                      }                      _authResponse = info.Line;                  }
Magic Number,System.Net.Mail,ConnectAndHandshakeAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,AuthenticateContinueCallback,The following statement contains a magic number: if (!result.CompletedSynchronously)                  {                      ConnectAndHandshakeAsyncResult thisPtr = (ConnectAndHandshakeAsyncResult)result.AsyncState;                      try                      {                          LineInfo info = AuthCommand.EndSend(result);                          if ((int)info.StatusCode == 235)                          {                              thisPtr._connection._authenticationModules[thisPtr._currentModule].CloseContext(thisPtr._connection);                              thisPtr._connection._isConnected = true;                              thisPtr.InvokeCallback();                              return;                          }                          else if ((int)info.StatusCode == 334)                          {                              thisPtr._authResponse = info.Line;                              if (!thisPtr.AuthenticateContinue())                              {                                  return;                              }                          }                          thisPtr.Authenticate();                      }                      catch (Exception e)                      {                          thisPtr.InvokeCallback(e);                      }                  }
Magic Number,System.Net.Mail,ConnectAndHandshakeAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpConnection.cs,AuthenticateContinueCallback,The following statement contains a magic number: if (!result.CompletedSynchronously)                  {                      ConnectAndHandshakeAsyncResult thisPtr = (ConnectAndHandshakeAsyncResult)result.AsyncState;                      try                      {                          LineInfo info = AuthCommand.EndSend(result);                          if ((int)info.StatusCode == 235)                          {                              thisPtr._connection._authenticationModules[thisPtr._currentModule].CloseContext(thisPtr._connection);                              thisPtr._connection._isConnected = true;                              thisPtr.InvokeCallback();                              return;                          }                          else if ((int)info.StatusCode == 334)                          {                              thisPtr._authResponse = info.Line;                              if (!thisPtr.AuthenticateContinue())                              {                                  return;                              }                          }                          thisPtr.Authenticate();                      }                      catch (Exception e)                      {                          thisPtr.InvokeCallback(e);                      }                  }
Magic Number,System.Net.Mail,SmtpReplyReaderFactory,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpReplyReaderFactory.cs,ProcessRead,The following statement contains a magic number: unsafe              {                  fixed (byte* pBuffer = buffer)                  {                      byte* start = pBuffer + offset;                      byte* ptr = start;                      byte* end = ptr + read;                        switch (_readState)                      {                          case ReadState.Status0:                              {                                  if (ptr < end)                                  {                                      byte b = *ptr++;                                      if (b < '0' && b > '9')                                      {                                          throw new FormatException(SR.SmtpInvalidResponse);                                      }                                        _statusCode = (SmtpStatusCode)(100 * (b - '0'));                                        goto case ReadState.Status1;                                  }                                  _readState = ReadState.Status0;                                  break;                              }                          case ReadState.Status1:                              {                                  if (ptr < end)                                  {                                      byte b = *ptr++;                                      if (b < '0' && b > '9')                                      {                                          throw new FormatException(SR.SmtpInvalidResponse);                                      }                                        _statusCode += 10 * (b - '0');                                        goto case ReadState.Status2;                                  }                                  _readState = ReadState.Status1;                                  break;                              }                          case ReadState.Status2:                              {                                  if (ptr < end)                                  {                                      byte b = *ptr++;                                      if (b < '0' && b > '9')                                      {                                          throw new FormatException(SR.SmtpInvalidResponse);                                      }                                        _statusCode += b - '0';                                        goto case ReadState.ContinueFlag;                                  }                                  _readState = ReadState.Status2;                                  break;                              }                          case ReadState.ContinueFlag:                              {                                  if (ptr < end)                                  {                                      byte b = *ptr++;                                      if (b == ' ')       // last line                                      {                                          goto case ReadState.LastCR;                                      }                                      else if (b == '-')  // more lines coming                                      {                                          goto case ReadState.ContinueCR;                                      }                                      else                // error                                      {                                          throw new FormatException(SR.SmtpInvalidResponse);                                      }                                  }                                  _readState = ReadState.ContinueFlag;                                  break;                              }                          case ReadState.ContinueCR:                              {                                  while (ptr < end)                                  {                                      if (*ptr++ == '\r')                                      {                                          goto case ReadState.ContinueLF;                                      }                                  }                                  _readState = ReadState.ContinueCR;                                  break;                              }                          case ReadState.ContinueLF:                              {                                  if (ptr < end)                                  {                                      if (*ptr++ != '\n')                                      {                                          throw new FormatException(SR.SmtpInvalidResponse);                                      }                                      if (readLine)                                      {                                          _readState = ReadState.Status0;                                          return (int)(ptr - start);                                      }                                      goto case ReadState.Status0;                                  }                                  _readState = ReadState.ContinueLF;                                  break;                              }                          case ReadState.LastCR:                              {                                  while (ptr < end)                                  {                                      if (*ptr++ == '\r')                                      {                                          goto case ReadState.LastLF;                                      }                                  }                                  _readState = ReadState.LastCR;                                  break;                              }                          case ReadState.LastLF:                              {                                  if (ptr < end)                                  {                                      if (*ptr++ != '\n')                                      {                                          throw new FormatException(SR.SmtpInvalidResponse);                                      }                                      goto case ReadState.Done;                                  }                                  _readState = ReadState.LastLF;                                  break;                              }                          case ReadState.Done:                              {                                  int actual = (int)(ptr - start);                                  _readState = ReadState.Done;                                  return actual;                              }                      }                      return (int)(ptr - start);                  }              }
Magic Number,System.Net.Mail,SmtpReplyReaderFactory,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpReplyReaderFactory.cs,ProcessRead,The following statement contains a magic number: unsafe              {                  fixed (byte* pBuffer = buffer)                  {                      byte* start = pBuffer + offset;                      byte* ptr = start;                      byte* end = ptr + read;                        switch (_readState)                      {                          case ReadState.Status0:                              {                                  if (ptr < end)                                  {                                      byte b = *ptr++;                                      if (b < '0' && b > '9')                                      {                                          throw new FormatException(SR.SmtpInvalidResponse);                                      }                                        _statusCode = (SmtpStatusCode)(100 * (b - '0'));                                        goto case ReadState.Status1;                                  }                                  _readState = ReadState.Status0;                                  break;                              }                          case ReadState.Status1:                              {                                  if (ptr < end)                                  {                                      byte b = *ptr++;                                      if (b < '0' && b > '9')                                      {                                          throw new FormatException(SR.SmtpInvalidResponse);                                      }                                        _statusCode += 10 * (b - '0');                                        goto case ReadState.Status2;                                  }                                  _readState = ReadState.Status1;                                  break;                              }                          case ReadState.Status2:                              {                                  if (ptr < end)                                  {                                      byte b = *ptr++;                                      if (b < '0' && b > '9')                                      {                                          throw new FormatException(SR.SmtpInvalidResponse);                                      }                                        _statusCode += b - '0';                                        goto case ReadState.ContinueFlag;                                  }                                  _readState = ReadState.Status2;                                  break;                              }                          case ReadState.ContinueFlag:                              {                                  if (ptr < end)                                  {                                      byte b = *ptr++;                                      if (b == ' ')       // last line                                      {                                          goto case ReadState.LastCR;                                      }                                      else if (b == '-')  // more lines coming                                      {                                          goto case ReadState.ContinueCR;                                      }                                      else                // error                                      {                                          throw new FormatException(SR.SmtpInvalidResponse);                                      }                                  }                                  _readState = ReadState.ContinueFlag;                                  break;                              }                          case ReadState.ContinueCR:                              {                                  while (ptr < end)                                  {                                      if (*ptr++ == '\r')                                      {                                          goto case ReadState.ContinueLF;                                      }                                  }                                  _readState = ReadState.ContinueCR;                                  break;                              }                          case ReadState.ContinueLF:                              {                                  if (ptr < end)                                  {                                      if (*ptr++ != '\n')                                      {                                          throw new FormatException(SR.SmtpInvalidResponse);                                      }                                      if (readLine)                                      {                                          _readState = ReadState.Status0;                                          return (int)(ptr - start);                                      }                                      goto case ReadState.Status0;                                  }                                  _readState = ReadState.ContinueLF;                                  break;                              }                          case ReadState.LastCR:                              {                                  while (ptr < end)                                  {                                      if (*ptr++ == '\r')                                      {                                          goto case ReadState.LastLF;                                      }                                  }                                  _readState = ReadState.LastCR;                                  break;                              }                          case ReadState.LastLF:                              {                                  if (ptr < end)                                  {                                      if (*ptr++ != '\n')                                      {                                          throw new FormatException(SR.SmtpInvalidResponse);                                      }                                      goto case ReadState.Done;                                  }                                  _readState = ReadState.LastLF;                                  break;                              }                          case ReadState.Done:                              {                                  int actual = (int)(ptr - start);                                  _readState = ReadState.Done;                                  return actual;                              }                      }                      return (int)(ptr - start);                  }              }
Magic Number,System.Net.Mail,SmtpReplyReaderFactory,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpReplyReaderFactory.cs,ReadLines,The following statement contains a magic number: for (int start = 0' read = 0; ;)              {                  if (start == read)                  {                      read = _bufferedStream.Read(_byteBuffer' 0' _byteBuffer.Length);                      start = 0;                  }                    int actual = ProcessRead(_byteBuffer' start' read - start' true);                    if (statusRead < 4)                  {                      int left = Math.Min(4 - statusRead' actual);                      statusRead += left;                      start += left;                      actual -= left;                      if (actual == 0)                      {                          continue;                      }                  }                    builder.Append(Encoding.UTF8.GetString(_byteBuffer' start' actual));                  start += actual;                    if (_readState == ReadState.Status0)                  {                      statusRead = 0;                      lines.Add(new LineInfo(_statusCode' builder.ToString(0' builder.Length - 2))); // return everything except CRLF                        if (oneLine)                      {                          _bufferedStream.Push(_byteBuffer' start' read - start);                          return (LineInfo[])lines.ToArray(typeof(LineInfo));                      }                      builder = new StringBuilder();                  }                  else if (_readState == ReadState.Done)                  {                      lines.Add(new LineInfo(_statusCode' builder.ToString(0' builder.Length - 2))); // return everything except CRLF                      _bufferedStream.Push(_byteBuffer' start' read - start);                      return (LineInfo[])lines.ToArray(typeof(LineInfo));                  }              }
Magic Number,System.Net.Mail,SmtpReplyReaderFactory,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpReplyReaderFactory.cs,ReadLines,The following statement contains a magic number: for (int start = 0' read = 0; ;)              {                  if (start == read)                  {                      read = _bufferedStream.Read(_byteBuffer' 0' _byteBuffer.Length);                      start = 0;                  }                    int actual = ProcessRead(_byteBuffer' start' read - start' true);                    if (statusRead < 4)                  {                      int left = Math.Min(4 - statusRead' actual);                      statusRead += left;                      start += left;                      actual -= left;                      if (actual == 0)                      {                          continue;                      }                  }                    builder.Append(Encoding.UTF8.GetString(_byteBuffer' start' actual));                  start += actual;                    if (_readState == ReadState.Status0)                  {                      statusRead = 0;                      lines.Add(new LineInfo(_statusCode' builder.ToString(0' builder.Length - 2))); // return everything except CRLF                        if (oneLine)                      {                          _bufferedStream.Push(_byteBuffer' start' read - start);                          return (LineInfo[])lines.ToArray(typeof(LineInfo));                      }                      builder = new StringBuilder();                  }                  else if (_readState == ReadState.Done)                  {                      lines.Add(new LineInfo(_statusCode' builder.ToString(0' builder.Length - 2))); // return everything except CRLF                      _bufferedStream.Push(_byteBuffer' start' read - start);                      return (LineInfo[])lines.ToArray(typeof(LineInfo));                  }              }
Magic Number,System.Net.Mail,SmtpReplyReaderFactory,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpReplyReaderFactory.cs,ReadLines,The following statement contains a magic number: for (int start = 0' read = 0; ;)              {                  if (start == read)                  {                      read = _bufferedStream.Read(_byteBuffer' 0' _byteBuffer.Length);                      start = 0;                  }                    int actual = ProcessRead(_byteBuffer' start' read - start' true);                    if (statusRead < 4)                  {                      int left = Math.Min(4 - statusRead' actual);                      statusRead += left;                      start += left;                      actual -= left;                      if (actual == 0)                      {                          continue;                      }                  }                    builder.Append(Encoding.UTF8.GetString(_byteBuffer' start' actual));                  start += actual;                    if (_readState == ReadState.Status0)                  {                      statusRead = 0;                      lines.Add(new LineInfo(_statusCode' builder.ToString(0' builder.Length - 2))); // return everything except CRLF                        if (oneLine)                      {                          _bufferedStream.Push(_byteBuffer' start' read - start);                          return (LineInfo[])lines.ToArray(typeof(LineInfo));                      }                      builder = new StringBuilder();                  }                  else if (_readState == ReadState.Done)                  {                      lines.Add(new LineInfo(_statusCode' builder.ToString(0' builder.Length - 2))); // return everything except CRLF                      _bufferedStream.Push(_byteBuffer' start' read - start);                      return (LineInfo[])lines.ToArray(typeof(LineInfo));                  }              }
Magic Number,System.Net.Mail,SmtpReplyReaderFactory,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpReplyReaderFactory.cs,ReadLines,The following statement contains a magic number: for (int start = 0' read = 0; ;)              {                  if (start == read)                  {                      read = _bufferedStream.Read(_byteBuffer' 0' _byteBuffer.Length);                      start = 0;                  }                    int actual = ProcessRead(_byteBuffer' start' read - start' true);                    if (statusRead < 4)                  {                      int left = Math.Min(4 - statusRead' actual);                      statusRead += left;                      start += left;                      actual -= left;                      if (actual == 0)                      {                          continue;                      }                  }                    builder.Append(Encoding.UTF8.GetString(_byteBuffer' start' actual));                  start += actual;                    if (_readState == ReadState.Status0)                  {                      statusRead = 0;                      lines.Add(new LineInfo(_statusCode' builder.ToString(0' builder.Length - 2))); // return everything except CRLF                        if (oneLine)                      {                          _bufferedStream.Push(_byteBuffer' start' read - start);                          return (LineInfo[])lines.ToArray(typeof(LineInfo));                      }                      builder = new StringBuilder();                  }                  else if (_readState == ReadState.Done)                  {                      lines.Add(new LineInfo(_statusCode' builder.ToString(0' builder.Length - 2))); // return everything except CRLF                      _bufferedStream.Push(_byteBuffer' start' read - start);                      return (LineInfo[])lines.ToArray(typeof(LineInfo));                  }              }
Magic Number,System.Net.Mail,ReadLinesAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpReplyReaderFactory.cs,ProcessRead,The following statement contains a magic number: for (int start = 0; start != _read;)                  {                      int actual = _parent.ProcessRead(_parent._byteBuffer' start' _read - start' true);                        if (_statusRead < 4)                      {                          int left = Math.Min(4 - _statusRead' actual);                          _statusRead += left;                          start += left;                          actual -= left;                          if (actual == 0)                          {                              continue;                          }                      }                        _builder.Append(Encoding.UTF8.GetString(_parent._byteBuffer' start' actual));                      start += actual;                        if (_parent._readState == ReadState.Status0)                      {                          _lines.Add(new LineInfo(_parent._statusCode' _builder.ToString(0' _builder.Length - 2))); // return everything except CRLF                          _builder = new StringBuilder();                          _statusRead = 0;                            if (_oneLine)                          {                              _parent._bufferedStream.Push(_parent._byteBuffer' start' _read - start);                              InvokeCallback();                              return false;                          }                      }                      else if (_parent._readState == ReadState.Done)                      {                          _lines.Add(new LineInfo(_parent._statusCode' _builder.ToString(0' _builder.Length - 2))); // return everything except CRLF                          _parent._bufferedStream.Push(_parent._byteBuffer' start' _read - start);                          InvokeCallback();                          return false;                      }                  }
Magic Number,System.Net.Mail,ReadLinesAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpReplyReaderFactory.cs,ProcessRead,The following statement contains a magic number: for (int start = 0; start != _read;)                  {                      int actual = _parent.ProcessRead(_parent._byteBuffer' start' _read - start' true);                        if (_statusRead < 4)                      {                          int left = Math.Min(4 - _statusRead' actual);                          _statusRead += left;                          start += left;                          actual -= left;                          if (actual == 0)                          {                              continue;                          }                      }                        _builder.Append(Encoding.UTF8.GetString(_parent._byteBuffer' start' actual));                      start += actual;                        if (_parent._readState == ReadState.Status0)                      {                          _lines.Add(new LineInfo(_parent._statusCode' _builder.ToString(0' _builder.Length - 2))); // return everything except CRLF                          _builder = new StringBuilder();                          _statusRead = 0;                            if (_oneLine)                          {                              _parent._bufferedStream.Push(_parent._byteBuffer' start' _read - start);                              InvokeCallback();                              return false;                          }                      }                      else if (_parent._readState == ReadState.Done)                      {                          _lines.Add(new LineInfo(_parent._statusCode' _builder.ToString(0' _builder.Length - 2))); // return everything except CRLF                          _parent._bufferedStream.Push(_parent._byteBuffer' start' _read - start);                          InvokeCallback();                          return false;                      }                  }
Magic Number,System.Net.Mail,ReadLinesAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpReplyReaderFactory.cs,ProcessRead,The following statement contains a magic number: for (int start = 0; start != _read;)                  {                      int actual = _parent.ProcessRead(_parent._byteBuffer' start' _read - start' true);                        if (_statusRead < 4)                      {                          int left = Math.Min(4 - _statusRead' actual);                          _statusRead += left;                          start += left;                          actual -= left;                          if (actual == 0)                          {                              continue;                          }                      }                        _builder.Append(Encoding.UTF8.GetString(_parent._byteBuffer' start' actual));                      start += actual;                        if (_parent._readState == ReadState.Status0)                      {                          _lines.Add(new LineInfo(_parent._statusCode' _builder.ToString(0' _builder.Length - 2))); // return everything except CRLF                          _builder = new StringBuilder();                          _statusRead = 0;                            if (_oneLine)                          {                              _parent._bufferedStream.Push(_parent._byteBuffer' start' _read - start);                              InvokeCallback();                              return false;                          }                      }                      else if (_parent._readState == ReadState.Done)                      {                          _lines.Add(new LineInfo(_parent._statusCode' _builder.ToString(0' _builder.Length - 2))); // return everything except CRLF                          _parent._bufferedStream.Push(_parent._byteBuffer' start' _read - start);                          InvokeCallback();                          return false;                      }                  }
Magic Number,System.Net.Mail,ReadLinesAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpReplyReaderFactory.cs,ProcessRead,The following statement contains a magic number: for (int start = 0; start != _read;)                  {                      int actual = _parent.ProcessRead(_parent._byteBuffer' start' _read - start' true);                        if (_statusRead < 4)                      {                          int left = Math.Min(4 - _statusRead' actual);                          _statusRead += left;                          start += left;                          actual -= left;                          if (actual == 0)                          {                              continue;                          }                      }                        _builder.Append(Encoding.UTF8.GetString(_parent._byteBuffer' start' actual));                      start += actual;                        if (_parent._readState == ReadState.Status0)                      {                          _lines.Add(new LineInfo(_parent._statusCode' _builder.ToString(0' _builder.Length - 2))); // return everything except CRLF                          _builder = new StringBuilder();                          _statusRead = 0;                            if (_oneLine)                          {                              _parent._bufferedStream.Push(_parent._byteBuffer' start' _read - start);                              InvokeCallback();                              return false;                          }                      }                      else if (_parent._readState == ReadState.Done)                      {                          _lines.Add(new LineInfo(_parent._statusCode' _builder.ToString(0' _builder.Length - 2))); // return everything except CRLF                          _parent._bufferedStream.Push(_parent._byteBuffer' start' _read - start);                          InvokeCallback();                          return false;                      }                  }
Magic Number,System.Net.Mail,SmtpNegotiateAuthenticationModule,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpNegotiateAuthenticationModule.cs,GetSecurityLayerOutgoingBlob,The following statement contains a magic number: if (len < 4 ||          // expect 4 bytes                  input[0] != 1 ||    // first value 1                  input[1] != 0 ||    // rest value 0                  input[2] != 0 ||                  input[3] != 0)              {                  return null;              }
Magic Number,System.Net.Mail,SmtpNegotiateAuthenticationModule,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpNegotiateAuthenticationModule.cs,GetSecurityLayerOutgoingBlob,The following statement contains a magic number: if (len < 4 ||          // expect 4 bytes                  input[0] != 1 ||    // first value 1                  input[1] != 0 ||    // rest value 0                  input[2] != 0 ||                  input[3] != 0)              {                  return null;              }
Magic Number,System.Net.Mail,SmtpNegotiateAuthenticationModule,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpNegotiateAuthenticationModule.cs,GetSecurityLayerOutgoingBlob,The following statement contains a magic number: if (len < 4 ||          // expect 4 bytes                  input[0] != 1 ||    // first value 1                  input[1] != 0 ||    // rest value 0                  input[2] != 0 ||                  input[3] != 0)              {                  return null;              }
Magic Number,System.Net.Mail,SmtpNegotiateAuthenticationModule,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpNegotiateAuthenticationModule.cs,GetSecurityLayerOutgoingBlob,The following statement contains a magic number: try              {                  len = clientContext.MakeSignature(input' 0' 4' ref output);              }              catch (Win32Exception)              {                  // any encrypt failure is an auth failure                  return null;              }
Magic Number,System.Net.Mail,MailAddressParser,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\MailAddressParser.cs,ParseDisplayName,The following statement contains a magic number: if (firstNonCommentIndex >= 0 && data[firstNonCommentIndex] == MailBnfHelper.Quote)              {                  // The preceding comment was not part of the display name.  Read just the quoted string.                  index = QuotedStringFormatReader.ReadReverseQuoted(data' firstNonCommentIndex' true);                    Debug.Assert(data[index + 1] == MailBnfHelper.Quote' "Mis-aligned index: " + index);                    // Do not include the bounding quotes on the display name                  int leftIndex = index + 2;                  displayName = data.Substring(leftIndex' firstNonCommentIndex - leftIndex);                    // Skip any CFWS after the display name                  index = WhitespaceReader.ReadCfwsReverse(data' index);                    // Check for completion. We are valid if we hit the end of the data string or if the rest of the data                   // belongs to another address.                  if (index >= 0 && !(expectMultipleAddresses && data[index] == MailBnfHelper.Comma))                  {                      // If there was still data' only a comma could have been the next valid character                      throw new FormatException(SR.Format(SR.MailHeaderFieldInvalidCharacter' data[index]));                  }              }              else              {                  // The comment (if any) should be part of the display name.                  int startingIndex = index;                    // Read until the dividing comma or the end of the line.                  index = QuotedStringFormatReader.ReadReverseUnQuoted(data' index' true' expectMultipleAddresses);                    Debug.Assert(index < 0 || data[index] == MailBnfHelper.Comma' "Mis-aligned index: " + index);                    // Do not include the Comma (if any)' and because there were no bounding quotes'                   // trim extra whitespace.                  displayName = data.SubstringTrim(index + 1' startingIndex - index);              }
Magic Number,System.Net.Mail,QuotedPairReader,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Mail\QuotedPairReader.cs,CountQuotedChars,The following statement contains a magic number: if (backslashCount % 2 == 0)              {                  return 0; // No quoted pair to skip              }              else              {                  if (!permitUnicodeEscaping && data[index] > MailBnfHelper.Ascii7bitMaxValue)                  {                      // Cannot accept quoted Unicode                      throw new FormatException(SR.Format(SR.MailHeaderFieldInvalidCharacter' data[index]));                  }                  // Skip the quoted char' and the odd number of backslashes preceding it                  return backslashCount + 1;              }
Missing Default,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,Close,The following switch statement is missing a default case: switch (WriteState.Padding)                  {                      case 1:                          WriteState.Append(s_base64EncodeMap[WriteState.LastBits]' s_base64EncodeMap[64]);                          break;                      case 2:                          WriteState.Append(s_base64EncodeMap[WriteState.LastBits]' s_base64EncodeMap[64]' s_base64EncodeMap[64]);                          break;                  }
Missing Default,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,DecodeBytes,The following switch statement is missing a default case: switch (ReadState.Pos)                      {                          case 0:                              ReadState.Val = (byte)(s << 2);                              ReadState.Pos++;                              break;                          case 1:                              *dest++ = (byte)(ReadState.Val + (s >> 4));                              ReadState.Val = unchecked((byte)(s << 4));                              ReadState.Pos++;                              break;                          case 2:                              *dest++ = (byte)(ReadState.Val + (s >> 2));                              ReadState.Val = unchecked((byte)(s << 6));                              ReadState.Pos++;                              break;                          case 3:                              *dest++ = (byte)(ReadState.Val + s);                              ReadState.Pos = 0;                              break;                      }
Missing Default,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following switch statement is missing a default case: switch (WriteState.Padding)              {                  case 2:                      WriteState.Append(s_base64EncodeMap[WriteState.LastBits | ((buffer[cur] & 0xf0) >> 4)]);                      if (count == 1)                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x0f) << 2);                          WriteState.Padding = 1;                          return cur - offset;                      }                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x0f) << 2) | ((buffer[cur + 1] & 0xc0) >> 6)]);                      WriteState.Append(s_base64EncodeMap[(buffer[cur + 1] & 0x3f)]);                      cur += 2;                      count -= 2;                      WriteState.Padding = 0;                      break;                  case 1:                      WriteState.Append(s_base64EncodeMap[WriteState.LastBits | ((buffer[cur] & 0xc0) >> 6)]);                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0x3f)]);                      cur++;                      count--;                      WriteState.Padding = 0;                      break;              }
Missing Default,System.Net,Base64Stream,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Base64Stream.cs,EncodeBytes,The following switch statement is missing a default case: switch (count % 3)              {                  case 2: //One character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      WriteState.Append(s_base64EncodeMap[((buffer[cur] & 0x03) << 4) | ((buffer[cur + 1] & 0xf0) >> 4)]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[((buffer[cur + 1] & 0x0f) << 2)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur + 1] & 0x0F) << 2);                          WriteState.Padding = 1;                      }                      cur += 2;                      break;                    case 1: // Two character padding needed                      WriteState.Append(s_base64EncodeMap[(buffer[cur] & 0xFC) >> 2]);                      if (dontDeferFinalBytes)                      {                          WriteState.Append(s_base64EncodeMap[(byte)((buffer[cur] & 0x03) << 4)]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Append(s_base64EncodeMap[64]);                          WriteState.Padding = 0;                      }                      else                      {                          WriteState.LastBits = (byte)((buffer[cur] & 0x03) << 4);                          WriteState.Padding = 2;                      }                      cur++;                      break;              }
Missing Default,System.Net.Mime,SmtpDateTime,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mime\SmtpDateTime.cs,SmtpDateTime,The following switch statement is missing a default case: switch (value.Kind)              {                  case DateTimeKind.Local:                      // GetUtcOffset takes local time zone information into account e.g. daylight savings time                      TimeSpan localTimeZone = TimeZoneInfo.Local.GetUtcOffset(value);                      _timeZone = ValidateAndGetSanitizedTimeSpan(localTimeZone);                      break;                    case DateTimeKind.Unspecified:                      _unknownTimeZone = true;                      break;                    case DateTimeKind.Utc:                      _timeZone = TimeSpan.Zero;                      break;              }
Missing Default,System.Net.Mail,SmtpReplyReaderFactory,C:\selectedRepos\dotnet_corefx\src\System.Net.Mail\src\System\Net\Mail\SmtpReplyReaderFactory.cs,ProcessRead,The following switch statement is missing a default case: switch (_readState)                      {                          case ReadState.Status0:                              {                                  if (ptr < end)                                  {                                      byte b = *ptr++;                                      if (b < '0' && b > '9')                                      {                                          throw new FormatException(SR.SmtpInvalidResponse);                                      }                                        _statusCode = (SmtpStatusCode)(100 * (b - '0'));                                        goto case ReadState.Status1;                                  }                                  _readState = ReadState.Status0;                                  break;                              }                          case ReadState.Status1:                              {                                  if (ptr < end)                                  {                                      byte b = *ptr++;                                      if (b < '0' && b > '9')                                      {                                          throw new FormatException(SR.SmtpInvalidResponse);                                      }                                        _statusCode += 10 * (b - '0');                                        goto case ReadState.Status2;                                  }                                  _readState = ReadState.Status1;                                  break;                              }                          case ReadState.Status2:                              {                                  if (ptr < end)                                  {                                      byte b = *ptr++;                                      if (b < '0' && b > '9')                                      {                                          throw new FormatException(SR.SmtpInvalidResponse);                                      }                                        _statusCode += b - '0';                                        goto case ReadState.ContinueFlag;                                  }                                  _readState = ReadState.Status2;                                  break;                              }                          case ReadState.ContinueFlag:                              {                                  if (ptr < end)                                  {                                      byte b = *ptr++;                                      if (b == ' ')       // last line                                      {                                          goto case ReadState.LastCR;                                      }                                      else if (b == '-')  // more lines coming                                      {                                          goto case ReadState.ContinueCR;                                      }                                      else                // error                                      {                                          throw new FormatException(SR.SmtpInvalidResponse);                                      }                                  }                                  _readState = ReadState.ContinueFlag;                                  break;                              }                          case ReadState.ContinueCR:                              {                                  while (ptr < end)                                  {                                      if (*ptr++ == '\r')                                      {                                          goto case ReadState.ContinueLF;                                      }                                  }                                  _readState = ReadState.ContinueCR;                                  break;                              }                          case ReadState.ContinueLF:                              {                                  if (ptr < end)                                  {                                      if (*ptr++ != '\n')                                      {                                          throw new FormatException(SR.SmtpInvalidResponse);                                      }                                      if (readLine)                                      {                                          _readState = ReadState.Status0;                                          return (int)(ptr - start);                                      }                                      goto case ReadState.Status0;                                  }                                  _readState = ReadState.ContinueLF;                                  break;                              }                          case ReadState.LastCR:                              {                                  while (ptr < end)                                  {                                      if (*ptr++ == '\r')                                      {                                          goto case ReadState.LastLF;                                      }                                  }                                  _readState = ReadState.LastCR;                                  break;                              }                          case ReadState.LastLF:                              {                                  if (ptr < end)                                  {                                      if (*ptr++ != '\n')                                      {                                          throw new FormatException(SR.SmtpInvalidResponse);                                      }                                      goto case ReadState.Done;                                  }                                  _readState = ReadState.LastLF;                                  break;                              }                          case ReadState.Done:                              {                                  int actual = (int)(ptr - start);                                  _readState = ReadState.Done;                                  return actual;                              }                      }
