Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.IO.Compression,DeflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\DeflaterManaged.cs,GetDeflateOutput,The method has 102 lines of code.
Long Method,System.IO.Compression,FastEncoderWindow,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoderWindow.cs,GetNextSymbolOrMatch,The method has 131 lines of code.
Long Method,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeBlock,The method has 128 lines of code.
Long Method,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeDynamicBlockHeader,The method has 163 lines of code.
Complex Method,System.IO.Compression,ZipArchive,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchive.cs,ReadEndOfCentralDirectory,Cyclomatic complexity of the method is 13
Complex Method,System.IO.Compression,ZipArchiveEntry,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchiveEntry.cs,WriteCentralDirectoryFileHeader,Cyclomatic complexity of the method is 8
Complex Method,System.IO.Compression,ZipArchiveEntry,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchiveEntry.cs,IsOpenable,Cyclomatic complexity of the method is 12
Complex Method,System.IO.Compression,FastEncoderWindow,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoderWindow.cs,FindMatch,Cyclomatic complexity of the method is 9
Complex Method,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,Decode,Cyclomatic complexity of the method is 14
Long Parameter List,System.IO.Compression,Zip64ExtraField,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,GetJustZip64Block,The method has 5 parameters. Parameters: extraFieldStream' readUncompressedSize' readCompressedSize' readLocalHeaderOffset' readStartDiskNumber
Long Parameter List,System.IO.Compression,Zip64ExtraField,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,TryGetZip64BlockFromGenericExtraField,The method has 6 parameters. Parameters: extraField' readUncompressedSize' readCompressedSize' readLocalHeaderOffset' readStartDiskNumber' zip64Block
Long Parameter List,System.IO.Compression,Zip64ExtraField,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,GetAndRemoveZip64Block,The method has 5 parameters. Parameters: extraFields' readUncompressedSize' readCompressedSize' readLocalHeaderOffset' readStartDiskNumber
Long Parameter List,System.IO.Compression,ZipEndOfCentralDirectoryBlock,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,WriteBlock,The method has 5 parameters. Parameters: stream' numberOfEntries' startOfCentralDirectory' sizeOfCentralDirectory' archiveComment
Long Parameter List,System.IO.Compression,CheckSumAndSizeWriteStream,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipCustomStreams.cs,CheckSumAndSizeWriteStream,The method has 6 parameters. Parameters: baseStream' baseBaseStream' leaveOpenOnClose' entry' onClose' saveCrcAndSizes
Long Parameter List,System.IO.Compression,DeflateManagedStream,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\DeflateManagedStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' asyncCallback' asyncState
Long Parameter List,System.IO.Compression,DeflateManagedStream,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\DeflateManagedStream.cs,ReadAsyncCore,The method has 5 parameters. Parameters: readTask' array' offset' count' cancellationToken
Long Parameter List,System.IO.Compression,DeflateManagedStream,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\DeflateManagedStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' asyncCallback' asyncState
Long Parameter List,System.IO.Compression,PositionPreservingWriteOnlyStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\PositionPreservingWriteOnlyStreamWrapper.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.IO.Compression,GZipStream,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\GZipStream.cs,BeginRead,The method has 5 parameters. Parameters: array' offset' count' asyncCallback' asyncState
Long Parameter List,System.IO.Compression,GZipStream,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\GZipStream.cs,BeginWrite,The method has 5 parameters. Parameters: array' offset' count' asyncCallback' asyncState
Long Parameter List,System.IO.Compression,DeflateStream,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateZLib\DeflateStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' asyncCallback' asyncState
Long Parameter List,System.IO.Compression,DeflateStream,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateZLib\DeflateStream.cs,BeginWrite,The method has 5 parameters. Parameters: array' offset' count' asyncCallback' asyncState
Long Parameter List,System.IO.Compression,ZLibNative,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateZLib\ZLibNative.cs,CreateZLibStreamForDeflate,The method has 5 parameters. Parameters: zLibStreamHandle' level' windowBits' memLevel' strategy
Long Identifier,System.IO.Compression,ZipArchiveEntry,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchiveEntry.cs,GetDataCompressor,The length of the parameter leaveCompressorStreamOpenOnClose is 32.
Long Identifier,System.IO.Compression,ZipArchiveEntry,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchiveEntry.cs,,The length of the parameter s_allowLargeZipArchiveEntriesInUpdateMode is 41.
Long Identifier,System.IO.Compression,ZipLocalFileHeader,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,,The length of the parameter OffsetToBitFlagFromHeaderStart is 30.
Long Identifier,System.IO.Compression,ZipCentralDirectoryFileHeader,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,TryReadBlock,The length of the parameter relativeOffsetOfLocalHeaderSmall is 32.
Long Identifier,System.IO.Compression,ZipEndOfCentralDirectoryBlock,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,WriteBlock,The length of the parameter startOfCentralDirectoryTruncated is 32.
Long Identifier,System.IO.Compression,ZipEndOfCentralDirectoryBlock,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,WriteBlock,The length of the parameter sizeOfCentralDirectoryTruncated is 31.
Long Identifier,System.IO.Compression,ZipEndOfCentralDirectoryBlock,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,,The length of the parameter NumberOfTheDiskWithTheStartOfTheCentralDirectory is 48.
Long Identifier,System.IO.Compression,ZipEndOfCentralDirectoryBlock,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,,The length of the parameter NumberOfEntriesInTheCentralDirectoryOnThisDisk is 46.
Long Identifier,System.IO.Compression,ZipEndOfCentralDirectoryBlock,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,,The length of the parameter NumberOfEntriesInTheCentralDirectory is 36.
Long Identifier,System.IO.Compression,ZipEndOfCentralDirectoryBlock,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,,The length of the parameter OffsetOfStartOfCentralDirectoryWithRespectToTheStartingDiskNumber is 65.
Long Identifier,System.IO.Compression,FastEncoderStatics,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoderStatus.cs,,The length of the parameter BFinalFastEncoderTreeStructureData is 34.
Long Identifier,System.IO.Compression,FastEncoderStatics,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoderStatus.cs,,The length of the parameter BFinalNoCompressionHeaderBitCount is 33.
Long Identifier,System.IO.Compression,FastEncoderWindow,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoderWindow.cs,,The length of the parameter FastEncoderMatch3DistThreshold is 30.
Long Identifier,System.IO.Compression,HuffmanTree,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\HuffmanTree.cs,,The length of the parameter NumberOfCodeLengthTreeElements is 30.
Long Statement,System.IO.Compression,ZipArchive,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchive.cs,WriteArchiveEpilogue,The length of the statement  "                Zip64EndOfCentralDirectoryRecord.WriteBlock(_archiveStream' _entries.Count' startOfCentralDirectory' sizeOfCentralDirectory); " is 125.
Long Statement,System.IO.Compression,ZipArchive,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchive.cs,WriteArchiveEpilogue,The length of the statement  "            ZipEndOfCentralDirectoryBlock.WriteBlock(_archiveStream' _entries.Count' startOfCentralDirectory' sizeOfCentralDirectory' _archiveComment); " is 139.
Long Statement,System.IO.Compression,ZipArchiveEntry,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchiveEntry.cs,WriteCentralDirectoryFileHeader,The length of the statement  "                // If we have one of the sizes' the other must go in there as speced for LH' but not necessarily for CH' but we do it anyways " is 125.
Long Statement,System.IO.Compression,ZipArchiveEntry,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchiveEntry.cs,WriteCentralDirectoryFileHeader,The length of the statement  "                // If we have one of the sizes' the other must go in there as speced for LH' but not necessarily for CH' but we do it anyways " is 125.
Long Statement,System.IO.Compression,ZipArchiveEntry,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchiveEntry.cs,WriteCentralDirectoryFileHeader,The length of the statement  "            writer.Write(ZipCentralDirectoryFileHeader.SignatureConstant);      // Central directory file header signature  (4 bytes) " is 121.
Long Statement,System.IO.Compression,ZipArchiveEntry,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchiveEntry.cs,WriteCentralDirectoryFileHeader,The length of the statement  "            writer.Write((byte)_versionMadeBySpecification);                    // Version made by Specification (version)  (1 byte) " is 120.
Long Statement,System.IO.Compression,ZipArchiveEntry,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchiveEntry.cs,WriteCentralDirectoryFileHeader,The length of the statement  "            writer.Write((byte)CurrentZipPlatform);                             // Version made by Compatibility (type)     (1 byte) " is 120.
Long Statement,System.IO.Compression,ZipArchiveEntry,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchiveEntry.cs,WriteCentralDirectoryFileHeader,The length of the statement  "            writer.Write((ushort)_versionToExtract);                            // Minimum version needed to extract        (2 bytes) " is 121.
Long Statement,System.IO.Compression,ZipArchiveEntry,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchiveEntry.cs,WriteCentralDirectoryFileHeader,The length of the statement  "            writer.Write((ushort)_generalPurposeBitFlag);                       // General Purpose bit flag                 (2 bytes) " is 121.
Long Statement,System.IO.Compression,ZipArchiveEntry,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchiveEntry.cs,WriteCentralDirectoryFileHeader,The length of the statement  "            writer.Write((ushort)CompressionMethod);                            // The Compression method                   (2 bytes) " is 121.
Long Statement,System.IO.Compression,ZipArchiveEntry,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchiveEntry.cs,WriteCentralDirectoryFileHeader,The length of the statement  "            writer.Write(ZipHelper.DateTimeToDosTime(_lastModified.DateTime));  // File last modification time and date     (4 bytes) " is 121.
Long Statement,System.IO.Compression,ZipArchiveEntry,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchiveEntry.cs,WriteCentralDirectoryFileHeader,The length of the statement  "            writer.Write(_crc32);                                               // CRC-32                                   (4 bytes) " is 121.
Long Statement,System.IO.Compression,ZipArchiveEntry,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchiveEntry.cs,WriteCentralDirectoryFileHeader,The length of the statement  "            writer.Write(compressedSizeTruncated);                              // Compressed Size                          (4 bytes) " is 121.
Long Statement,System.IO.Compression,ZipArchiveEntry,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchiveEntry.cs,WriteCentralDirectoryFileHeader,The length of the statement  "            writer.Write(uncompressedSizeTruncated);                            // Uncompressed Size                        (4 bytes) " is 121.
Long Statement,System.IO.Compression,ZipArchiveEntry,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchiveEntry.cs,WriteCentralDirectoryFileHeader,The length of the statement  "            writer.Write((ushort)_storedEntryNameBytes.Length);                 // File Name Length                         (2 bytes) " is 121.
Long Statement,System.IO.Compression,ZipArchiveEntry,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchiveEntry.cs,WriteCentralDirectoryFileHeader,The length of the statement  "            writer.Write(extraFieldLength);                                     // Extra Field Length                       (2 bytes) " is 121.
Long Statement,System.IO.Compression,ZipArchiveEntry,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchiveEntry.cs,LoadLocalHeaderExtraFieldAndCompressedBytesIfNeeded,The length of the statement  "                ZipHelper.ReadBytes(_archive.ArchiveStream' _compressedBytes[_compressedBytes.Length - 1]' (int)(_compressedSize % MaxSingleBufferSize)); " is 137.
Long Statement,System.IO.Compression,ZipArchiveEntry,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchiveEntry.cs,GetDataCompressor,The length of the statement  "                (long initialPosition' long currentPosition' uint checkSum' Stream backing' ZipArchiveEntry thisRef' EventHandler closeHandler) => " is 130.
Long Statement,System.IO.Compression,ZipArchiveEntry,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchiveEntry.cs,OpenInWriteMode,The length of the statement  "            // we assume that if another entry grabbed the archive stream' that it set this entry's _everOpenedForWrite property to true by calling WriteLocalFileHeaderIfNeeed " is 163.
Long Statement,System.IO.Compression,ZipArchiveEntry,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipArchiveEntry.cs,WriteLocalFileHeader,The length of the statement  "            // calculate extra field. if zip64 stuff + original extraField aren't going to fit' dump the original extraField' because this is more important " is 144.
Long Statement,System.IO.Compression,Zip64EndOfCentralDirectoryRecord,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,WriteBlock,The length of the statement  "            writer.Write((ushort)ZipVersionNeededValues.Zip64); // version made by: high byte is 0 for MS DOS' low byte is version needed " is 125.
Long Statement,System.IO.Compression,ZipCentralDirectoryFileHeader,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,TryReadBlock,The length of the statement  "            // There are zip files that have malformed ExtraField blocks in which GetJustZip64Block() silently bails out without reading all the way to the end " is 147.
Long Statement,System.IO.Compression,DeflateManagedStream,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\DeflateManagedStream.cs,InitializeInflater,The length of the statement  "            Debug.Assert(method == ZipArchiveEntry.CompressionMethodValues.Deflate || method == ZipArchiveEntry.CompressionMethodValues.Deflate64); " is 135.
Long Statement,System.IO.Compression,FastEncoder,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoder.cs,GetCompressedOutput,The length of the statement  "            } while (SafeToWriteTo(output) && InputAvailable(input) && (maxBytesToCopy < 1 || bytesConsumedFromInput < maxBytesToCopy)); " is 124.
Long Statement,System.IO.Compression,FastEncoder,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoder.cs,WriteMatch,The length of the statement  "            Debug.Assert(matchLen >= FastEncoderWindow.MinMatch && matchLen <= FastEncoderWindow.MaxMatch' "Illegal currentMatch length!"); " is 127.
Long Statement,System.IO.Compression,FastEncoder,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoder.cs,WriteMatch,The length of the statement  "            uint codeInfo = FastEncoderStatics.FastEncoderLiteralCodeInfo[(FastEncoderStatics.NumChars + 1 - FastEncoderWindow.MinMatch) + matchLen]; " is 137.
Long Statement,System.IO.Compression,FastEncoder,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoder.cs,WriteDeflatePreamble,The length of the statement  "            output.WriteBytes(FastEncoderStatics.FastEncoderTreeStructureData' 0' FastEncoderStatics.FastEncoderTreeStructureData.Length); " is 126.
Long Statement,System.IO.Compression,Deflater,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateZLib\Deflater.cs,DeflateInit,The length of the statement  "                    throw new ZLibException(SR.ZLibErrorIncorrectInitParameters' "deflateInit2_"' (int)errC' _zlibStream.GetErrorMessage()); " is 120.
Long Statement,System.IO.Compression,Inflater,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateZLib\Inflater.cs,InflateInit,The length of the statement  "                    throw new ZLibException(SR.ZLibErrorIncorrectInitParameters' "inflateInit2_"' (int)error' _zlibStream.GetErrorMessage()); " is 121.
Long Statement,System.IO.Compression,Inflater,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateZLib\Inflater.cs,Inflate,The length of the statement  "                case ZLibNative.ErrorCode.BufError:     // No room in the output buffer - inflate() can be called again with more space to continue " is 131.
Long Statement,System.IO.Compression,Inflater,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateZLib\Inflater.cs,Inflate,The length of the statement  "                case ZLibNative.ErrorCode.DataError:    // The input data was corrupted (input stream not conforming to the zlib format or incorrect check value) " is 145.
Long Statement,System.IO.Compression,Inflater,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateZLib\Inflater.cs,Inflate,The length of the statement  "                case ZLibNative.ErrorCode.StreamError:  //the stream structure was inconsistent (for example if next_in or next_out was NULL)' " is 126.
Long Statement,System.IO.Compression,ZLibStreamHandle,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateZLib\ZLibNative.cs,DeflateInit2_,The length of the statement  "                ErrorCode errC = Interop.zlib.DeflateInit2_(ref _zStream' level' CompressionMethod.Deflated' windowBits' memLevel' strategy); " is 125.
Long Statement,System.Threading.Tasks,TaskToApm,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Threading\Tasks\TaskToApm.cs,Begin,The length of the statement  "                asyncResult = task.AsyncState == state ? (IAsyncResult)task : new TaskWrapperAsyncResult(task' state' completedSynchronously: false); " is 133.
Complex Conditional,System.IO,PathInternal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\IO\PathInternal.cs,EqualStartingCharacterCount,The conditional expression  "l != leftEnd && r != rightEnd                      && (*l == *r || (ignoreCase && char.ToUpperInvariant((*l)) == char.ToUpperInvariant((*r))))"  is complex.
Magic Number,System.IO.Compression,ZipGenericExtraField,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,TryReadBlock,The following statement contains a magic number: if (endExtraField - reader.BaseStream.Position < 4)                  return false;
Magic Number,System.IO.Compression,Zip64ExtraField,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,UpdateSize,The following statement contains a magic number: if (_uncompressedSize != null) _size += 8;
Magic Number,System.IO.Compression,Zip64ExtraField,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,UpdateSize,The following statement contains a magic number: if (_compressedSize != null) _size += 8;
Magic Number,System.IO.Compression,Zip64ExtraField,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,UpdateSize,The following statement contains a magic number: if (_localHeaderOffset != null) _size += 8;
Magic Number,System.IO.Compression,Zip64ExtraField,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,UpdateSize,The following statement contains a magic number: if (_startDiskNumber != null) _size += 4;
Magic Number,System.IO.Compression,Zip64ExtraField,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,TryGetZip64BlockFromGenericExtraField,The following statement contains a magic number: try              {                  ms = new MemoryStream(extraField.Data);                  using (BinaryReader reader = new BinaryReader(ms))                  {                      ms = null;                        zip64Block._size = extraField.Size;                        ushort expectedSize = 0;                        if (readUncompressedSize) expectedSize += 8;                      if (readCompressedSize) expectedSize += 8;                      if (readLocalHeaderOffset) expectedSize += 8;                      if (readStartDiskNumber) expectedSize += 4;                        // if it is not the expected size' perhaps there is another extra field that matches                      if (expectedSize != zip64Block._size)                          return false;                        if (readUncompressedSize) zip64Block._uncompressedSize = reader.ReadInt64();                      if (readCompressedSize) zip64Block._compressedSize = reader.ReadInt64();                      if (readLocalHeaderOffset) zip64Block._localHeaderOffset = reader.ReadInt64();                      if (readStartDiskNumber) zip64Block._startDiskNumber = reader.ReadInt32();                        // original values are unsigned' so implies value is too big to fit in signed integer                      if (zip64Block._uncompressedSize < 0) throw new InvalidDataException(SR.FieldTooBigUncompressedSize);                      if (zip64Block._compressedSize < 0) throw new InvalidDataException(SR.FieldTooBigCompressedSize);                      if (zip64Block._localHeaderOffset < 0) throw new InvalidDataException(SR.FieldTooBigLocalHeaderOffset);                      if (zip64Block._startDiskNumber < 0) throw new InvalidDataException(SR.FieldTooBigStartDiskNumber);                        return true;                  }              }              finally              {                  if (ms != null)                      ms.Dispose();              }
Magic Number,System.IO.Compression,Zip64ExtraField,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,TryGetZip64BlockFromGenericExtraField,The following statement contains a magic number: try              {                  ms = new MemoryStream(extraField.Data);                  using (BinaryReader reader = new BinaryReader(ms))                  {                      ms = null;                        zip64Block._size = extraField.Size;                        ushort expectedSize = 0;                        if (readUncompressedSize) expectedSize += 8;                      if (readCompressedSize) expectedSize += 8;                      if (readLocalHeaderOffset) expectedSize += 8;                      if (readStartDiskNumber) expectedSize += 4;                        // if it is not the expected size' perhaps there is another extra field that matches                      if (expectedSize != zip64Block._size)                          return false;                        if (readUncompressedSize) zip64Block._uncompressedSize = reader.ReadInt64();                      if (readCompressedSize) zip64Block._compressedSize = reader.ReadInt64();                      if (readLocalHeaderOffset) zip64Block._localHeaderOffset = reader.ReadInt64();                      if (readStartDiskNumber) zip64Block._startDiskNumber = reader.ReadInt32();                        // original values are unsigned' so implies value is too big to fit in signed integer                      if (zip64Block._uncompressedSize < 0) throw new InvalidDataException(SR.FieldTooBigUncompressedSize);                      if (zip64Block._compressedSize < 0) throw new InvalidDataException(SR.FieldTooBigCompressedSize);                      if (zip64Block._localHeaderOffset < 0) throw new InvalidDataException(SR.FieldTooBigLocalHeaderOffset);                      if (zip64Block._startDiskNumber < 0) throw new InvalidDataException(SR.FieldTooBigStartDiskNumber);                        return true;                  }              }              finally              {                  if (ms != null)                      ms.Dispose();              }
Magic Number,System.IO.Compression,Zip64ExtraField,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,TryGetZip64BlockFromGenericExtraField,The following statement contains a magic number: try              {                  ms = new MemoryStream(extraField.Data);                  using (BinaryReader reader = new BinaryReader(ms))                  {                      ms = null;                        zip64Block._size = extraField.Size;                        ushort expectedSize = 0;                        if (readUncompressedSize) expectedSize += 8;                      if (readCompressedSize) expectedSize += 8;                      if (readLocalHeaderOffset) expectedSize += 8;                      if (readStartDiskNumber) expectedSize += 4;                        // if it is not the expected size' perhaps there is another extra field that matches                      if (expectedSize != zip64Block._size)                          return false;                        if (readUncompressedSize) zip64Block._uncompressedSize = reader.ReadInt64();                      if (readCompressedSize) zip64Block._compressedSize = reader.ReadInt64();                      if (readLocalHeaderOffset) zip64Block._localHeaderOffset = reader.ReadInt64();                      if (readStartDiskNumber) zip64Block._startDiskNumber = reader.ReadInt32();                        // original values are unsigned' so implies value is too big to fit in signed integer                      if (zip64Block._uncompressedSize < 0) throw new InvalidDataException(SR.FieldTooBigUncompressedSize);                      if (zip64Block._compressedSize < 0) throw new InvalidDataException(SR.FieldTooBigCompressedSize);                      if (zip64Block._localHeaderOffset < 0) throw new InvalidDataException(SR.FieldTooBigLocalHeaderOffset);                      if (zip64Block._startDiskNumber < 0) throw new InvalidDataException(SR.FieldTooBigStartDiskNumber);                        return true;                  }              }              finally              {                  if (ms != null)                      ms.Dispose();              }
Magic Number,System.IO.Compression,Zip64ExtraField,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,TryGetZip64BlockFromGenericExtraField,The following statement contains a magic number: try              {                  ms = new MemoryStream(extraField.Data);                  using (BinaryReader reader = new BinaryReader(ms))                  {                      ms = null;                        zip64Block._size = extraField.Size;                        ushort expectedSize = 0;                        if (readUncompressedSize) expectedSize += 8;                      if (readCompressedSize) expectedSize += 8;                      if (readLocalHeaderOffset) expectedSize += 8;                      if (readStartDiskNumber) expectedSize += 4;                        // if it is not the expected size' perhaps there is another extra field that matches                      if (expectedSize != zip64Block._size)                          return false;                        if (readUncompressedSize) zip64Block._uncompressedSize = reader.ReadInt64();                      if (readCompressedSize) zip64Block._compressedSize = reader.ReadInt64();                      if (readLocalHeaderOffset) zip64Block._localHeaderOffset = reader.ReadInt64();                      if (readStartDiskNumber) zip64Block._startDiskNumber = reader.ReadInt32();                        // original values are unsigned' so implies value is too big to fit in signed integer                      if (zip64Block._uncompressedSize < 0) throw new InvalidDataException(SR.FieldTooBigUncompressedSize);                      if (zip64Block._compressedSize < 0) throw new InvalidDataException(SR.FieldTooBigCompressedSize);                      if (zip64Block._localHeaderOffset < 0) throw new InvalidDataException(SR.FieldTooBigLocalHeaderOffset);                      if (zip64Block._startDiskNumber < 0) throw new InvalidDataException(SR.FieldTooBigStartDiskNumber);                        return true;                  }              }              finally              {                  if (ms != null)                      ms.Dispose();              }
Magic Number,System.IO.Compression,ZipLocalFileHeader,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,GetExtraFields,The following statement contains a magic number: const int OffsetToFilenameLength = 26;
Magic Number,System.IO.Compression,ZipLocalFileHeader,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipBlocks.cs,TrySkipBlock,The following statement contains a magic number: const int OffsetToFilenameLength = 22;
Magic Number,System.IO.Compression,ZipHelper,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipHelper.cs,RequiresUnicode,The following statement contains a magic number: foreach (char c in test)              {                  // The Zip Format uses code page 437 when the Unicode bit is not set. This format                  // is the same as ASCII for characters 32-126 but differs otherwise. If we can fit                  // the string into CP437 then we treat ASCII as acceptable.                  if (c > 126 || c < 32)                      return true;              }
Magic Number,System.IO.Compression,ZipHelper,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipHelper.cs,RequiresUnicode,The following statement contains a magic number: foreach (char c in test)              {                  // The Zip Format uses code page 437 when the Unicode bit is not set. This format                  // is the same as ASCII for characters 32-126 but differs otherwise. If we can fit                  // the string into CP437 then we treat ASCII as acceptable.                  if (c > 126 || c < 32)                      return true;              }
Magic Number,System.IO.Compression,ZipHelper,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipHelper.cs,DosTimeToDateTime,The following statement contains a magic number: int year = (int)(ValidZipDate_YearMin + (dateTime >> 25));
Magic Number,System.IO.Compression,ZipHelper,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipHelper.cs,DosTimeToDateTime,The following statement contains a magic number: int month = (int)((dateTime >> 21) & 0xF);
Magic Number,System.IO.Compression,ZipHelper,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipHelper.cs,DosTimeToDateTime,The following statement contains a magic number: int day = (int)((dateTime >> 16) & 0x1F);
Magic Number,System.IO.Compression,ZipHelper,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipHelper.cs,DosTimeToDateTime,The following statement contains a magic number: int hour = (int)((dateTime >> 11) & 0x1F);
Magic Number,System.IO.Compression,ZipHelper,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipHelper.cs,DosTimeToDateTime,The following statement contains a magic number: int minute = (int)((dateTime >> 5) & 0x3F);
Magic Number,System.IO.Compression,ZipHelper,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipHelper.cs,DosTimeToDateTime,The following statement contains a magic number: int second = (int)((dateTime & 0x001F) * 2);
Magic Number,System.IO.Compression,ZipHelper,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipHelper.cs,DateTimeToDosTime,The following statement contains a magic number: ret = (ret << 4) + dateTime.Month;
Magic Number,System.IO.Compression,ZipHelper,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipHelper.cs,DateTimeToDosTime,The following statement contains a magic number: ret = (ret << 5) + dateTime.Day;
Magic Number,System.IO.Compression,ZipHelper,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipHelper.cs,DateTimeToDosTime,The following statement contains a magic number: ret = (ret << 5) + dateTime.Hour;
Magic Number,System.IO.Compression,ZipHelper,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipHelper.cs,DateTimeToDosTime,The following statement contains a magic number: ret = (ret << 6) + dateTime.Minute;
Magic Number,System.IO.Compression,ZipHelper,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipHelper.cs,DateTimeToDosTime,The following statement contains a magic number: ret = (ret << 5) + (dateTime.Second / 2);
Magic Number,System.IO.Compression,ZipHelper,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipHelper.cs,DateTimeToDosTime,The following statement contains a magic number: ret = (ret << 5) + (dateTime.Second / 2);
Magic Number,System.IO.Compression,ZipHelper,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipHelper.cs,SeekBackwardsToSignature,The following statement contains a magic number: while (!signatureFound && !outOfBytes)              {                  outOfBytes = SeekBackwardsAndRead(stream' buffer' out bufferPointer);                    Debug.Assert(bufferPointer < buffer.Length);                    while (bufferPointer >= 0 && !signatureFound)                  {                      currentSignature = (currentSignature << 8) | ((uint)buffer[bufferPointer]);                      if (currentSignature == signatureToFind)                      {                          signatureFound = true;                      }                      else                      {                          bufferPointer--;                      }                  }              }
Magic Number,System.IO.Compression,ZipHelper,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\ZipHelper.cs,AdvanceToPosition,The following statement contains a magic number: while (numBytesLeft != 0)              {                  const int throwAwayBufferSize = 64;                  int numBytesToSkip = (numBytesLeft > throwAwayBufferSize) ? throwAwayBufferSize : (int)numBytesLeft;                  int numBytesActuallySkipped = stream.Read(new byte[throwAwayBufferSize]' 0' numBytesToSkip);                  if (numBytesActuallySkipped == 0)                      throw new IOException(SR.UnexpectedEndOfStream);                  numBytesLeft -= numBytesActuallySkipped;              }
Magic Number,System.IO.Compression,FastEncoder,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoder.cs,WriteEndOfBlock,The following statement contains a magic number: const int EndOfBlockCode = 256;
Magic Number,System.IO.Compression,FastEncoder,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoder.cs,WriteEndOfBlock,The following statement contains a magic number: int code_len = (int)(code_info & 31);
Magic Number,System.IO.Compression,FastEncoder,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoder.cs,WriteEndOfBlock,The following statement contains a magic number: output.WriteBits(code_len' code_info >> 5);
Magic Number,System.IO.Compression,FastEncoder,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoder.cs,WriteMatch,The following statement contains a magic number: int codeLen = (int)codeInfo & 31;
Magic Number,System.IO.Compression,FastEncoder,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoder.cs,WriteMatch,The following statement contains a magic number: if (codeLen <= 16)              {                  output.WriteBits(codeLen' codeInfo >> 5);              }              else              {                  output.WriteBits(16' (codeInfo >> 5) & 65535);                  output.WriteBits(codeLen - 16' codeInfo >> (5 + 16));              }
Magic Number,System.IO.Compression,FastEncoder,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoder.cs,WriteMatch,The following statement contains a magic number: if (codeLen <= 16)              {                  output.WriteBits(codeLen' codeInfo >> 5);              }              else              {                  output.WriteBits(16' (codeInfo >> 5) & 65535);                  output.WriteBits(codeLen - 16' codeInfo >> (5 + 16));              }
Magic Number,System.IO.Compression,FastEncoder,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoder.cs,WriteMatch,The following statement contains a magic number: if (codeLen <= 16)              {                  output.WriteBits(codeLen' codeInfo >> 5);              }              else              {                  output.WriteBits(16' (codeInfo >> 5) & 65535);                  output.WriteBits(codeLen - 16' codeInfo >> (5 + 16));              }
Magic Number,System.IO.Compression,FastEncoder,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoder.cs,WriteMatch,The following statement contains a magic number: if (codeLen <= 16)              {                  output.WriteBits(codeLen' codeInfo >> 5);              }              else              {                  output.WriteBits(16' (codeInfo >> 5) & 65535);                  output.WriteBits(codeLen - 16' codeInfo >> (5 + 16));              }
Magic Number,System.IO.Compression,FastEncoder,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoder.cs,WriteMatch,The following statement contains a magic number: if (codeLen <= 16)              {                  output.WriteBits(codeLen' codeInfo >> 5);              }              else              {                  output.WriteBits(16' (codeInfo >> 5) & 65535);                  output.WriteBits(codeLen - 16' codeInfo >> (5 + 16));              }
Magic Number,System.IO.Compression,FastEncoder,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoder.cs,WriteMatch,The following statement contains a magic number: if (codeLen <= 16)              {                  output.WriteBits(codeLen' codeInfo >> 5);              }              else              {                  output.WriteBits(16' (codeInfo >> 5) & 65535);                  output.WriteBits(codeLen - 16' codeInfo >> (5 + 16));              }
Magic Number,System.IO.Compression,FastEncoder,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoder.cs,WriteMatch,The following statement contains a magic number: if (codeLen <= 16)              {                  output.WriteBits(codeLen' codeInfo >> 5);              }              else              {                  output.WriteBits(16' (codeInfo >> 5) & 65535);                  output.WriteBits(codeLen - 16' codeInfo >> (5 + 16));              }
Magic Number,System.IO.Compression,FastEncoder,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoder.cs,WriteMatch,The following statement contains a magic number: if (codeLen <= 16)              {                  output.WriteBits(codeLen' codeInfo >> 5);              }              else              {                  output.WriteBits(16' (codeInfo >> 5) & 65535);                  output.WriteBits(codeLen - 16' codeInfo >> (5 + 16));              }
Magic Number,System.IO.Compression,FastEncoder,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoder.cs,WriteMatch,The following statement contains a magic number: output.WriteBits((int)(codeInfo & 15)' codeInfo >> 8);
Magic Number,System.IO.Compression,FastEncoder,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoder.cs,WriteMatch,The following statement contains a magic number: output.WriteBits((int)(codeInfo & 15)' codeInfo >> 8);
Magic Number,System.IO.Compression,FastEncoder,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoder.cs,WriteMatch,The following statement contains a magic number: int extraBits = (int)(codeInfo >> 4) & 15;
Magic Number,System.IO.Compression,FastEncoder,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoder.cs,WriteMatch,The following statement contains a magic number: int extraBits = (int)(codeInfo >> 4) & 15;
Magic Number,System.IO.Compression,FastEncoder,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoder.cs,WriteChar,The following statement contains a magic number: output.WriteBits((int)code & 31' code >> 5);
Magic Number,System.IO.Compression,FastEncoder,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoder.cs,WriteChar,The following statement contains a magic number: output.WriteBits((int)code & 31' code >> 5);
Magic Number,System.IO.Compression,FastEncoderStatics,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoderStatus.cs,CreateDistanceLookup,The following statement contains a magic number: byte[] result = new byte[512];
Magic Number,System.IO.Compression,FastEncoderStatics,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoderStatus.cs,CreateDistanceLookup,The following statement contains a magic number: for (code = 0; code < 16; code++)              {                  for (int n = 0; n < (1 << ExtraDistanceBits[code]); n++)                      result[dist++] = (byte)code;              }
Magic Number,System.IO.Compression,FastEncoderStatics,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoderStatus.cs,CreateDistanceLookup,The following statement contains a magic number: dist >>= 7;
Magic Number,System.IO.Compression,FastEncoderStatics,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoderStatus.cs,CreateDistanceLookup,The following statement contains a magic number: for (; code < NumDistBaseCodes; code++)              {                  for (int n = 0; n < (1 << (ExtraDistanceBits[code] - 7)); n++)                      result[256 + dist++] = (byte)code;              }
Magic Number,System.IO.Compression,FastEncoderStatics,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoderStatus.cs,CreateDistanceLookup,The following statement contains a magic number: for (; code < NumDistBaseCodes; code++)              {                  for (int n = 0; n < (1 << (ExtraDistanceBits[code] - 7)); n++)                      result[256 + dist++] = (byte)code;              }
Magic Number,System.IO.Compression,FastEncoderStatics,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoderStatus.cs,BitReverse,The following statement contains a magic number: Debug.Assert(length > 0 && length <= 16' "Invalid len");
Magic Number,System.IO.Compression,FastEncoderWindow,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoderWindow.cs,ResetWindow,The following statement contains a magic number: _window = new byte[2 * FastEncoderWindowSize + MaxMatch + 4];
Magic Number,System.IO.Compression,FastEncoderWindow,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoderWindow.cs,ResetWindow,The following statement contains a magic number: _window = new byte[2 * FastEncoderWindowSize + MaxMatch + 4];
Magic Number,System.IO.Compression,FastEncoderWindow,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoderWindow.cs,MoveWindows,The following statement contains a magic number: Debug.Assert(_bufPos == 2 * FastEncoderWindowSize' "only call this at the end of the window");
Magic Number,System.IO.Compression,FastEncoderWindow,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoderWindow.cs,InsertString,The following statement contains a magic number: hash = HashValue(hash' _window[_bufPos + 2]);
Magic Number,System.IO.Compression,FastEncoderWindow,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoderWindow.cs,GetNextSymbolOrMatch,The following statement contains a magic number: Debug.Assert(_bufPos >= FastEncoderWindowSize && _bufPos < (2 * FastEncoderWindowSize)' "Invalid Buffer Position!");
Magic Number,System.IO.Compression,FastEncoderWindow,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoderWindow.cs,GetNextSymbolOrMatch,The following statement contains a magic number: if (_bufEnd - _bufPos <= 3)              {                  // The hash value becomes corrupt when we get within 3 characters of the end of the                  // input window' since the hash value is based on 3 characters.  We just stop                  // inserting into the hash table at this point' and allow no matches.                  matchLen = 0;              }              else              {                  // insert string into hash table and return most recent location of same hash value                  int search = (int)InsertString(ref hash);                    // did we find a recent location of this hash value?                  if (search != 0)                  {                      // yes' now find a match at what we'll call position X                      matchLen = FindMatch(search' out matchPos' SearchDepth' NiceLength);                        // truncate match if we're too close to the end of the input window                      if (_bufPos + matchLen > _bufEnd)                          matchLen = _bufEnd - _bufPos;                  }                  else                  {                      // no most recent location found                      matchLen = 0;                  }              }
Magic Number,System.IO.Compression,FastEncoderWindow,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoderWindow.cs,GetNextSymbolOrMatch,The following statement contains a magic number: if (matchLen < MinMatch)              {                  // didn't find a match' so output unmatched char                  match.State = MatchState.HasSymbol;                  match.Symbol = _window[_bufPos];                  _bufPos++;              }              else              {                  // bufPos now points to X+1                  _bufPos++;                    // is this match so good (long) that we should take it automatically without                  // checking X+1 ?                  if (matchLen <= LazyMatchThreshold)                  {                      int nextMatchLen;                      int nextMatchPos = 0;                        // search at position X+1                      int search = (int)InsertString(ref hash);                        // no' so check for a better match at X+1                      if (search != 0)                      {                          nextMatchLen = FindMatch(search' out nextMatchPos'                                                     matchLen < GoodLength ? SearchDepth : (SearchDepth >> 2)' NiceLength);                            // truncate match if we're too close to the end of the window                          // note: nextMatchLen could now be < MinMatch                          if (_bufPos + nextMatchLen > _bufEnd)                          {                              nextMatchLen = _bufEnd - _bufPos;                          }                      }                      else                      {                          nextMatchLen = 0;                      }                        // right now X and X+1 are both inserted into the search tree                      if (nextMatchLen > matchLen)                      {                          // since nextMatchLen > matchLen' it can't be < MinMatch here                            // match at X+1 is better' so output unmatched char at X                          match.State = MatchState.HasSymbolAndMatch;                          match.Symbol = _window[_bufPos - 1];                          match.Position = nextMatchPos;                          match.Length = nextMatchLen;                            // insert remainder of second match into search tree                          // example: (*=inserted already)                          //                          // X      X+1               X+2      X+3     X+4                          // *      *                          //        nextmatchlen=3                          //        bufPos                          //                          // If nextMatchLen == 3' we want to perform 2                          // insertions (at X+2 and X+3).  However' first we must                          // inc bufPos.                          //                          _bufPos++; // now points to X+2                          matchLen = nextMatchLen;                          InsertStrings(ref hash' matchLen);                      }                      else                      {                          // match at X is better' so take it                          match.State = MatchState.HasMatch;                          match.Position = matchPos;                          match.Length = matchLen;                            // Insert remainder of first match into search tree' minus the first                          // two locations' which were inserted by the FindMatch() calls.                          //                          // For example' if matchLen == 3' then we've inserted at X and X+1                          // already (and bufPos is now pointing at X+1)' and now we need to insert                          // only at X+2.                          //                          matchLen--;                          _bufPos++; // now bufPos points to X+2                          InsertStrings(ref hash' matchLen);                      }                  }                  else                  {                      // match_length >= good_match                      // in assertion: bufPos points to X+1' location X inserted already                      // first match is so good that we're not even going to check at X+1                      match.State = MatchState.HasMatch;                      match.Position = matchPos;                      match.Length = matchLen;                        // insert remainder of match at X into search tree                      InsertStrings(ref hash' matchLen);                  }              }
Magic Number,System.IO.Compression,FastEncoderWindow,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoderWindow.cs,GetNextSymbolOrMatch,The following statement contains a magic number: if (_bufPos == 2 * FastEncoderWindowSize)              {                  MoveWindows();              }
Magic Number,System.IO.Compression,FastEncoderWindow,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoderWindow.cs,FindMatch,The following statement contains a magic number: Debug.Assert(_bufPos >= 0 && _bufPos < 2 * FastEncoderWindowSize' "Invalid Buffer position!");
Magic Number,System.IO.Compression,FastEncoderWindow,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\FastEncoderWindow.cs,FindMatch,The following statement contains a magic number: if (bestMatch == 3 && matchPos >= FastEncoderMatch3DistThreshold)              {                  return 0;              }
Magic Number,System.IO.Compression,HuffmanTree,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\HuffmanTree.cs,HuffmanTree,The following statement contains a magic number: if (_codeLengthArray.Length == MaxLiteralTreeElements)              {                  // bits for Literal/Length tree table                  _tableBits = 9;              }              else              {                  // bits for distance tree table and code length tree table                  _tableBits = 7;              }
Magic Number,System.IO.Compression,HuffmanTree,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\HuffmanTree.cs,HuffmanTree,The following statement contains a magic number: if (_codeLengthArray.Length == MaxLiteralTreeElements)              {                  // bits for Literal/Length tree table                  _tableBits = 9;              }              else              {                  // bits for distance tree table and code length tree table                  _tableBits = 7;              }
Magic Number,System.IO.Compression,HuffmanTree,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\HuffmanTree.cs,HuffmanTree,The following statement contains a magic number: _left = new short[2 * _codeLengthArray.Length];
Magic Number,System.IO.Compression,HuffmanTree,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\HuffmanTree.cs,HuffmanTree,The following statement contains a magic number: _right = new short[2 * _codeLengthArray.Length];
Magic Number,System.IO.Compression,HuffmanTree,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\HuffmanTree.cs,GetStaticLiteralTreeLength,The following statement contains a magic number: for (int i = 0; i <= 143; i++)                  literalTreeLength[i] = 8;
Magic Number,System.IO.Compression,HuffmanTree,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\HuffmanTree.cs,GetStaticLiteralTreeLength,The following statement contains a magic number: for (int i = 0; i <= 143; i++)                  literalTreeLength[i] = 8;
Magic Number,System.IO.Compression,HuffmanTree,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\HuffmanTree.cs,GetStaticLiteralTreeLength,The following statement contains a magic number: for (int i = 144; i <= 255; i++)                  literalTreeLength[i] = 9;
Magic Number,System.IO.Compression,HuffmanTree,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\HuffmanTree.cs,GetStaticLiteralTreeLength,The following statement contains a magic number: for (int i = 144; i <= 255; i++)                  literalTreeLength[i] = 9;
Magic Number,System.IO.Compression,HuffmanTree,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\HuffmanTree.cs,GetStaticLiteralTreeLength,The following statement contains a magic number: for (int i = 144; i <= 255; i++)                  literalTreeLength[i] = 9;
Magic Number,System.IO.Compression,HuffmanTree,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\HuffmanTree.cs,GetStaticLiteralTreeLength,The following statement contains a magic number: for (int i = 256; i <= 279; i++)                  literalTreeLength[i] = 7;
Magic Number,System.IO.Compression,HuffmanTree,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\HuffmanTree.cs,GetStaticLiteralTreeLength,The following statement contains a magic number: for (int i = 256; i <= 279; i++)                  literalTreeLength[i] = 7;
Magic Number,System.IO.Compression,HuffmanTree,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\HuffmanTree.cs,GetStaticLiteralTreeLength,The following statement contains a magic number: for (int i = 256; i <= 279; i++)                  literalTreeLength[i] = 7;
Magic Number,System.IO.Compression,HuffmanTree,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\HuffmanTree.cs,GetStaticLiteralTreeLength,The following statement contains a magic number: for (int i = 280; i <= 287; i++)                  literalTreeLength[i] = 8;
Magic Number,System.IO.Compression,HuffmanTree,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\HuffmanTree.cs,GetStaticLiteralTreeLength,The following statement contains a magic number: for (int i = 280; i <= 287; i++)                  literalTreeLength[i] = 8;
Magic Number,System.IO.Compression,HuffmanTree,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\HuffmanTree.cs,GetStaticLiteralTreeLength,The following statement contains a magic number: for (int i = 280; i <= 287; i++)                  literalTreeLength[i] = 8;
Magic Number,System.IO.Compression,HuffmanTree,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\HuffmanTree.cs,GetStaticDistanceTreeLength,The following statement contains a magic number: for (int i = 0; i < MaxDistTreeElements; i++)              {                  staticDistanceTreeLength[i] = 5;              }
Magic Number,System.IO.Compression,HuffmanTree,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\HuffmanTree.cs,CalculateHuffmanCode,The following statement contains a magic number: uint[] bitLengthCount = new uint[17];
Magic Number,System.IO.Compression,HuffmanTree,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\HuffmanTree.cs,CalculateHuffmanCode,The following statement contains a magic number: uint[] nextCode = new uint[17];
Magic Number,System.IO.Compression,HuffmanTree,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\HuffmanTree.cs,CalculateHuffmanCode,The following statement contains a magic number: for (int bits = 1; bits <= 16; bits++)              {                  tempCode = (tempCode + bitLengthCount[bits - 1]) << 1;                  nextCode[bits] = tempCode;              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,Decode,The following statement contains a magic number: if (_state == InflaterState.ReadingBType)              {                  // Need 2 bits                  if (!_input.EnsureBitsAvailable(2))                  {                      _state = InflaterState.ReadingBType;                      return false;                  }                    _blockType = (BlockType)_input.GetBits(2);                  if (_blockType == BlockType.Dynamic)                  {                      _state = InflaterState.ReadingNumLitCodes;                  }                  else if (_blockType == BlockType.Static)                  {                      _literalLengthTree = HuffmanTree.StaticLiteralLengthTree;                      _distanceTree = HuffmanTree.StaticDistanceTree;                      _state = InflaterState.DecodeTop;                  }                  else if (_blockType == BlockType.Uncompressed)                  {                      _state = InflaterState.UncompressedAligning;                  }                  else                  {                      throw new InvalidDataException(SR.UnknownBlockType);                  }              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,Decode,The following statement contains a magic number: if (_state == InflaterState.ReadingBType)              {                  // Need 2 bits                  if (!_input.EnsureBitsAvailable(2))                  {                      _state = InflaterState.ReadingBType;                      return false;                  }                    _blockType = (BlockType)_input.GetBits(2);                  if (_blockType == BlockType.Dynamic)                  {                      _state = InflaterState.ReadingNumLitCodes;                  }                  else if (_blockType == BlockType.Static)                  {                      _literalLengthTree = HuffmanTree.StaticLiteralLengthTree;                      _distanceTree = HuffmanTree.StaticDistanceTree;                      _state = InflaterState.DecodeTop;                  }                  else if (_blockType == BlockType.Uncompressed)                  {                      _state = InflaterState.UncompressedAligning;                  }                  else                  {                      throw new InvalidDataException(SR.UnknownBlockType);                  }              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeUncompressedBlock,The following statement contains a magic number: while (true)              {                  switch (_state)                  {                      case InflaterState.UncompressedAligning: // initial state when calling this function                                                               // we must skip to a byte boundary                          _input.SkipToByteBoundary();                          _state = InflaterState.UncompressedByte1;                          goto case InflaterState.UncompressedByte1;                        case InflaterState.UncompressedByte1:   // decoding block length                      case InflaterState.UncompressedByte2:                      case InflaterState.UncompressedByte3:                      case InflaterState.UncompressedByte4:                          int bits = _input.GetBits(8);                          if (bits < 0)                          {                              return false;                          }                            _blockLengthBuffer[_state - InflaterState.UncompressedByte1] = (byte)bits;                          if (_state == InflaterState.UncompressedByte4)                          {                              _blockLength = _blockLengthBuffer[0] + ((int)_blockLengthBuffer[1]) * 256;                              int blockLengthComplement = _blockLengthBuffer[2] + ((int)_blockLengthBuffer[3]) * 256;                                // make sure complement matches                              if ((ushort)_blockLength != (ushort)(~blockLengthComplement))                              {                                  throw new InvalidDataException(SR.InvalidBlockLength);                              }                          }                            _state += 1;                          break;                        case InflaterState.DecodingUncompressed: // copying block data                            // Directly copy bytes from input to output.                          int bytesCopied = _output.CopyFrom(_input' _blockLength);                          _blockLength -= bytesCopied;                            if (_blockLength == 0)                          {                              // Done with this block' need to re-init bit buffer for next block                              _state = InflaterState.ReadingBFinal;                              end_of_block = true;                              return true;                          }                            // We can fail to copy all bytes for two reasons:                          //    Running out of Input                          //    running out of free space in output window                          if (_output.FreeBytes == 0)                          {                              return true;                          }                            return false;                        default:                          Debug.Fail("check why we are here!");                          throw new InvalidDataException(SR.UnknownState);                  }              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeUncompressedBlock,The following statement contains a magic number: while (true)              {                  switch (_state)                  {                      case InflaterState.UncompressedAligning: // initial state when calling this function                                                               // we must skip to a byte boundary                          _input.SkipToByteBoundary();                          _state = InflaterState.UncompressedByte1;                          goto case InflaterState.UncompressedByte1;                        case InflaterState.UncompressedByte1:   // decoding block length                      case InflaterState.UncompressedByte2:                      case InflaterState.UncompressedByte3:                      case InflaterState.UncompressedByte4:                          int bits = _input.GetBits(8);                          if (bits < 0)                          {                              return false;                          }                            _blockLengthBuffer[_state - InflaterState.UncompressedByte1] = (byte)bits;                          if (_state == InflaterState.UncompressedByte4)                          {                              _blockLength = _blockLengthBuffer[0] + ((int)_blockLengthBuffer[1]) * 256;                              int blockLengthComplement = _blockLengthBuffer[2] + ((int)_blockLengthBuffer[3]) * 256;                                // make sure complement matches                              if ((ushort)_blockLength != (ushort)(~blockLengthComplement))                              {                                  throw new InvalidDataException(SR.InvalidBlockLength);                              }                          }                            _state += 1;                          break;                        case InflaterState.DecodingUncompressed: // copying block data                            // Directly copy bytes from input to output.                          int bytesCopied = _output.CopyFrom(_input' _blockLength);                          _blockLength -= bytesCopied;                            if (_blockLength == 0)                          {                              // Done with this block' need to re-init bit buffer for next block                              _state = InflaterState.ReadingBFinal;                              end_of_block = true;                              return true;                          }                            // We can fail to copy all bytes for two reasons:                          //    Running out of Input                          //    running out of free space in output window                          if (_output.FreeBytes == 0)                          {                              return true;                          }                            return false;                        default:                          Debug.Fail("check why we are here!");                          throw new InvalidDataException(SR.UnknownState);                  }              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeUncompressedBlock,The following statement contains a magic number: while (true)              {                  switch (_state)                  {                      case InflaterState.UncompressedAligning: // initial state when calling this function                                                               // we must skip to a byte boundary                          _input.SkipToByteBoundary();                          _state = InflaterState.UncompressedByte1;                          goto case InflaterState.UncompressedByte1;                        case InflaterState.UncompressedByte1:   // decoding block length                      case InflaterState.UncompressedByte2:                      case InflaterState.UncompressedByte3:                      case InflaterState.UncompressedByte4:                          int bits = _input.GetBits(8);                          if (bits < 0)                          {                              return false;                          }                            _blockLengthBuffer[_state - InflaterState.UncompressedByte1] = (byte)bits;                          if (_state == InflaterState.UncompressedByte4)                          {                              _blockLength = _blockLengthBuffer[0] + ((int)_blockLengthBuffer[1]) * 256;                              int blockLengthComplement = _blockLengthBuffer[2] + ((int)_blockLengthBuffer[3]) * 256;                                // make sure complement matches                              if ((ushort)_blockLength != (ushort)(~blockLengthComplement))                              {                                  throw new InvalidDataException(SR.InvalidBlockLength);                              }                          }                            _state += 1;                          break;                        case InflaterState.DecodingUncompressed: // copying block data                            // Directly copy bytes from input to output.                          int bytesCopied = _output.CopyFrom(_input' _blockLength);                          _blockLength -= bytesCopied;                            if (_blockLength == 0)                          {                              // Done with this block' need to re-init bit buffer for next block                              _state = InflaterState.ReadingBFinal;                              end_of_block = true;                              return true;                          }                            // We can fail to copy all bytes for two reasons:                          //    Running out of Input                          //    running out of free space in output window                          if (_output.FreeBytes == 0)                          {                              return true;                          }                            return false;                        default:                          Debug.Fail("check why we are here!");                          throw new InvalidDataException(SR.UnknownState);                  }              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeUncompressedBlock,The following statement contains a magic number: while (true)              {                  switch (_state)                  {                      case InflaterState.UncompressedAligning: // initial state when calling this function                                                               // we must skip to a byte boundary                          _input.SkipToByteBoundary();                          _state = InflaterState.UncompressedByte1;                          goto case InflaterState.UncompressedByte1;                        case InflaterState.UncompressedByte1:   // decoding block length                      case InflaterState.UncompressedByte2:                      case InflaterState.UncompressedByte3:                      case InflaterState.UncompressedByte4:                          int bits = _input.GetBits(8);                          if (bits < 0)                          {                              return false;                          }                            _blockLengthBuffer[_state - InflaterState.UncompressedByte1] = (byte)bits;                          if (_state == InflaterState.UncompressedByte4)                          {                              _blockLength = _blockLengthBuffer[0] + ((int)_blockLengthBuffer[1]) * 256;                              int blockLengthComplement = _blockLengthBuffer[2] + ((int)_blockLengthBuffer[3]) * 256;                                // make sure complement matches                              if ((ushort)_blockLength != (ushort)(~blockLengthComplement))                              {                                  throw new InvalidDataException(SR.InvalidBlockLength);                              }                          }                            _state += 1;                          break;                        case InflaterState.DecodingUncompressed: // copying block data                            // Directly copy bytes from input to output.                          int bytesCopied = _output.CopyFrom(_input' _blockLength);                          _blockLength -= bytesCopied;                            if (_blockLength == 0)                          {                              // Done with this block' need to re-init bit buffer for next block                              _state = InflaterState.ReadingBFinal;                              end_of_block = true;                              return true;                          }                            // We can fail to copy all bytes for two reasons:                          //    Running out of Input                          //    running out of free space in output window                          if (_output.FreeBytes == 0)                          {                              return true;                          }                            return false;                        default:                          Debug.Fail("check why we are here!");                          throw new InvalidDataException(SR.UnknownState);                  }              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeUncompressedBlock,The following statement contains a magic number: while (true)              {                  switch (_state)                  {                      case InflaterState.UncompressedAligning: // initial state when calling this function                                                               // we must skip to a byte boundary                          _input.SkipToByteBoundary();                          _state = InflaterState.UncompressedByte1;                          goto case InflaterState.UncompressedByte1;                        case InflaterState.UncompressedByte1:   // decoding block length                      case InflaterState.UncompressedByte2:                      case InflaterState.UncompressedByte3:                      case InflaterState.UncompressedByte4:                          int bits = _input.GetBits(8);                          if (bits < 0)                          {                              return false;                          }                            _blockLengthBuffer[_state - InflaterState.UncompressedByte1] = (byte)bits;                          if (_state == InflaterState.UncompressedByte4)                          {                              _blockLength = _blockLengthBuffer[0] + ((int)_blockLengthBuffer[1]) * 256;                              int blockLengthComplement = _blockLengthBuffer[2] + ((int)_blockLengthBuffer[3]) * 256;                                // make sure complement matches                              if ((ushort)_blockLength != (ushort)(~blockLengthComplement))                              {                                  throw new InvalidDataException(SR.InvalidBlockLength);                              }                          }                            _state += 1;                          break;                        case InflaterState.DecodingUncompressed: // copying block data                            // Directly copy bytes from input to output.                          int bytesCopied = _output.CopyFrom(_input' _blockLength);                          _blockLength -= bytesCopied;                            if (_blockLength == 0)                          {                              // Done with this block' need to re-init bit buffer for next block                              _state = InflaterState.ReadingBFinal;                              end_of_block = true;                              return true;                          }                            // We can fail to copy all bytes for two reasons:                          //    Running out of Input                          //    running out of free space in output window                          if (_output.FreeBytes == 0)                          {                              return true;                          }                            return false;                        default:                          Debug.Fail("check why we are here!");                          throw new InvalidDataException(SR.UnknownState);                  }              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeBlock,The following statement contains a magic number: while (freeBytes > 65536)              {                  // With Deflate64 we can have up to a 64kb length' so we ensure at least that much space is available                  // in the OutputWindow to avoid overwriting previous unflushed output data.                    int symbol;                  switch (_state)                  {                      case InflaterState.DecodeTop:                          // decode an element from the literal tree                            // TODO: optimize this!!!                          symbol = _literalLengthTree.GetNextSymbol(_input);                          if (symbol < 0)                          {                              // running out of input                              return false;                          }                            if (symbol < 256)                          {                              // literal                              _output.Write((byte)symbol);                              --freeBytes;                          }                          else if (symbol == 256)                          {                              // end of block                              end_of_block_code_seen = true;                              // Reset state                              _state = InflaterState.ReadingBFinal;                              return true;                          }                          else                          {                              // length/distance pair                              symbol -= 257;     // length code started at 257                              if (symbol < 8)                              {                                  symbol += 3;   // match length = 3'4'5'6'7'8'9'10                                  _extraBits = 0;                              }                              else if (!_deflate64 && symbol == 28)                              {                                  // extra bits for code 285 is 0                                  symbol = 258;             // code 285 means length 258                                  _extraBits = 0;                              }                              else                              {                                  if (symbol < 0 || symbol >= s_extraLengthBits.Length)                                  {                                      throw new InvalidDataException(SR.GenericInvalidData);                                  }                                  _extraBits = s_extraLengthBits[symbol];                                  Debug.Assert(_extraBits != 0' "We handle other cases separately!");                              }                              _length = symbol;                              goto case InflaterState.HaveInitialLength;                          }                          break;                        case InflaterState.HaveInitialLength:                          if (_extraBits > 0)                          {                              _state = InflaterState.HaveInitialLength;                              int bits = _input.GetBits(_extraBits);                              if (bits < 0)                              {                                  return false;                              }                                if (_length < 0 || _length >= s_lengthBase.Length)                              {                                  throw new InvalidDataException(SR.GenericInvalidData);                              }                              _length = s_lengthBase[_length] + bits;                          }                          _state = InflaterState.HaveFullLength;                          goto case InflaterState.HaveFullLength;                        case InflaterState.HaveFullLength:                          if (_blockType == BlockType.Dynamic)                          {                              _distanceCode = _distanceTree.GetNextSymbol(_input);                          }                          else                          {                              // get distance code directly for static block                              _distanceCode = _input.GetBits(5);                              if (_distanceCode >= 0)                              {                                  _distanceCode = s_staticDistanceTreeTable[_distanceCode];                              }                          }                            if (_distanceCode < 0)                          {                              // running out input                              return false;                          }                            _state = InflaterState.HaveDistCode;                          goto case InflaterState.HaveDistCode;                        case InflaterState.HaveDistCode:                          // To avoid a table lookup we note that for distanceCode > 3'                          // extra_bits = (distanceCode-2) >> 1                          int offset;                          if (_distanceCode > 3)                          {                              _extraBits = (_distanceCode - 2) >> 1;                              int bits = _input.GetBits(_extraBits);                              if (bits < 0)                              {                                  return false;                              }                              offset = s_distanceBasePosition[_distanceCode] + bits;                          }                          else                          {                              offset = _distanceCode + 1;                          }                            _output.WriteLengthDistance(_length' offset);                          freeBytes -= _length;                          _state = InflaterState.DecodeTop;                          break;                        default:                          Debug.Fail("check why we are here!");                          throw new InvalidDataException(SR.UnknownState);                  }              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeBlock,The following statement contains a magic number: while (freeBytes > 65536)              {                  // With Deflate64 we can have up to a 64kb length' so we ensure at least that much space is available                  // in the OutputWindow to avoid overwriting previous unflushed output data.                    int symbol;                  switch (_state)                  {                      case InflaterState.DecodeTop:                          // decode an element from the literal tree                            // TODO: optimize this!!!                          symbol = _literalLengthTree.GetNextSymbol(_input);                          if (symbol < 0)                          {                              // running out of input                              return false;                          }                            if (symbol < 256)                          {                              // literal                              _output.Write((byte)symbol);                              --freeBytes;                          }                          else if (symbol == 256)                          {                              // end of block                              end_of_block_code_seen = true;                              // Reset state                              _state = InflaterState.ReadingBFinal;                              return true;                          }                          else                          {                              // length/distance pair                              symbol -= 257;     // length code started at 257                              if (symbol < 8)                              {                                  symbol += 3;   // match length = 3'4'5'6'7'8'9'10                                  _extraBits = 0;                              }                              else if (!_deflate64 && symbol == 28)                              {                                  // extra bits for code 285 is 0                                  symbol = 258;             // code 285 means length 258                                  _extraBits = 0;                              }                              else                              {                                  if (symbol < 0 || symbol >= s_extraLengthBits.Length)                                  {                                      throw new InvalidDataException(SR.GenericInvalidData);                                  }                                  _extraBits = s_extraLengthBits[symbol];                                  Debug.Assert(_extraBits != 0' "We handle other cases separately!");                              }                              _length = symbol;                              goto case InflaterState.HaveInitialLength;                          }                          break;                        case InflaterState.HaveInitialLength:                          if (_extraBits > 0)                          {                              _state = InflaterState.HaveInitialLength;                              int bits = _input.GetBits(_extraBits);                              if (bits < 0)                              {                                  return false;                              }                                if (_length < 0 || _length >= s_lengthBase.Length)                              {                                  throw new InvalidDataException(SR.GenericInvalidData);                              }                              _length = s_lengthBase[_length] + bits;                          }                          _state = InflaterState.HaveFullLength;                          goto case InflaterState.HaveFullLength;                        case InflaterState.HaveFullLength:                          if (_blockType == BlockType.Dynamic)                          {                              _distanceCode = _distanceTree.GetNextSymbol(_input);                          }                          else                          {                              // get distance code directly for static block                              _distanceCode = _input.GetBits(5);                              if (_distanceCode >= 0)                              {                                  _distanceCode = s_staticDistanceTreeTable[_distanceCode];                              }                          }                            if (_distanceCode < 0)                          {                              // running out input                              return false;                          }                            _state = InflaterState.HaveDistCode;                          goto case InflaterState.HaveDistCode;                        case InflaterState.HaveDistCode:                          // To avoid a table lookup we note that for distanceCode > 3'                          // extra_bits = (distanceCode-2) >> 1                          int offset;                          if (_distanceCode > 3)                          {                              _extraBits = (_distanceCode - 2) >> 1;                              int bits = _input.GetBits(_extraBits);                              if (bits < 0)                              {                                  return false;                              }                              offset = s_distanceBasePosition[_distanceCode] + bits;                          }                          else                          {                              offset = _distanceCode + 1;                          }                            _output.WriteLengthDistance(_length' offset);                          freeBytes -= _length;                          _state = InflaterState.DecodeTop;                          break;                        default:                          Debug.Fail("check why we are here!");                          throw new InvalidDataException(SR.UnknownState);                  }              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeBlock,The following statement contains a magic number: while (freeBytes > 65536)              {                  // With Deflate64 we can have up to a 64kb length' so we ensure at least that much space is available                  // in the OutputWindow to avoid overwriting previous unflushed output data.                    int symbol;                  switch (_state)                  {                      case InflaterState.DecodeTop:                          // decode an element from the literal tree                            // TODO: optimize this!!!                          symbol = _literalLengthTree.GetNextSymbol(_input);                          if (symbol < 0)                          {                              // running out of input                              return false;                          }                            if (symbol < 256)                          {                              // literal                              _output.Write((byte)symbol);                              --freeBytes;                          }                          else if (symbol == 256)                          {                              // end of block                              end_of_block_code_seen = true;                              // Reset state                              _state = InflaterState.ReadingBFinal;                              return true;                          }                          else                          {                              // length/distance pair                              symbol -= 257;     // length code started at 257                              if (symbol < 8)                              {                                  symbol += 3;   // match length = 3'4'5'6'7'8'9'10                                  _extraBits = 0;                              }                              else if (!_deflate64 && symbol == 28)                              {                                  // extra bits for code 285 is 0                                  symbol = 258;             // code 285 means length 258                                  _extraBits = 0;                              }                              else                              {                                  if (symbol < 0 || symbol >= s_extraLengthBits.Length)                                  {                                      throw new InvalidDataException(SR.GenericInvalidData);                                  }                                  _extraBits = s_extraLengthBits[symbol];                                  Debug.Assert(_extraBits != 0' "We handle other cases separately!");                              }                              _length = symbol;                              goto case InflaterState.HaveInitialLength;                          }                          break;                        case InflaterState.HaveInitialLength:                          if (_extraBits > 0)                          {                              _state = InflaterState.HaveInitialLength;                              int bits = _input.GetBits(_extraBits);                              if (bits < 0)                              {                                  return false;                              }                                if (_length < 0 || _length >= s_lengthBase.Length)                              {                                  throw new InvalidDataException(SR.GenericInvalidData);                              }                              _length = s_lengthBase[_length] + bits;                          }                          _state = InflaterState.HaveFullLength;                          goto case InflaterState.HaveFullLength;                        case InflaterState.HaveFullLength:                          if (_blockType == BlockType.Dynamic)                          {                              _distanceCode = _distanceTree.GetNextSymbol(_input);                          }                          else                          {                              // get distance code directly for static block                              _distanceCode = _input.GetBits(5);                              if (_distanceCode >= 0)                              {                                  _distanceCode = s_staticDistanceTreeTable[_distanceCode];                              }                          }                            if (_distanceCode < 0)                          {                              // running out input                              return false;                          }                            _state = InflaterState.HaveDistCode;                          goto case InflaterState.HaveDistCode;                        case InflaterState.HaveDistCode:                          // To avoid a table lookup we note that for distanceCode > 3'                          // extra_bits = (distanceCode-2) >> 1                          int offset;                          if (_distanceCode > 3)                          {                              _extraBits = (_distanceCode - 2) >> 1;                              int bits = _input.GetBits(_extraBits);                              if (bits < 0)                              {                                  return false;                              }                              offset = s_distanceBasePosition[_distanceCode] + bits;                          }                          else                          {                              offset = _distanceCode + 1;                          }                            _output.WriteLengthDistance(_length' offset);                          freeBytes -= _length;                          _state = InflaterState.DecodeTop;                          break;                        default:                          Debug.Fail("check why we are here!");                          throw new InvalidDataException(SR.UnknownState);                  }              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeBlock,The following statement contains a magic number: while (freeBytes > 65536)              {                  // With Deflate64 we can have up to a 64kb length' so we ensure at least that much space is available                  // in the OutputWindow to avoid overwriting previous unflushed output data.                    int symbol;                  switch (_state)                  {                      case InflaterState.DecodeTop:                          // decode an element from the literal tree                            // TODO: optimize this!!!                          symbol = _literalLengthTree.GetNextSymbol(_input);                          if (symbol < 0)                          {                              // running out of input                              return false;                          }                            if (symbol < 256)                          {                              // literal                              _output.Write((byte)symbol);                              --freeBytes;                          }                          else if (symbol == 256)                          {                              // end of block                              end_of_block_code_seen = true;                              // Reset state                              _state = InflaterState.ReadingBFinal;                              return true;                          }                          else                          {                              // length/distance pair                              symbol -= 257;     // length code started at 257                              if (symbol < 8)                              {                                  symbol += 3;   // match length = 3'4'5'6'7'8'9'10                                  _extraBits = 0;                              }                              else if (!_deflate64 && symbol == 28)                              {                                  // extra bits for code 285 is 0                                  symbol = 258;             // code 285 means length 258                                  _extraBits = 0;                              }                              else                              {                                  if (symbol < 0 || symbol >= s_extraLengthBits.Length)                                  {                                      throw new InvalidDataException(SR.GenericInvalidData);                                  }                                  _extraBits = s_extraLengthBits[symbol];                                  Debug.Assert(_extraBits != 0' "We handle other cases separately!");                              }                              _length = symbol;                              goto case InflaterState.HaveInitialLength;                          }                          break;                        case InflaterState.HaveInitialLength:                          if (_extraBits > 0)                          {                              _state = InflaterState.HaveInitialLength;                              int bits = _input.GetBits(_extraBits);                              if (bits < 0)                              {                                  return false;                              }                                if (_length < 0 || _length >= s_lengthBase.Length)                              {                                  throw new InvalidDataException(SR.GenericInvalidData);                              }                              _length = s_lengthBase[_length] + bits;                          }                          _state = InflaterState.HaveFullLength;                          goto case InflaterState.HaveFullLength;                        case InflaterState.HaveFullLength:                          if (_blockType == BlockType.Dynamic)                          {                              _distanceCode = _distanceTree.GetNextSymbol(_input);                          }                          else                          {                              // get distance code directly for static block                              _distanceCode = _input.GetBits(5);                              if (_distanceCode >= 0)                              {                                  _distanceCode = s_staticDistanceTreeTable[_distanceCode];                              }                          }                            if (_distanceCode < 0)                          {                              // running out input                              return false;                          }                            _state = InflaterState.HaveDistCode;                          goto case InflaterState.HaveDistCode;                        case InflaterState.HaveDistCode:                          // To avoid a table lookup we note that for distanceCode > 3'                          // extra_bits = (distanceCode-2) >> 1                          int offset;                          if (_distanceCode > 3)                          {                              _extraBits = (_distanceCode - 2) >> 1;                              int bits = _input.GetBits(_extraBits);                              if (bits < 0)                              {                                  return false;                              }                              offset = s_distanceBasePosition[_distanceCode] + bits;                          }                          else                          {                              offset = _distanceCode + 1;                          }                            _output.WriteLengthDistance(_length' offset);                          freeBytes -= _length;                          _state = InflaterState.DecodeTop;                          break;                        default:                          Debug.Fail("check why we are here!");                          throw new InvalidDataException(SR.UnknownState);                  }              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeBlock,The following statement contains a magic number: while (freeBytes > 65536)              {                  // With Deflate64 we can have up to a 64kb length' so we ensure at least that much space is available                  // in the OutputWindow to avoid overwriting previous unflushed output data.                    int symbol;                  switch (_state)                  {                      case InflaterState.DecodeTop:                          // decode an element from the literal tree                            // TODO: optimize this!!!                          symbol = _literalLengthTree.GetNextSymbol(_input);                          if (symbol < 0)                          {                              // running out of input                              return false;                          }                            if (symbol < 256)                          {                              // literal                              _output.Write((byte)symbol);                              --freeBytes;                          }                          else if (symbol == 256)                          {                              // end of block                              end_of_block_code_seen = true;                              // Reset state                              _state = InflaterState.ReadingBFinal;                              return true;                          }                          else                          {                              // length/distance pair                              symbol -= 257;     // length code started at 257                              if (symbol < 8)                              {                                  symbol += 3;   // match length = 3'4'5'6'7'8'9'10                                  _extraBits = 0;                              }                              else if (!_deflate64 && symbol == 28)                              {                                  // extra bits for code 285 is 0                                  symbol = 258;             // code 285 means length 258                                  _extraBits = 0;                              }                              else                              {                                  if (symbol < 0 || symbol >= s_extraLengthBits.Length)                                  {                                      throw new InvalidDataException(SR.GenericInvalidData);                                  }                                  _extraBits = s_extraLengthBits[symbol];                                  Debug.Assert(_extraBits != 0' "We handle other cases separately!");                              }                              _length = symbol;                              goto case InflaterState.HaveInitialLength;                          }                          break;                        case InflaterState.HaveInitialLength:                          if (_extraBits > 0)                          {                              _state = InflaterState.HaveInitialLength;                              int bits = _input.GetBits(_extraBits);                              if (bits < 0)                              {                                  return false;                              }                                if (_length < 0 || _length >= s_lengthBase.Length)                              {                                  throw new InvalidDataException(SR.GenericInvalidData);                              }                              _length = s_lengthBase[_length] + bits;                          }                          _state = InflaterState.HaveFullLength;                          goto case InflaterState.HaveFullLength;                        case InflaterState.HaveFullLength:                          if (_blockType == BlockType.Dynamic)                          {                              _distanceCode = _distanceTree.GetNextSymbol(_input);                          }                          else                          {                              // get distance code directly for static block                              _distanceCode = _input.GetBits(5);                              if (_distanceCode >= 0)                              {                                  _distanceCode = s_staticDistanceTreeTable[_distanceCode];                              }                          }                            if (_distanceCode < 0)                          {                              // running out input                              return false;                          }                            _state = InflaterState.HaveDistCode;                          goto case InflaterState.HaveDistCode;                        case InflaterState.HaveDistCode:                          // To avoid a table lookup we note that for distanceCode > 3'                          // extra_bits = (distanceCode-2) >> 1                          int offset;                          if (_distanceCode > 3)                          {                              _extraBits = (_distanceCode - 2) >> 1;                              int bits = _input.GetBits(_extraBits);                              if (bits < 0)                              {                                  return false;                              }                              offset = s_distanceBasePosition[_distanceCode] + bits;                          }                          else                          {                              offset = _distanceCode + 1;                          }                            _output.WriteLengthDistance(_length' offset);                          freeBytes -= _length;                          _state = InflaterState.DecodeTop;                          break;                        default:                          Debug.Fail("check why we are here!");                          throw new InvalidDataException(SR.UnknownState);                  }              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeBlock,The following statement contains a magic number: while (freeBytes > 65536)              {                  // With Deflate64 we can have up to a 64kb length' so we ensure at least that much space is available                  // in the OutputWindow to avoid overwriting previous unflushed output data.                    int symbol;                  switch (_state)                  {                      case InflaterState.DecodeTop:                          // decode an element from the literal tree                            // TODO: optimize this!!!                          symbol = _literalLengthTree.GetNextSymbol(_input);                          if (symbol < 0)                          {                              // running out of input                              return false;                          }                            if (symbol < 256)                          {                              // literal                              _output.Write((byte)symbol);                              --freeBytes;                          }                          else if (symbol == 256)                          {                              // end of block                              end_of_block_code_seen = true;                              // Reset state                              _state = InflaterState.ReadingBFinal;                              return true;                          }                          else                          {                              // length/distance pair                              symbol -= 257;     // length code started at 257                              if (symbol < 8)                              {                                  symbol += 3;   // match length = 3'4'5'6'7'8'9'10                                  _extraBits = 0;                              }                              else if (!_deflate64 && symbol == 28)                              {                                  // extra bits for code 285 is 0                                  symbol = 258;             // code 285 means length 258                                  _extraBits = 0;                              }                              else                              {                                  if (symbol < 0 || symbol >= s_extraLengthBits.Length)                                  {                                      throw new InvalidDataException(SR.GenericInvalidData);                                  }                                  _extraBits = s_extraLengthBits[symbol];                                  Debug.Assert(_extraBits != 0' "We handle other cases separately!");                              }                              _length = symbol;                              goto case InflaterState.HaveInitialLength;                          }                          break;                        case InflaterState.HaveInitialLength:                          if (_extraBits > 0)                          {                              _state = InflaterState.HaveInitialLength;                              int bits = _input.GetBits(_extraBits);                              if (bits < 0)                              {                                  return false;                              }                                if (_length < 0 || _length >= s_lengthBase.Length)                              {                                  throw new InvalidDataException(SR.GenericInvalidData);                              }                              _length = s_lengthBase[_length] + bits;                          }                          _state = InflaterState.HaveFullLength;                          goto case InflaterState.HaveFullLength;                        case InflaterState.HaveFullLength:                          if (_blockType == BlockType.Dynamic)                          {                              _distanceCode = _distanceTree.GetNextSymbol(_input);                          }                          else                          {                              // get distance code directly for static block                              _distanceCode = _input.GetBits(5);                              if (_distanceCode >= 0)                              {                                  _distanceCode = s_staticDistanceTreeTable[_distanceCode];                              }                          }                            if (_distanceCode < 0)                          {                              // running out input                              return false;                          }                            _state = InflaterState.HaveDistCode;                          goto case InflaterState.HaveDistCode;                        case InflaterState.HaveDistCode:                          // To avoid a table lookup we note that for distanceCode > 3'                          // extra_bits = (distanceCode-2) >> 1                          int offset;                          if (_distanceCode > 3)                          {                              _extraBits = (_distanceCode - 2) >> 1;                              int bits = _input.GetBits(_extraBits);                              if (bits < 0)                              {                                  return false;                              }                              offset = s_distanceBasePosition[_distanceCode] + bits;                          }                          else                          {                              offset = _distanceCode + 1;                          }                            _output.WriteLengthDistance(_length' offset);                          freeBytes -= _length;                          _state = InflaterState.DecodeTop;                          break;                        default:                          Debug.Fail("check why we are here!");                          throw new InvalidDataException(SR.UnknownState);                  }              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeBlock,The following statement contains a magic number: while (freeBytes > 65536)              {                  // With Deflate64 we can have up to a 64kb length' so we ensure at least that much space is available                  // in the OutputWindow to avoid overwriting previous unflushed output data.                    int symbol;                  switch (_state)                  {                      case InflaterState.DecodeTop:                          // decode an element from the literal tree                            // TODO: optimize this!!!                          symbol = _literalLengthTree.GetNextSymbol(_input);                          if (symbol < 0)                          {                              // running out of input                              return false;                          }                            if (symbol < 256)                          {                              // literal                              _output.Write((byte)symbol);                              --freeBytes;                          }                          else if (symbol == 256)                          {                              // end of block                              end_of_block_code_seen = true;                              // Reset state                              _state = InflaterState.ReadingBFinal;                              return true;                          }                          else                          {                              // length/distance pair                              symbol -= 257;     // length code started at 257                              if (symbol < 8)                              {                                  symbol += 3;   // match length = 3'4'5'6'7'8'9'10                                  _extraBits = 0;                              }                              else if (!_deflate64 && symbol == 28)                              {                                  // extra bits for code 285 is 0                                  symbol = 258;             // code 285 means length 258                                  _extraBits = 0;                              }                              else                              {                                  if (symbol < 0 || symbol >= s_extraLengthBits.Length)                                  {                                      throw new InvalidDataException(SR.GenericInvalidData);                                  }                                  _extraBits = s_extraLengthBits[symbol];                                  Debug.Assert(_extraBits != 0' "We handle other cases separately!");                              }                              _length = symbol;                              goto case InflaterState.HaveInitialLength;                          }                          break;                        case InflaterState.HaveInitialLength:                          if (_extraBits > 0)                          {                              _state = InflaterState.HaveInitialLength;                              int bits = _input.GetBits(_extraBits);                              if (bits < 0)                              {                                  return false;                              }                                if (_length < 0 || _length >= s_lengthBase.Length)                              {                                  throw new InvalidDataException(SR.GenericInvalidData);                              }                              _length = s_lengthBase[_length] + bits;                          }                          _state = InflaterState.HaveFullLength;                          goto case InflaterState.HaveFullLength;                        case InflaterState.HaveFullLength:                          if (_blockType == BlockType.Dynamic)                          {                              _distanceCode = _distanceTree.GetNextSymbol(_input);                          }                          else                          {                              // get distance code directly for static block                              _distanceCode = _input.GetBits(5);                              if (_distanceCode >= 0)                              {                                  _distanceCode = s_staticDistanceTreeTable[_distanceCode];                              }                          }                            if (_distanceCode < 0)                          {                              // running out input                              return false;                          }                            _state = InflaterState.HaveDistCode;                          goto case InflaterState.HaveDistCode;                        case InflaterState.HaveDistCode:                          // To avoid a table lookup we note that for distanceCode > 3'                          // extra_bits = (distanceCode-2) >> 1                          int offset;                          if (_distanceCode > 3)                          {                              _extraBits = (_distanceCode - 2) >> 1;                              int bits = _input.GetBits(_extraBits);                              if (bits < 0)                              {                                  return false;                              }                              offset = s_distanceBasePosition[_distanceCode] + bits;                          }                          else                          {                              offset = _distanceCode + 1;                          }                            _output.WriteLengthDistance(_length' offset);                          freeBytes -= _length;                          _state = InflaterState.DecodeTop;                          break;                        default:                          Debug.Fail("check why we are here!");                          throw new InvalidDataException(SR.UnknownState);                  }              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeBlock,The following statement contains a magic number: while (freeBytes > 65536)              {                  // With Deflate64 we can have up to a 64kb length' so we ensure at least that much space is available                  // in the OutputWindow to avoid overwriting previous unflushed output data.                    int symbol;                  switch (_state)                  {                      case InflaterState.DecodeTop:                          // decode an element from the literal tree                            // TODO: optimize this!!!                          symbol = _literalLengthTree.GetNextSymbol(_input);                          if (symbol < 0)                          {                              // running out of input                              return false;                          }                            if (symbol < 256)                          {                              // literal                              _output.Write((byte)symbol);                              --freeBytes;                          }                          else if (symbol == 256)                          {                              // end of block                              end_of_block_code_seen = true;                              // Reset state                              _state = InflaterState.ReadingBFinal;                              return true;                          }                          else                          {                              // length/distance pair                              symbol -= 257;     // length code started at 257                              if (symbol < 8)                              {                                  symbol += 3;   // match length = 3'4'5'6'7'8'9'10                                  _extraBits = 0;                              }                              else if (!_deflate64 && symbol == 28)                              {                                  // extra bits for code 285 is 0                                  symbol = 258;             // code 285 means length 258                                  _extraBits = 0;                              }                              else                              {                                  if (symbol < 0 || symbol >= s_extraLengthBits.Length)                                  {                                      throw new InvalidDataException(SR.GenericInvalidData);                                  }                                  _extraBits = s_extraLengthBits[symbol];                                  Debug.Assert(_extraBits != 0' "We handle other cases separately!");                              }                              _length = symbol;                              goto case InflaterState.HaveInitialLength;                          }                          break;                        case InflaterState.HaveInitialLength:                          if (_extraBits > 0)                          {                              _state = InflaterState.HaveInitialLength;                              int bits = _input.GetBits(_extraBits);                              if (bits < 0)                              {                                  return false;                              }                                if (_length < 0 || _length >= s_lengthBase.Length)                              {                                  throw new InvalidDataException(SR.GenericInvalidData);                              }                              _length = s_lengthBase[_length] + bits;                          }                          _state = InflaterState.HaveFullLength;                          goto case InflaterState.HaveFullLength;                        case InflaterState.HaveFullLength:                          if (_blockType == BlockType.Dynamic)                          {                              _distanceCode = _distanceTree.GetNextSymbol(_input);                          }                          else                          {                              // get distance code directly for static block                              _distanceCode = _input.GetBits(5);                              if (_distanceCode >= 0)                              {                                  _distanceCode = s_staticDistanceTreeTable[_distanceCode];                              }                          }                            if (_distanceCode < 0)                          {                              // running out input                              return false;                          }                            _state = InflaterState.HaveDistCode;                          goto case InflaterState.HaveDistCode;                        case InflaterState.HaveDistCode:                          // To avoid a table lookup we note that for distanceCode > 3'                          // extra_bits = (distanceCode-2) >> 1                          int offset;                          if (_distanceCode > 3)                          {                              _extraBits = (_distanceCode - 2) >> 1;                              int bits = _input.GetBits(_extraBits);                              if (bits < 0)                              {                                  return false;                              }                              offset = s_distanceBasePosition[_distanceCode] + bits;                          }                          else                          {                              offset = _distanceCode + 1;                          }                            _output.WriteLengthDistance(_length' offset);                          freeBytes -= _length;                          _state = InflaterState.DecodeTop;                          break;                        default:                          Debug.Fail("check why we are here!");                          throw new InvalidDataException(SR.UnknownState);                  }              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeBlock,The following statement contains a magic number: while (freeBytes > 65536)              {                  // With Deflate64 we can have up to a 64kb length' so we ensure at least that much space is available                  // in the OutputWindow to avoid overwriting previous unflushed output data.                    int symbol;                  switch (_state)                  {                      case InflaterState.DecodeTop:                          // decode an element from the literal tree                            // TODO: optimize this!!!                          symbol = _literalLengthTree.GetNextSymbol(_input);                          if (symbol < 0)                          {                              // running out of input                              return false;                          }                            if (symbol < 256)                          {                              // literal                              _output.Write((byte)symbol);                              --freeBytes;                          }                          else if (symbol == 256)                          {                              // end of block                              end_of_block_code_seen = true;                              // Reset state                              _state = InflaterState.ReadingBFinal;                              return true;                          }                          else                          {                              // length/distance pair                              symbol -= 257;     // length code started at 257                              if (symbol < 8)                              {                                  symbol += 3;   // match length = 3'4'5'6'7'8'9'10                                  _extraBits = 0;                              }                              else if (!_deflate64 && symbol == 28)                              {                                  // extra bits for code 285 is 0                                  symbol = 258;             // code 285 means length 258                                  _extraBits = 0;                              }                              else                              {                                  if (symbol < 0 || symbol >= s_extraLengthBits.Length)                                  {                                      throw new InvalidDataException(SR.GenericInvalidData);                                  }                                  _extraBits = s_extraLengthBits[symbol];                                  Debug.Assert(_extraBits != 0' "We handle other cases separately!");                              }                              _length = symbol;                              goto case InflaterState.HaveInitialLength;                          }                          break;                        case InflaterState.HaveInitialLength:                          if (_extraBits > 0)                          {                              _state = InflaterState.HaveInitialLength;                              int bits = _input.GetBits(_extraBits);                              if (bits < 0)                              {                                  return false;                              }                                if (_length < 0 || _length >= s_lengthBase.Length)                              {                                  throw new InvalidDataException(SR.GenericInvalidData);                              }                              _length = s_lengthBase[_length] + bits;                          }                          _state = InflaterState.HaveFullLength;                          goto case InflaterState.HaveFullLength;                        case InflaterState.HaveFullLength:                          if (_blockType == BlockType.Dynamic)                          {                              _distanceCode = _distanceTree.GetNextSymbol(_input);                          }                          else                          {                              // get distance code directly for static block                              _distanceCode = _input.GetBits(5);                              if (_distanceCode >= 0)                              {                                  _distanceCode = s_staticDistanceTreeTable[_distanceCode];                              }                          }                            if (_distanceCode < 0)                          {                              // running out input                              return false;                          }                            _state = InflaterState.HaveDistCode;                          goto case InflaterState.HaveDistCode;                        case InflaterState.HaveDistCode:                          // To avoid a table lookup we note that for distanceCode > 3'                          // extra_bits = (distanceCode-2) >> 1                          int offset;                          if (_distanceCode > 3)                          {                              _extraBits = (_distanceCode - 2) >> 1;                              int bits = _input.GetBits(_extraBits);                              if (bits < 0)                              {                                  return false;                              }                              offset = s_distanceBasePosition[_distanceCode] + bits;                          }                          else                          {                              offset = _distanceCode + 1;                          }                            _output.WriteLengthDistance(_length' offset);                          freeBytes -= _length;                          _state = InflaterState.DecodeTop;                          break;                        default:                          Debug.Fail("check why we are here!");                          throw new InvalidDataException(SR.UnknownState);                  }              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeBlock,The following statement contains a magic number: while (freeBytes > 65536)              {                  // With Deflate64 we can have up to a 64kb length' so we ensure at least that much space is available                  // in the OutputWindow to avoid overwriting previous unflushed output data.                    int symbol;                  switch (_state)                  {                      case InflaterState.DecodeTop:                          // decode an element from the literal tree                            // TODO: optimize this!!!                          symbol = _literalLengthTree.GetNextSymbol(_input);                          if (symbol < 0)                          {                              // running out of input                              return false;                          }                            if (symbol < 256)                          {                              // literal                              _output.Write((byte)symbol);                              --freeBytes;                          }                          else if (symbol == 256)                          {                              // end of block                              end_of_block_code_seen = true;                              // Reset state                              _state = InflaterState.ReadingBFinal;                              return true;                          }                          else                          {                              // length/distance pair                              symbol -= 257;     // length code started at 257                              if (symbol < 8)                              {                                  symbol += 3;   // match length = 3'4'5'6'7'8'9'10                                  _extraBits = 0;                              }                              else if (!_deflate64 && symbol == 28)                              {                                  // extra bits for code 285 is 0                                  symbol = 258;             // code 285 means length 258                                  _extraBits = 0;                              }                              else                              {                                  if (symbol < 0 || symbol >= s_extraLengthBits.Length)                                  {                                      throw new InvalidDataException(SR.GenericInvalidData);                                  }                                  _extraBits = s_extraLengthBits[symbol];                                  Debug.Assert(_extraBits != 0' "We handle other cases separately!");                              }                              _length = symbol;                              goto case InflaterState.HaveInitialLength;                          }                          break;                        case InflaterState.HaveInitialLength:                          if (_extraBits > 0)                          {                              _state = InflaterState.HaveInitialLength;                              int bits = _input.GetBits(_extraBits);                              if (bits < 0)                              {                                  return false;                              }                                if (_length < 0 || _length >= s_lengthBase.Length)                              {                                  throw new InvalidDataException(SR.GenericInvalidData);                              }                              _length = s_lengthBase[_length] + bits;                          }                          _state = InflaterState.HaveFullLength;                          goto case InflaterState.HaveFullLength;                        case InflaterState.HaveFullLength:                          if (_blockType == BlockType.Dynamic)                          {                              _distanceCode = _distanceTree.GetNextSymbol(_input);                          }                          else                          {                              // get distance code directly for static block                              _distanceCode = _input.GetBits(5);                              if (_distanceCode >= 0)                              {                                  _distanceCode = s_staticDistanceTreeTable[_distanceCode];                              }                          }                            if (_distanceCode < 0)                          {                              // running out input                              return false;                          }                            _state = InflaterState.HaveDistCode;                          goto case InflaterState.HaveDistCode;                        case InflaterState.HaveDistCode:                          // To avoid a table lookup we note that for distanceCode > 3'                          // extra_bits = (distanceCode-2) >> 1                          int offset;                          if (_distanceCode > 3)                          {                              _extraBits = (_distanceCode - 2) >> 1;                              int bits = _input.GetBits(_extraBits);                              if (bits < 0)                              {                                  return false;                              }                              offset = s_distanceBasePosition[_distanceCode] + bits;                          }                          else                          {                              offset = _distanceCode + 1;                          }                            _output.WriteLengthDistance(_length' offset);                          freeBytes -= _length;                          _state = InflaterState.DecodeTop;                          break;                        default:                          Debug.Fail("check why we are here!");                          throw new InvalidDataException(SR.UnknownState);                  }              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeBlock,The following statement contains a magic number: while (freeBytes > 65536)              {                  // With Deflate64 we can have up to a 64kb length' so we ensure at least that much space is available                  // in the OutputWindow to avoid overwriting previous unflushed output data.                    int symbol;                  switch (_state)                  {                      case InflaterState.DecodeTop:                          // decode an element from the literal tree                            // TODO: optimize this!!!                          symbol = _literalLengthTree.GetNextSymbol(_input);                          if (symbol < 0)                          {                              // running out of input                              return false;                          }                            if (symbol < 256)                          {                              // literal                              _output.Write((byte)symbol);                              --freeBytes;                          }                          else if (symbol == 256)                          {                              // end of block                              end_of_block_code_seen = true;                              // Reset state                              _state = InflaterState.ReadingBFinal;                              return true;                          }                          else                          {                              // length/distance pair                              symbol -= 257;     // length code started at 257                              if (symbol < 8)                              {                                  symbol += 3;   // match length = 3'4'5'6'7'8'9'10                                  _extraBits = 0;                              }                              else if (!_deflate64 && symbol == 28)                              {                                  // extra bits for code 285 is 0                                  symbol = 258;             // code 285 means length 258                                  _extraBits = 0;                              }                              else                              {                                  if (symbol < 0 || symbol >= s_extraLengthBits.Length)                                  {                                      throw new InvalidDataException(SR.GenericInvalidData);                                  }                                  _extraBits = s_extraLengthBits[symbol];                                  Debug.Assert(_extraBits != 0' "We handle other cases separately!");                              }                              _length = symbol;                              goto case InflaterState.HaveInitialLength;                          }                          break;                        case InflaterState.HaveInitialLength:                          if (_extraBits > 0)                          {                              _state = InflaterState.HaveInitialLength;                              int bits = _input.GetBits(_extraBits);                              if (bits < 0)                              {                                  return false;                              }                                if (_length < 0 || _length >= s_lengthBase.Length)                              {                                  throw new InvalidDataException(SR.GenericInvalidData);                              }                              _length = s_lengthBase[_length] + bits;                          }                          _state = InflaterState.HaveFullLength;                          goto case InflaterState.HaveFullLength;                        case InflaterState.HaveFullLength:                          if (_blockType == BlockType.Dynamic)                          {                              _distanceCode = _distanceTree.GetNextSymbol(_input);                          }                          else                          {                              // get distance code directly for static block                              _distanceCode = _input.GetBits(5);                              if (_distanceCode >= 0)                              {                                  _distanceCode = s_staticDistanceTreeTable[_distanceCode];                              }                          }                            if (_distanceCode < 0)                          {                              // running out input                              return false;                          }                            _state = InflaterState.HaveDistCode;                          goto case InflaterState.HaveDistCode;                        case InflaterState.HaveDistCode:                          // To avoid a table lookup we note that for distanceCode > 3'                          // extra_bits = (distanceCode-2) >> 1                          int offset;                          if (_distanceCode > 3)                          {                              _extraBits = (_distanceCode - 2) >> 1;                              int bits = _input.GetBits(_extraBits);                              if (bits < 0)                              {                                  return false;                              }                              offset = s_distanceBasePosition[_distanceCode] + bits;                          }                          else                          {                              offset = _distanceCode + 1;                          }                            _output.WriteLengthDistance(_length' offset);                          freeBytes -= _length;                          _state = InflaterState.DecodeTop;                          break;                        default:                          Debug.Fail("check why we are here!");                          throw new InvalidDataException(SR.UnknownState);                  }              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeDynamicBlockHeader,The following statement contains a magic number: switch (_state)              {                  case InflaterState.ReadingNumLitCodes:                      _literalLengthCodeCount = _input.GetBits(5);                      if (_literalLengthCodeCount < 0)                      {                          return false;                      }                      _literalLengthCodeCount += 257;                      _state = InflaterState.ReadingNumDistCodes;                      goto case InflaterState.ReadingNumDistCodes;                    case InflaterState.ReadingNumDistCodes:                      _distanceCodeCount = _input.GetBits(5);                      if (_distanceCodeCount < 0)                      {                          return false;                      }                      _distanceCodeCount += 1;                      _state = InflaterState.ReadingNumCodeLengthCodes;                      goto case InflaterState.ReadingNumCodeLengthCodes;                    case InflaterState.ReadingNumCodeLengthCodes:                      _codeLengthCodeCount = _input.GetBits(4);                      if (_codeLengthCodeCount < 0)                      {                          return false;                      }                      _codeLengthCodeCount += 4;                      _loopCounter = 0;                      _state = InflaterState.ReadingCodeLengthCodes;                      goto case InflaterState.ReadingCodeLengthCodes;                    case InflaterState.ReadingCodeLengthCodes:                      while (_loopCounter < _codeLengthCodeCount)                      {                          int bits = _input.GetBits(3);                          if (bits < 0)                          {                              return false;                          }                          _codeLengthTreeCodeLength[s_codeOrder[_loopCounter]] = (byte)bits;                          ++_loopCounter;                      }                        for (int i = _codeLengthCodeCount; i < s_codeOrder.Length; i++)                      {                          _codeLengthTreeCodeLength[s_codeOrder[i]] = 0;                      }                        // create huffman tree for code length                      _codeLengthTree = new HuffmanTree(_codeLengthTreeCodeLength);                      _codeArraySize = _literalLengthCodeCount + _distanceCodeCount;                      _loopCounter = 0; // reset loop count                        _state = InflaterState.ReadingTreeCodesBefore;                      goto case InflaterState.ReadingTreeCodesBefore;                    case InflaterState.ReadingTreeCodesBefore:                  case InflaterState.ReadingTreeCodesAfter:                      while (_loopCounter < _codeArraySize)                      {                          if (_state == InflaterState.ReadingTreeCodesBefore)                          {                              if ((_lengthCode = _codeLengthTree.GetNextSymbol(_input)) < 0)                              {                                  return false;                              }                          }                            // The alphabet for code lengths is as follows:                          //  0 - 15: Represent code lengths of 0 - 15                          //  16: Copy the previous code length 3 - 6 times.                          //  The next 2 bits indicate repeat length                          //         (0 = 3' ... ' 3 = 6)                          //      Example:  Codes 8' 16 (+2 bits 11)'                          //                16 (+2 bits 10) will expand to                          //                12 code lengths of 8 (1 + 6 + 5)                          //  17: Repeat a code length of 0 for 3 - 10 times.                          //    (3 bits of length)                          //  18: Repeat a code length of 0 for 11 - 138 times                          //    (7 bits of length)                          if (_lengthCode <= 15)                          {                              _codeList[_loopCounter++] = (byte)_lengthCode;                          }                          else                          {                              int repeatCount;                              if (_lengthCode == 16)                              {                                  if (!_input.EnsureBitsAvailable(2))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    if (_loopCounter == 0)                                  {                                      // can't have "prev code" on first code                                      throw new InvalidDataException();                                  }                                    byte previousCode = _codeList[_loopCounter - 1];                                  repeatCount = _input.GetBits(2) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = previousCode;                                  }                              }                              else if (_lengthCode == 17)                              {                                  if (!_input.EnsureBitsAvailable(3))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(3) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                              else                              {                                  // code == 18                                  if (!_input.EnsureBitsAvailable(7))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(7) + 11;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                          }                          _state = InflaterState.ReadingTreeCodesBefore; // we want to read the next code.                      }                      break;                    default:                      Debug.Fail("check why we are here!");                      throw new InvalidDataException(SR.UnknownState);              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeDynamicBlockHeader,The following statement contains a magic number: switch (_state)              {                  case InflaterState.ReadingNumLitCodes:                      _literalLengthCodeCount = _input.GetBits(5);                      if (_literalLengthCodeCount < 0)                      {                          return false;                      }                      _literalLengthCodeCount += 257;                      _state = InflaterState.ReadingNumDistCodes;                      goto case InflaterState.ReadingNumDistCodes;                    case InflaterState.ReadingNumDistCodes:                      _distanceCodeCount = _input.GetBits(5);                      if (_distanceCodeCount < 0)                      {                          return false;                      }                      _distanceCodeCount += 1;                      _state = InflaterState.ReadingNumCodeLengthCodes;                      goto case InflaterState.ReadingNumCodeLengthCodes;                    case InflaterState.ReadingNumCodeLengthCodes:                      _codeLengthCodeCount = _input.GetBits(4);                      if (_codeLengthCodeCount < 0)                      {                          return false;                      }                      _codeLengthCodeCount += 4;                      _loopCounter = 0;                      _state = InflaterState.ReadingCodeLengthCodes;                      goto case InflaterState.ReadingCodeLengthCodes;                    case InflaterState.ReadingCodeLengthCodes:                      while (_loopCounter < _codeLengthCodeCount)                      {                          int bits = _input.GetBits(3);                          if (bits < 0)                          {                              return false;                          }                          _codeLengthTreeCodeLength[s_codeOrder[_loopCounter]] = (byte)bits;                          ++_loopCounter;                      }                        for (int i = _codeLengthCodeCount; i < s_codeOrder.Length; i++)                      {                          _codeLengthTreeCodeLength[s_codeOrder[i]] = 0;                      }                        // create huffman tree for code length                      _codeLengthTree = new HuffmanTree(_codeLengthTreeCodeLength);                      _codeArraySize = _literalLengthCodeCount + _distanceCodeCount;                      _loopCounter = 0; // reset loop count                        _state = InflaterState.ReadingTreeCodesBefore;                      goto case InflaterState.ReadingTreeCodesBefore;                    case InflaterState.ReadingTreeCodesBefore:                  case InflaterState.ReadingTreeCodesAfter:                      while (_loopCounter < _codeArraySize)                      {                          if (_state == InflaterState.ReadingTreeCodesBefore)                          {                              if ((_lengthCode = _codeLengthTree.GetNextSymbol(_input)) < 0)                              {                                  return false;                              }                          }                            // The alphabet for code lengths is as follows:                          //  0 - 15: Represent code lengths of 0 - 15                          //  16: Copy the previous code length 3 - 6 times.                          //  The next 2 bits indicate repeat length                          //         (0 = 3' ... ' 3 = 6)                          //      Example:  Codes 8' 16 (+2 bits 11)'                          //                16 (+2 bits 10) will expand to                          //                12 code lengths of 8 (1 + 6 + 5)                          //  17: Repeat a code length of 0 for 3 - 10 times.                          //    (3 bits of length)                          //  18: Repeat a code length of 0 for 11 - 138 times                          //    (7 bits of length)                          if (_lengthCode <= 15)                          {                              _codeList[_loopCounter++] = (byte)_lengthCode;                          }                          else                          {                              int repeatCount;                              if (_lengthCode == 16)                              {                                  if (!_input.EnsureBitsAvailable(2))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    if (_loopCounter == 0)                                  {                                      // can't have "prev code" on first code                                      throw new InvalidDataException();                                  }                                    byte previousCode = _codeList[_loopCounter - 1];                                  repeatCount = _input.GetBits(2) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = previousCode;                                  }                              }                              else if (_lengthCode == 17)                              {                                  if (!_input.EnsureBitsAvailable(3))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(3) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                              else                              {                                  // code == 18                                  if (!_input.EnsureBitsAvailable(7))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(7) + 11;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                          }                          _state = InflaterState.ReadingTreeCodesBefore; // we want to read the next code.                      }                      break;                    default:                      Debug.Fail("check why we are here!");                      throw new InvalidDataException(SR.UnknownState);              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeDynamicBlockHeader,The following statement contains a magic number: switch (_state)              {                  case InflaterState.ReadingNumLitCodes:                      _literalLengthCodeCount = _input.GetBits(5);                      if (_literalLengthCodeCount < 0)                      {                          return false;                      }                      _literalLengthCodeCount += 257;                      _state = InflaterState.ReadingNumDistCodes;                      goto case InflaterState.ReadingNumDistCodes;                    case InflaterState.ReadingNumDistCodes:                      _distanceCodeCount = _input.GetBits(5);                      if (_distanceCodeCount < 0)                      {                          return false;                      }                      _distanceCodeCount += 1;                      _state = InflaterState.ReadingNumCodeLengthCodes;                      goto case InflaterState.ReadingNumCodeLengthCodes;                    case InflaterState.ReadingNumCodeLengthCodes:                      _codeLengthCodeCount = _input.GetBits(4);                      if (_codeLengthCodeCount < 0)                      {                          return false;                      }                      _codeLengthCodeCount += 4;                      _loopCounter = 0;                      _state = InflaterState.ReadingCodeLengthCodes;                      goto case InflaterState.ReadingCodeLengthCodes;                    case InflaterState.ReadingCodeLengthCodes:                      while (_loopCounter < _codeLengthCodeCount)                      {                          int bits = _input.GetBits(3);                          if (bits < 0)                          {                              return false;                          }                          _codeLengthTreeCodeLength[s_codeOrder[_loopCounter]] = (byte)bits;                          ++_loopCounter;                      }                        for (int i = _codeLengthCodeCount; i < s_codeOrder.Length; i++)                      {                          _codeLengthTreeCodeLength[s_codeOrder[i]] = 0;                      }                        // create huffman tree for code length                      _codeLengthTree = new HuffmanTree(_codeLengthTreeCodeLength);                      _codeArraySize = _literalLengthCodeCount + _distanceCodeCount;                      _loopCounter = 0; // reset loop count                        _state = InflaterState.ReadingTreeCodesBefore;                      goto case InflaterState.ReadingTreeCodesBefore;                    case InflaterState.ReadingTreeCodesBefore:                  case InflaterState.ReadingTreeCodesAfter:                      while (_loopCounter < _codeArraySize)                      {                          if (_state == InflaterState.ReadingTreeCodesBefore)                          {                              if ((_lengthCode = _codeLengthTree.GetNextSymbol(_input)) < 0)                              {                                  return false;                              }                          }                            // The alphabet for code lengths is as follows:                          //  0 - 15: Represent code lengths of 0 - 15                          //  16: Copy the previous code length 3 - 6 times.                          //  The next 2 bits indicate repeat length                          //         (0 = 3' ... ' 3 = 6)                          //      Example:  Codes 8' 16 (+2 bits 11)'                          //                16 (+2 bits 10) will expand to                          //                12 code lengths of 8 (1 + 6 + 5)                          //  17: Repeat a code length of 0 for 3 - 10 times.                          //    (3 bits of length)                          //  18: Repeat a code length of 0 for 11 - 138 times                          //    (7 bits of length)                          if (_lengthCode <= 15)                          {                              _codeList[_loopCounter++] = (byte)_lengthCode;                          }                          else                          {                              int repeatCount;                              if (_lengthCode == 16)                              {                                  if (!_input.EnsureBitsAvailable(2))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    if (_loopCounter == 0)                                  {                                      // can't have "prev code" on first code                                      throw new InvalidDataException();                                  }                                    byte previousCode = _codeList[_loopCounter - 1];                                  repeatCount = _input.GetBits(2) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = previousCode;                                  }                              }                              else if (_lengthCode == 17)                              {                                  if (!_input.EnsureBitsAvailable(3))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(3) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                              else                              {                                  // code == 18                                  if (!_input.EnsureBitsAvailable(7))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(7) + 11;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                          }                          _state = InflaterState.ReadingTreeCodesBefore; // we want to read the next code.                      }                      break;                    default:                      Debug.Fail("check why we are here!");                      throw new InvalidDataException(SR.UnknownState);              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeDynamicBlockHeader,The following statement contains a magic number: switch (_state)              {                  case InflaterState.ReadingNumLitCodes:                      _literalLengthCodeCount = _input.GetBits(5);                      if (_literalLengthCodeCount < 0)                      {                          return false;                      }                      _literalLengthCodeCount += 257;                      _state = InflaterState.ReadingNumDistCodes;                      goto case InflaterState.ReadingNumDistCodes;                    case InflaterState.ReadingNumDistCodes:                      _distanceCodeCount = _input.GetBits(5);                      if (_distanceCodeCount < 0)                      {                          return false;                      }                      _distanceCodeCount += 1;                      _state = InflaterState.ReadingNumCodeLengthCodes;                      goto case InflaterState.ReadingNumCodeLengthCodes;                    case InflaterState.ReadingNumCodeLengthCodes:                      _codeLengthCodeCount = _input.GetBits(4);                      if (_codeLengthCodeCount < 0)                      {                          return false;                      }                      _codeLengthCodeCount += 4;                      _loopCounter = 0;                      _state = InflaterState.ReadingCodeLengthCodes;                      goto case InflaterState.ReadingCodeLengthCodes;                    case InflaterState.ReadingCodeLengthCodes:                      while (_loopCounter < _codeLengthCodeCount)                      {                          int bits = _input.GetBits(3);                          if (bits < 0)                          {                              return false;                          }                          _codeLengthTreeCodeLength[s_codeOrder[_loopCounter]] = (byte)bits;                          ++_loopCounter;                      }                        for (int i = _codeLengthCodeCount; i < s_codeOrder.Length; i++)                      {                          _codeLengthTreeCodeLength[s_codeOrder[i]] = 0;                      }                        // create huffman tree for code length                      _codeLengthTree = new HuffmanTree(_codeLengthTreeCodeLength);                      _codeArraySize = _literalLengthCodeCount + _distanceCodeCount;                      _loopCounter = 0; // reset loop count                        _state = InflaterState.ReadingTreeCodesBefore;                      goto case InflaterState.ReadingTreeCodesBefore;                    case InflaterState.ReadingTreeCodesBefore:                  case InflaterState.ReadingTreeCodesAfter:                      while (_loopCounter < _codeArraySize)                      {                          if (_state == InflaterState.ReadingTreeCodesBefore)                          {                              if ((_lengthCode = _codeLengthTree.GetNextSymbol(_input)) < 0)                              {                                  return false;                              }                          }                            // The alphabet for code lengths is as follows:                          //  0 - 15: Represent code lengths of 0 - 15                          //  16: Copy the previous code length 3 - 6 times.                          //  The next 2 bits indicate repeat length                          //         (0 = 3' ... ' 3 = 6)                          //      Example:  Codes 8' 16 (+2 bits 11)'                          //                16 (+2 bits 10) will expand to                          //                12 code lengths of 8 (1 + 6 + 5)                          //  17: Repeat a code length of 0 for 3 - 10 times.                          //    (3 bits of length)                          //  18: Repeat a code length of 0 for 11 - 138 times                          //    (7 bits of length)                          if (_lengthCode <= 15)                          {                              _codeList[_loopCounter++] = (byte)_lengthCode;                          }                          else                          {                              int repeatCount;                              if (_lengthCode == 16)                              {                                  if (!_input.EnsureBitsAvailable(2))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    if (_loopCounter == 0)                                  {                                      // can't have "prev code" on first code                                      throw new InvalidDataException();                                  }                                    byte previousCode = _codeList[_loopCounter - 1];                                  repeatCount = _input.GetBits(2) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = previousCode;                                  }                              }                              else if (_lengthCode == 17)                              {                                  if (!_input.EnsureBitsAvailable(3))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(3) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                              else                              {                                  // code == 18                                  if (!_input.EnsureBitsAvailable(7))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(7) + 11;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                          }                          _state = InflaterState.ReadingTreeCodesBefore; // we want to read the next code.                      }                      break;                    default:                      Debug.Fail("check why we are here!");                      throw new InvalidDataException(SR.UnknownState);              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeDynamicBlockHeader,The following statement contains a magic number: switch (_state)              {                  case InflaterState.ReadingNumLitCodes:                      _literalLengthCodeCount = _input.GetBits(5);                      if (_literalLengthCodeCount < 0)                      {                          return false;                      }                      _literalLengthCodeCount += 257;                      _state = InflaterState.ReadingNumDistCodes;                      goto case InflaterState.ReadingNumDistCodes;                    case InflaterState.ReadingNumDistCodes:                      _distanceCodeCount = _input.GetBits(5);                      if (_distanceCodeCount < 0)                      {                          return false;                      }                      _distanceCodeCount += 1;                      _state = InflaterState.ReadingNumCodeLengthCodes;                      goto case InflaterState.ReadingNumCodeLengthCodes;                    case InflaterState.ReadingNumCodeLengthCodes:                      _codeLengthCodeCount = _input.GetBits(4);                      if (_codeLengthCodeCount < 0)                      {                          return false;                      }                      _codeLengthCodeCount += 4;                      _loopCounter = 0;                      _state = InflaterState.ReadingCodeLengthCodes;                      goto case InflaterState.ReadingCodeLengthCodes;                    case InflaterState.ReadingCodeLengthCodes:                      while (_loopCounter < _codeLengthCodeCount)                      {                          int bits = _input.GetBits(3);                          if (bits < 0)                          {                              return false;                          }                          _codeLengthTreeCodeLength[s_codeOrder[_loopCounter]] = (byte)bits;                          ++_loopCounter;                      }                        for (int i = _codeLengthCodeCount; i < s_codeOrder.Length; i++)                      {                          _codeLengthTreeCodeLength[s_codeOrder[i]] = 0;                      }                        // create huffman tree for code length                      _codeLengthTree = new HuffmanTree(_codeLengthTreeCodeLength);                      _codeArraySize = _literalLengthCodeCount + _distanceCodeCount;                      _loopCounter = 0; // reset loop count                        _state = InflaterState.ReadingTreeCodesBefore;                      goto case InflaterState.ReadingTreeCodesBefore;                    case InflaterState.ReadingTreeCodesBefore:                  case InflaterState.ReadingTreeCodesAfter:                      while (_loopCounter < _codeArraySize)                      {                          if (_state == InflaterState.ReadingTreeCodesBefore)                          {                              if ((_lengthCode = _codeLengthTree.GetNextSymbol(_input)) < 0)                              {                                  return false;                              }                          }                            // The alphabet for code lengths is as follows:                          //  0 - 15: Represent code lengths of 0 - 15                          //  16: Copy the previous code length 3 - 6 times.                          //  The next 2 bits indicate repeat length                          //         (0 = 3' ... ' 3 = 6)                          //      Example:  Codes 8' 16 (+2 bits 11)'                          //                16 (+2 bits 10) will expand to                          //                12 code lengths of 8 (1 + 6 + 5)                          //  17: Repeat a code length of 0 for 3 - 10 times.                          //    (3 bits of length)                          //  18: Repeat a code length of 0 for 11 - 138 times                          //    (7 bits of length)                          if (_lengthCode <= 15)                          {                              _codeList[_loopCounter++] = (byte)_lengthCode;                          }                          else                          {                              int repeatCount;                              if (_lengthCode == 16)                              {                                  if (!_input.EnsureBitsAvailable(2))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    if (_loopCounter == 0)                                  {                                      // can't have "prev code" on first code                                      throw new InvalidDataException();                                  }                                    byte previousCode = _codeList[_loopCounter - 1];                                  repeatCount = _input.GetBits(2) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = previousCode;                                  }                              }                              else if (_lengthCode == 17)                              {                                  if (!_input.EnsureBitsAvailable(3))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(3) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                              else                              {                                  // code == 18                                  if (!_input.EnsureBitsAvailable(7))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(7) + 11;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                          }                          _state = InflaterState.ReadingTreeCodesBefore; // we want to read the next code.                      }                      break;                    default:                      Debug.Fail("check why we are here!");                      throw new InvalidDataException(SR.UnknownState);              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeDynamicBlockHeader,The following statement contains a magic number: switch (_state)              {                  case InflaterState.ReadingNumLitCodes:                      _literalLengthCodeCount = _input.GetBits(5);                      if (_literalLengthCodeCount < 0)                      {                          return false;                      }                      _literalLengthCodeCount += 257;                      _state = InflaterState.ReadingNumDistCodes;                      goto case InflaterState.ReadingNumDistCodes;                    case InflaterState.ReadingNumDistCodes:                      _distanceCodeCount = _input.GetBits(5);                      if (_distanceCodeCount < 0)                      {                          return false;                      }                      _distanceCodeCount += 1;                      _state = InflaterState.ReadingNumCodeLengthCodes;                      goto case InflaterState.ReadingNumCodeLengthCodes;                    case InflaterState.ReadingNumCodeLengthCodes:                      _codeLengthCodeCount = _input.GetBits(4);                      if (_codeLengthCodeCount < 0)                      {                          return false;                      }                      _codeLengthCodeCount += 4;                      _loopCounter = 0;                      _state = InflaterState.ReadingCodeLengthCodes;                      goto case InflaterState.ReadingCodeLengthCodes;                    case InflaterState.ReadingCodeLengthCodes:                      while (_loopCounter < _codeLengthCodeCount)                      {                          int bits = _input.GetBits(3);                          if (bits < 0)                          {                              return false;                          }                          _codeLengthTreeCodeLength[s_codeOrder[_loopCounter]] = (byte)bits;                          ++_loopCounter;                      }                        for (int i = _codeLengthCodeCount; i < s_codeOrder.Length; i++)                      {                          _codeLengthTreeCodeLength[s_codeOrder[i]] = 0;                      }                        // create huffman tree for code length                      _codeLengthTree = new HuffmanTree(_codeLengthTreeCodeLength);                      _codeArraySize = _literalLengthCodeCount + _distanceCodeCount;                      _loopCounter = 0; // reset loop count                        _state = InflaterState.ReadingTreeCodesBefore;                      goto case InflaterState.ReadingTreeCodesBefore;                    case InflaterState.ReadingTreeCodesBefore:                  case InflaterState.ReadingTreeCodesAfter:                      while (_loopCounter < _codeArraySize)                      {                          if (_state == InflaterState.ReadingTreeCodesBefore)                          {                              if ((_lengthCode = _codeLengthTree.GetNextSymbol(_input)) < 0)                              {                                  return false;                              }                          }                            // The alphabet for code lengths is as follows:                          //  0 - 15: Represent code lengths of 0 - 15                          //  16: Copy the previous code length 3 - 6 times.                          //  The next 2 bits indicate repeat length                          //         (0 = 3' ... ' 3 = 6)                          //      Example:  Codes 8' 16 (+2 bits 11)'                          //                16 (+2 bits 10) will expand to                          //                12 code lengths of 8 (1 + 6 + 5)                          //  17: Repeat a code length of 0 for 3 - 10 times.                          //    (3 bits of length)                          //  18: Repeat a code length of 0 for 11 - 138 times                          //    (7 bits of length)                          if (_lengthCode <= 15)                          {                              _codeList[_loopCounter++] = (byte)_lengthCode;                          }                          else                          {                              int repeatCount;                              if (_lengthCode == 16)                              {                                  if (!_input.EnsureBitsAvailable(2))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    if (_loopCounter == 0)                                  {                                      // can't have "prev code" on first code                                      throw new InvalidDataException();                                  }                                    byte previousCode = _codeList[_loopCounter - 1];                                  repeatCount = _input.GetBits(2) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = previousCode;                                  }                              }                              else if (_lengthCode == 17)                              {                                  if (!_input.EnsureBitsAvailable(3))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(3) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                              else                              {                                  // code == 18                                  if (!_input.EnsureBitsAvailable(7))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(7) + 11;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                          }                          _state = InflaterState.ReadingTreeCodesBefore; // we want to read the next code.                      }                      break;                    default:                      Debug.Fail("check why we are here!");                      throw new InvalidDataException(SR.UnknownState);              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeDynamicBlockHeader,The following statement contains a magic number: switch (_state)              {                  case InflaterState.ReadingNumLitCodes:                      _literalLengthCodeCount = _input.GetBits(5);                      if (_literalLengthCodeCount < 0)                      {                          return false;                      }                      _literalLengthCodeCount += 257;                      _state = InflaterState.ReadingNumDistCodes;                      goto case InflaterState.ReadingNumDistCodes;                    case InflaterState.ReadingNumDistCodes:                      _distanceCodeCount = _input.GetBits(5);                      if (_distanceCodeCount < 0)                      {                          return false;                      }                      _distanceCodeCount += 1;                      _state = InflaterState.ReadingNumCodeLengthCodes;                      goto case InflaterState.ReadingNumCodeLengthCodes;                    case InflaterState.ReadingNumCodeLengthCodes:                      _codeLengthCodeCount = _input.GetBits(4);                      if (_codeLengthCodeCount < 0)                      {                          return false;                      }                      _codeLengthCodeCount += 4;                      _loopCounter = 0;                      _state = InflaterState.ReadingCodeLengthCodes;                      goto case InflaterState.ReadingCodeLengthCodes;                    case InflaterState.ReadingCodeLengthCodes:                      while (_loopCounter < _codeLengthCodeCount)                      {                          int bits = _input.GetBits(3);                          if (bits < 0)                          {                              return false;                          }                          _codeLengthTreeCodeLength[s_codeOrder[_loopCounter]] = (byte)bits;                          ++_loopCounter;                      }                        for (int i = _codeLengthCodeCount; i < s_codeOrder.Length; i++)                      {                          _codeLengthTreeCodeLength[s_codeOrder[i]] = 0;                      }                        // create huffman tree for code length                      _codeLengthTree = new HuffmanTree(_codeLengthTreeCodeLength);                      _codeArraySize = _literalLengthCodeCount + _distanceCodeCount;                      _loopCounter = 0; // reset loop count                        _state = InflaterState.ReadingTreeCodesBefore;                      goto case InflaterState.ReadingTreeCodesBefore;                    case InflaterState.ReadingTreeCodesBefore:                  case InflaterState.ReadingTreeCodesAfter:                      while (_loopCounter < _codeArraySize)                      {                          if (_state == InflaterState.ReadingTreeCodesBefore)                          {                              if ((_lengthCode = _codeLengthTree.GetNextSymbol(_input)) < 0)                              {                                  return false;                              }                          }                            // The alphabet for code lengths is as follows:                          //  0 - 15: Represent code lengths of 0 - 15                          //  16: Copy the previous code length 3 - 6 times.                          //  The next 2 bits indicate repeat length                          //         (0 = 3' ... ' 3 = 6)                          //      Example:  Codes 8' 16 (+2 bits 11)'                          //                16 (+2 bits 10) will expand to                          //                12 code lengths of 8 (1 + 6 + 5)                          //  17: Repeat a code length of 0 for 3 - 10 times.                          //    (3 bits of length)                          //  18: Repeat a code length of 0 for 11 - 138 times                          //    (7 bits of length)                          if (_lengthCode <= 15)                          {                              _codeList[_loopCounter++] = (byte)_lengthCode;                          }                          else                          {                              int repeatCount;                              if (_lengthCode == 16)                              {                                  if (!_input.EnsureBitsAvailable(2))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    if (_loopCounter == 0)                                  {                                      // can't have "prev code" on first code                                      throw new InvalidDataException();                                  }                                    byte previousCode = _codeList[_loopCounter - 1];                                  repeatCount = _input.GetBits(2) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = previousCode;                                  }                              }                              else if (_lengthCode == 17)                              {                                  if (!_input.EnsureBitsAvailable(3))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(3) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                              else                              {                                  // code == 18                                  if (!_input.EnsureBitsAvailable(7))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(7) + 11;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                          }                          _state = InflaterState.ReadingTreeCodesBefore; // we want to read the next code.                      }                      break;                    default:                      Debug.Fail("check why we are here!");                      throw new InvalidDataException(SR.UnknownState);              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeDynamicBlockHeader,The following statement contains a magic number: switch (_state)              {                  case InflaterState.ReadingNumLitCodes:                      _literalLengthCodeCount = _input.GetBits(5);                      if (_literalLengthCodeCount < 0)                      {                          return false;                      }                      _literalLengthCodeCount += 257;                      _state = InflaterState.ReadingNumDistCodes;                      goto case InflaterState.ReadingNumDistCodes;                    case InflaterState.ReadingNumDistCodes:                      _distanceCodeCount = _input.GetBits(5);                      if (_distanceCodeCount < 0)                      {                          return false;                      }                      _distanceCodeCount += 1;                      _state = InflaterState.ReadingNumCodeLengthCodes;                      goto case InflaterState.ReadingNumCodeLengthCodes;                    case InflaterState.ReadingNumCodeLengthCodes:                      _codeLengthCodeCount = _input.GetBits(4);                      if (_codeLengthCodeCount < 0)                      {                          return false;                      }                      _codeLengthCodeCount += 4;                      _loopCounter = 0;                      _state = InflaterState.ReadingCodeLengthCodes;                      goto case InflaterState.ReadingCodeLengthCodes;                    case InflaterState.ReadingCodeLengthCodes:                      while (_loopCounter < _codeLengthCodeCount)                      {                          int bits = _input.GetBits(3);                          if (bits < 0)                          {                              return false;                          }                          _codeLengthTreeCodeLength[s_codeOrder[_loopCounter]] = (byte)bits;                          ++_loopCounter;                      }                        for (int i = _codeLengthCodeCount; i < s_codeOrder.Length; i++)                      {                          _codeLengthTreeCodeLength[s_codeOrder[i]] = 0;                      }                        // create huffman tree for code length                      _codeLengthTree = new HuffmanTree(_codeLengthTreeCodeLength);                      _codeArraySize = _literalLengthCodeCount + _distanceCodeCount;                      _loopCounter = 0; // reset loop count                        _state = InflaterState.ReadingTreeCodesBefore;                      goto case InflaterState.ReadingTreeCodesBefore;                    case InflaterState.ReadingTreeCodesBefore:                  case InflaterState.ReadingTreeCodesAfter:                      while (_loopCounter < _codeArraySize)                      {                          if (_state == InflaterState.ReadingTreeCodesBefore)                          {                              if ((_lengthCode = _codeLengthTree.GetNextSymbol(_input)) < 0)                              {                                  return false;                              }                          }                            // The alphabet for code lengths is as follows:                          //  0 - 15: Represent code lengths of 0 - 15                          //  16: Copy the previous code length 3 - 6 times.                          //  The next 2 bits indicate repeat length                          //         (0 = 3' ... ' 3 = 6)                          //      Example:  Codes 8' 16 (+2 bits 11)'                          //                16 (+2 bits 10) will expand to                          //                12 code lengths of 8 (1 + 6 + 5)                          //  17: Repeat a code length of 0 for 3 - 10 times.                          //    (3 bits of length)                          //  18: Repeat a code length of 0 for 11 - 138 times                          //    (7 bits of length)                          if (_lengthCode <= 15)                          {                              _codeList[_loopCounter++] = (byte)_lengthCode;                          }                          else                          {                              int repeatCount;                              if (_lengthCode == 16)                              {                                  if (!_input.EnsureBitsAvailable(2))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    if (_loopCounter == 0)                                  {                                      // can't have "prev code" on first code                                      throw new InvalidDataException();                                  }                                    byte previousCode = _codeList[_loopCounter - 1];                                  repeatCount = _input.GetBits(2) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = previousCode;                                  }                              }                              else if (_lengthCode == 17)                              {                                  if (!_input.EnsureBitsAvailable(3))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(3) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                              else                              {                                  // code == 18                                  if (!_input.EnsureBitsAvailable(7))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(7) + 11;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                          }                          _state = InflaterState.ReadingTreeCodesBefore; // we want to read the next code.                      }                      break;                    default:                      Debug.Fail("check why we are here!");                      throw new InvalidDataException(SR.UnknownState);              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeDynamicBlockHeader,The following statement contains a magic number: switch (_state)              {                  case InflaterState.ReadingNumLitCodes:                      _literalLengthCodeCount = _input.GetBits(5);                      if (_literalLengthCodeCount < 0)                      {                          return false;                      }                      _literalLengthCodeCount += 257;                      _state = InflaterState.ReadingNumDistCodes;                      goto case InflaterState.ReadingNumDistCodes;                    case InflaterState.ReadingNumDistCodes:                      _distanceCodeCount = _input.GetBits(5);                      if (_distanceCodeCount < 0)                      {                          return false;                      }                      _distanceCodeCount += 1;                      _state = InflaterState.ReadingNumCodeLengthCodes;                      goto case InflaterState.ReadingNumCodeLengthCodes;                    case InflaterState.ReadingNumCodeLengthCodes:                      _codeLengthCodeCount = _input.GetBits(4);                      if (_codeLengthCodeCount < 0)                      {                          return false;                      }                      _codeLengthCodeCount += 4;                      _loopCounter = 0;                      _state = InflaterState.ReadingCodeLengthCodes;                      goto case InflaterState.ReadingCodeLengthCodes;                    case InflaterState.ReadingCodeLengthCodes:                      while (_loopCounter < _codeLengthCodeCount)                      {                          int bits = _input.GetBits(3);                          if (bits < 0)                          {                              return false;                          }                          _codeLengthTreeCodeLength[s_codeOrder[_loopCounter]] = (byte)bits;                          ++_loopCounter;                      }                        for (int i = _codeLengthCodeCount; i < s_codeOrder.Length; i++)                      {                          _codeLengthTreeCodeLength[s_codeOrder[i]] = 0;                      }                        // create huffman tree for code length                      _codeLengthTree = new HuffmanTree(_codeLengthTreeCodeLength);                      _codeArraySize = _literalLengthCodeCount + _distanceCodeCount;                      _loopCounter = 0; // reset loop count                        _state = InflaterState.ReadingTreeCodesBefore;                      goto case InflaterState.ReadingTreeCodesBefore;                    case InflaterState.ReadingTreeCodesBefore:                  case InflaterState.ReadingTreeCodesAfter:                      while (_loopCounter < _codeArraySize)                      {                          if (_state == InflaterState.ReadingTreeCodesBefore)                          {                              if ((_lengthCode = _codeLengthTree.GetNextSymbol(_input)) < 0)                              {                                  return false;                              }                          }                            // The alphabet for code lengths is as follows:                          //  0 - 15: Represent code lengths of 0 - 15                          //  16: Copy the previous code length 3 - 6 times.                          //  The next 2 bits indicate repeat length                          //         (0 = 3' ... ' 3 = 6)                          //      Example:  Codes 8' 16 (+2 bits 11)'                          //                16 (+2 bits 10) will expand to                          //                12 code lengths of 8 (1 + 6 + 5)                          //  17: Repeat a code length of 0 for 3 - 10 times.                          //    (3 bits of length)                          //  18: Repeat a code length of 0 for 11 - 138 times                          //    (7 bits of length)                          if (_lengthCode <= 15)                          {                              _codeList[_loopCounter++] = (byte)_lengthCode;                          }                          else                          {                              int repeatCount;                              if (_lengthCode == 16)                              {                                  if (!_input.EnsureBitsAvailable(2))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    if (_loopCounter == 0)                                  {                                      // can't have "prev code" on first code                                      throw new InvalidDataException();                                  }                                    byte previousCode = _codeList[_loopCounter - 1];                                  repeatCount = _input.GetBits(2) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = previousCode;                                  }                              }                              else if (_lengthCode == 17)                              {                                  if (!_input.EnsureBitsAvailable(3))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(3) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                              else                              {                                  // code == 18                                  if (!_input.EnsureBitsAvailable(7))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(7) + 11;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                          }                          _state = InflaterState.ReadingTreeCodesBefore; // we want to read the next code.                      }                      break;                    default:                      Debug.Fail("check why we are here!");                      throw new InvalidDataException(SR.UnknownState);              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeDynamicBlockHeader,The following statement contains a magic number: switch (_state)              {                  case InflaterState.ReadingNumLitCodes:                      _literalLengthCodeCount = _input.GetBits(5);                      if (_literalLengthCodeCount < 0)                      {                          return false;                      }                      _literalLengthCodeCount += 257;                      _state = InflaterState.ReadingNumDistCodes;                      goto case InflaterState.ReadingNumDistCodes;                    case InflaterState.ReadingNumDistCodes:                      _distanceCodeCount = _input.GetBits(5);                      if (_distanceCodeCount < 0)                      {                          return false;                      }                      _distanceCodeCount += 1;                      _state = InflaterState.ReadingNumCodeLengthCodes;                      goto case InflaterState.ReadingNumCodeLengthCodes;                    case InflaterState.ReadingNumCodeLengthCodes:                      _codeLengthCodeCount = _input.GetBits(4);                      if (_codeLengthCodeCount < 0)                      {                          return false;                      }                      _codeLengthCodeCount += 4;                      _loopCounter = 0;                      _state = InflaterState.ReadingCodeLengthCodes;                      goto case InflaterState.ReadingCodeLengthCodes;                    case InflaterState.ReadingCodeLengthCodes:                      while (_loopCounter < _codeLengthCodeCount)                      {                          int bits = _input.GetBits(3);                          if (bits < 0)                          {                              return false;                          }                          _codeLengthTreeCodeLength[s_codeOrder[_loopCounter]] = (byte)bits;                          ++_loopCounter;                      }                        for (int i = _codeLengthCodeCount; i < s_codeOrder.Length; i++)                      {                          _codeLengthTreeCodeLength[s_codeOrder[i]] = 0;                      }                        // create huffman tree for code length                      _codeLengthTree = new HuffmanTree(_codeLengthTreeCodeLength);                      _codeArraySize = _literalLengthCodeCount + _distanceCodeCount;                      _loopCounter = 0; // reset loop count                        _state = InflaterState.ReadingTreeCodesBefore;                      goto case InflaterState.ReadingTreeCodesBefore;                    case InflaterState.ReadingTreeCodesBefore:                  case InflaterState.ReadingTreeCodesAfter:                      while (_loopCounter < _codeArraySize)                      {                          if (_state == InflaterState.ReadingTreeCodesBefore)                          {                              if ((_lengthCode = _codeLengthTree.GetNextSymbol(_input)) < 0)                              {                                  return false;                              }                          }                            // The alphabet for code lengths is as follows:                          //  0 - 15: Represent code lengths of 0 - 15                          //  16: Copy the previous code length 3 - 6 times.                          //  The next 2 bits indicate repeat length                          //         (0 = 3' ... ' 3 = 6)                          //      Example:  Codes 8' 16 (+2 bits 11)'                          //                16 (+2 bits 10) will expand to                          //                12 code lengths of 8 (1 + 6 + 5)                          //  17: Repeat a code length of 0 for 3 - 10 times.                          //    (3 bits of length)                          //  18: Repeat a code length of 0 for 11 - 138 times                          //    (7 bits of length)                          if (_lengthCode <= 15)                          {                              _codeList[_loopCounter++] = (byte)_lengthCode;                          }                          else                          {                              int repeatCount;                              if (_lengthCode == 16)                              {                                  if (!_input.EnsureBitsAvailable(2))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    if (_loopCounter == 0)                                  {                                      // can't have "prev code" on first code                                      throw new InvalidDataException();                                  }                                    byte previousCode = _codeList[_loopCounter - 1];                                  repeatCount = _input.GetBits(2) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = previousCode;                                  }                              }                              else if (_lengthCode == 17)                              {                                  if (!_input.EnsureBitsAvailable(3))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(3) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                              else                              {                                  // code == 18                                  if (!_input.EnsureBitsAvailable(7))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(7) + 11;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                          }                          _state = InflaterState.ReadingTreeCodesBefore; // we want to read the next code.                      }                      break;                    default:                      Debug.Fail("check why we are here!");                      throw new InvalidDataException(SR.UnknownState);              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeDynamicBlockHeader,The following statement contains a magic number: switch (_state)              {                  case InflaterState.ReadingNumLitCodes:                      _literalLengthCodeCount = _input.GetBits(5);                      if (_literalLengthCodeCount < 0)                      {                          return false;                      }                      _literalLengthCodeCount += 257;                      _state = InflaterState.ReadingNumDistCodes;                      goto case InflaterState.ReadingNumDistCodes;                    case InflaterState.ReadingNumDistCodes:                      _distanceCodeCount = _input.GetBits(5);                      if (_distanceCodeCount < 0)                      {                          return false;                      }                      _distanceCodeCount += 1;                      _state = InflaterState.ReadingNumCodeLengthCodes;                      goto case InflaterState.ReadingNumCodeLengthCodes;                    case InflaterState.ReadingNumCodeLengthCodes:                      _codeLengthCodeCount = _input.GetBits(4);                      if (_codeLengthCodeCount < 0)                      {                          return false;                      }                      _codeLengthCodeCount += 4;                      _loopCounter = 0;                      _state = InflaterState.ReadingCodeLengthCodes;                      goto case InflaterState.ReadingCodeLengthCodes;                    case InflaterState.ReadingCodeLengthCodes:                      while (_loopCounter < _codeLengthCodeCount)                      {                          int bits = _input.GetBits(3);                          if (bits < 0)                          {                              return false;                          }                          _codeLengthTreeCodeLength[s_codeOrder[_loopCounter]] = (byte)bits;                          ++_loopCounter;                      }                        for (int i = _codeLengthCodeCount; i < s_codeOrder.Length; i++)                      {                          _codeLengthTreeCodeLength[s_codeOrder[i]] = 0;                      }                        // create huffman tree for code length                      _codeLengthTree = new HuffmanTree(_codeLengthTreeCodeLength);                      _codeArraySize = _literalLengthCodeCount + _distanceCodeCount;                      _loopCounter = 0; // reset loop count                        _state = InflaterState.ReadingTreeCodesBefore;                      goto case InflaterState.ReadingTreeCodesBefore;                    case InflaterState.ReadingTreeCodesBefore:                  case InflaterState.ReadingTreeCodesAfter:                      while (_loopCounter < _codeArraySize)                      {                          if (_state == InflaterState.ReadingTreeCodesBefore)                          {                              if ((_lengthCode = _codeLengthTree.GetNextSymbol(_input)) < 0)                              {                                  return false;                              }                          }                            // The alphabet for code lengths is as follows:                          //  0 - 15: Represent code lengths of 0 - 15                          //  16: Copy the previous code length 3 - 6 times.                          //  The next 2 bits indicate repeat length                          //         (0 = 3' ... ' 3 = 6)                          //      Example:  Codes 8' 16 (+2 bits 11)'                          //                16 (+2 bits 10) will expand to                          //                12 code lengths of 8 (1 + 6 + 5)                          //  17: Repeat a code length of 0 for 3 - 10 times.                          //    (3 bits of length)                          //  18: Repeat a code length of 0 for 11 - 138 times                          //    (7 bits of length)                          if (_lengthCode <= 15)                          {                              _codeList[_loopCounter++] = (byte)_lengthCode;                          }                          else                          {                              int repeatCount;                              if (_lengthCode == 16)                              {                                  if (!_input.EnsureBitsAvailable(2))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    if (_loopCounter == 0)                                  {                                      // can't have "prev code" on first code                                      throw new InvalidDataException();                                  }                                    byte previousCode = _codeList[_loopCounter - 1];                                  repeatCount = _input.GetBits(2) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = previousCode;                                  }                              }                              else if (_lengthCode == 17)                              {                                  if (!_input.EnsureBitsAvailable(3))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(3) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                              else                              {                                  // code == 18                                  if (!_input.EnsureBitsAvailable(7))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(7) + 11;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                          }                          _state = InflaterState.ReadingTreeCodesBefore; // we want to read the next code.                      }                      break;                    default:                      Debug.Fail("check why we are here!");                      throw new InvalidDataException(SR.UnknownState);              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeDynamicBlockHeader,The following statement contains a magic number: switch (_state)              {                  case InflaterState.ReadingNumLitCodes:                      _literalLengthCodeCount = _input.GetBits(5);                      if (_literalLengthCodeCount < 0)                      {                          return false;                      }                      _literalLengthCodeCount += 257;                      _state = InflaterState.ReadingNumDistCodes;                      goto case InflaterState.ReadingNumDistCodes;                    case InflaterState.ReadingNumDistCodes:                      _distanceCodeCount = _input.GetBits(5);                      if (_distanceCodeCount < 0)                      {                          return false;                      }                      _distanceCodeCount += 1;                      _state = InflaterState.ReadingNumCodeLengthCodes;                      goto case InflaterState.ReadingNumCodeLengthCodes;                    case InflaterState.ReadingNumCodeLengthCodes:                      _codeLengthCodeCount = _input.GetBits(4);                      if (_codeLengthCodeCount < 0)                      {                          return false;                      }                      _codeLengthCodeCount += 4;                      _loopCounter = 0;                      _state = InflaterState.ReadingCodeLengthCodes;                      goto case InflaterState.ReadingCodeLengthCodes;                    case InflaterState.ReadingCodeLengthCodes:                      while (_loopCounter < _codeLengthCodeCount)                      {                          int bits = _input.GetBits(3);                          if (bits < 0)                          {                              return false;                          }                          _codeLengthTreeCodeLength[s_codeOrder[_loopCounter]] = (byte)bits;                          ++_loopCounter;                      }                        for (int i = _codeLengthCodeCount; i < s_codeOrder.Length; i++)                      {                          _codeLengthTreeCodeLength[s_codeOrder[i]] = 0;                      }                        // create huffman tree for code length                      _codeLengthTree = new HuffmanTree(_codeLengthTreeCodeLength);                      _codeArraySize = _literalLengthCodeCount + _distanceCodeCount;                      _loopCounter = 0; // reset loop count                        _state = InflaterState.ReadingTreeCodesBefore;                      goto case InflaterState.ReadingTreeCodesBefore;                    case InflaterState.ReadingTreeCodesBefore:                  case InflaterState.ReadingTreeCodesAfter:                      while (_loopCounter < _codeArraySize)                      {                          if (_state == InflaterState.ReadingTreeCodesBefore)                          {                              if ((_lengthCode = _codeLengthTree.GetNextSymbol(_input)) < 0)                              {                                  return false;                              }                          }                            // The alphabet for code lengths is as follows:                          //  0 - 15: Represent code lengths of 0 - 15                          //  16: Copy the previous code length 3 - 6 times.                          //  The next 2 bits indicate repeat length                          //         (0 = 3' ... ' 3 = 6)                          //      Example:  Codes 8' 16 (+2 bits 11)'                          //                16 (+2 bits 10) will expand to                          //                12 code lengths of 8 (1 + 6 + 5)                          //  17: Repeat a code length of 0 for 3 - 10 times.                          //    (3 bits of length)                          //  18: Repeat a code length of 0 for 11 - 138 times                          //    (7 bits of length)                          if (_lengthCode <= 15)                          {                              _codeList[_loopCounter++] = (byte)_lengthCode;                          }                          else                          {                              int repeatCount;                              if (_lengthCode == 16)                              {                                  if (!_input.EnsureBitsAvailable(2))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    if (_loopCounter == 0)                                  {                                      // can't have "prev code" on first code                                      throw new InvalidDataException();                                  }                                    byte previousCode = _codeList[_loopCounter - 1];                                  repeatCount = _input.GetBits(2) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = previousCode;                                  }                              }                              else if (_lengthCode == 17)                              {                                  if (!_input.EnsureBitsAvailable(3))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(3) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                              else                              {                                  // code == 18                                  if (!_input.EnsureBitsAvailable(7))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(7) + 11;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                          }                          _state = InflaterState.ReadingTreeCodesBefore; // we want to read the next code.                      }                      break;                    default:                      Debug.Fail("check why we are here!");                      throw new InvalidDataException(SR.UnknownState);              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeDynamicBlockHeader,The following statement contains a magic number: switch (_state)              {                  case InflaterState.ReadingNumLitCodes:                      _literalLengthCodeCount = _input.GetBits(5);                      if (_literalLengthCodeCount < 0)                      {                          return false;                      }                      _literalLengthCodeCount += 257;                      _state = InflaterState.ReadingNumDistCodes;                      goto case InflaterState.ReadingNumDistCodes;                    case InflaterState.ReadingNumDistCodes:                      _distanceCodeCount = _input.GetBits(5);                      if (_distanceCodeCount < 0)                      {                          return false;                      }                      _distanceCodeCount += 1;                      _state = InflaterState.ReadingNumCodeLengthCodes;                      goto case InflaterState.ReadingNumCodeLengthCodes;                    case InflaterState.ReadingNumCodeLengthCodes:                      _codeLengthCodeCount = _input.GetBits(4);                      if (_codeLengthCodeCount < 0)                      {                          return false;                      }                      _codeLengthCodeCount += 4;                      _loopCounter = 0;                      _state = InflaterState.ReadingCodeLengthCodes;                      goto case InflaterState.ReadingCodeLengthCodes;                    case InflaterState.ReadingCodeLengthCodes:                      while (_loopCounter < _codeLengthCodeCount)                      {                          int bits = _input.GetBits(3);                          if (bits < 0)                          {                              return false;                          }                          _codeLengthTreeCodeLength[s_codeOrder[_loopCounter]] = (byte)bits;                          ++_loopCounter;                      }                        for (int i = _codeLengthCodeCount; i < s_codeOrder.Length; i++)                      {                          _codeLengthTreeCodeLength[s_codeOrder[i]] = 0;                      }                        // create huffman tree for code length                      _codeLengthTree = new HuffmanTree(_codeLengthTreeCodeLength);                      _codeArraySize = _literalLengthCodeCount + _distanceCodeCount;                      _loopCounter = 0; // reset loop count                        _state = InflaterState.ReadingTreeCodesBefore;                      goto case InflaterState.ReadingTreeCodesBefore;                    case InflaterState.ReadingTreeCodesBefore:                  case InflaterState.ReadingTreeCodesAfter:                      while (_loopCounter < _codeArraySize)                      {                          if (_state == InflaterState.ReadingTreeCodesBefore)                          {                              if ((_lengthCode = _codeLengthTree.GetNextSymbol(_input)) < 0)                              {                                  return false;                              }                          }                            // The alphabet for code lengths is as follows:                          //  0 - 15: Represent code lengths of 0 - 15                          //  16: Copy the previous code length 3 - 6 times.                          //  The next 2 bits indicate repeat length                          //         (0 = 3' ... ' 3 = 6)                          //      Example:  Codes 8' 16 (+2 bits 11)'                          //                16 (+2 bits 10) will expand to                          //                12 code lengths of 8 (1 + 6 + 5)                          //  17: Repeat a code length of 0 for 3 - 10 times.                          //    (3 bits of length)                          //  18: Repeat a code length of 0 for 11 - 138 times                          //    (7 bits of length)                          if (_lengthCode <= 15)                          {                              _codeList[_loopCounter++] = (byte)_lengthCode;                          }                          else                          {                              int repeatCount;                              if (_lengthCode == 16)                              {                                  if (!_input.EnsureBitsAvailable(2))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    if (_loopCounter == 0)                                  {                                      // can't have "prev code" on first code                                      throw new InvalidDataException();                                  }                                    byte previousCode = _codeList[_loopCounter - 1];                                  repeatCount = _input.GetBits(2) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = previousCode;                                  }                              }                              else if (_lengthCode == 17)                              {                                  if (!_input.EnsureBitsAvailable(3))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(3) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                              else                              {                                  // code == 18                                  if (!_input.EnsureBitsAvailable(7))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(7) + 11;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                          }                          _state = InflaterState.ReadingTreeCodesBefore; // we want to read the next code.                      }                      break;                    default:                      Debug.Fail("check why we are here!");                      throw new InvalidDataException(SR.UnknownState);              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeDynamicBlockHeader,The following statement contains a magic number: switch (_state)              {                  case InflaterState.ReadingNumLitCodes:                      _literalLengthCodeCount = _input.GetBits(5);                      if (_literalLengthCodeCount < 0)                      {                          return false;                      }                      _literalLengthCodeCount += 257;                      _state = InflaterState.ReadingNumDistCodes;                      goto case InflaterState.ReadingNumDistCodes;                    case InflaterState.ReadingNumDistCodes:                      _distanceCodeCount = _input.GetBits(5);                      if (_distanceCodeCount < 0)                      {                          return false;                      }                      _distanceCodeCount += 1;                      _state = InflaterState.ReadingNumCodeLengthCodes;                      goto case InflaterState.ReadingNumCodeLengthCodes;                    case InflaterState.ReadingNumCodeLengthCodes:                      _codeLengthCodeCount = _input.GetBits(4);                      if (_codeLengthCodeCount < 0)                      {                          return false;                      }                      _codeLengthCodeCount += 4;                      _loopCounter = 0;                      _state = InflaterState.ReadingCodeLengthCodes;                      goto case InflaterState.ReadingCodeLengthCodes;                    case InflaterState.ReadingCodeLengthCodes:                      while (_loopCounter < _codeLengthCodeCount)                      {                          int bits = _input.GetBits(3);                          if (bits < 0)                          {                              return false;                          }                          _codeLengthTreeCodeLength[s_codeOrder[_loopCounter]] = (byte)bits;                          ++_loopCounter;                      }                        for (int i = _codeLengthCodeCount; i < s_codeOrder.Length; i++)                      {                          _codeLengthTreeCodeLength[s_codeOrder[i]] = 0;                      }                        // create huffman tree for code length                      _codeLengthTree = new HuffmanTree(_codeLengthTreeCodeLength);                      _codeArraySize = _literalLengthCodeCount + _distanceCodeCount;                      _loopCounter = 0; // reset loop count                        _state = InflaterState.ReadingTreeCodesBefore;                      goto case InflaterState.ReadingTreeCodesBefore;                    case InflaterState.ReadingTreeCodesBefore:                  case InflaterState.ReadingTreeCodesAfter:                      while (_loopCounter < _codeArraySize)                      {                          if (_state == InflaterState.ReadingTreeCodesBefore)                          {                              if ((_lengthCode = _codeLengthTree.GetNextSymbol(_input)) < 0)                              {                                  return false;                              }                          }                            // The alphabet for code lengths is as follows:                          //  0 - 15: Represent code lengths of 0 - 15                          //  16: Copy the previous code length 3 - 6 times.                          //  The next 2 bits indicate repeat length                          //         (0 = 3' ... ' 3 = 6)                          //      Example:  Codes 8' 16 (+2 bits 11)'                          //                16 (+2 bits 10) will expand to                          //                12 code lengths of 8 (1 + 6 + 5)                          //  17: Repeat a code length of 0 for 3 - 10 times.                          //    (3 bits of length)                          //  18: Repeat a code length of 0 for 11 - 138 times                          //    (7 bits of length)                          if (_lengthCode <= 15)                          {                              _codeList[_loopCounter++] = (byte)_lengthCode;                          }                          else                          {                              int repeatCount;                              if (_lengthCode == 16)                              {                                  if (!_input.EnsureBitsAvailable(2))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    if (_loopCounter == 0)                                  {                                      // can't have "prev code" on first code                                      throw new InvalidDataException();                                  }                                    byte previousCode = _codeList[_loopCounter - 1];                                  repeatCount = _input.GetBits(2) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = previousCode;                                  }                              }                              else if (_lengthCode == 17)                              {                                  if (!_input.EnsureBitsAvailable(3))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(3) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                              else                              {                                  // code == 18                                  if (!_input.EnsureBitsAvailable(7))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(7) + 11;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                          }                          _state = InflaterState.ReadingTreeCodesBefore; // we want to read the next code.                      }                      break;                    default:                      Debug.Fail("check why we are here!");                      throw new InvalidDataException(SR.UnknownState);              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeDynamicBlockHeader,The following statement contains a magic number: switch (_state)              {                  case InflaterState.ReadingNumLitCodes:                      _literalLengthCodeCount = _input.GetBits(5);                      if (_literalLengthCodeCount < 0)                      {                          return false;                      }                      _literalLengthCodeCount += 257;                      _state = InflaterState.ReadingNumDistCodes;                      goto case InflaterState.ReadingNumDistCodes;                    case InflaterState.ReadingNumDistCodes:                      _distanceCodeCount = _input.GetBits(5);                      if (_distanceCodeCount < 0)                      {                          return false;                      }                      _distanceCodeCount += 1;                      _state = InflaterState.ReadingNumCodeLengthCodes;                      goto case InflaterState.ReadingNumCodeLengthCodes;                    case InflaterState.ReadingNumCodeLengthCodes:                      _codeLengthCodeCount = _input.GetBits(4);                      if (_codeLengthCodeCount < 0)                      {                          return false;                      }                      _codeLengthCodeCount += 4;                      _loopCounter = 0;                      _state = InflaterState.ReadingCodeLengthCodes;                      goto case InflaterState.ReadingCodeLengthCodes;                    case InflaterState.ReadingCodeLengthCodes:                      while (_loopCounter < _codeLengthCodeCount)                      {                          int bits = _input.GetBits(3);                          if (bits < 0)                          {                              return false;                          }                          _codeLengthTreeCodeLength[s_codeOrder[_loopCounter]] = (byte)bits;                          ++_loopCounter;                      }                        for (int i = _codeLengthCodeCount; i < s_codeOrder.Length; i++)                      {                          _codeLengthTreeCodeLength[s_codeOrder[i]] = 0;                      }                        // create huffman tree for code length                      _codeLengthTree = new HuffmanTree(_codeLengthTreeCodeLength);                      _codeArraySize = _literalLengthCodeCount + _distanceCodeCount;                      _loopCounter = 0; // reset loop count                        _state = InflaterState.ReadingTreeCodesBefore;                      goto case InflaterState.ReadingTreeCodesBefore;                    case InflaterState.ReadingTreeCodesBefore:                  case InflaterState.ReadingTreeCodesAfter:                      while (_loopCounter < _codeArraySize)                      {                          if (_state == InflaterState.ReadingTreeCodesBefore)                          {                              if ((_lengthCode = _codeLengthTree.GetNextSymbol(_input)) < 0)                              {                                  return false;                              }                          }                            // The alphabet for code lengths is as follows:                          //  0 - 15: Represent code lengths of 0 - 15                          //  16: Copy the previous code length 3 - 6 times.                          //  The next 2 bits indicate repeat length                          //         (0 = 3' ... ' 3 = 6)                          //      Example:  Codes 8' 16 (+2 bits 11)'                          //                16 (+2 bits 10) will expand to                          //                12 code lengths of 8 (1 + 6 + 5)                          //  17: Repeat a code length of 0 for 3 - 10 times.                          //    (3 bits of length)                          //  18: Repeat a code length of 0 for 11 - 138 times                          //    (7 bits of length)                          if (_lengthCode <= 15)                          {                              _codeList[_loopCounter++] = (byte)_lengthCode;                          }                          else                          {                              int repeatCount;                              if (_lengthCode == 16)                              {                                  if (!_input.EnsureBitsAvailable(2))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    if (_loopCounter == 0)                                  {                                      // can't have "prev code" on first code                                      throw new InvalidDataException();                                  }                                    byte previousCode = _codeList[_loopCounter - 1];                                  repeatCount = _input.GetBits(2) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = previousCode;                                  }                              }                              else if (_lengthCode == 17)                              {                                  if (!_input.EnsureBitsAvailable(3))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(3) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                              else                              {                                  // code == 18                                  if (!_input.EnsureBitsAvailable(7))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(7) + 11;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                          }                          _state = InflaterState.ReadingTreeCodesBefore; // we want to read the next code.                      }                      break;                    default:                      Debug.Fail("check why we are here!");                      throw new InvalidDataException(SR.UnknownState);              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeDynamicBlockHeader,The following statement contains a magic number: switch (_state)              {                  case InflaterState.ReadingNumLitCodes:                      _literalLengthCodeCount = _input.GetBits(5);                      if (_literalLengthCodeCount < 0)                      {                          return false;                      }                      _literalLengthCodeCount += 257;                      _state = InflaterState.ReadingNumDistCodes;                      goto case InflaterState.ReadingNumDistCodes;                    case InflaterState.ReadingNumDistCodes:                      _distanceCodeCount = _input.GetBits(5);                      if (_distanceCodeCount < 0)                      {                          return false;                      }                      _distanceCodeCount += 1;                      _state = InflaterState.ReadingNumCodeLengthCodes;                      goto case InflaterState.ReadingNumCodeLengthCodes;                    case InflaterState.ReadingNumCodeLengthCodes:                      _codeLengthCodeCount = _input.GetBits(4);                      if (_codeLengthCodeCount < 0)                      {                          return false;                      }                      _codeLengthCodeCount += 4;                      _loopCounter = 0;                      _state = InflaterState.ReadingCodeLengthCodes;                      goto case InflaterState.ReadingCodeLengthCodes;                    case InflaterState.ReadingCodeLengthCodes:                      while (_loopCounter < _codeLengthCodeCount)                      {                          int bits = _input.GetBits(3);                          if (bits < 0)                          {                              return false;                          }                          _codeLengthTreeCodeLength[s_codeOrder[_loopCounter]] = (byte)bits;                          ++_loopCounter;                      }                        for (int i = _codeLengthCodeCount; i < s_codeOrder.Length; i++)                      {                          _codeLengthTreeCodeLength[s_codeOrder[i]] = 0;                      }                        // create huffman tree for code length                      _codeLengthTree = new HuffmanTree(_codeLengthTreeCodeLength);                      _codeArraySize = _literalLengthCodeCount + _distanceCodeCount;                      _loopCounter = 0; // reset loop count                        _state = InflaterState.ReadingTreeCodesBefore;                      goto case InflaterState.ReadingTreeCodesBefore;                    case InflaterState.ReadingTreeCodesBefore:                  case InflaterState.ReadingTreeCodesAfter:                      while (_loopCounter < _codeArraySize)                      {                          if (_state == InflaterState.ReadingTreeCodesBefore)                          {                              if ((_lengthCode = _codeLengthTree.GetNextSymbol(_input)) < 0)                              {                                  return false;                              }                          }                            // The alphabet for code lengths is as follows:                          //  0 - 15: Represent code lengths of 0 - 15                          //  16: Copy the previous code length 3 - 6 times.                          //  The next 2 bits indicate repeat length                          //         (0 = 3' ... ' 3 = 6)                          //      Example:  Codes 8' 16 (+2 bits 11)'                          //                16 (+2 bits 10) will expand to                          //                12 code lengths of 8 (1 + 6 + 5)                          //  17: Repeat a code length of 0 for 3 - 10 times.                          //    (3 bits of length)                          //  18: Repeat a code length of 0 for 11 - 138 times                          //    (7 bits of length)                          if (_lengthCode <= 15)                          {                              _codeList[_loopCounter++] = (byte)_lengthCode;                          }                          else                          {                              int repeatCount;                              if (_lengthCode == 16)                              {                                  if (!_input.EnsureBitsAvailable(2))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    if (_loopCounter == 0)                                  {                                      // can't have "prev code" on first code                                      throw new InvalidDataException();                                  }                                    byte previousCode = _codeList[_loopCounter - 1];                                  repeatCount = _input.GetBits(2) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = previousCode;                                  }                              }                              else if (_lengthCode == 17)                              {                                  if (!_input.EnsureBitsAvailable(3))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(3) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                              else                              {                                  // code == 18                                  if (!_input.EnsureBitsAvailable(7))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(7) + 11;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                          }                          _state = InflaterState.ReadingTreeCodesBefore; // we want to read the next code.                      }                      break;                    default:                      Debug.Fail("check why we are here!");                      throw new InvalidDataException(SR.UnknownState);              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeDynamicBlockHeader,The following statement contains a magic number: switch (_state)              {                  case InflaterState.ReadingNumLitCodes:                      _literalLengthCodeCount = _input.GetBits(5);                      if (_literalLengthCodeCount < 0)                      {                          return false;                      }                      _literalLengthCodeCount += 257;                      _state = InflaterState.ReadingNumDistCodes;                      goto case InflaterState.ReadingNumDistCodes;                    case InflaterState.ReadingNumDistCodes:                      _distanceCodeCount = _input.GetBits(5);                      if (_distanceCodeCount < 0)                      {                          return false;                      }                      _distanceCodeCount += 1;                      _state = InflaterState.ReadingNumCodeLengthCodes;                      goto case InflaterState.ReadingNumCodeLengthCodes;                    case InflaterState.ReadingNumCodeLengthCodes:                      _codeLengthCodeCount = _input.GetBits(4);                      if (_codeLengthCodeCount < 0)                      {                          return false;                      }                      _codeLengthCodeCount += 4;                      _loopCounter = 0;                      _state = InflaterState.ReadingCodeLengthCodes;                      goto case InflaterState.ReadingCodeLengthCodes;                    case InflaterState.ReadingCodeLengthCodes:                      while (_loopCounter < _codeLengthCodeCount)                      {                          int bits = _input.GetBits(3);                          if (bits < 0)                          {                              return false;                          }                          _codeLengthTreeCodeLength[s_codeOrder[_loopCounter]] = (byte)bits;                          ++_loopCounter;                      }                        for (int i = _codeLengthCodeCount; i < s_codeOrder.Length; i++)                      {                          _codeLengthTreeCodeLength[s_codeOrder[i]] = 0;                      }                        // create huffman tree for code length                      _codeLengthTree = new HuffmanTree(_codeLengthTreeCodeLength);                      _codeArraySize = _literalLengthCodeCount + _distanceCodeCount;                      _loopCounter = 0; // reset loop count                        _state = InflaterState.ReadingTreeCodesBefore;                      goto case InflaterState.ReadingTreeCodesBefore;                    case InflaterState.ReadingTreeCodesBefore:                  case InflaterState.ReadingTreeCodesAfter:                      while (_loopCounter < _codeArraySize)                      {                          if (_state == InflaterState.ReadingTreeCodesBefore)                          {                              if ((_lengthCode = _codeLengthTree.GetNextSymbol(_input)) < 0)                              {                                  return false;                              }                          }                            // The alphabet for code lengths is as follows:                          //  0 - 15: Represent code lengths of 0 - 15                          //  16: Copy the previous code length 3 - 6 times.                          //  The next 2 bits indicate repeat length                          //         (0 = 3' ... ' 3 = 6)                          //      Example:  Codes 8' 16 (+2 bits 11)'                          //                16 (+2 bits 10) will expand to                          //                12 code lengths of 8 (1 + 6 + 5)                          //  17: Repeat a code length of 0 for 3 - 10 times.                          //    (3 bits of length)                          //  18: Repeat a code length of 0 for 11 - 138 times                          //    (7 bits of length)                          if (_lengthCode <= 15)                          {                              _codeList[_loopCounter++] = (byte)_lengthCode;                          }                          else                          {                              int repeatCount;                              if (_lengthCode == 16)                              {                                  if (!_input.EnsureBitsAvailable(2))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    if (_loopCounter == 0)                                  {                                      // can't have "prev code" on first code                                      throw new InvalidDataException();                                  }                                    byte previousCode = _codeList[_loopCounter - 1];                                  repeatCount = _input.GetBits(2) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = previousCode;                                  }                              }                              else if (_lengthCode == 17)                              {                                  if (!_input.EnsureBitsAvailable(3))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(3) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                              else                              {                                  // code == 18                                  if (!_input.EnsureBitsAvailable(7))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(7) + 11;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                          }                          _state = InflaterState.ReadingTreeCodesBefore; // we want to read the next code.                      }                      break;                    default:                      Debug.Fail("check why we are here!");                      throw new InvalidDataException(SR.UnknownState);              }
Magic Number,System.IO.Compression,InflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InflaterManaged.cs,DecodeDynamicBlockHeader,The following statement contains a magic number: switch (_state)              {                  case InflaterState.ReadingNumLitCodes:                      _literalLengthCodeCount = _input.GetBits(5);                      if (_literalLengthCodeCount < 0)                      {                          return false;                      }                      _literalLengthCodeCount += 257;                      _state = InflaterState.ReadingNumDistCodes;                      goto case InflaterState.ReadingNumDistCodes;                    case InflaterState.ReadingNumDistCodes:                      _distanceCodeCount = _input.GetBits(5);                      if (_distanceCodeCount < 0)                      {                          return false;                      }                      _distanceCodeCount += 1;                      _state = InflaterState.ReadingNumCodeLengthCodes;                      goto case InflaterState.ReadingNumCodeLengthCodes;                    case InflaterState.ReadingNumCodeLengthCodes:                      _codeLengthCodeCount = _input.GetBits(4);                      if (_codeLengthCodeCount < 0)                      {                          return false;                      }                      _codeLengthCodeCount += 4;                      _loopCounter = 0;                      _state = InflaterState.ReadingCodeLengthCodes;                      goto case InflaterState.ReadingCodeLengthCodes;                    case InflaterState.ReadingCodeLengthCodes:                      while (_loopCounter < _codeLengthCodeCount)                      {                          int bits = _input.GetBits(3);                          if (bits < 0)                          {                              return false;                          }                          _codeLengthTreeCodeLength[s_codeOrder[_loopCounter]] = (byte)bits;                          ++_loopCounter;                      }                        for (int i = _codeLengthCodeCount; i < s_codeOrder.Length; i++)                      {                          _codeLengthTreeCodeLength[s_codeOrder[i]] = 0;                      }                        // create huffman tree for code length                      _codeLengthTree = new HuffmanTree(_codeLengthTreeCodeLength);                      _codeArraySize = _literalLengthCodeCount + _distanceCodeCount;                      _loopCounter = 0; // reset loop count                        _state = InflaterState.ReadingTreeCodesBefore;                      goto case InflaterState.ReadingTreeCodesBefore;                    case InflaterState.ReadingTreeCodesBefore:                  case InflaterState.ReadingTreeCodesAfter:                      while (_loopCounter < _codeArraySize)                      {                          if (_state == InflaterState.ReadingTreeCodesBefore)                          {                              if ((_lengthCode = _codeLengthTree.GetNextSymbol(_input)) < 0)                              {                                  return false;                              }                          }                            // The alphabet for code lengths is as follows:                          //  0 - 15: Represent code lengths of 0 - 15                          //  16: Copy the previous code length 3 - 6 times.                          //  The next 2 bits indicate repeat length                          //         (0 = 3' ... ' 3 = 6)                          //      Example:  Codes 8' 16 (+2 bits 11)'                          //                16 (+2 bits 10) will expand to                          //                12 code lengths of 8 (1 + 6 + 5)                          //  17: Repeat a code length of 0 for 3 - 10 times.                          //    (3 bits of length)                          //  18: Repeat a code length of 0 for 11 - 138 times                          //    (7 bits of length)                          if (_lengthCode <= 15)                          {                              _codeList[_loopCounter++] = (byte)_lengthCode;                          }                          else                          {                              int repeatCount;                              if (_lengthCode == 16)                              {                                  if (!_input.EnsureBitsAvailable(2))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    if (_loopCounter == 0)                                  {                                      // can't have "prev code" on first code                                      throw new InvalidDataException();                                  }                                    byte previousCode = _codeList[_loopCounter - 1];                                  repeatCount = _input.GetBits(2) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = previousCode;                                  }                              }                              else if (_lengthCode == 17)                              {                                  if (!_input.EnsureBitsAvailable(3))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(3) + 3;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                              else                              {                                  // code == 18                                  if (!_input.EnsureBitsAvailable(7))                                  {                                      _state = InflaterState.ReadingTreeCodesAfter;                                      return false;                                  }                                    repeatCount = _input.GetBits(7) + 11;                                    if (_loopCounter + repeatCount > _codeArraySize)                                  {                                      throw new InvalidDataException();                                  }                                    for (int j = 0; j < repeatCount; j++)                                  {                                      _codeList[_loopCounter++] = 0;                                  }                              }                          }                          _state = InflaterState.ReadingTreeCodesBefore; // we want to read the next code.                      }                      break;                    default:                      Debug.Fail("check why we are here!");                      throw new InvalidDataException(SR.UnknownState);              }
Magic Number,System.IO.Compression,InputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InputBuffer.cs,EnsureBitsAvailable,The following statement contains a magic number: Debug.Assert(0 < count && count <= 16' "count is invalid.");
Magic Number,System.IO.Compression,InputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InputBuffer.cs,EnsureBitsAvailable,The following statement contains a magic number: if (_bitsInBuffer < count)              {                  if (NeedsInput())                  {                      return false;                  }                  // insert a byte to bitbuffer                  _bitBuffer |= (uint)_buffer[_start++] << _bitsInBuffer;                  _bitsInBuffer += 8;                    if (_bitsInBuffer < count)                  {                      if (NeedsInput())                      {                          return false;                      }                      // insert a byte to bitbuffer                      _bitBuffer |= (uint)_buffer[_start++] << _bitsInBuffer;                      _bitsInBuffer += 8;                  }              }
Magic Number,System.IO.Compression,InputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InputBuffer.cs,EnsureBitsAvailable,The following statement contains a magic number: if (_bitsInBuffer < count)              {                  if (NeedsInput())                  {                      return false;                  }                  // insert a byte to bitbuffer                  _bitBuffer |= (uint)_buffer[_start++] << _bitsInBuffer;                  _bitsInBuffer += 8;                    if (_bitsInBuffer < count)                  {                      if (NeedsInput())                      {                          return false;                      }                      // insert a byte to bitbuffer                      _bitBuffer |= (uint)_buffer[_start++] << _bitsInBuffer;                      _bitsInBuffer += 8;                  }              }
Magic Number,System.IO.Compression,InputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InputBuffer.cs,TryLoad16Bits,The following statement contains a magic number: if (_bitsInBuffer < 8)              {                  if (_start < _end)                  {                      _bitBuffer |= (uint)_buffer[_start++] << _bitsInBuffer;                      _bitsInBuffer += 8;                  }                    if (_start < _end)                  {                      _bitBuffer |= (uint)_buffer[_start++] << _bitsInBuffer;                      _bitsInBuffer += 8;                  }              }              else if (_bitsInBuffer < 16)              {                  if (_start < _end)                  {                      _bitBuffer |= (uint)_buffer[_start++] << _bitsInBuffer;                      _bitsInBuffer += 8;                  }              }
Magic Number,System.IO.Compression,InputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InputBuffer.cs,TryLoad16Bits,The following statement contains a magic number: if (_bitsInBuffer < 8)              {                  if (_start < _end)                  {                      _bitBuffer |= (uint)_buffer[_start++] << _bitsInBuffer;                      _bitsInBuffer += 8;                  }                    if (_start < _end)                  {                      _bitBuffer |= (uint)_buffer[_start++] << _bitsInBuffer;                      _bitsInBuffer += 8;                  }              }              else if (_bitsInBuffer < 16)              {                  if (_start < _end)                  {                      _bitBuffer |= (uint)_buffer[_start++] << _bitsInBuffer;                      _bitsInBuffer += 8;                  }              }
Magic Number,System.IO.Compression,InputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InputBuffer.cs,TryLoad16Bits,The following statement contains a magic number: if (_bitsInBuffer < 8)              {                  if (_start < _end)                  {                      _bitBuffer |= (uint)_buffer[_start++] << _bitsInBuffer;                      _bitsInBuffer += 8;                  }                    if (_start < _end)                  {                      _bitBuffer |= (uint)_buffer[_start++] << _bitsInBuffer;                      _bitsInBuffer += 8;                  }              }              else if (_bitsInBuffer < 16)              {                  if (_start < _end)                  {                      _bitBuffer |= (uint)_buffer[_start++] << _bitsInBuffer;                      _bitsInBuffer += 8;                  }              }
Magic Number,System.IO.Compression,InputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InputBuffer.cs,TryLoad16Bits,The following statement contains a magic number: if (_bitsInBuffer < 8)              {                  if (_start < _end)                  {                      _bitBuffer |= (uint)_buffer[_start++] << _bitsInBuffer;                      _bitsInBuffer += 8;                  }                    if (_start < _end)                  {                      _bitBuffer |= (uint)_buffer[_start++] << _bitsInBuffer;                      _bitsInBuffer += 8;                  }              }              else if (_bitsInBuffer < 16)              {                  if (_start < _end)                  {                      _bitBuffer |= (uint)_buffer[_start++] << _bitsInBuffer;                      _bitsInBuffer += 8;                  }              }
Magic Number,System.IO.Compression,InputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InputBuffer.cs,TryLoad16Bits,The following statement contains a magic number: if (_bitsInBuffer < 8)              {                  if (_start < _end)                  {                      _bitBuffer |= (uint)_buffer[_start++] << _bitsInBuffer;                      _bitsInBuffer += 8;                  }                    if (_start < _end)                  {                      _bitBuffer |= (uint)_buffer[_start++] << _bitsInBuffer;                      _bitsInBuffer += 8;                  }              }              else if (_bitsInBuffer < 16)              {                  if (_start < _end)                  {                      _bitBuffer |= (uint)_buffer[_start++] << _bitsInBuffer;                      _bitsInBuffer += 8;                  }              }
Magic Number,System.IO.Compression,InputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InputBuffer.cs,GetBits,The following statement contains a magic number: Debug.Assert(0 < count && count <= 16' "count is invalid.");
Magic Number,System.IO.Compression,InputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InputBuffer.cs,CopyTo,The following statement contains a magic number: Debug.Assert((_bitsInBuffer % 8) == 0);
Magic Number,System.IO.Compression,InputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InputBuffer.cs,CopyTo,The following statement contains a magic number: while (_bitsInBuffer > 0 && length > 0)              {                  output[offset++] = (byte)_bitBuffer;                  _bitBuffer >>= 8;                  _bitsInBuffer -= 8;                  length--;                  bytesFromBitBuffer++;              }
Magic Number,System.IO.Compression,InputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InputBuffer.cs,CopyTo,The following statement contains a magic number: while (_bitsInBuffer > 0 && length > 0)              {                  output[offset++] = (byte)_bitBuffer;                  _bitBuffer >>= 8;                  _bitsInBuffer -= 8;                  length--;                  bytesFromBitBuffer++;              }
Magic Number,System.IO.Compression,InputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InputBuffer.cs,SkipToByteBoundary,The following statement contains a magic number: _bitBuffer >>= (_bitsInBuffer % 8);
Magic Number,System.IO.Compression,InputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\InputBuffer.cs,SkipToByteBoundary,The following statement contains a magic number: _bitsInBuffer = _bitsInBuffer - (_bitsInBuffer % 8);
Magic Number,System.IO.Compression,OutputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\OutputBuffer.cs,WriteUInt16,The following statement contains a magic number: Debug.Assert(FreeBytes >= 2' "No enough space in output buffer!");
Magic Number,System.IO.Compression,OutputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\OutputBuffer.cs,WriteUInt16,The following statement contains a magic number: _byteBuffer[_pos++] = (byte)(value >> 8);
Magic Number,System.IO.Compression,OutputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\OutputBuffer.cs,WriteBits,The following statement contains a magic number: Debug.Assert(n <= 16' "length must be larger than 16!");
Magic Number,System.IO.Compression,OutputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\OutputBuffer.cs,WriteBits,The following statement contains a magic number: if (_bitCount >= 16)              {                  Debug.Assert(_byteBuffer.Length - _pos >= 2' "No enough space in output buffer!");                  _byteBuffer[_pos++] = unchecked((byte)_bitBuf);                  _byteBuffer[_pos++] = unchecked((byte)(_bitBuf >> 8));                  _bitCount -= 16;                  _bitBuf >>= 16;              }
Magic Number,System.IO.Compression,OutputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\OutputBuffer.cs,WriteBits,The following statement contains a magic number: if (_bitCount >= 16)              {                  Debug.Assert(_byteBuffer.Length - _pos >= 2' "No enough space in output buffer!");                  _byteBuffer[_pos++] = unchecked((byte)_bitBuf);                  _byteBuffer[_pos++] = unchecked((byte)(_bitBuf >> 8));                  _bitCount -= 16;                  _bitBuf >>= 16;              }
Magic Number,System.IO.Compression,OutputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\OutputBuffer.cs,WriteBits,The following statement contains a magic number: if (_bitCount >= 16)              {                  Debug.Assert(_byteBuffer.Length - _pos >= 2' "No enough space in output buffer!");                  _byteBuffer[_pos++] = unchecked((byte)_bitBuf);                  _byteBuffer[_pos++] = unchecked((byte)(_bitBuf >> 8));                  _bitCount -= 16;                  _bitBuf >>= 16;              }
Magic Number,System.IO.Compression,OutputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\OutputBuffer.cs,WriteBits,The following statement contains a magic number: if (_bitCount >= 16)              {                  Debug.Assert(_byteBuffer.Length - _pos >= 2' "No enough space in output buffer!");                  _byteBuffer[_pos++] = unchecked((byte)_bitBuf);                  _byteBuffer[_pos++] = unchecked((byte)(_bitBuf >> 8));                  _bitCount -= 16;                  _bitBuf >>= 16;              }
Magic Number,System.IO.Compression,OutputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\OutputBuffer.cs,WriteBits,The following statement contains a magic number: if (_bitCount >= 16)              {                  Debug.Assert(_byteBuffer.Length - _pos >= 2' "No enough space in output buffer!");                  _byteBuffer[_pos++] = unchecked((byte)_bitBuf);                  _byteBuffer[_pos++] = unchecked((byte)(_bitBuf >> 8));                  _bitCount -= 16;                  _bitBuf >>= 16;              }
Magic Number,System.IO.Compression,OutputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\OutputBuffer.cs,FlushBits,The following statement contains a magic number: while (_bitCount >= 8)              {                  _byteBuffer[_pos++] = unchecked((byte)_bitBuf);                  _bitCount -= 8;                  _bitBuf >>= 8;              }
Magic Number,System.IO.Compression,OutputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\OutputBuffer.cs,FlushBits,The following statement contains a magic number: while (_bitCount >= 8)              {                  _byteBuffer[_pos++] = unchecked((byte)_bitBuf);                  _bitCount -= 8;                  _bitBuf >>= 8;              }
Magic Number,System.IO.Compression,OutputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\OutputBuffer.cs,FlushBits,The following statement contains a magic number: while (_bitCount >= 8)              {                  _byteBuffer[_pos++] = unchecked((byte)_bitBuf);                  _bitCount -= 8;                  _bitBuf >>= 8;              }
Magic Number,System.IO.Compression,OutputBuffer,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\OutputBuffer.cs,WriteByteUnaligned,The following statement contains a magic number: WriteBits(8' b);
Missing Default,System.IO.Compression,DeflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\DeflaterManaged.cs,SetInput,The following switch statement is missing a default case: switch (_processingState)                  {                      case DeflaterState.NotStarted:                      case DeflaterState.CheckingForIncompressible:                          // clean states' needs a block header first                          _processingState = DeflaterState.StartingSmallData;                          break;                        case DeflaterState.CompressThenCheck:                          // already has correct block header                          _processingState = DeflaterState.HandlingSmallData;                          break;                  }
Missing Default,System.IO.Compression,DeflaterManaged,C:\selectedRepos\dotnet_corefx\src\System.IO.Compression\src\System\IO\Compression\DeflateManaged\DeflaterManaged.cs,GetDeflateOutput,The following switch statement is missing a default case: switch (_processingState)              {                  case DeflaterState.NotStarted:                      {                          // first call. Try to compress but if we get bad compression ratio' switch to uncompressed blocks.                          Debug.Assert(_deflateEncoder.BytesInHistory == 0' "have leftover bytes in window");                            // save these in case we need to switch to uncompressed format                          DeflateInput.InputState initialInputState = _input.DumpState();                          OutputBuffer.BufferState initialOutputState = _output.DumpState();                            _deflateEncoder.GetBlockHeader(_output);                          _deflateEncoder.GetCompressedData(_input' _output);                            if (!UseCompressed(_deflateEncoder.LastCompressionRatio))                          {                              // we're expanding; restore state and switch to uncompressed                              _input.RestoreState(initialInputState);                              _output.RestoreState(initialOutputState);                              _copyEncoder.GetBlock(_input' _output' isFinal: false);                              FlushInputWindows();                              _processingState = DeflaterState.CheckingForIncompressible;                          }                          else                          {                              _processingState = DeflaterState.CompressThenCheck;                          }                            break;                      }                  case DeflaterState.CompressThenCheck:                      {                          // continue assuming data is compressible. If we reach data that indicates otherwise                          // finish off remaining data in history and decide whether to compress on a                          // block-by-block basis                          _deflateEncoder.GetCompressedData(_input' _output);                            if (!UseCompressed(_deflateEncoder.LastCompressionRatio))                          {                              _processingState = DeflaterState.SlowDownForIncompressible1;                              _inputFromHistory = _deflateEncoder.UnprocessedInput;                          }                          break;                      }                  case DeflaterState.SlowDownForIncompressible1:                      {                          // finish off previous compressed block                          _deflateEncoder.GetBlockFooter(_output);                            _processingState = DeflaterState.SlowDownForIncompressible2;                          goto case DeflaterState.SlowDownForIncompressible2; // yeah I know' but there's no fallthrough                      }                    case DeflaterState.SlowDownForIncompressible2:                      {                          // clear out data from history' but add them as uncompressed blocks                          if (_inputFromHistory.Count > 0)                          {                              _copyEncoder.GetBlock(_inputFromHistory' _output' isFinal: false);                          }                            if (_inputFromHistory.Count == 0)                          {                              // now we're clean                              _deflateEncoder.FlushInput();                              _processingState = DeflaterState.CheckingForIncompressible;                          }                          break;                      }                    case DeflaterState.CheckingForIncompressible:                      {                          // decide whether to compress on a block-by-block basis                          Debug.Assert(_deflateEncoder.BytesInHistory == 0' "have leftover bytes in window");                            // save these in case we need to store as uncompressed                          DeflateInput.InputState initialInputState = _input.DumpState();                          OutputBuffer.BufferState initialOutputState = _output.DumpState();                            // enforce max so we can ensure state between calls                          _deflateEncoder.GetBlock(_input' _output' CleanCopySize);                            if (!UseCompressed(_deflateEncoder.LastCompressionRatio))                          {                              // we're expanding; restore state and switch to uncompressed                              _input.RestoreState(initialInputState);                              _output.RestoreState(initialOutputState);                              _copyEncoder.GetBlock(_input' _output' isFinal: false);                              FlushInputWindows();                          }                            break;                      }                    case DeflaterState.StartingSmallData:                      {                          // add compressed header and data' but not footer. Subsequent calls will keep                          // adding compressed data (no header and no footer). We're doing this to                          // avoid overhead of header and footer size relative to compressed payload.                          _deflateEncoder.GetBlockHeader(_output);                            _processingState = DeflaterState.HandlingSmallData;                          goto case DeflaterState.HandlingSmallData; // yeah I know' but there's no fallthrough                      }                    case DeflaterState.HandlingSmallData:                      {                          // continue adding compressed data                          _deflateEncoder.GetCompressedData(_input' _output);                          break;                      }              }
