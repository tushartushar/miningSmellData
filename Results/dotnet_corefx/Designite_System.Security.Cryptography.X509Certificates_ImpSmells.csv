Implementation smell,Namespace,Class,File,Method,Description
Long Method,Internal.Cryptography.Pal,FindPal,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\Internal\Cryptography\FindPal.cs,FindFromCollection,The method has 112 lines of code.
Long Method,System.Security.Cryptography.X509Certificates,X509Certificate2,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\X509Certificate2.cs,ToString,The method has 183 lines of code.
Complex Method,System.Security.Cryptography,DerSequenceReader,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerSequenceReader.cs,ScanContentLength,Cyclomatic complexity of the method is 10
Complex Method,Internal.Cryptography.Pal,FindPal,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\Internal\Cryptography\FindPal.cs,ValidateOidValue,Cyclomatic complexity of the method is 8
Complex Method,System.Security.Cryptography.X509Certificates,CertificateRequest,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\CertificateRequest.cs,Create,Cyclomatic complexity of the method is 12
Complex Method,System.Security.Cryptography.X509Certificates,ECDsaCertificateExtensions,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\ECDsaCertificateExtensions.cs,IsSameKey,Cyclomatic complexity of the method is 8
Complex Method,System.Security.Cryptography.X509Certificates,X509Certificate2,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\X509Certificate2.cs,ToString,Cyclomatic complexity of the method is 12
Long Parameter List,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\Internal\Cryptography\Helpers.cs,IsValidDay,The method has 5 parameters. Parameters: calendar' year' month' day' era
Long Parameter List,System.Security.Cryptography.X509Certificates,CertificateRequest,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\CertificateRequest.cs,Create,The method has 5 parameters. Parameters: issuerName' generator' notBefore' notAfter' serialNumber
Long Identifier,Internal.Cryptography,ErrorCode,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\Internal\Cryptography\ErrorCode.cs,,The length of the parameter CERTSRV_E_WEAK_SIGNATURE_OR_KEY is 31.
Long Identifier,System.Security.Cryptography,DerSequenceReader,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerSequenceReader.cs,,The length of the parameter ContextSpecificConstructedTag0 is 30.
Long Identifier,System.Security.Cryptography,DerSequenceReader,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerSequenceReader.cs,,The length of the parameter ContextSpecificConstructedTag1 is 30.
Long Identifier,System.Security.Cryptography,DerSequenceReader,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerSequenceReader.cs,,The length of the parameter ContextSpecificConstructedTag2 is 30.
Long Identifier,System.Security.Cryptography,DerSequenceReader,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerSequenceReader.cs,,The length of the parameter ContextSpecificConstructedTag3 is 30.
Long Statement,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\Internal\Cryptography\Helpers.cs,IsValidYear,The length of the statement  "            return (year >= calendar.GetYear(calendar.MinSupportedDateTime) && year <= calendar.GetYear(calendar.MaxSupportedDateTime)); " is 124.
Long Statement,System.Security.Cryptography.X509Certificates,X509BasicConstraintsExtension,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\X509BasicConstraintsExtension.cs,EncodeExtension,The length of the statement  "            return X509Pal.Instance.EncodeX509BasicConstraints2Extension(certificateAuthority' hasPathLengthConstraint' pathLengthConstraint); " is 130.
Long Statement,System.Security.Cryptography.X509Certificates,X509BasicConstraintsExtension,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\X509BasicConstraintsExtension.cs,DecodeExtension,The length of the statement  "                X509Pal.Instance.DecodeX509BasicConstraintsExtension(RawData' out _certificateAuthority' out _hasPathLenConstraint' out _pathLenConstraint); " is 140.
Long Statement,System.Security.Cryptography.X509Certificates,X509BasicConstraintsExtension,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\X509BasicConstraintsExtension.cs,DecodeExtension,The length of the statement  "                X509Pal.Instance.DecodeX509BasicConstraints2Extension(RawData' out _certificateAuthority' out _hasPathLenConstraint' out _pathLenConstraint); " is 141.
Long Statement,System.Security.Cryptography.X509Certificates,X509Certificate,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\X509Certificate.cs,ThrowIfInvalid,The length of the statement  "                throw new CryptographicException(SR.Format(SR.Cryptography_InvalidHandle' "m_safeCertContext")); // Keeping "m_safeCertContext" string for backward compat sake. " is 160.
Long Statement,System.Security.Cryptography.X509Certificates,X509Certificate,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\X509Certificate.cs,VerifyContentType,The length of the statement  "            if (!(contentType == X509ContentType.Cert || contentType == X509ContentType.SerializedCert || contentType == X509ContentType.Pkcs12)) " is 133.
Long Statement,System.Security.Cryptography.X509Certificates,X509Certificate2,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\X509Certificate2.cs,GetCertContentType,The length of the statement  "            // Desktop compat: The desktop CLR expands the filename to a full path for the purpose of performing a CAS permission check. While CAS is not present here' " is 155.
Complex Conditional,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,IsPrintableStringCharacter,The conditional expression  "(c >= 'A' && c <= 'Z') ||                  (c >= 'a' && c <= 'z') ||                  (c >= '0' && c <= '9')"  is complex.
Complex Conditional,System.Security.Cryptography.X509Certificates,DSACertificateExtensions,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\DSACertificateExtensions.cs,CopyWithPrivateKey,The conditional expression  "!currentParameters.G.ContentsEqual(newParameters.G) ||                      !currentParameters.P.ContentsEqual(newParameters.P) ||                      !currentParameters.Q.ContentsEqual(newParameters.Q) ||                      !currentParameters.Y.ContentsEqual(newParameters.Y)"  is complex.
Complex Conditional,System.Security.Cryptography.X509Certificates,ECDsaCertificateExtensions,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\ECDsaCertificateExtensions.cs,IsSameKey,The conditional expression  "!aCurve.G.X.ContentsEqual(bCurve.G.X) ||                  !aCurve.G.Y.ContentsEqual(bCurve.G.Y) ||                  !aCurve.Order.ContentsEqual(bCurve.Order) ||                  !aCurve.A.ContentsEqual(bCurve.A) ||                  !aCurve.B.ContentsEqual(bCurve.B)"  is complex.
Empty Catch Block,System.Security.Cryptography.X509Certificates,X509Certificate2,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\X509Certificate2.cs,ToString,The method has an empty catch block.
Empty Catch Block,System.Security.Cryptography.X509Certificates,X509Certificate2,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\X509Certificate2.cs,ToString,The method has an empty catch block.
Empty Catch Block,System.Security.Cryptography.X509Certificates,X509Certificate2,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\X509Certificate2.cs,ToString,The method has an empty catch block.
Magic Number,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\Internal\Cryptography\Helpers.cs,ToHexArrayUpper,The following statement contains a magic number: char[] chars = new char[bytes.Length * 2];
Magic Number,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\Internal\Cryptography\Helpers.cs,ToHexArrayUpper,The following statement contains a magic number: foreach (byte b in bytes)              {                  chars[i++] = NibbleToHex((byte)(b >> 4));                  chars[i++] = NibbleToHex((byte)(b & 0xF));              }
Magic Number,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\Internal\Cryptography\Helpers.cs,DecodeHexString,The following statement contains a magic number: uint cbHex = (uint)(s.Length - whitespaceCount) / 2;
Magic Number,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\Internal\Cryptography\Helpers.cs,DecodeHexString,The following statement contains a magic number: for (int i = 0; i < s.Length; i++)              {                  char c = s[i];                    if (char.IsWhiteSpace(c))                  {                      continue;                  }                    accum <<= 4;                  accum |= HexToByte(c);                    byteInProgress = !byteInProgress;                    // If we've flipped from 0 to 1' back to 0' we have a whole byte                  // so add it to the buffer.                  if (!byteInProgress)                  {                      Debug.Assert(index < cbHex' "index < cbHex");                        hex[index] = accum;                      index++;                  }              }
Magic Number,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\Internal\Cryptography\Helpers.cs,HexToByte,The following statement contains a magic number: if (val <= '9' && val >= '0')                  return (byte)(val - '0');              else if (val >= 'a' && val <= 'f')                  return (byte)((val - 'a') + 10);              else if (val >= 'A' && val <= 'F')                  return (byte)((val - 'A') + 10);              else                  return 0xFF;
Magic Number,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\Internal\Cryptography\Helpers.cs,HexToByte,The following statement contains a magic number: if (val <= '9' && val >= '0')                  return (byte)(val - '0');              else if (val >= 'a' && val <= 'f')                  return (byte)((val - 'a') + 10);              else if (val >= 'A' && val <= 'F')                  return (byte)((val - 'A') + 10);              else                  return 0xFF;
Magic Number,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\Internal\Cryptography\Helpers.cs,NibbleToHex,The following statement contains a magic number: Debug.Assert(b >= 0 && b <= 15);
Magic Number,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\Internal\Cryptography\Helpers.cs,NibbleToHex,The following statement contains a magic number: return (char)(b >= 0 && b <= 9 ?                   '0' + b :                   'A' + (b - 10));
Magic Number,Internal.Cryptography,Helpers,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\Internal\Cryptography\Helpers.cs,NibbleToHex,The following statement contains a magic number: return (char)(b >= 0 && b <= 9 ?                   '0' + b :                   'A' + (b - 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,EncodeLength,The following statement contains a magic number: int remainder = length >> 8;
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,EncodeLength,The following statement contains a magic number: remainder >>= 8;
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,EncodeLength,The following statement contains a magic number: remainder >>= 8;
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeBitString,The following statement contains a magic number: Debug.Assert(unusedBits <= 7);
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeNamedBitList,The following statement contains a magic number: int lastBitProvided = (bigEndianBytes.Length * 8) - 1;
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeNamedBitList,The following statement contains a magic number: for (int currentBit = lastPossibleBit; currentBit >= 0; currentBit--)              {                  int currentByte = currentBit / 8;                    // As we loop through the numbered bits we need to figure out                  // 1) which indexed byte it would be in (currentByte)                  // 2) How many bits from the right it is (shiftIndex)                  //                   // For example:                  // currentBit 0 => currentByte 0' shiftIndex 7 (1 << 7)                  // currentBit 1 => currentByte 0' shiftIndex 6 (1 << 6)                  // currentBit 7 => currentByte 0' shiftIndex 0 (1 << 0)                  // currentBit 8 => currentByte 1' shiftIndex 7 (1 << 7)                  // etc                  int shiftIndex = 7 - (currentBit % 8);                  int testValue = 1 << shiftIndex;                  byte dataByte = bigEndianBytes[currentByte];                    if ((dataByte & testValue) == testValue)                  {                      lastSetBit = currentBit;                      break;                  }              }
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeNamedBitList,The following statement contains a magic number: for (int currentBit = lastPossibleBit; currentBit >= 0; currentBit--)              {                  int currentByte = currentBit / 8;                    // As we loop through the numbered bits we need to figure out                  // 1) which indexed byte it would be in (currentByte)                  // 2) How many bits from the right it is (shiftIndex)                  //                   // For example:                  // currentBit 0 => currentByte 0' shiftIndex 7 (1 << 7)                  // currentBit 1 => currentByte 0' shiftIndex 6 (1 << 6)                  // currentBit 7 => currentByte 0' shiftIndex 0 (1 << 0)                  // currentBit 8 => currentByte 1' shiftIndex 7 (1 << 7)                  // etc                  int shiftIndex = 7 - (currentBit % 8);                  int testValue = 1 << shiftIndex;                  byte dataByte = bigEndianBytes[currentByte];                    if ((dataByte & testValue) == testValue)                  {                      lastSetBit = currentBit;                      break;                  }              }
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeNamedBitList,The following statement contains a magic number: for (int currentBit = lastPossibleBit; currentBit >= 0; currentBit--)              {                  int currentByte = currentBit / 8;                    // As we loop through the numbered bits we need to figure out                  // 1) which indexed byte it would be in (currentByte)                  // 2) How many bits from the right it is (shiftIndex)                  //                   // For example:                  // currentBit 0 => currentByte 0' shiftIndex 7 (1 << 7)                  // currentBit 1 => currentByte 0' shiftIndex 6 (1 << 6)                  // currentBit 7 => currentByte 0' shiftIndex 0 (1 << 0)                  // currentBit 8 => currentByte 1' shiftIndex 7 (1 << 7)                  // etc                  int shiftIndex = 7 - (currentBit % 8);                  int testValue = 1 << shiftIndex;                  byte dataByte = bigEndianBytes[currentByte];                    if ((dataByte & testValue) == testValue)                  {                      lastSetBit = currentBit;                      break;                  }              }
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeNamedBitList,The following statement contains a magic number: if (lastSetBit >= 0)              {                  // Bits are zero-indexed' so lastSetBit=0 means "1 semantic bit"' and                  // "1 semantic bit" requires a byte to write it down.                  int semanticBits = lastSetBit + 1;                  int semanticBytes = (7 + semanticBits) / 8;                    // For a lastSetBit of  : 0 1 2 3 4 5 6 7 8 9 A B C D E F                  // unused bits should be: 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0                  int unusedBits = 7 - (lastSetBit % 8);                    // We need to make a mask of the bits to keep around for the last                  // byte' ensuring we clear out any bits that were set' but beyond                  // the namedBitsCount limit.                  //                   // For example:                  // lastSetBit 0 => mask 0b10000000                  // lastSetBit 1 => mask 0b11000000                  // lastSetBit 7 => mask 0b11111111                  // lastSetBit 8 => mask 0b10000000                  byte lastByteSemanticMask = unchecked((byte)(-1 << unusedBits));                    // Semantic bytes plus the "how many unused bits" prefix byte.                  dataSegment = new byte[semanticBytes + 1];                  dataSegment[0] = (byte)unusedBits;                                    Debug.Assert(semanticBytes <= bigEndianBytes.Length);                    Buffer.BlockCopy(bigEndianBytes' 0' dataSegment' 1' semanticBytes);                    // But the last byte might have too many bits set' trim it down                  // to only the ones we knew about (all "don't care" values must be 0)                  dataSegment[semanticBytes] &= lastByteSemanticMask;              }              else              {                  // No bits being set is encoded as just "no unused bits"'                  // with no semantic payload.                  dataSegment = new byte[] { 0x00 };              }
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeNamedBitList,The following statement contains a magic number: if (lastSetBit >= 0)              {                  // Bits are zero-indexed' so lastSetBit=0 means "1 semantic bit"' and                  // "1 semantic bit" requires a byte to write it down.                  int semanticBits = lastSetBit + 1;                  int semanticBytes = (7 + semanticBits) / 8;                    // For a lastSetBit of  : 0 1 2 3 4 5 6 7 8 9 A B C D E F                  // unused bits should be: 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0                  int unusedBits = 7 - (lastSetBit % 8);                    // We need to make a mask of the bits to keep around for the last                  // byte' ensuring we clear out any bits that were set' but beyond                  // the namedBitsCount limit.                  //                   // For example:                  // lastSetBit 0 => mask 0b10000000                  // lastSetBit 1 => mask 0b11000000                  // lastSetBit 7 => mask 0b11111111                  // lastSetBit 8 => mask 0b10000000                  byte lastByteSemanticMask = unchecked((byte)(-1 << unusedBits));                    // Semantic bytes plus the "how many unused bits" prefix byte.                  dataSegment = new byte[semanticBytes + 1];                  dataSegment[0] = (byte)unusedBits;                                    Debug.Assert(semanticBytes <= bigEndianBytes.Length);                    Buffer.BlockCopy(bigEndianBytes' 0' dataSegment' 1' semanticBytes);                    // But the last byte might have too many bits set' trim it down                  // to only the ones we knew about (all "don't care" values must be 0)                  dataSegment[semanticBytes] &= lastByteSemanticMask;              }              else              {                  // No bits being set is encoded as just "no unused bits"'                  // with no semantic payload.                  dataSegment = new byte[] { 0x00 };              }
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeNamedBitList,The following statement contains a magic number: if (lastSetBit >= 0)              {                  // Bits are zero-indexed' so lastSetBit=0 means "1 semantic bit"' and                  // "1 semantic bit" requires a byte to write it down.                  int semanticBits = lastSetBit + 1;                  int semanticBytes = (7 + semanticBits) / 8;                    // For a lastSetBit of  : 0 1 2 3 4 5 6 7 8 9 A B C D E F                  // unused bits should be: 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0                  int unusedBits = 7 - (lastSetBit % 8);                    // We need to make a mask of the bits to keep around for the last                  // byte' ensuring we clear out any bits that were set' but beyond                  // the namedBitsCount limit.                  //                   // For example:                  // lastSetBit 0 => mask 0b10000000                  // lastSetBit 1 => mask 0b11000000                  // lastSetBit 7 => mask 0b11111111                  // lastSetBit 8 => mask 0b10000000                  byte lastByteSemanticMask = unchecked((byte)(-1 << unusedBits));                    // Semantic bytes plus the "how many unused bits" prefix byte.                  dataSegment = new byte[semanticBytes + 1];                  dataSegment[0] = (byte)unusedBits;                                    Debug.Assert(semanticBytes <= bigEndianBytes.Length);                    Buffer.BlockCopy(bigEndianBytes' 0' dataSegment' 1' semanticBytes);                    // But the last byte might have too many bits set' trim it down                  // to only the ones we knew about (all "don't care" values must be 0)                  dataSegment[semanticBytes] &= lastByteSemanticMask;              }              else              {                  // No bits being set is encoded as just "no unused bits"'                  // with no semantic payload.                  dataSegment = new byte[] { 0x00 };              }
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeNamedBitList,The following statement contains a magic number: if (lastSetBit >= 0)              {                  // Bits are zero-indexed' so lastSetBit=0 means "1 semantic bit"' and                  // "1 semantic bit" requires a byte to write it down.                  int semanticBits = lastSetBit + 1;                  int semanticBytes = (7 + semanticBits) / 8;                    // For a lastSetBit of  : 0 1 2 3 4 5 6 7 8 9 A B C D E F                  // unused bits should be: 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0                  int unusedBits = 7 - (lastSetBit % 8);                    // We need to make a mask of the bits to keep around for the last                  // byte' ensuring we clear out any bits that were set' but beyond                  // the namedBitsCount limit.                  //                   // For example:                  // lastSetBit 0 => mask 0b10000000                  // lastSetBit 1 => mask 0b11000000                  // lastSetBit 7 => mask 0b11111111                  // lastSetBit 8 => mask 0b10000000                  byte lastByteSemanticMask = unchecked((byte)(-1 << unusedBits));                    // Semantic bytes plus the "how many unused bits" prefix byte.                  dataSegment = new byte[semanticBytes + 1];                  dataSegment[0] = (byte)unusedBits;                                    Debug.Assert(semanticBytes <= bigEndianBytes.Length);                    Buffer.BlockCopy(bigEndianBytes' 0' dataSegment' 1' semanticBytes);                    // But the last byte might have too many bits set' trim it down                  // to only the ones we knew about (all "don't care" values must be 0)                  dataSegment[semanticBytes] &= lastByteSemanticMask;              }              else              {                  // No bits being set is encoded as just "no unused bits"'                  // with no semantic payload.                  dataSegment = new byte[] { 0x00 };              }
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeOid,The following statement contains a magic number: if (oidValue.Length < 3 /* "1.1" is the shortest value */)                  throw new CryptographicException(SR.Argument_InvalidOidValue);
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeOid,The following statement contains a magic number: switch (oidValue[0])              {                  case '0':                      firstRid = 0;                      break;                  case '1':                      firstRid = 1;                      break;                  case '2':                      firstRid = 2;                      break;                  default:                      throw new CryptographicException(SR.Argument_InvalidOidValue);              }
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeOid,The following statement contains a magic number: int startPos = 2;
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeOid,The following statement contains a magic number: rid += 40 * firstRid;
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeOid,The following statement contains a magic number: List<byte> encodedBytes = new List<byte>(oidValue.Length / 2);
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,ConstructSegmentedContextSpecificValue,The following statement contains a magic number: Debug.Assert(contextId >= 0 && contextId <= 30);
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeIA5String,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  char c = chars[i + offset];                    // IA5 is ASCII 0x00-0x7F.                  if (c > 127)                  {                      throw new CryptographicException(SR.Cryptography_Invalid_IA5String);                  }                    encodedString[i] = (byte)c;              }
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: byte[] asciiDateBytes = new byte[13];
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: asciiDateBytes[1] = (byte)(Char0 + (year % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: year /= 10;
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: asciiDateBytes[0] = (byte)(Char0 + (year % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: asciiDateBytes[3] = (byte)(Char0 + (month % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: asciiDateBytes[3] = (byte)(Char0 + (month % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: month /= 10;
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: asciiDateBytes[2] = (byte)(Char0 + (month % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: asciiDateBytes[2] = (byte)(Char0 + (month % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: asciiDateBytes[5] = (byte)(Char0 + (day % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: asciiDateBytes[5] = (byte)(Char0 + (day % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: day /= 10;
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: asciiDateBytes[4] = (byte)(Char0 + (day % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: asciiDateBytes[4] = (byte)(Char0 + (day % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: asciiDateBytes[7] = (byte)(Char0 + (hour % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: asciiDateBytes[7] = (byte)(Char0 + (hour % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: hour /= 10;
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: asciiDateBytes[6] = (byte)(Char0 + (hour % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: asciiDateBytes[6] = (byte)(Char0 + (hour % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: asciiDateBytes[9] = (byte)(Char0 + (minute % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: asciiDateBytes[9] = (byte)(Char0 + (minute % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: minute /= 10;
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: asciiDateBytes[8] = (byte)(Char0 + (minute % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: asciiDateBytes[8] = (byte)(Char0 + (minute % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: asciiDateBytes[11] = (byte)(Char0 + (second % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: asciiDateBytes[11] = (byte)(Char0 + (second % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: second /= 10;
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: asciiDateBytes[10] = (byte)(Char0 + (second % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: asciiDateBytes[10] = (byte)(Char0 + (second % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeUtcTime,The following statement contains a magic number: asciiDateBytes[12] = (byte)'Z';
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: byte[] asciiDateBytes = new byte[15];
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[3] = (byte)(Char0 + (year % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[3] = (byte)(Char0 + (year % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: year /= 10;
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[2] = (byte)(Char0 + (year % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[2] = (byte)(Char0 + (year % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: year /= 10;
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[1] = (byte)(Char0 + (year % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: year /= 10;
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[0] = (byte)(Char0 + (year % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[5] = (byte)(Char0 + (month % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[5] = (byte)(Char0 + (month % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: month /= 10;
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[4] = (byte)(Char0 + (month % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[4] = (byte)(Char0 + (month % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[7] = (byte)(Char0 + (day % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[7] = (byte)(Char0 + (day % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: day /= 10;
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[6] = (byte)(Char0 + (day % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[6] = (byte)(Char0 + (day % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[9] = (byte)(Char0 + (hour % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[9] = (byte)(Char0 + (hour % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: hour /= 10;
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[8] = (byte)(Char0 + (hour % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[8] = (byte)(Char0 + (hour % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[11] = (byte)(Char0 + (minute % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[11] = (byte)(Char0 + (minute % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: minute /= 10;
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[10] = (byte)(Char0 + (minute % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[10] = (byte)(Char0 + (minute % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[13] = (byte)(Char0 + (second % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[13] = (byte)(Char0 + (second % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: second /= 10;
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[12] = (byte)(Char0 + (second % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[12] = (byte)(Char0 + (second % 10));
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,SegmentedEncodeGeneralizedTime,The following statement contains a magic number: asciiDateBytes[14] = (byte)'Z';
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,ConstructSequence,The following statement contains a magic number: foreach (byte[][] segments in items)              {                  Debug.Assert(segments != null);                  Debug.Assert(segments.Length == 3);                    foreach (byte[] segment in segments)                  {                      Debug.Assert(segment != null);                        Buffer.BlockCopy(segment' 0' encodedSequence' writeStart' segment.Length);                      writeStart += segment.Length;                  }              }
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,ParseOidRid,The following statement contains a magic number: for (int position = startIndex; position < endIndex; position++)              {                  value *= 10;                  value += AtoI(oidValue[position]);              }
Magic Number,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,EncodeRid,The following statement contains a magic number: BigInteger divisor = new BigInteger(128);
Magic Number,System.Security.Cryptography,AsnSetValueComparer,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,Compare,The following statement contains a magic number: Debug.Assert(x.Length == 3' $"x.Length is {x.Length} when it should be 3");
Magic Number,System.Security.Cryptography,AsnSetValueComparer,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,Compare,The following statement contains a magic number: Debug.Assert(y.Length == 3' $"y.Length is {y.Length} when it should be 3");
Magic Number,System.Security.Cryptography,AsnSetValueComparer,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,Compare,The following statement contains a magic number: comparison = x[2].Length - y[2].Length;
Magic Number,System.Security.Cryptography,AsnSetValueComparer,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,Compare,The following statement contains a magic number: comparison = x[2].Length - y[2].Length;
Magic Number,System.Security.Cryptography,AsnSetValueComparer,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,Compare,The following statement contains a magic number: for (int i = 0; i < x[2].Length; i++)                  {                      comparison = x[2][i] - y[2][i];                        if (comparison != 0)                      {                          return comparison;                      }                  }
Magic Number,System.Security.Cryptography,AsnSetValueComparer,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,Compare,The following statement contains a magic number: for (int i = 0; i < x[2].Length; i++)                  {                      comparison = x[2][i] - y[2][i];                        if (comparison != 0)                      {                          return comparison;                      }                  }
Magic Number,System.Security.Cryptography,AsnSetValueComparer,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,Compare,The following statement contains a magic number: for (int i = 0; i < x[2].Length; i++)                  {                      comparison = x[2][i] - y[2][i];                        if (comparison != 0)                      {                          return comparison;                      }                  }
Magic Number,System.Security.Cryptography,DerSequenceReader,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerSequenceReader.cs,DerSequenceReader,The following statement contains a magic number: if (offset < 0 || length < 2 || length > data.Length - offset)                  throw new CryptographicException(SR.Cryptography_Der_Invalid_Encoding);
Magic Number,System.Security.Cryptography,DerSequenceReader,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerSequenceReader.cs,ValidateAndSkipDerValue,The following statement contains a magic number: if ((tag & TagClassMask) == 0)              {                  // Tag 0 is special ("reserved for use by the encoding rules")' but mainly is used                  // as the End-of-Contents marker for the indefinite length encodings' which DER prohibits.                  //                  // Tag 15 is reserved.                  //                  // So either of these are invalid.                    if (tag == 0 || tag == 15)                      throw new CryptographicException(SR.Cryptography_Der_Invalid_Encoding);                    // DER limits the constructed encoding to SEQUENCE and SET' as well as anything which gets                  // a defined encoding as being an IMPLICIT SEQUENCE.                    bool expectConstructed = false;                    switch (tag & TagNumberMask)                  {                      case 0x08: // External or Instance-Of                      case 0x0B: // EmbeddedPDV                      case (byte)DerTag.Sequence:                      case (byte)DerTag.Set:                      case 0x1D: // Unrestricted Character String                          expectConstructed = true;                          break;                  }                    bool isConstructed = (tag & ConstructedFlag) == ConstructedFlag;                    if (expectConstructed != isConstructed)                      throw new CryptographicException(SR.Cryptography_Der_Invalid_Encoding);              }
Magic Number,System.Security.Cryptography,DerSequenceReader,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerSequenceReader.cs,ReadBitString,The following statement contains a magic number: if (unusedBits > 7)                  throw new CryptographicException(SR.Cryptography_Der_Invalid_Encoding);
Magic Number,System.Security.Cryptography,DerSequenceReader,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerSequenceReader.cs,ReadOidAsString,The following statement contains a magic number: StringBuilder builder = new StringBuilder(contentLength * 4);
Magic Number,System.Security.Cryptography,DerSequenceReader,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerSequenceReader.cs,ReadOidAsString,The following statement contains a magic number: byte first = (byte)(firstByte / 40);
Magic Number,System.Security.Cryptography,DerSequenceReader,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerSequenceReader.cs,ReadOidAsString,The following statement contains a magic number: byte second = (byte)(firstByte % 40);
Magic Number,System.Security.Cryptography,DerSequenceReader,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerSequenceReader.cs,ReadOidAsString,The following statement contains a magic number: for (int i = 1; i < contentLength; i++)              {                  byte current = _data[_position + i];                  byte data = (byte)(current & 0x7F);                    if (needDot)                  {                      builder.Append('.');                      needDot = false;                  }                    bigInt <<= 7;                  bigInt += data;                    if (current == data)                  {                      builder.Append(bigInt);                      bigInt = 0;                      needDot = true;                  }              }
Magic Number,System.Security.Cryptography,DerSequenceReader,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerSequenceReader.cs,ReadTime,The following statement contains a magic number: DateTimeFormatInfo fi = LazyInitializer.EnsureInitialized(                  ref s_validityDateTimeFormatInfo'                  () =>                  {                      var clone = (DateTimeFormatInfo)CultureInfo.InvariantCulture.DateTimeFormat.Clone();                      clone.Calendar.TwoDigitYearMax = 2049;                        return clone;                  });
Magic Number,System.Security.Cryptography,DerSequenceReader,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerSequenceReader.cs,ScanContentLength,The following statement contains a magic number: for (int i = offset + 1; i < lengthEnd; i++)              {                  accum <<= 8;                  accum |= data[i];              }
Magic Number,Internal.Cryptography.Pal,FindPal,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\Internal\Cryptography\FindPal.cs,ValidateOidValue,The following statement contains a magic number: if (len < 2)                  throw new ArgumentException(SR.Argument_InvalidOidValue);
Magic Number,Internal.Cryptography.Pal,FindPal,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\Internal\Cryptography\FindPal.cs,LaxParseDecimalBigInteger,The following statement contains a magic number: BigInteger ten = new BigInteger(10);
Magic Number,System.Security.Cryptography.X509Certificates,CertificateRequest,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\CertificateRequest.cs,CreateSelfSigned,The following statement contains a magic number: byte[] serialNumber = new byte[8];
Magic Number,System.Security.Cryptography.X509Certificates,CertificateRequest,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\CertificateRequest.cs,Create,The following statement contains a magic number: TbsCertificate tbsCertificate = new TbsCertificate              {                  Version = 2'                  SerialNumber = serialNumber'                  Issuer = issuerName'                  PublicKey = PublicKey'                  NotBefore = notBefore'                  NotAfter = notAfter'                  Subject = SubjectName'              };
Magic Number,System.Security.Cryptography.X509Certificates,ECDsaX509SignatureGenerator,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\ECDsaX509SignatureGenerator.cs,SignData,The following statement contains a magic number: Debug.Assert(ieeeFormat.Length % 2 == 0);
Magic Number,System.Security.Cryptography.X509Certificates,ECDsaX509SignatureGenerator,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\ECDsaX509SignatureGenerator.cs,SignData,The following statement contains a magic number: int segmentLength = ieeeFormat.Length / 2;
Magic Number,System.Security.Cryptography.X509Certificates,RSAPssX509SignatureGenerator,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\RSAPssX509SignatureGenerator.cs,GetSignatureAlgorithmIdentifier,The following statement contains a magic number: if (hashAlgorithm == HashAlgorithmName.SHA256)              {                  cbSalt = 256 / 8;                  digestOid = Oids.Sha256;              }              else if (hashAlgorithm == HashAlgorithmName.SHA384)              {                  cbSalt = 384 / 8;                  digestOid = Oids.Sha384;              }              else if (hashAlgorithm == HashAlgorithmName.SHA512)              {                  cbSalt = 512 / 8;                  digestOid = Oids.Sha512;              }              else              {                  throw new ArgumentOutOfRangeException(                      nameof(hashAlgorithm)'                      hashAlgorithm'                      SR.Format(SR.Cryptography_UnknownHashAlgorithm' hashAlgorithm.Name));              }
Magic Number,System.Security.Cryptography.X509Certificates,RSAPssX509SignatureGenerator,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\RSAPssX509SignatureGenerator.cs,GetSignatureAlgorithmIdentifier,The following statement contains a magic number: if (hashAlgorithm == HashAlgorithmName.SHA256)              {                  cbSalt = 256 / 8;                  digestOid = Oids.Sha256;              }              else if (hashAlgorithm == HashAlgorithmName.SHA384)              {                  cbSalt = 384 / 8;                  digestOid = Oids.Sha384;              }              else if (hashAlgorithm == HashAlgorithmName.SHA512)              {                  cbSalt = 512 / 8;                  digestOid = Oids.Sha512;              }              else              {                  throw new ArgumentOutOfRangeException(                      nameof(hashAlgorithm)'                      hashAlgorithm'                      SR.Format(SR.Cryptography_UnknownHashAlgorithm' hashAlgorithm.Name));              }
Magic Number,System.Security.Cryptography.X509Certificates,RSAPssX509SignatureGenerator,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\RSAPssX509SignatureGenerator.cs,GetSignatureAlgorithmIdentifier,The following statement contains a magic number: if (hashAlgorithm == HashAlgorithmName.SHA256)              {                  cbSalt = 256 / 8;                  digestOid = Oids.Sha256;              }              else if (hashAlgorithm == HashAlgorithmName.SHA384)              {                  cbSalt = 384 / 8;                  digestOid = Oids.Sha384;              }              else if (hashAlgorithm == HashAlgorithmName.SHA512)              {                  cbSalt = 512 / 8;                  digestOid = Oids.Sha512;              }              else              {                  throw new ArgumentOutOfRangeException(                      nameof(hashAlgorithm)'                      hashAlgorithm'                      SR.Format(SR.Cryptography_UnknownHashAlgorithm' hashAlgorithm.Name));              }
Magic Number,System.Security.Cryptography.X509Certificates,RSAPssX509SignatureGenerator,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\RSAPssX509SignatureGenerator.cs,GetSignatureAlgorithmIdentifier,The following statement contains a magic number: if (hashAlgorithm == HashAlgorithmName.SHA256)              {                  cbSalt = 256 / 8;                  digestOid = Oids.Sha256;              }              else if (hashAlgorithm == HashAlgorithmName.SHA384)              {                  cbSalt = 384 / 8;                  digestOid = Oids.Sha384;              }              else if (hashAlgorithm == HashAlgorithmName.SHA512)              {                  cbSalt = 512 / 8;                  digestOid = Oids.Sha512;              }              else              {                  throw new ArgumentOutOfRangeException(                      nameof(hashAlgorithm)'                      hashAlgorithm'                      SR.Format(SR.Cryptography_UnknownHashAlgorithm' hashAlgorithm.Name));              }
Magic Number,System.Security.Cryptography.X509Certificates,RSAPssX509SignatureGenerator,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\RSAPssX509SignatureGenerator.cs,GetSignatureAlgorithmIdentifier,The following statement contains a magic number: if (hashAlgorithm == HashAlgorithmName.SHA256)              {                  cbSalt = 256 / 8;                  digestOid = Oids.Sha256;              }              else if (hashAlgorithm == HashAlgorithmName.SHA384)              {                  cbSalt = 384 / 8;                  digestOid = Oids.Sha384;              }              else if (hashAlgorithm == HashAlgorithmName.SHA512)              {                  cbSalt = 512 / 8;                  digestOid = Oids.Sha512;              }              else              {                  throw new ArgumentOutOfRangeException(                      nameof(hashAlgorithm)'                      hashAlgorithm'                      SR.Format(SR.Cryptography_UnknownHashAlgorithm' hashAlgorithm.Name));              }
Magic Number,System.Security.Cryptography.X509Certificates,RSAPssX509SignatureGenerator,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\RSAPssX509SignatureGenerator.cs,GetSignatureAlgorithmIdentifier,The following statement contains a magic number: if (hashAlgorithm == HashAlgorithmName.SHA256)              {                  cbSalt = 256 / 8;                  digestOid = Oids.Sha256;              }              else if (hashAlgorithm == HashAlgorithmName.SHA384)              {                  cbSalt = 384 / 8;                  digestOid = Oids.Sha384;              }              else if (hashAlgorithm == HashAlgorithmName.SHA512)              {                  cbSalt = 512 / 8;                  digestOid = Oids.Sha512;              }              else              {                  throw new ArgumentOutOfRangeException(                      nameof(hashAlgorithm)'                      hashAlgorithm'                      SR.Format(SR.Cryptography_UnknownHashAlgorithm' hashAlgorithm.Name));              }
Magic Number,System.Security.Cryptography.X509Certificates,TbsCertificate,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\TbsCertificate.cs,Encode,The following statement contains a magic number: if (Extensions.Count > 0)              {                  Debug.Assert(version >= 2);                    List<byte[][]> encodedExtensions = new List<byte[][]>(Extensions.Count);                    // extensions[3]  Extensions OPTIONAL                  //                  // Since this doesn't say IMPLICIT' it will look like                  //                  // A3 [length]                  //   30 [length]                  //     First Extension                  //     Second Extension                  //     ...                    // An interesting quirk of skipping null values here is that                  // Extensions.Count == 0 => no extensions                  // Extensions.ContainsOnly(null) => empty extensions list                    HashSet<string> usedOids = new HashSet<string>(Extensions.Count);                    foreach (X509Extension extension in Extensions)                  {                      if (extension == null)                          continue;                        if (!usedOids.Add(extension.Oid.Value))                      {                          throw new InvalidOperationException(                              SR.Format(SR.Cryptography_CertReq_DuplicateExtension' extension.Oid.Value));                      }                        encodedExtensions.Add(extension.SegmentedEncodedX509Extension());                  }                    byte[][] extensionField = DerEncoder.ConstructSegmentedSequence(                      DerEncoder.ConstructSegmentedSequence(encodedExtensions));                  extensionField[0][0] = DerSequenceReader.ContextSpecificConstructedTag3;                    encodedFields.Add(extensionField);              }
Magic Number,System.Security.Cryptography.X509Certificates,TbsCertificate,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\TbsCertificate.cs,EncodeValidityField,The following statement contains a magic number: if (utcValue.Year < 1950)              {                  throw new ArgumentOutOfRangeException(propertyName' utcValue' SR.Cryptography_CertReq_DateTooOld);              }
Magic Number,System.Security.Cryptography.X509Certificates,TbsCertificate,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\TbsCertificate.cs,EncodeValidityField,The following statement contains a magic number: if (utcValue.Year < 2050)              {                  return DerEncoder.SegmentedEncodeUtcTime(utcValue);              }
Magic Number,System.Security.Cryptography.X509Certificates,X509Certificate,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\X509Certificate.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < thumbPrint.Length && i < 4; ++i)              {                  value = value << 8 | thumbPrint[i];              }
Magic Number,System.Security.Cryptography.X509Certificates,X509Certificate,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\X509Certificate.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < thumbPrint.Length && i < 4; ++i)              {                  value = value << 8 | thumbPrint[i];              }
Magic Number,System.Security.Cryptography.X509Certificates,X509SubjectKeyIdentifierExtension,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\X509SubjectKeyIdentifierExtension.cs,GenerateSubjectKeyIdentifierFromPublicKey,The following statement contains a magic number: switch (algorithm)              {                  case X509SubjectKeyIdentifierHashAlgorithm.Sha1:                      return ComputeSha1(key.EncodedKeyValue.RawData);                    case X509SubjectKeyIdentifierHashAlgorithm.ShortSha1:                      {                          byte[] sha1 = ComputeSha1(key.EncodedKeyValue.RawData);                            //  ShortSha1: The keyIdentifier is composed of a four bit type field with                          //  the value 0100 followed by the least significant 60 bits of the                          //  SHA-1 hash of the value of the BIT STRING subjectPublicKey                           // (excluding the tag' length' and number of unused bit string bits)                          byte[] shortSha1 = new byte[8];                          Buffer.BlockCopy(sha1' sha1.Length - 8' shortSha1' 0' shortSha1.Length);                          shortSha1[0] &= 0x0f;                          shortSha1[0] |= 0x40;                          return shortSha1;                      }                    case X509SubjectKeyIdentifierHashAlgorithm.CapiSha1:                      return X509Pal.Instance.ComputeCapiSha1OfPublicKey(key);                    default:                      throw new ArgumentException(SR.Format(SR.Arg_EnumIllegalVal' algorithm)' nameof(algorithm));              }
Magic Number,System.Security.Cryptography.X509Certificates,X509SubjectKeyIdentifierExtension,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.X509Certificates\src\System\Security\Cryptography\X509Certificates\X509SubjectKeyIdentifierExtension.cs,GenerateSubjectKeyIdentifierFromPublicKey,The following statement contains a magic number: switch (algorithm)              {                  case X509SubjectKeyIdentifierHashAlgorithm.Sha1:                      return ComputeSha1(key.EncodedKeyValue.RawData);                    case X509SubjectKeyIdentifierHashAlgorithm.ShortSha1:                      {                          byte[] sha1 = ComputeSha1(key.EncodedKeyValue.RawData);                            //  ShortSha1: The keyIdentifier is composed of a four bit type field with                          //  the value 0100 followed by the least significant 60 bits of the                          //  SHA-1 hash of the value of the BIT STRING subjectPublicKey                           // (excluding the tag' length' and number of unused bit string bits)                          byte[] shortSha1 = new byte[8];                          Buffer.BlockCopy(sha1' sha1.Length - 8' shortSha1' 0' shortSha1.Length);                          shortSha1[0] &= 0x0f;                          shortSha1[0] |= 0x40;                          return shortSha1;                      }                    case X509SubjectKeyIdentifierHashAlgorithm.CapiSha1:                      return X509Pal.Instance.ComputeCapiSha1OfPublicKey(key);                    default:                      throw new ArgumentException(SR.Format(SR.Arg_EnumIllegalVal' algorithm)' nameof(algorithm));              }
Missing Default,System.Security.Cryptography,DerEncoder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerEncoder.cs,IsPrintableStringCharacter,The following switch statement is missing a default case: switch (c)              {                  case ' ':                  case '\'':                  case '(':                  case ')':                  case '+':                  case ''':                  case '-':                  case '.':                  case '/':                  case ':':                  case '=':                  case '?':                      return true;              }
Missing Default,System.Security.Cryptography,DerSequenceReader,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerSequenceReader.cs,ValidateAndSkipDerValue,The following switch statement is missing a default case: switch (tag & TagNumberMask)                  {                      case 0x08: // External or Instance-Of                      case 0x0B: // EmbeddedPDV                      case (byte)DerTag.Sequence:                      case (byte)DerTag.Set:                      case 0x1D: // Unrestricted Character String                          expectConstructed = true;                          break;                  }
Missing Default,System.Security.Cryptography,DerSequenceReader,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\Cryptography\DerSequenceReader.cs,ReadX509Date,The following switch statement is missing a default case: switch ((DerTag)tag)              {                  case DerTag.UTCTime:                      return ReadUtcTime();                  case DerTag.GeneralizedTime:                      return ReadGeneralizedTime();              }
