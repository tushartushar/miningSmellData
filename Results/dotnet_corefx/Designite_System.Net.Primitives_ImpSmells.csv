Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Net,Cookie,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\Cookie.cs,VerifySetDefaults,The method has 218 lines of code.
Long Method,System.Net,CookieContainer,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CookieContainer.cs,AgeCookies,The method has 127 lines of code.
Long Method,System.Net,CookieParser,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\CookieParser.cs,Get,The method has 159 lines of code.
Long Method,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseNonCanonical,The method has 130 lines of code.
Long Method,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,IsValidStrict,The method has 146 lines of code.
Long Method,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,Parse,The method has 117 lines of code.
Complex Method,System.Net,Cookie,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\Cookie.cs,VerifySetDefaults,Cyclomatic complexity of the method is 20
Complex Method,System.Net,Cookie,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\Cookie.cs,ToString,Cyclomatic complexity of the method is 12
Complex Method,System.Net,Cookie,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\Cookie.cs,ToServerString,Cyclomatic complexity of the method is 10
Complex Method,System.Net,CookieContainer,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CookieContainer.cs,IsLocalDomain,Cyclomatic complexity of the method is 8
Complex Method,System.Net,CredentialCache,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CredentialCache.cs,Add,Cyclomatic complexity of the method is 8
Complex Method,System.Net,CredentialCache,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CredentialCache.cs,GetCredential,Cyclomatic complexity of the method is 10
Complex Method,System.Net,CredentialCache,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CredentialCache.cs,GetCredential,Cyclomatic complexity of the method is 9
Complex Method,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,Format,Cyclomatic complexity of the method is 8
Complex Method,System.Net,CookieTokenizer,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\CookieParser.cs,FindNext,Cyclomatic complexity of the method is 13
Complex Method,System.Net,CookieTokenizer,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\CookieParser.cs,Next,Cyclomatic complexity of the method is 8
Complex Method,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,IsValidCanonical,Cyclomatic complexity of the method is 9
Complex Method,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseNonCanonical,Cyclomatic complexity of the method is 12
Long Parameter List,System.Net,Cookie,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\Cookie.cs,VerifySetDefaults,The method has 6 parameters. Parameters: variant' uri' isLocalDomain' localDomain' setDefault' shouldThrow
Long Parameter List,System.Net,CookieContainer,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CookieContainer.cs,BuildCookieCollectionFromDomainMatches,The method has 6 parameters. Parameters: uri' isSecure' port' cookies' domainAttribute' matchOnlyPlainCookie
Long Parameter List,System.Net,CookieContainer,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CookieContainer.cs,MergeUpdateCollections,The method has 5 parameters. Parameters: destination' source' port' isSecure' isPlainOnly
Long Parameter List,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,Enter,The method has 5 parameters. Parameters: thisOrContextObject' arg0' arg1' arg2' memberName
Long Parameter List,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,DumpBuffer,The method has 5 parameters. Parameters: thisOrContextObject' buffer' offset' count' memberName
Long Parameter List,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The method has 5 parameters. Parameters: eventId' arg1' arg2' arg3' arg4
Long Parameter List,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The method has 5 parameters. Parameters: eventId' arg1' arg2' arg3' arg4
Long Parameter List,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The method has 5 parameters. Parameters: eventId' arg1' arg2' arg3' arg4
Long Parameter List,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,IsValid,The method has 6 parameters. Parameters: name' start' end' allowIPv6' notImplicitFile' unknownScheme
Long Parameter List,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,IsValidCanonical,The method has 5 parameters. Parameters: name' start' end' allowIPv6' notImplicitFile
Long Identifier,System.Net,CookieContainer,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CookieContainer.cs,InternalGetCookies,The length of the parameter domainAttributeMatchAnyCookieVariant is 36.
Long Identifier,System.Net,CookieContainer,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CookieContainer.cs,InternalGetCookies,The length of the parameter domainAttributeMatchOnlyCookieVariantPlain is 42.
Long Statement,System.Net,Cookie,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\Cookie.cs,VerifySetDefaults,The length of the statement  "                (!(m_value.Length > 2 && m_value[0] == '\"' && m_value[m_value.Length - 1] == '\"') && m_value.IndexOfAny(ReservedToValue) != -1)) " is 130.
Long Statement,System.Net,Cookie,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\Cookie.cs,VerifySetDefaults,The length of the statement  "                            throw new CookieException(SR.Format(SR.net_cookie_attribute' CookieFields.DomainAttributeName' domain == null ? "<null>" : domain)); " is 132.
Long Statement,System.Net,Cookie,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\Cookie.cs,ToString,The length of the statement  "                    sb.Append(SeparatorLiteral + SpecialAttributeLiteral + CookieFields.PathAttributeName + EqualsLiteral); // const strings " is 120.
Long Statement,System.Net,Cookie,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\Cookie.cs,ToString,The length of the statement  "                    sb.Append(SeparatorLiteral + SpecialAttributeLiteral + CookieFields.DomainAttributeName + EqualsLiteral); // const strings " is 122.
Long Statement,System.Net,Cookie,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\Cookie.cs,ToServerString,The length of the statement  "                result += SeparatorLiteral + CookieFields.CommentUrlAttributeName + EqualsLiteral + QuotesLiteral + m_commentUri.ToString() + QuotesLiteral; " is 140.
Long Statement,System.Net,Cookie,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\Cookie.cs,ToServerString,The length of the statement  "                result += SeparatorLiteral + CookieFields.MaxAgeAttributeName + EqualsLiteral + seconds.ToString(NumberFormatInfo.InvariantInfo); " is 129.
Long Statement,System.Net,Cookie,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\Cookie.cs,ToServerString,The length of the statement  "                result += SeparatorLiteral + CookieFields.VersionAttributeName + EqualsLiteral + m_version.ToString(NumberFormatInfo.InvariantInfo); " is 132.
Long Statement,System.Net,CookieContainer,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CookieContainer.cs,CookieCutter,The length of the statement  "                if (NetEventSource.IsEnabled) NetEventSource.Info(this' $"uri:{uri} headerName:{headerName} setCookieHeader:{setCookieHeader} isThrow:{isThrow}"); " is 146.
Long Statement,System.Net,CookieContainer,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CookieContainer.cs,InternalGetCookies,The length of the statement  "                BuildCookieCollectionFromDomainMatches(uri' isSecure' port' ref cookies' domainAttributeMatchOnlyCookieVariantPlain' true); " is 123.
Long Statement,System.Net,CredentialCache,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CredentialCache.cs,Add,The length of the statement  "            if (NetEventSource.IsEnabled) NetEventSource.Info(this' $"Adding key:[{key}]' cred:[{credential.Domain}]'[{credential.UserName}]"); " is 131.
Long Statement,System.Net,CredentialCache,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CredentialCache.cs,GetCredential,The length of the statement  "                if (NetEventSource.IsEnabled) NetEventSource.Info(this' "CredentialCache::GetCredential short-circuiting because the dictionary is null."); " is 139.
Long Statement,System.Net,CredentialCache,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CredentialCache.cs,GetCredential,The length of the statement  "            if (NetEventSource.IsEnabled) NetEventSource.Info(this' $"Returning {(mostSpecificMatch == null ? "null" : "(" + mostSpecificMatch.UserName + ":" + mostSpecificMatch.Domain + ")")}"); " is 183.
Long Statement,System.Net,CredentialCache,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CredentialCache.cs,GetCredential,The length of the statement  "                if (NetEventSource.IsEnabled) NetEventSource.Info(this' "CredentialCache::GetCredential short-circuiting because the dictionary is null."); " is 139.
Long Statement,System.Net,CredentialCache,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CredentialCache.cs,GetCredential,The length of the statement  "            if (NetEventSource.IsEnabled) NetEventSource.Info(this' $"Returning {((match == null) ? "null" : "(" + match.UserName + ":" + match.Domain + ")")}"); " is 149.
Long Statement,System.Net,CredentialKey,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CredentialCache.cs,IsPrefix,The length of the statement  "            return string.Compare(uri.AbsolutePath' 0' prefixUri.AbsolutePath' 0' prefixLen' StringComparison.OrdinalIgnoreCase) == 0; " is 122.
Long Statement,System.Net,IPEndPoint,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPEndPoint.cs,Create,The length of the statement  "                throw new ArgumentException(SR.Format(SR.net_InvalidAddressFamily' socketAddress.Family.ToString()' this.GetType().FullName' this.AddressFamily.ToString())' nameof(socketAddress)); " is 180.
Long Statement,System.Net,IPEndPoint,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPEndPoint.cs,Create,The length of the statement  "                throw new ArgumentException(SR.Format(SR.net_InvalidSocketAddressSize' socketAddress.GetType().FullName' this.GetType().FullName)' nameof(socketAddress)); " is 154.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,Enter,The length of the statement  "            if (IsEnabled) Log.Enter(IdOf(thisOrContextObject)' memberName' formattableString != null ? Format(formattableString) : NoParameters); " is 134.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,Exit,The length of the statement  "            if (IsEnabled) Log.Exit(IdOf(thisOrContextObject)' memberName' formattableString != null ? Format(formattableString) : NoParameters); " is 133.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,Info,The length of the statement  "            if (IsEnabled) Log.Info(IdOf(thisOrContextObject)' memberName' formattableString != null ? Format(formattableString) : NoParameters); " is 133.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,DumpBuffer,The length of the statement  "                    Fail(thisOrContextObject' $"Invalid {nameof(DumpBuffer)} Args. Length={buffer.Length}' Offset={offset}' Count={count}"' memberName); " is 132.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,DebugValidateArg,The length of the statement  "                Debug.Assert(!(arg is ValueType)' $"Should not be passing value type {arg?.GetType()} to logging without IsEnabled check"); " is 123.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,DebugValidateArg,The length of the statement  "                Debug.Assert(!(arg is FormattableString)' $"Should not be formatting FormattableString \"{arg}\" if tracing isn't enabled"); " is 124.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,DebugValidateArg,The length of the statement  "            Debug.Assert(IsEnabled || arg == null' $"Should not be formatting FormattableString \"{arg}\" if tracing isn't enabled"); " is 121.
Long Statement,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,IsValid,The length of the statement  "            // IPv6 can only have canonical IPv4 embedded. Unknown schemes will not attempt parsing of non-canonical IPv4 addresses. " is 120.
Complex Conditional,System.Net,Cookie,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\Cookie.cs,VerifySetDefaults,The conditional expression  "m_name == null || m_name.Length == 0 || m_name[0] == '$' || m_name.IndexOfAny(ReservedToName) != -1"  is complex.
Complex Conditional,System.Net,Cookie,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\Cookie.cs,VerifySetDefaults,The conditional expression  "m_value == null ||                  (!(m_value.Length > 2 && m_value[0] == '\"' && m_value[m_value.Length - 1] == '\"') && m_value.IndexOfAny(ReservedToValue) != -1)"  is complex.
Complex Conditional,System.Net,Cookie,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\Cookie.cs,VerifySetDefaults,The conditional expression  "Comment != null && !(Comment.Length > 2 && Comment[0] == '\"' && Comment[Comment.Length - 1] == '\"')                  && (Comment.IndexOfAny(ReservedToValue) != -1)"  is complex.
Complex Conditional,System.Net,Cookie,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\Cookie.cs,VerifySetDefaults,The conditional expression  "Path != null && !(Path.Length > 2 && Path[0] == '\"' && Path[Path.Length - 1] == '\"')                  && (Path.IndexOfAny(ReservedToValue) != -1)"  is complex.
Complex Conditional,System.Net,Cookie,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\Cookie.cs,DomainCharsTest,The conditional expression  "!((ch >= '0' && ch <= '9') ||                        (ch == '.' || ch == '-') ||                        (ch >= 'a' && ch <= 'z') ||                        (ch >= 'A' && ch <= 'Z') ||                        (ch == '_'))"  is complex.
Complex Conditional,System.Net,Cookie,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\Cookie.cs,ToServerString,The conditional expression  "!Plain && !m_port_implicit && m_port != null && m_port.Length > 0"  is complex.
Complex Conditional,System.Net,CredentialCache,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CredentialCache.cs,Add,The conditional expression  "(cred is SystemNetworkCredential)                  && !((string.Equals(authType' NegotiationInfoClass.NTLM' StringComparison.OrdinalIgnoreCase))                       || (string.Equals(authType' NegotiationInfoClass.Kerberos' StringComparison.OrdinalIgnoreCase))                       || (string.Equals(authType' NegotiationInfoClass.Negotiate' StringComparison.OrdinalIgnoreCase)))"  is complex.
Complex Conditional,System.Net,CredentialCache,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CredentialCache.cs,Add,The conditional expression  "(credential is SystemNetworkCredential)                  && !((string.Equals(authenticationType' NegotiationInfoClass.NTLM' StringComparison.OrdinalIgnoreCase))                       || (string.Equals(authenticationType' NegotiationInfoClass.Kerberos' StringComparison.OrdinalIgnoreCase))                       || (string.Equals(authenticationType' NegotiationInfoClass.Negotiate' StringComparison.OrdinalIgnoreCase)))"  is complex.
Complex Conditional,System.Net,CookieTokenizer,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\CookieParser.cs,FindNext,The conditional expression  "(_index < _length)                         && (_tokenStream[_index] != ';')                         && (ignoreEquals || (_tokenStream[_index] != '='))                         && (ignoreComma || (_tokenStream[_index] != '''))"  is complex.
Complex Conditional,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,IsValidCanonical,The conditional expression  "ch == '/' || ch == '\\' || (notImplicitFile && (ch == ':' || ch == '?' || ch == '#'))"  is complex.
Complex Conditional,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseNonCanonical,The conditional expression  "(numberBase == Decimal || numberBase == Hex) && '0' <= ch && ch <= '9'"  is complex.
Complex Conditional,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseNonCanonical,The conditional expression  "(ch = name[current]) == '/' || ch == '\\' || (notImplicitFile && (ch == ':' || ch == '?' || ch == '#'))"  is complex.
Complex Conditional,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,ShouldHaveIpv4Embedded,The conditional expression  "numbers[0] == 0 && numbers[1] == 0 && numbers[2] == 0 && numbers[3] == 0 && numbers[6] != 0"  is complex.
Complex Conditional,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,Parse,The conditional expression  "j < address.Length && (address[j] != ']') && (address[j] != '/') && (address[j] != '%')"  is complex.
Empty Catch Block,System.Net,DictionaryEnumeratorHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CredentialCache.cs,Reset,The method has an empty catch block.
Magic Number,System.Net,Cookie,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\Cookie.cs,VerifySetDefaults,The following statement contains a magic number: if (m_value == null ||                  (!(m_value.Length > 2 && m_value[0] == '\"' && m_value[m_value.Length - 1] == '\"') && m_value.IndexOfAny(ReservedToValue) != -1))              {                  if (shouldThrow)                  {                      throw new CookieException(SR.Format(SR.net_cookie_attribute' "Value"' m_value == null ? "<null>" : m_value));                  }                  return false;              }
Magic Number,System.Net,Cookie,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\Cookie.cs,VerifySetDefaults,The following statement contains a magic number: if (Comment != null && !(Comment.Length > 2 && Comment[0] == '\"' && Comment[Comment.Length - 1] == '\"')                  && (Comment.IndexOfAny(ReservedToValue) != -1))              {                  if (shouldThrow)                  {                      throw new CookieException(SR.Format(SR.net_cookie_attribute' CookieFields.CommentAttributeName' Comment));                  }                  return false;              }
Magic Number,System.Net,Cookie,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\Cookie.cs,VerifySetDefaults,The following statement contains a magic number: if (Path != null && !(Path.Length > 2 && Path[0] == '\"' && Path[Path.Length - 1] == '\"')                  && (Path.IndexOfAny(ReservedToValue) != -1))              {                  if (shouldThrow)                  {                      throw new CookieException(SR.Format(SR.net_cookie_attribute' CookieFields.PathAttributeName' Path));                  }                  return false;              }
Magic Number,System.Net,Cookie,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\Cookie.cs,VerifySetDefaults,The following statement contains a magic number: if (setDefault && m_domain_implicit == true)              {                  m_domain = host;              }              else              {                  if (!m_domain_implicit)                  {                      // Forwarding note: If Uri.Host is of IP address form then the only supported case                      // is for IMPLICIT domain property of a cookie.                      // The code below (explicit cookie.Domain value) will try to parse Uri.Host IP string                      // as a fqdn and reject the cookie.                        // Aliasing since we might need the KeyValue (but not the original one).                      string domain = m_domain;                        // Syntax check for Domain charset plus empty string.                      if (!DomainCharsTest(domain))                      {                          if (shouldThrow)                          {                              throw new CookieException(SR.Format(SR.net_cookie_attribute' CookieFields.DomainAttributeName' domain == null ? "<null>" : domain));                          }                          return false;                      }                        // Domain must start with '.' if set explicitly.                      if (domain[0] != '.')                      {                          if (!(variant == CookieVariant.Rfc2965 || variant == CookieVariant.Plain))                          {                              if (shouldThrow)                              {                                  throw new CookieException(SR.Format(SR.net_cookie_attribute' CookieFields.DomainAttributeName' m_domain));                              }                              return false;                          }                          domain = '.' + domain;                      }                        int host_dot = host.IndexOf('.');                        // First quick check is for pushing a cookie into the local domain.                      if (isLocalDomain && string.Equals(localDomain' domain' StringComparison.OrdinalIgnoreCase))                      {                          valid = true;                      }                      else if (domain.IndexOf('.'' 1' domain.Length - 2) == -1)                      {                          // A single label domain is valid only if the domain is exactly the same as the host specified in the URI.                          if (!IsDomainEqualToHost(domain' host))                          {                              valid = false;                          }                      }                      else if (variant == CookieVariant.Plain)                      {                          // We distinguish between Version0 cookie and other versions on domain issue.                          // According to Version0 spec a domain must be just a substring of the hostname.                            if (!IsDomainEqualToHost(domain' host))                          {                              if (host.Length <= domain.Length ||                                  (string.Compare(host' host.Length - domain.Length' domain' 0' domain.Length' StringComparison.OrdinalIgnoreCase) != 0))                              {                                  valid = false;                              }                          }                      }                      else if (host_dot == -1 ||                               domain.Length != host.Length - host_dot ||                               (string.Compare(host' host_dot' domain' 0' domain.Length' StringComparison.OrdinalIgnoreCase) != 0))                      {                          // Starting from the first dot' the host must match the domain.                          //                          // For null hosts' the host must match the domain exactly.                          if (!IsDomainEqualToHost(domain' host))                          {                              valid = false;                          }                      }                        if (valid)                      {                          m_domainKey = domain.ToLowerInvariant();                      }                  }                  else                  {                      // For implicitly set domain AND at the set_default == false time                      // we simply need to match uri.Host against m_domain.                      if (!string.Equals(host' m_domain' StringComparison.OrdinalIgnoreCase))                      {                          valid = false;                      }                  }                  if (!valid)                  {                      if (shouldThrow)                      {                          throw new CookieException(SR.Format(SR.net_cookie_attribute' CookieFields.DomainAttributeName' m_domain));                      }                      return false;                  }              }
Magic Number,System.Net,CookieContainer,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CookieContainer.cs,IsLocalDomain,The following statement contains a magic number: if (ipParts != null && ipParts.Length == 4 && ipParts[0] == "127")              {                  int i;                  for (i = 1; i < ipParts.Length; i++)                  {                      string part = ipParts[i];                      switch (part.Length)                      {                          case 3:                              if (part[2] < '0' || part[2] > '9')                              {                                  break;                              }                              goto case 2;                            case 2:                              if (part[1] < '0' || part[1] > '9')                              {                                  break;                              }                              goto case 1;                            case 1:                              if (part[0] < '0' || part[0] > '9')                              {                                  break;                              }                              continue;                      }                      break;                  }                  if (i == 4)                  {                      return true;                  }              }
Magic Number,System.Net,CookieContainer,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CookieContainer.cs,IsLocalDomain,The following statement contains a magic number: if (ipParts != null && ipParts.Length == 4 && ipParts[0] == "127")              {                  int i;                  for (i = 1; i < ipParts.Length; i++)                  {                      string part = ipParts[i];                      switch (part.Length)                      {                          case 3:                              if (part[2] < '0' || part[2] > '9')                              {                                  break;                              }                              goto case 2;                            case 2:                              if (part[1] < '0' || part[1] > '9')                              {                                  break;                              }                              goto case 1;                            case 1:                              if (part[0] < '0' || part[0] > '9')                              {                                  break;                              }                              continue;                      }                      break;                  }                  if (i == 4)                  {                      return true;                  }              }
Magic Number,System.Net,CookieContainer,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CookieContainer.cs,IsLocalDomain,The following statement contains a magic number: if (ipParts != null && ipParts.Length == 4 && ipParts[0] == "127")              {                  int i;                  for (i = 1; i < ipParts.Length; i++)                  {                      string part = ipParts[i];                      switch (part.Length)                      {                          case 3:                              if (part[2] < '0' || part[2] > '9')                              {                                  break;                              }                              goto case 2;                            case 2:                              if (part[1] < '0' || part[1] > '9')                              {                                  break;                              }                              goto case 1;                            case 1:                              if (part[0] < '0' || part[0] > '9')                              {                                  break;                              }                              continue;                      }                      break;                  }                  if (i == 4)                  {                      return true;                  }              }
Magic Number,System.Net,CookieContainer,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CookieContainer.cs,IsLocalDomain,The following statement contains a magic number: if (ipParts != null && ipParts.Length == 4 && ipParts[0] == "127")              {                  int i;                  for (i = 1; i < ipParts.Length; i++)                  {                      string part = ipParts[i];                      switch (part.Length)                      {                          case 3:                              if (part[2] < '0' || part[2] > '9')                              {                                  break;                              }                              goto case 2;                            case 2:                              if (part[1] < '0' || part[1] > '9')                              {                                  break;                              }                              goto case 1;                            case 1:                              if (part[0] < '0' || part[0] > '9')                              {                                  break;                              }                              continue;                      }                      break;                  }                  if (i == 4)                  {                      return true;                  }              }
Magic Number,System.Net,CookieContainer,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CookieContainer.cs,IsLocalDomain,The following statement contains a magic number: if (ipParts != null && ipParts.Length == 4 && ipParts[0] == "127")              {                  int i;                  for (i = 1; i < ipParts.Length; i++)                  {                      string part = ipParts[i];                      switch (part.Length)                      {                          case 3:                              if (part[2] < '0' || part[2] > '9')                              {                                  break;                              }                              goto case 2;                            case 2:                              if (part[1] < '0' || part[1] > '9')                              {                                  break;                              }                              goto case 1;                            case 1:                              if (part[0] < '0' || part[0] > '9')                              {                                  break;                              }                              continue;                      }                      break;                  }                  if (i == 4)                  {                      return true;                  }              }
Magic Number,System.Net,CookieContainer,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CookieContainer.cs,IsLocalDomain,The following statement contains a magic number: if (ipParts != null && ipParts.Length == 4 && ipParts[0] == "127")              {                  int i;                  for (i = 1; i < ipParts.Length; i++)                  {                      string part = ipParts[i];                      switch (part.Length)                      {                          case 3:                              if (part[2] < '0' || part[2] > '9')                              {                                  break;                              }                              goto case 2;                            case 2:                              if (part[1] < '0' || part[1] > '9')                              {                                  break;                              }                              goto case 1;                            case 1:                              if (part[0] < '0' || part[0] > '9')                              {                                  break;                              }                              continue;                      }                      break;                  }                  if (i == 4)                  {                      return true;                  }              }
Magic Number,System.Net,CookieContainer,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CookieContainer.cs,IsLocalDomain,The following statement contains a magic number: if (ipParts != null && ipParts.Length == 4 && ipParts[0] == "127")              {                  int i;                  for (i = 1; i < ipParts.Length; i++)                  {                      string part = ipParts[i];                      switch (part.Length)                      {                          case 3:                              if (part[2] < '0' || part[2] > '9')                              {                                  break;                              }                              goto case 2;                            case 2:                              if (part[1] < '0' || part[1] > '9')                              {                                  break;                              }                              goto case 1;                            case 1:                              if (part[0] < '0' || part[0] > '9')                              {                                  break;                              }                              continue;                      }                      break;                  }                  if (i == 4)                  {                      return true;                  }              }
Magic Number,System.Net,CookieContainer,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CookieContainer.cs,InternalGetCookies,The following statement contains a magic number: if (dot == -1)              {                  // DNS.resolve may return short names even for other inet domains ;-(                  // We _don't_ know what the exact domain is' so try also grab short hostname cookies.                  // Grab long name from the local domain                  if (m_fqdnMyDomain != null && m_fqdnMyDomain.Length != 0)                  {                      domainAttributeMatchAnyCookieVariant.Add(fqdnRemote + m_fqdnMyDomain);                      // Grab the local domain itself                      domainAttributeMatchAnyCookieVariant.Add(m_fqdnMyDomain);                  }              }              else              {                  // Grab the host domain                  domainAttributeMatchAnyCookieVariant.Add(fqdnRemote.Substring(dot));                    // The following block is only for compatibility with Version0 spec.                  // Still' we'll add only Plain-Variant cookies if found under below keys                  if (fqdnRemote.Length > 2)                  {                      // We ignore the '.' at the end on the name                      int last = fqdnRemote.LastIndexOf('.'' fqdnRemote.Length - 2);                      // AND keys with <2 dots inside.                      if (last > 0)                      {                          last = fqdnRemote.LastIndexOf('.'' last - 1);                      }                      if (last != -1)                      {                          while ((dot < last) && (dot = fqdnRemote.IndexOf('.'' dot + 1)) != -1)                          {                              if (domainAttributeMatchOnlyCookieVariantPlain == null)                              {                                  domainAttributeMatchOnlyCookieVariantPlain = new System.Collections.Generic.List<string>();                              }                                // These candidates can only match CookieVariant.Plain cookies.                              domainAttributeMatchOnlyCookieVariantPlain.Add(fqdnRemote.Substring(dot));                          }                      }                  }              }
Magic Number,System.Net,CookieContainer,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CookieContainer.cs,InternalGetCookies,The following statement contains a magic number: if (dot == -1)              {                  // DNS.resolve may return short names even for other inet domains ;-(                  // We _don't_ know what the exact domain is' so try also grab short hostname cookies.                  // Grab long name from the local domain                  if (m_fqdnMyDomain != null && m_fqdnMyDomain.Length != 0)                  {                      domainAttributeMatchAnyCookieVariant.Add(fqdnRemote + m_fqdnMyDomain);                      // Grab the local domain itself                      domainAttributeMatchAnyCookieVariant.Add(m_fqdnMyDomain);                  }              }              else              {                  // Grab the host domain                  domainAttributeMatchAnyCookieVariant.Add(fqdnRemote.Substring(dot));                    // The following block is only for compatibility with Version0 spec.                  // Still' we'll add only Plain-Variant cookies if found under below keys                  if (fqdnRemote.Length > 2)                  {                      // We ignore the '.' at the end on the name                      int last = fqdnRemote.LastIndexOf('.'' fqdnRemote.Length - 2);                      // AND keys with <2 dots inside.                      if (last > 0)                      {                          last = fqdnRemote.LastIndexOf('.'' last - 1);                      }                      if (last != -1)                      {                          while ((dot < last) && (dot = fqdnRemote.IndexOf('.'' dot + 1)) != -1)                          {                              if (domainAttributeMatchOnlyCookieVariantPlain == null)                              {                                  domainAttributeMatchOnlyCookieVariantPlain = new System.Collections.Generic.List<string>();                              }                                // These candidates can only match CookieVariant.Plain cookies.                              domainAttributeMatchOnlyCookieVariantPlain.Add(fqdnRemote.Substring(dot));                          }                      }                  }              }
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,IPAddress,The following statement contains a magic number: for (int i = 0; i < NumberOfLabels; i++)              {                  _numbers[i] = (ushort)(address[i * 2] * 256 + address[i * 2 + 1]);              }
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,IPAddress,The following statement contains a magic number: for (int i = 0; i < NumberOfLabels; i++)              {                  _numbers[i] = (ushort)(address[i * 2] * 256 + address[i * 2 + 1]);              }
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,IPAddress,The following statement contains a magic number: for (int i = 0; i < NumberOfLabels; i++)              {                  _numbers[i] = (ushort)(address[i * 2] * 256 + address[i * 2 + 1]);              }
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,IPAddress,The following statement contains a magic number: if (address.Length == IPAddressParserStatics.IPv4AddressBytes)              {                  PrivateAddress = (uint)((address[3] << 24 | address[2] << 16 | address[1] << 8 | address[0]) & 0x0FFFFFFFF);              }              else if (address.Length == IPAddressParserStatics.IPv6AddressBytes)              {                  _numbers = new ushort[NumberOfLabels];                    for (int i = 0; i < NumberOfLabels; i++)                  {                      _numbers[i] = (ushort)(address[i * 2] * 256 + address[i * 2 + 1]);                  }              }              else              {                  throw new ArgumentException(SR.dns_bad_ip_address' nameof(address));              }
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,IPAddress,The following statement contains a magic number: if (address.Length == IPAddressParserStatics.IPv4AddressBytes)              {                  PrivateAddress = (uint)((address[3] << 24 | address[2] << 16 | address[1] << 8 | address[0]) & 0x0FFFFFFFF);              }              else if (address.Length == IPAddressParserStatics.IPv6AddressBytes)              {                  _numbers = new ushort[NumberOfLabels];                    for (int i = 0; i < NumberOfLabels; i++)                  {                      _numbers[i] = (ushort)(address[i * 2] * 256 + address[i * 2 + 1]);                  }              }              else              {                  throw new ArgumentException(SR.dns_bad_ip_address' nameof(address));              }
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,IPAddress,The following statement contains a magic number: if (address.Length == IPAddressParserStatics.IPv4AddressBytes)              {                  PrivateAddress = (uint)((address[3] << 24 | address[2] << 16 | address[1] << 8 | address[0]) & 0x0FFFFFFFF);              }              else if (address.Length == IPAddressParserStatics.IPv6AddressBytes)              {                  _numbers = new ushort[NumberOfLabels];                    for (int i = 0; i < NumberOfLabels; i++)                  {                      _numbers[i] = (ushort)(address[i * 2] * 256 + address[i * 2 + 1]);                  }              }              else              {                  throw new ArgumentException(SR.dns_bad_ip_address' nameof(address));              }
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,IPAddress,The following statement contains a magic number: if (address.Length == IPAddressParserStatics.IPv4AddressBytes)              {                  PrivateAddress = (uint)((address[3] << 24 | address[2] << 16 | address[1] << 8 | address[0]) & 0x0FFFFFFFF);              }              else if (address.Length == IPAddressParserStatics.IPv6AddressBytes)              {                  _numbers = new ushort[NumberOfLabels];                    for (int i = 0; i < NumberOfLabels; i++)                  {                      _numbers[i] = (ushort)(address[i * 2] * 256 + address[i * 2 + 1]);                  }              }              else              {                  throw new ArgumentException(SR.dns_bad_ip_address' nameof(address));              }
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,IPAddress,The following statement contains a magic number: if (address.Length == IPAddressParserStatics.IPv4AddressBytes)              {                  PrivateAddress = (uint)((address[3] << 24 | address[2] << 16 | address[1] << 8 | address[0]) & 0x0FFFFFFFF);              }              else if (address.Length == IPAddressParserStatics.IPv6AddressBytes)              {                  _numbers = new ushort[NumberOfLabels];                    for (int i = 0; i < NumberOfLabels; i++)                  {                      _numbers[i] = (ushort)(address[i * 2] * 256 + address[i * 2 + 1]);                  }              }              else              {                  throw new ArgumentException(SR.dns_bad_ip_address' nameof(address));              }
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,IPAddress,The following statement contains a magic number: if (address.Length == IPAddressParserStatics.IPv4AddressBytes)              {                  PrivateAddress = (uint)((address[3] << 24 | address[2] << 16 | address[1] << 8 | address[0]) & 0x0FFFFFFFF);              }              else if (address.Length == IPAddressParserStatics.IPv6AddressBytes)              {                  _numbers = new ushort[NumberOfLabels];                    for (int i = 0; i < NumberOfLabels; i++)                  {                      _numbers[i] = (ushort)(address[i * 2] * 256 + address[i * 2 + 1]);                  }              }              else              {                  throw new ArgumentException(SR.dns_bad_ip_address' nameof(address));              }
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,IPAddress,The following statement contains a magic number: if (address.Length == IPAddressParserStatics.IPv4AddressBytes)              {                  PrivateAddress = (uint)((address[3] << 24 | address[2] << 16 | address[1] << 8 | address[0]) & 0x0FFFFFFFF);              }              else if (address.Length == IPAddressParserStatics.IPv6AddressBytes)              {                  _numbers = new ushort[NumberOfLabels];                    for (int i = 0; i < NumberOfLabels; i++)                  {                      _numbers[i] = (ushort)(address[i * 2] * 256 + address[i * 2 + 1]);                  }              }              else              {                  throw new ArgumentException(SR.dns_bad_ip_address' nameof(address));              }
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,IPAddress,The following statement contains a magic number: if (address.Length == IPAddressParserStatics.IPv4AddressBytes)              {                  PrivateAddress = (uint)((address[3] << 24 | address[2] << 16 | address[1] << 8 | address[0]) & 0x0FFFFFFFF);              }              else if (address.Length == IPAddressParserStatics.IPv6AddressBytes)              {                  _numbers = new ushort[NumberOfLabels];                    for (int i = 0; i < NumberOfLabels; i++)                  {                      _numbers[i] = (ushort)(address[i * 2] * 256 + address[i * 2 + 1]);                  }              }              else              {                  throw new ArgumentException(SR.dns_bad_ip_address' nameof(address));              }
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,WriteIPv6Bytes,The following statement contains a magic number: for (int i = 0; i < NumberOfLabels; i++)              {                  destination[j++] = (byte)((_numbers[i] >> 8) & 0xFF);                  destination[j++] = (byte)((_numbers[i]) & 0xFF);              }
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,WriteIPv4Bytes,The following statement contains a magic number: destination[1] = (byte)(address >> 8);
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,WriteIPv4Bytes,The following statement contains a magic number: destination[2] = (byte)(address >> 16);
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,WriteIPv4Bytes,The following statement contains a magic number: destination[2] = (byte)(address >> 16);
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,WriteIPv4Bytes,The following statement contains a magic number: destination[3] = (byte)(address >> 24);
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,WriteIPv4Bytes,The following statement contains a magic number: destination[3] = (byte)(address >> 24);
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,HostToNetworkOrder,The following statement contains a magic number: value = (value << 32) | (value >> 32);
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,HostToNetworkOrder,The following statement contains a magic number: value = (value << 32) | (value >> 32);
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,HostToNetworkOrder,The following statement contains a magic number: value = (value & 0x0000FFFF0000FFFF) << 16 | (value & 0xFFFF0000FFFF0000) >> 16;
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,HostToNetworkOrder,The following statement contains a magic number: value = (value & 0x0000FFFF0000FFFF) << 16 | (value & 0xFFFF0000FFFF0000) >> 16;
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,HostToNetworkOrder,The following statement contains a magic number: value = (value & 0x00FF00FF00FF00FF) << 8 | (value & 0xFF00FF00FF00FF00) >> 8;
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,HostToNetworkOrder,The following statement contains a magic number: value = (value & 0x00FF00FF00FF00FF) << 8 | (value & 0xFF00FF00FF00FF00) >> 8;
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,HostToNetworkOrder,The following statement contains a magic number: value = (value << 16) | (value >> 16);
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,HostToNetworkOrder,The following statement contains a magic number: value = (value << 16) | (value >> 16);
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,HostToNetworkOrder,The following statement contains a magic number: value = (value & 0x00FF00FF) << 8 | (value & 0xFF00FF00) >> 8;
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,HostToNetworkOrder,The following statement contains a magic number: value = (value & 0x00FF00FF) << 8 | (value & 0xFF00FF00) >> 8;
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,HostToNetworkOrder,The following statement contains a magic number: return unchecked((short)((((int)host & 0xFF) << 8) | (int)((host >> 8) & 0xFF)));
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,HostToNetworkOrder,The following statement contains a magic number: return unchecked((short)((((int)host & 0xFF) << 8) | (int)((host >> 8) & 0xFF)));
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,MapToIPv6,The following statement contains a magic number: labels[5] = 0xFFFF;
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,MapToIPv6,The following statement contains a magic number: labels[6] = (ushort)(((address & 0x0000FF00) >> 8) | ((address & 0x000000FF) << 8));
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,MapToIPv6,The following statement contains a magic number: labels[6] = (ushort)(((address & 0x0000FF00) >> 8) | ((address & 0x000000FF) << 8));
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,MapToIPv6,The following statement contains a magic number: labels[6] = (ushort)(((address & 0x0000FF00) >> 8) | ((address & 0x000000FF) << 8));
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,MapToIPv6,The following statement contains a magic number: labels[7] = (ushort)(((address & 0xFF000000) >> 24) | ((address & 0x00FF0000) >> 8));
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,MapToIPv6,The following statement contains a magic number: labels[7] = (ushort)(((address & 0xFF000000) >> 24) | ((address & 0x00FF0000) >> 8));
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,MapToIPv6,The following statement contains a magic number: labels[7] = (ushort)(((address & 0xFF000000) >> 24) | ((address & 0x00FF0000) >> 8));
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,MapToIPv4,The following statement contains a magic number: long address = ((((uint)_numbers[6] & 0x0000FF00u) >> 8) | (((uint)_numbers[6] & 0x000000FFu) << 8)) |                      (((((uint)_numbers[7] & 0x0000FF00u) >> 8) | (((uint)_numbers[7] & 0x000000FFu) << 8)) << 16);
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,MapToIPv4,The following statement contains a magic number: long address = ((((uint)_numbers[6] & 0x0000FF00u) >> 8) | (((uint)_numbers[6] & 0x000000FFu) << 8)) |                      (((((uint)_numbers[7] & 0x0000FF00u) >> 8) | (((uint)_numbers[7] & 0x000000FFu) << 8)) << 16);
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,MapToIPv4,The following statement contains a magic number: long address = ((((uint)_numbers[6] & 0x0000FF00u) >> 8) | (((uint)_numbers[6] & 0x000000FFu) << 8)) |                      (((((uint)_numbers[7] & 0x0000FF00u) >> 8) | (((uint)_numbers[7] & 0x000000FFu) << 8)) << 16);
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,MapToIPv4,The following statement contains a magic number: long address = ((((uint)_numbers[6] & 0x0000FF00u) >> 8) | (((uint)_numbers[6] & 0x000000FFu) << 8)) |                      (((((uint)_numbers[7] & 0x0000FF00u) >> 8) | (((uint)_numbers[7] & 0x000000FFu) << 8)) << 16);
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,MapToIPv4,The following statement contains a magic number: long address = ((((uint)_numbers[6] & 0x0000FF00u) >> 8) | (((uint)_numbers[6] & 0x000000FFu) << 8)) |                      (((((uint)_numbers[7] & 0x0000FF00u) >> 8) | (((uint)_numbers[7] & 0x000000FFu) << 8)) << 16);
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,MapToIPv4,The following statement contains a magic number: long address = ((((uint)_numbers[6] & 0x0000FF00u) >> 8) | (((uint)_numbers[6] & 0x000000FFu) << 8)) |                      (((((uint)_numbers[7] & 0x0000FF00u) >> 8) | (((uint)_numbers[7] & 0x000000FFu) << 8)) << 16);
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,MapToIPv4,The following statement contains a magic number: long address = ((((uint)_numbers[6] & 0x0000FF00u) >> 8) | (((uint)_numbers[6] & 0x000000FFu) << 8)) |                      (((((uint)_numbers[7] & 0x0000FF00u) >> 8) | (((uint)_numbers[7] & 0x000000FFu) << 8)) << 16);
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,MapToIPv4,The following statement contains a magic number: long address = ((((uint)_numbers[6] & 0x0000FF00u) >> 8) | (((uint)_numbers[6] & 0x000000FFu) << 8)) |                      (((((uint)_numbers[7] & 0x0000FF00u) >> 8) | (((uint)_numbers[7] & 0x000000FFu) << 8)) << 16);
Magic Number,System.Net,IPAddress,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddress.cs,MapToIPv4,The following statement contains a magic number: long address = ((((uint)_numbers[6] & 0x0000FF00u) >> 8) | (((uint)_numbers[6] & 0x000000FFu) << 8)) |                      (((((uint)_numbers[7] & 0x0000FF00u) >> 8) | (((uint)_numbers[7] & 0x000000FFu) << 8)) << 16);
Magic Number,System.Net,IPAddressParser,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddressParser.cs,IPv4AddressToStringHelper,The following statement contains a magic number: FormatIPv4AddressNumber((int)((address >> 8) & 0xFF)' addressString' ref offset);
Magic Number,System.Net,IPAddressParser,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddressParser.cs,IPv4AddressToStringHelper,The following statement contains a magic number: FormatIPv4AddressNumber((int)((address >> 16) & 0xFF)' addressString' ref offset);
Magic Number,System.Net,IPAddressParser,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddressParser.cs,IPv4AddressToStringHelper,The following statement contains a magic number: FormatIPv4AddressNumber((int)((address >> 24) & 0xFF)' addressString' ref offset);
Magic Number,System.Net,IPAddressParser,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddressParser.cs,IPv6AddressToStringHelper,The following statement contains a magic number: const int INET6_ADDRSTRLEN = 65;
Magic Number,System.Net,IPAddressParser,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddressParser.cs,IPv6AddressToStringHelper,The following statement contains a magic number: if (IPv6AddressHelper.ShouldHaveIpv4Embedded(address))              {                  // We need to treat the last 2 ushorts as a 4-byte IPv4 address'                  // so output the first 6 ushorts normally' followed by the IPv4 address.                  AppendSections(address' 0' 6' buffer);                  if (buffer[buffer.Length - 1] != ':')                  {                      buffer.Append(':');                  }                  buffer.Append(IPAddressParser.IPv4AddressToString(ExtractIPv4Address(address)));              }              else              {                  // No IPv4 address.  Output all 8 sections as part of the IPv6 address                  // with normal formatting rules.                  AppendSections(address' 0' 8' buffer);              }
Magic Number,System.Net,IPAddressParser,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddressParser.cs,IPv6AddressToStringHelper,The following statement contains a magic number: if (IPv6AddressHelper.ShouldHaveIpv4Embedded(address))              {                  // We need to treat the last 2 ushorts as a 4-byte IPv4 address'                  // so output the first 6 ushorts normally' followed by the IPv4 address.                  AppendSections(address' 0' 6' buffer);                  if (buffer[buffer.Length - 1] != ':')                  {                      buffer.Append(':');                  }                  buffer.Append(IPAddressParser.IPv4AddressToString(ExtractIPv4Address(address)));              }              else              {                  // No IPv4 address.  Output all 8 sections as part of the IPv6 address                  // with normal formatting rules.                  AppendSections(address' 0' 8' buffer);              }
Magic Number,System.Net,IPAddressParser,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddressParser.cs,FormatIPv4AddressNumber,The following statement contains a magic number: Debug.Assert(number < 256);
Magic Number,System.Net,IPAddressParser,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddressParser.cs,FormatIPv4AddressNumber,The following statement contains a magic number: offset += number > 99 ? 3 : number > 9 ? 2 : 1;
Magic Number,System.Net,IPAddressParser,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddressParser.cs,FormatIPv4AddressNumber,The following statement contains a magic number: offset += number > 99 ? 3 : number > 9 ? 2 : 1;
Magic Number,System.Net,IPAddressParser,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddressParser.cs,FormatIPv4AddressNumber,The following statement contains a magic number: offset += number > 99 ? 3 : number > 9 ? 2 : 1;
Magic Number,System.Net,IPAddressParser,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddressParser.cs,FormatIPv4AddressNumber,The following statement contains a magic number: offset += number > 99 ? 3 : number > 9 ? 2 : 1;
Magic Number,System.Net,IPAddressParser,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddressParser.cs,FormatIPv4AddressNumber,The following statement contains a magic number: do              {                  number = Math.DivRem(number' 10' out int rem);                  addressString[--i] = (char)('0' + rem);              } while (number != 0);
Magic Number,System.Net,IPAddressParser,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddressParser.cs,Ipv4StringToAddress,The following statement contains a magic number: if (tmpAddr != IPv4AddressHelper.Invalid && end == ipSpan.Length)              {                  // IPv4AddressHelper.ParseNonCanonical returns the bytes in the inverse order.                  // Reverse them and return success.                  address =                      ((0xFF000000 & tmpAddr) >> 24) |                      ((0x00FF0000 & tmpAddr) >> 8) |                      ((0x0000FF00 & tmpAddr) << 8) |                      ((0x000000FF & tmpAddr) << 24);                  return true;              }              else              {                  // Failed to parse the address.                  address = 0;                  return false;              }
Magic Number,System.Net,IPAddressParser,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddressParser.cs,Ipv4StringToAddress,The following statement contains a magic number: if (tmpAddr != IPv4AddressHelper.Invalid && end == ipSpan.Length)              {                  // IPv4AddressHelper.ParseNonCanonical returns the bytes in the inverse order.                  // Reverse them and return success.                  address =                      ((0xFF000000 & tmpAddr) >> 24) |                      ((0x00FF0000 & tmpAddr) >> 8) |                      ((0x0000FF00 & tmpAddr) << 8) |                      ((0x000000FF & tmpAddr) << 24);                  return true;              }              else              {                  // Failed to parse the address.                  address = 0;                  return false;              }
Magic Number,System.Net,IPAddressParser,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddressParser.cs,Ipv4StringToAddress,The following statement contains a magic number: if (tmpAddr != IPv4AddressHelper.Invalid && end == ipSpan.Length)              {                  // IPv4AddressHelper.ParseNonCanonical returns the bytes in the inverse order.                  // Reverse them and return success.                  address =                      ((0xFF000000 & tmpAddr) >> 24) |                      ((0x00FF0000 & tmpAddr) >> 8) |                      ((0x0000FF00 & tmpAddr) << 8) |                      ((0x000000FF & tmpAddr) << 24);                  return true;              }              else              {                  // Failed to parse the address.                  address = 0;                  return false;              }
Magic Number,System.Net,IPAddressParser,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddressParser.cs,Ipv4StringToAddress,The following statement contains a magic number: if (tmpAddr != IPv4AddressHelper.Invalid && end == ipSpan.Length)              {                  // IPv4AddressHelper.ParseNonCanonical returns the bytes in the inverse order.                  // Reverse them and return success.                  address =                      ((0xFF000000 & tmpAddr) >> 24) |                      ((0x00FF0000 & tmpAddr) >> 8) |                      ((0x0000FF00 & tmpAddr) << 8) |                      ((0x000000FF & tmpAddr) << 24);                  return true;              }              else              {                  // Failed to parse the address.                  address = 0;                  return false;              }
Magic Number,System.Net,IPAddressParser,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddressParser.cs,Ipv6StringToAddress,The following statement contains a magic number: if (isValid || (end != ipSpan.Length))              {                  string scopeId = null;                  IPv6AddressHelper.Parse(ipSpan' numbers' 0' ref scopeId);                    long result = 0;                  if (!string.IsNullOrEmpty(scopeId))                  {                      if (scopeId.Length < 2)                      {                          scope = 0;                          return false;                      }                        for (int i = 1; i < scopeId.Length; i++)                      {                          char c = scopeId[i];                          if (c < '0' || c > '9')                          {                              scope = 0;                              return false;                          }                          result = (result * 10) + (c - '0');                          if (result > uint.MaxValue)                          {                              scope = 0;                              return false;                          }                      }                  }                    scope = (uint)result;                  return true;              }
Magic Number,System.Net,IPAddressParser,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddressParser.cs,Ipv6StringToAddress,The following statement contains a magic number: if (isValid || (end != ipSpan.Length))              {                  string scopeId = null;                  IPv6AddressHelper.Parse(ipSpan' numbers' 0' ref scopeId);                    long result = 0;                  if (!string.IsNullOrEmpty(scopeId))                  {                      if (scopeId.Length < 2)                      {                          scope = 0;                          return false;                      }                        for (int i = 1; i < scopeId.Length; i++)                      {                          char c = scopeId[i];                          if (c < '0' || c > '9')                          {                              scope = 0;                              return false;                          }                          result = (result * 10) + (c - '0');                          if (result > uint.MaxValue)                          {                              scope = 0;                              return false;                          }                      }                  }                    scope = (uint)result;                  return true;              }
Magic Number,System.Net,IPAddressParser,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddressParser.cs,AppendHex,The following statement contains a magic number: const int MaxLength = sizeof(ushort) * 2;
Magic Number,System.Net,IPAddressParser,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddressParser.cs,AppendHex,The following statement contains a magic number: do              {                  int rem = value % 16;                  value /= 16;                  chars[--pos] = rem < 10 ? (char)('0' + rem) : (char)('a' + (rem - 10));                  Debug.Assert(pos >= 0);              }              while (value != 0);
Magic Number,System.Net,IPAddressParser,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddressParser.cs,AppendHex,The following statement contains a magic number: do              {                  int rem = value % 16;                  value /= 16;                  chars[--pos] = rem < 10 ? (char)('0' + rem) : (char)('a' + (rem - 10));                  Debug.Assert(pos >= 0);              }              while (value != 0);
Magic Number,System.Net,IPAddressParser,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddressParser.cs,AppendHex,The following statement contains a magic number: do              {                  int rem = value % 16;                  value /= 16;                  chars[--pos] = rem < 10 ? (char)('0' + rem) : (char)('a' + (rem - 10));                  Debug.Assert(pos >= 0);              }              while (value != 0);
Magic Number,System.Net,IPAddressParser,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPAddressParser.cs,AppendHex,The following statement contains a magic number: do              {                  int rem = value % 16;                  value /= 16;                  chars[--pos] = rem < 10 ? (char)('0' + rem) : (char)('a' + (rem - 10));                  Debug.Assert(pos >= 0);              }              while (value != 0);
Magic Number,System.Net,IPEndPoint,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPEndPoint.cs,Create,The following statement contains a magic number: if (socketAddress.Size < 8)              {                  throw new ArgumentException(SR.Format(SR.net_InvalidSocketAddressSize' socketAddress.GetType().FullName' this.GetType().FullName)' nameof(socketAddress));              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,Format,The following statement contains a magic number: switch (s.ArgumentCount)              {                  case 0: return s.Format;                  case 1: return string.Format(s.Format' Format(s.GetArgument(0)));                  case 2: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1)));                  case 3: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1))' Format(s.GetArgument(2)));                  default:                      object[] args = s.GetArguments();                      object[] formattedArgs = new object[args.Length];                      for (int i = 0; i < args.Length; i++)                      {                          formattedArgs[i] = Format(args[i]);                      }                      return string.Format(s.Format' formattedArgs);              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,Format,The following statement contains a magic number: switch (s.ArgumentCount)              {                  case 0: return s.Format;                  case 1: return string.Format(s.Format' Format(s.GetArgument(0)));                  case 2: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1)));                  case 3: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1))' Format(s.GetArgument(2)));                  default:                      object[] args = s.GetArguments();                      object[] formattedArgs = new object[args.Length];                      for (int i = 0; i < args.Length; i++)                      {                          formattedArgs[i] = Format(args[i]);                      }                      return string.Format(s.Format' formattedArgs);              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,Format,The following statement contains a magic number: switch (s.ArgumentCount)              {                  case 0: return s.Format;                  case 1: return string.Format(s.Format' Format(s.GetArgument(0)));                  case 2: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1)));                  case 3: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1))' Format(s.GetArgument(2)));                  default:                      object[] args = s.GetArguments();                      object[] formattedArgs = new object[args.Length];                      for (int i = 0; i < args.Length; i++)                      {                          formattedArgs[i] = Format(args[i]);                      }                      return string.Format(s.Format' formattedArgs);              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\NetEventSource.Primitives.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,ByteOrder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\ByteOrder.cs,HostToNetworkBytes,The following statement contains a magic number: bytes[index] = (byte)(host >> 8);
Magic Number,System.Net,ByteOrder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\ByteOrder.cs,NetworkBytesToHostUInt16,The following statement contains a magic number: return (ushort)(((ushort)bytes[index] << 8) | (ushort)bytes[index + 1]);
Magic Number,System.Net,CookieParser,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\CookieParser.cs,CheckQuoted,The following statement contains a magic number: if (value.Length < 2 || value[0] != '\"' || value[value.Length - 1] != '\"')                  return value;
Magic Number,System.Net,CookieParser,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\CookieParser.cs,CheckQuoted,The following statement contains a magic number: return value.Length == 2 ? string.Empty : value.Substring(1' value.Length - 2);
Magic Number,System.Net,CookieParser,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\CookieParser.cs,CheckQuoted,The following statement contains a magic number: return value.Length == 2 ? string.Empty : value.Substring(1' value.Length - 2);
Magic Number,System.Net,SocketAddress,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\SocketAddress.cs,SocketAddress,The following statement contains a magic number: Buffer = new byte[(size / IntPtr.Size + 2) * IntPtr.Size];
Magic Number,System.Net,SocketAddress,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\SocketAddress.cs,CopyAddressSizeIntoBuffer,The following statement contains a magic number: Buffer[Buffer.Length - IntPtr.Size + 1] = unchecked((byte)(InternalSize >> 8));
Magic Number,System.Net,SocketAddress,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\SocketAddress.cs,CopyAddressSizeIntoBuffer,The following statement contains a magic number: Buffer[Buffer.Length - IntPtr.Size + 2] = unchecked((byte)(InternalSize >> 16));
Magic Number,System.Net,SocketAddress,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\SocketAddress.cs,CopyAddressSizeIntoBuffer,The following statement contains a magic number: Buffer[Buffer.Length - IntPtr.Size + 2] = unchecked((byte)(InternalSize >> 16));
Magic Number,System.Net,SocketAddress,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\SocketAddress.cs,CopyAddressSizeIntoBuffer,The following statement contains a magic number: Buffer[Buffer.Length - IntPtr.Size + 3] = unchecked((byte)(InternalSize >> 24));
Magic Number,System.Net,SocketAddress,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\SocketAddress.cs,CopyAddressSizeIntoBuffer,The following statement contains a magic number: Buffer[Buffer.Length - IntPtr.Size + 3] = unchecked((byte)(InternalSize >> 24));
Magic Number,System.Net,SocketAddress,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\SocketAddress.cs,GetHashCode,The following statement contains a magic number: if (_changed)              {                  _changed = false;                  _hash = 0;                    int i;                  int size = Size & ~3;                    for (i = 0; i < size; i += 4)                  {                      _hash ^= (int)Buffer[i]                              | ((int)Buffer[i + 1] << 8)                              | ((int)Buffer[i + 2] << 16)                              | ((int)Buffer[i + 3] << 24);                  }                  if ((Size & 3) != 0)                  {                      int remnant = 0;                      int shift = 0;                        for (; i < Size; ++i)                      {                          remnant |= ((int)Buffer[i]) << shift;                          shift += 8;                      }                      _hash ^= remnant;                  }              }
Magic Number,System.Net,SocketAddress,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\SocketAddress.cs,GetHashCode,The following statement contains a magic number: if (_changed)              {                  _changed = false;                  _hash = 0;                    int i;                  int size = Size & ~3;                    for (i = 0; i < size; i += 4)                  {                      _hash ^= (int)Buffer[i]                              | ((int)Buffer[i + 1] << 8)                              | ((int)Buffer[i + 2] << 16)                              | ((int)Buffer[i + 3] << 24);                  }                  if ((Size & 3) != 0)                  {                      int remnant = 0;                      int shift = 0;                        for (; i < Size; ++i)                      {                          remnant |= ((int)Buffer[i]) << shift;                          shift += 8;                      }                      _hash ^= remnant;                  }              }
Magic Number,System.Net,SocketAddress,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\SocketAddress.cs,GetHashCode,The following statement contains a magic number: if (_changed)              {                  _changed = false;                  _hash = 0;                    int i;                  int size = Size & ~3;                    for (i = 0; i < size; i += 4)                  {                      _hash ^= (int)Buffer[i]                              | ((int)Buffer[i + 1] << 8)                              | ((int)Buffer[i + 2] << 16)                              | ((int)Buffer[i + 3] << 24);                  }                  if ((Size & 3) != 0)                  {                      int remnant = 0;                      int shift = 0;                        for (; i < Size; ++i)                      {                          remnant |= ((int)Buffer[i]) << shift;                          shift += 8;                      }                      _hash ^= remnant;                  }              }
Magic Number,System.Net,SocketAddress,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\SocketAddress.cs,GetHashCode,The following statement contains a magic number: if (_changed)              {                  _changed = false;                  _hash = 0;                    int i;                  int size = Size & ~3;                    for (i = 0; i < size; i += 4)                  {                      _hash ^= (int)Buffer[i]                              | ((int)Buffer[i + 1] << 8)                              | ((int)Buffer[i + 2] << 16)                              | ((int)Buffer[i + 3] << 24);                  }                  if ((Size & 3) != 0)                  {                      int remnant = 0;                      int shift = 0;                        for (; i < Size; ++i)                      {                          remnant |= ((int)Buffer[i]) << shift;                          shift += 8;                      }                      _hash ^= remnant;                  }              }
Magic Number,System.Net,SocketAddress,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\SocketAddress.cs,GetHashCode,The following statement contains a magic number: if (_changed)              {                  _changed = false;                  _hash = 0;                    int i;                  int size = Size & ~3;                    for (i = 0; i < size; i += 4)                  {                      _hash ^= (int)Buffer[i]                              | ((int)Buffer[i + 1] << 8)                              | ((int)Buffer[i + 2] << 16)                              | ((int)Buffer[i + 3] << 24);                  }                  if ((Size & 3) != 0)                  {                      int remnant = 0;                      int shift = 0;                        for (; i < Size; ++i)                      {                          remnant |= ((int)Buffer[i]) << shift;                          shift += 8;                      }                      _hash ^= remnant;                  }              }
Magic Number,System.Net,SocketAddress,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\SocketAddress.cs,GetHashCode,The following statement contains a magic number: if (_changed)              {                  _changed = false;                  _hash = 0;                    int i;                  int size = Size & ~3;                    for (i = 0; i < size; i += 4)                  {                      _hash ^= (int)Buffer[i]                              | ((int)Buffer[i + 1] << 8)                              | ((int)Buffer[i + 2] << 16)                              | ((int)Buffer[i + 3] << 24);                  }                  if ((Size & 3) != 0)                  {                      int remnant = 0;                      int shift = 0;                        for (; i < Size; ++i)                      {                          remnant |= ((int)Buffer[i]) << shift;                          shift += 8;                      }                      _hash ^= remnant;                  }              }
Magic Number,System.Net,SocketAddress,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\SocketAddress.cs,GetHashCode,The following statement contains a magic number: if (_changed)              {                  _changed = false;                  _hash = 0;                    int i;                  int size = Size & ~3;                    for (i = 0; i < size; i += 4)                  {                      _hash ^= (int)Buffer[i]                              | ((int)Buffer[i + 1] << 8)                              | ((int)Buffer[i + 2] << 16)                              | ((int)Buffer[i + 3] << 24);                  }                  if ((Size & 3) != 0)                  {                      int remnant = 0;                      int shift = 0;                        for (; i < Size; ++i)                      {                          remnant |= ((int)Buffer[i]) << shift;                          shift += 8;                      }                      _hash ^= remnant;                  }              }
Magic Number,System.Net,SocketAddress,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\SocketAddress.cs,GetHashCode,The following statement contains a magic number: if (_changed)              {                  _changed = false;                  _hash = 0;                    int i;                  int size = Size & ~3;                    for (i = 0; i < size; i += 4)                  {                      _hash ^= (int)Buffer[i]                              | ((int)Buffer[i + 1] << 8)                              | ((int)Buffer[i + 2] << 16)                              | ((int)Buffer[i + 3] << 24);                  }                  if ((Size & 3) != 0)                  {                      int remnant = 0;                      int shift = 0;                        for (; i < Size; ++i)                      {                          remnant |= ((int)Buffer[i]) << shift;                          shift += 8;                      }                      _hash ^= remnant;                  }              }
Magic Number,System.Net,SocketAddress,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\SocketAddress.cs,GetHashCode,The following statement contains a magic number: if (_changed)              {                  _changed = false;                  _hash = 0;                    int i;                  int size = Size & ~3;                    for (i = 0; i < size; i += 4)                  {                      _hash ^= (int)Buffer[i]                              | ((int)Buffer[i + 1] << 8)                              | ((int)Buffer[i + 2] << 16)                              | ((int)Buffer[i + 3] << 24);                  }                  if ((Size & 3) != 0)                  {                      int remnant = 0;                      int shift = 0;                        for (; i < Size; ++i)                      {                          remnant |= ((int)Buffer[i]) << shift;                          shift += 8;                      }                      _hash ^= remnant;                  }              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseHostNumber,The following statement contains a magic number: return (numbers[0] << 24) + (numbers[1] << 16) + (numbers[2] << 8) + numbers[3];
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseHostNumber,The following statement contains a magic number: return (numbers[0] << 24) + (numbers[1] << 16) + (numbers[2] << 8) + numbers[3];
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseHostNumber,The following statement contains a magic number: return (numbers[0] << 24) + (numbers[1] << 16) + (numbers[2] << 8) + numbers[3];
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseHostNumber,The following statement contains a magic number: return (numbers[0] << 24) + (numbers[1] << 16) + (numbers[2] << 8) + numbers[3];
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseHostNumber,The following statement contains a magic number: return (numbers[0] << 24) + (numbers[1] << 16) + (numbers[2] << 8) + numbers[3];
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,IsValidCanonical,The following statement contains a magic number: while (start < end)              {                  char ch = name[start];                  if (allowIPv6)                  {                      // for ipv4 inside ipv6 the terminator is either ScopeId' prefix or ipv6 terminator                      if (ch == ']' || ch == '/' || ch == '%')                          break;                  }                  else if (ch == '/' || ch == '\\' || (notImplicitFile && (ch == ':' || ch == '?' || ch == '#')))                  {                      break;                  }                    if (ch <= '9' && ch >= '0')                  {                      if (!haveNumber && (ch == '0'))                      {                          if ((start + 1 < end) && name[start + 1] == '0')                          {                              // 00 is not allowed as a prefix.                              return false;                          }                            firstCharIsZero = true;                      }                        haveNumber = true;                      number = number * 10 + (name[start] - '0');                      if (number > 255)                      {                          return false;                      }                  }                  else if (ch == '.')                  {                      if (!haveNumber || (number > 0 && firstCharIsZero))                      {                          // 0 is not allowed to prefix a number.                          return false;                      }                      ++dots;                      haveNumber = false;                      number = 0;                      firstCharIsZero = false;                  }                  else                  {                      return false;                  }                  ++start;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,IsValidCanonical,The following statement contains a magic number: while (start < end)              {                  char ch = name[start];                  if (allowIPv6)                  {                      // for ipv4 inside ipv6 the terminator is either ScopeId' prefix or ipv6 terminator                      if (ch == ']' || ch == '/' || ch == '%')                          break;                  }                  else if (ch == '/' || ch == '\\' || (notImplicitFile && (ch == ':' || ch == '?' || ch == '#')))                  {                      break;                  }                    if (ch <= '9' && ch >= '0')                  {                      if (!haveNumber && (ch == '0'))                      {                          if ((start + 1 < end) && name[start + 1] == '0')                          {                              // 00 is not allowed as a prefix.                              return false;                          }                            firstCharIsZero = true;                      }                        haveNumber = true;                      number = number * 10 + (name[start] - '0');                      if (number > 255)                      {                          return false;                      }                  }                  else if (ch == '.')                  {                      if (!haveNumber || (number > 0 && firstCharIsZero))                      {                          // 0 is not allowed to prefix a number.                          return false;                      }                      ++dots;                      haveNumber = false;                      number = 0;                      firstCharIsZero = false;                  }                  else                  {                      return false;                  }                  ++start;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,IsValidCanonical,The following statement contains a magic number: bool res = (dots == 3) && haveNumber;
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: long* parts = stackalloc long[4];
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: for (; current < end; current++)              {                  ch = name[current];                  currentValue = 0;                    // Figure out what base this section is in                  numberBase = Decimal;                  if (ch == '0')                  {                      numberBase = Octal;                      current++;                      atLeastOneChar = true;                      if (current < end)                      {                          ch = name[current];                          if (ch == 'x' || ch == 'X')                          {                              numberBase = Hex;                              current++;                              atLeastOneChar = false;                          }                      }                  }                    // Parse this section                  for (; current < end; current++)                  {                      ch = name[current];                      int digitValue;                        if ((numberBase == Decimal || numberBase == Hex) && '0' <= ch && ch <= '9')                      {                          digitValue = ch - '0';                      }                      else if (numberBase == Octal && '0' <= ch && ch <= '7')                      {                          digitValue = ch - '0';                      }                      else if (numberBase == Hex && 'a' <= ch && ch <= 'f')                      {                          digitValue = ch + 10 - 'a';                      }                      else if (numberBase == Hex && 'A' <= ch && ch <= 'F')                      {                          digitValue = ch + 10 - 'A';                      }                      else                      {                          break; // Invalid/terminator                      }                        currentValue = (currentValue * numberBase) + digitValue;                        if (currentValue > MaxIPv4Value) // Overflow                      {                          return Invalid;                      }                        atLeastOneChar = true;                  }                    if (current < end && name[current] == '.')                  {                      if (dotCount >= 3 // Max of 3 dots and 4 segments                          || !atLeastOneChar // No empty segmets: 1...1                                             // Only the last segment can be more than 255 (if there are less than 3 dots)                          || currentValue > 0xFF)                      {                          return Invalid;                      }                      parts[dotCount] = currentValue;                      dotCount++;                      atLeastOneChar = false;                      continue;                  }                  // We don't get here unless We find an invalid character or a terminator                  break;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: for (; current < end; current++)              {                  ch = name[current];                  currentValue = 0;                    // Figure out what base this section is in                  numberBase = Decimal;                  if (ch == '0')                  {                      numberBase = Octal;                      current++;                      atLeastOneChar = true;                      if (current < end)                      {                          ch = name[current];                          if (ch == 'x' || ch == 'X')                          {                              numberBase = Hex;                              current++;                              atLeastOneChar = false;                          }                      }                  }                    // Parse this section                  for (; current < end; current++)                  {                      ch = name[current];                      int digitValue;                        if ((numberBase == Decimal || numberBase == Hex) && '0' <= ch && ch <= '9')                      {                          digitValue = ch - '0';                      }                      else if (numberBase == Octal && '0' <= ch && ch <= '7')                      {                          digitValue = ch - '0';                      }                      else if (numberBase == Hex && 'a' <= ch && ch <= 'f')                      {                          digitValue = ch + 10 - 'a';                      }                      else if (numberBase == Hex && 'A' <= ch && ch <= 'F')                      {                          digitValue = ch + 10 - 'A';                      }                      else                      {                          break; // Invalid/terminator                      }                        currentValue = (currentValue * numberBase) + digitValue;                        if (currentValue > MaxIPv4Value) // Overflow                      {                          return Invalid;                      }                        atLeastOneChar = true;                  }                    if (current < end && name[current] == '.')                  {                      if (dotCount >= 3 // Max of 3 dots and 4 segments                          || !atLeastOneChar // No empty segmets: 1...1                                             // Only the last segment can be more than 255 (if there are less than 3 dots)                          || currentValue > 0xFF)                      {                          return Invalid;                      }                      parts[dotCount] = currentValue;                      dotCount++;                      atLeastOneChar = false;                      continue;                  }                  // We don't get here unless We find an invalid character or a terminator                  break;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: for (; current < end; current++)              {                  ch = name[current];                  currentValue = 0;                    // Figure out what base this section is in                  numberBase = Decimal;                  if (ch == '0')                  {                      numberBase = Octal;                      current++;                      atLeastOneChar = true;                      if (current < end)                      {                          ch = name[current];                          if (ch == 'x' || ch == 'X')                          {                              numberBase = Hex;                              current++;                              atLeastOneChar = false;                          }                      }                  }                    // Parse this section                  for (; current < end; current++)                  {                      ch = name[current];                      int digitValue;                        if ((numberBase == Decimal || numberBase == Hex) && '0' <= ch && ch <= '9')                      {                          digitValue = ch - '0';                      }                      else if (numberBase == Octal && '0' <= ch && ch <= '7')                      {                          digitValue = ch - '0';                      }                      else if (numberBase == Hex && 'a' <= ch && ch <= 'f')                      {                          digitValue = ch + 10 - 'a';                      }                      else if (numberBase == Hex && 'A' <= ch && ch <= 'F')                      {                          digitValue = ch + 10 - 'A';                      }                      else                      {                          break; // Invalid/terminator                      }                        currentValue = (currentValue * numberBase) + digitValue;                        if (currentValue > MaxIPv4Value) // Overflow                      {                          return Invalid;                      }                        atLeastOneChar = true;                  }                    if (current < end && name[current] == '.')                  {                      if (dotCount >= 3 // Max of 3 dots and 4 segments                          || !atLeastOneChar // No empty segmets: 1...1                                             // Only the last segment can be more than 255 (if there are less than 3 dots)                          || currentValue > 0xFF)                      {                          return Invalid;                      }                      parts[dotCount] = currentValue;                      dotCount++;                      atLeastOneChar = false;                      continue;                  }                  // We don't get here unless We find an invalid character or a terminator                  break;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseCanonical,The following statement contains a magic number: for (int i = 0; i < NumberOfLabels; ++i)              {                    byte b = 0;                  char ch;                  for (; (start < end) && (ch = name[start]) != '.' && ch != ':'; ++start)                  {                      b = (byte)(b * 10 + (byte)(ch - '0'));                  }                  numbers[i] = b;                  ++start;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv4AddressHelper.cs,ParseCanonical,The following statement contains a magic number: return numbers[0] == 127;
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,ShouldHaveIpv4Embedded,The following statement contains a magic number: if (numbers[0] == 0 && numbers[1] == 0 && numbers[2] == 0 && numbers[3] == 0 && numbers[6] != 0)              {                  // RFC 5952 Section 5 - 0:0 : 0:0 : 0:[0 | FFFF] : x.x.x.x                  if (numbers[4] == 0 && (numbers[5] == 0 || numbers[5] == 0xFFFF))                  {                      return true;                  }                  // SIIT - 0:0 : 0:0 : FFFF:0 : x.x.x.x                  else if (numbers[4] == 0xFFFF && numbers[5] == 0)                  {                      return true;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,ShouldHaveIpv4Embedded,The following statement contains a magic number: if (numbers[0] == 0 && numbers[1] == 0 && numbers[2] == 0 && numbers[3] == 0 && numbers[6] != 0)              {                  // RFC 5952 Section 5 - 0:0 : 0:0 : 0:[0 | FFFF] : x.x.x.x                  if (numbers[4] == 0 && (numbers[5] == 0 || numbers[5] == 0xFFFF))                  {                      return true;                  }                  // SIIT - 0:0 : 0:0 : FFFF:0 : x.x.x.x                  else if (numbers[4] == 0xFFFF && numbers[5] == 0)                  {                      return true;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,ShouldHaveIpv4Embedded,The following statement contains a magic number: if (numbers[0] == 0 && numbers[1] == 0 && numbers[2] == 0 && numbers[3] == 0 && numbers[6] != 0)              {                  // RFC 5952 Section 5 - 0:0 : 0:0 : 0:[0 | FFFF] : x.x.x.x                  if (numbers[4] == 0 && (numbers[5] == 0 || numbers[5] == 0xFFFF))                  {                      return true;                  }                  // SIIT - 0:0 : 0:0 : FFFF:0 : x.x.x.x                  else if (numbers[4] == 0xFFFF && numbers[5] == 0)                  {                      return true;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,ShouldHaveIpv4Embedded,The following statement contains a magic number: if (numbers[0] == 0 && numbers[1] == 0 && numbers[2] == 0 && numbers[3] == 0 && numbers[6] != 0)              {                  // RFC 5952 Section 5 - 0:0 : 0:0 : 0:[0 | FFFF] : x.x.x.x                  if (numbers[4] == 0 && (numbers[5] == 0 || numbers[5] == 0xFFFF))                  {                      return true;                  }                  // SIIT - 0:0 : 0:0 : FFFF:0 : x.x.x.x                  else if (numbers[4] == 0xFFFF && numbers[5] == 0)                  {                      return true;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,ShouldHaveIpv4Embedded,The following statement contains a magic number: if (numbers[0] == 0 && numbers[1] == 0 && numbers[2] == 0 && numbers[3] == 0 && numbers[6] != 0)              {                  // RFC 5952 Section 5 - 0:0 : 0:0 : 0:[0 | FFFF] : x.x.x.x                  if (numbers[4] == 0 && (numbers[5] == 0 || numbers[5] == 0xFFFF))                  {                      return true;                  }                  // SIIT - 0:0 : 0:0 : FFFF:0 : x.x.x.x                  else if (numbers[4] == 0xFFFF && numbers[5] == 0)                  {                      return true;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,ShouldHaveIpv4Embedded,The following statement contains a magic number: if (numbers[0] == 0 && numbers[1] == 0 && numbers[2] == 0 && numbers[3] == 0 && numbers[6] != 0)              {                  // RFC 5952 Section 5 - 0:0 : 0:0 : 0:[0 | FFFF] : x.x.x.x                  if (numbers[4] == 0 && (numbers[5] == 0 || numbers[5] == 0xFFFF))                  {                      return true;                  }                  // SIIT - 0:0 : 0:0 : FFFF:0 : x.x.x.x                  else if (numbers[4] == 0xFFFF && numbers[5] == 0)                  {                      return true;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,ShouldHaveIpv4Embedded,The following statement contains a magic number: if (numbers[0] == 0 && numbers[1] == 0 && numbers[2] == 0 && numbers[3] == 0 && numbers[6] != 0)              {                  // RFC 5952 Section 5 - 0:0 : 0:0 : 0:[0 | FFFF] : x.x.x.x                  if (numbers[4] == 0 && (numbers[5] == 0 || numbers[5] == 0xFFFF))                  {                      return true;                  }                  // SIIT - 0:0 : 0:0 : FFFF:0 : x.x.x.x                  else if (numbers[4] == 0xFFFF && numbers[5] == 0)                  {                      return true;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,ShouldHaveIpv4Embedded,The following statement contains a magic number: if (numbers[0] == 0 && numbers[1] == 0 && numbers[2] == 0 && numbers[3] == 0 && numbers[6] != 0)              {                  // RFC 5952 Section 5 - 0:0 : 0:0 : 0:[0 | FFFF] : x.x.x.x                  if (numbers[4] == 0 && (numbers[5] == 0 || numbers[5] == 0xFFFF))                  {                      return true;                  }                  // SIIT - 0:0 : 0:0 : FFFF:0 : x.x.x.x                  else if (numbers[4] == 0xFFFF && numbers[5] == 0)                  {                      return true;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,ShouldHaveIpv4Embedded,The following statement contains a magic number: return numbers[4] == 0 && numbers[5] == 0x5EFE;
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,ShouldHaveIpv4Embedded,The following statement contains a magic number: return numbers[4] == 0 && numbers[5] == 0x5EFE;
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,IsValidStrict,The following statement contains a magic number: for (i = start; i < end; ++i)              {                  if (Uri.IsHexDigit(name[i]))                  {                      ++sequenceLength;                      expectingNumber = false;                  }                  else                  {                      if (sequenceLength > 4)                      {                          return false;                      }                      if (sequenceLength != 0)                      {                          ++sequenceCount;                          lastSequence = i - sequenceLength;                          sequenceLength = 0;                      }                      switch (name[i])                      {                          case '%':                              while (i+1 < end)                              {                                  i++;                                  if (name[i] == ']')                                  {                                      goto case ']';                                  }                                  else if (name[i] == '/')                                  {                                      goto case '/';                                  }                                  else if (name[i] < '0' || name[i] > '9')                                  {                                      // scope ID must only contain digits                                      return false;                                  }                              }                              break;                          case ']':                              if (!needsClosingBracket)                              {                                  return false;                              }                              needsClosingBracket = false;                                // If there's more after the closing bracket' it must be a port.                              // We don't use the port' but we still validate it.                              if (i + 1 < end && name[i + 1] != ':')                              {                                  return false;                              }                                // If there is a port' it must either be a hexadecimal or decimal number.                              if (i + 3 < end && name[i + 2] == '0' && name[i + 3] == 'x')                              {                                  i += 4;                                  for (; i < end; i++)                                  {                                      if (!Uri.IsHexDigit(name[i]))                                      {                                          return false;                                      }                                  }                              }                              else                              {                                  i += 2;                                  for (; i < end; i++)                                  {                                      if (name[i] < '0' || name[i] > '9')                                      {                                          return false;                                      }                                  }                              }                              continue;                          case ':':                              if ((i > 0) && (name[i - 1] == ':'))                              {                                  if (haveCompressor)                                  {                                      // can only have one per IPv6 address                                      return false;                                  }                                  haveCompressor = true;                                  expectingNumber = false;                              }                              else                              {                                  expectingNumber = true;                              }                              break;                            case '/':                              return false;                            case '.':                              if (haveIPv4Address)                              {                                  return false;                              }                                i = end;                              if (!IPv4AddressHelper.IsValid(name' lastSequence' ref i' true' false' false))                              {                                  return false;                              }                              // ipv4 address takes 2 slots in ipv6 address' one was just counted meeting the '.'                              ++sequenceCount;                              lastSequence = i - sequenceLength;                              sequenceLength = 0;                              haveIPv4Address = true;                              --i;            // it will be incremented back on the next loop                              break;                            default:                              return false;                      }                      sequenceLength = 0;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,IsValidStrict,The following statement contains a magic number: for (i = start; i < end; ++i)              {                  if (Uri.IsHexDigit(name[i]))                  {                      ++sequenceLength;                      expectingNumber = false;                  }                  else                  {                      if (sequenceLength > 4)                      {                          return false;                      }                      if (sequenceLength != 0)                      {                          ++sequenceCount;                          lastSequence = i - sequenceLength;                          sequenceLength = 0;                      }                      switch (name[i])                      {                          case '%':                              while (i+1 < end)                              {                                  i++;                                  if (name[i] == ']')                                  {                                      goto case ']';                                  }                                  else if (name[i] == '/')                                  {                                      goto case '/';                                  }                                  else if (name[i] < '0' || name[i] > '9')                                  {                                      // scope ID must only contain digits                                      return false;                                  }                              }                              break;                          case ']':                              if (!needsClosingBracket)                              {                                  return false;                              }                              needsClosingBracket = false;                                // If there's more after the closing bracket' it must be a port.                              // We don't use the port' but we still validate it.                              if (i + 1 < end && name[i + 1] != ':')                              {                                  return false;                              }                                // If there is a port' it must either be a hexadecimal or decimal number.                              if (i + 3 < end && name[i + 2] == '0' && name[i + 3] == 'x')                              {                                  i += 4;                                  for (; i < end; i++)                                  {                                      if (!Uri.IsHexDigit(name[i]))                                      {                                          return false;                                      }                                  }                              }                              else                              {                                  i += 2;                                  for (; i < end; i++)                                  {                                      if (name[i] < '0' || name[i] > '9')                                      {                                          return false;                                      }                                  }                              }                              continue;                          case ':':                              if ((i > 0) && (name[i - 1] == ':'))                              {                                  if (haveCompressor)                                  {                                      // can only have one per IPv6 address                                      return false;                                  }                                  haveCompressor = true;                                  expectingNumber = false;                              }                              else                              {                                  expectingNumber = true;                              }                              break;                            case '/':                              return false;                            case '.':                              if (haveIPv4Address)                              {                                  return false;                              }                                i = end;                              if (!IPv4AddressHelper.IsValid(name' lastSequence' ref i' true' false' false))                              {                                  return false;                              }                              // ipv4 address takes 2 slots in ipv6 address' one was just counted meeting the '.'                              ++sequenceCount;                              lastSequence = i - sequenceLength;                              sequenceLength = 0;                              haveIPv4Address = true;                              --i;            // it will be incremented back on the next loop                              break;                            default:                              return false;                      }                      sequenceLength = 0;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,IsValidStrict,The following statement contains a magic number: for (i = start; i < end; ++i)              {                  if (Uri.IsHexDigit(name[i]))                  {                      ++sequenceLength;                      expectingNumber = false;                  }                  else                  {                      if (sequenceLength > 4)                      {                          return false;                      }                      if (sequenceLength != 0)                      {                          ++sequenceCount;                          lastSequence = i - sequenceLength;                          sequenceLength = 0;                      }                      switch (name[i])                      {                          case '%':                              while (i+1 < end)                              {                                  i++;                                  if (name[i] == ']')                                  {                                      goto case ']';                                  }                                  else if (name[i] == '/')                                  {                                      goto case '/';                                  }                                  else if (name[i] < '0' || name[i] > '9')                                  {                                      // scope ID must only contain digits                                      return false;                                  }                              }                              break;                          case ']':                              if (!needsClosingBracket)                              {                                  return false;                              }                              needsClosingBracket = false;                                // If there's more after the closing bracket' it must be a port.                              // We don't use the port' but we still validate it.                              if (i + 1 < end && name[i + 1] != ':')                              {                                  return false;                              }                                // If there is a port' it must either be a hexadecimal or decimal number.                              if (i + 3 < end && name[i + 2] == '0' && name[i + 3] == 'x')                              {                                  i += 4;                                  for (; i < end; i++)                                  {                                      if (!Uri.IsHexDigit(name[i]))                                      {                                          return false;                                      }                                  }                              }                              else                              {                                  i += 2;                                  for (; i < end; i++)                                  {                                      if (name[i] < '0' || name[i] > '9')                                      {                                          return false;                                      }                                  }                              }                              continue;                          case ':':                              if ((i > 0) && (name[i - 1] == ':'))                              {                                  if (haveCompressor)                                  {                                      // can only have one per IPv6 address                                      return false;                                  }                                  haveCompressor = true;                                  expectingNumber = false;                              }                              else                              {                                  expectingNumber = true;                              }                              break;                            case '/':                              return false;                            case '.':                              if (haveIPv4Address)                              {                                  return false;                              }                                i = end;                              if (!IPv4AddressHelper.IsValid(name' lastSequence' ref i' true' false' false))                              {                                  return false;                              }                              // ipv4 address takes 2 slots in ipv6 address' one was just counted meeting the '.'                              ++sequenceCount;                              lastSequence = i - sequenceLength;                              sequenceLength = 0;                              haveIPv4Address = true;                              --i;            // it will be incremented back on the next loop                              break;                            default:                              return false;                      }                      sequenceLength = 0;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,IsValidStrict,The following statement contains a magic number: for (i = start; i < end; ++i)              {                  if (Uri.IsHexDigit(name[i]))                  {                      ++sequenceLength;                      expectingNumber = false;                  }                  else                  {                      if (sequenceLength > 4)                      {                          return false;                      }                      if (sequenceLength != 0)                      {                          ++sequenceCount;                          lastSequence = i - sequenceLength;                          sequenceLength = 0;                      }                      switch (name[i])                      {                          case '%':                              while (i+1 < end)                              {                                  i++;                                  if (name[i] == ']')                                  {                                      goto case ']';                                  }                                  else if (name[i] == '/')                                  {                                      goto case '/';                                  }                                  else if (name[i] < '0' || name[i] > '9')                                  {                                      // scope ID must only contain digits                                      return false;                                  }                              }                              break;                          case ']':                              if (!needsClosingBracket)                              {                                  return false;                              }                              needsClosingBracket = false;                                // If there's more after the closing bracket' it must be a port.                              // We don't use the port' but we still validate it.                              if (i + 1 < end && name[i + 1] != ':')                              {                                  return false;                              }                                // If there is a port' it must either be a hexadecimal or decimal number.                              if (i + 3 < end && name[i + 2] == '0' && name[i + 3] == 'x')                              {                                  i += 4;                                  for (; i < end; i++)                                  {                                      if (!Uri.IsHexDigit(name[i]))                                      {                                          return false;                                      }                                  }                              }                              else                              {                                  i += 2;                                  for (; i < end; i++)                                  {                                      if (name[i] < '0' || name[i] > '9')                                      {                                          return false;                                      }                                  }                              }                              continue;                          case ':':                              if ((i > 0) && (name[i - 1] == ':'))                              {                                  if (haveCompressor)                                  {                                      // can only have one per IPv6 address                                      return false;                                  }                                  haveCompressor = true;                                  expectingNumber = false;                              }                              else                              {                                  expectingNumber = true;                              }                              break;                            case '/':                              return false;                            case '.':                              if (haveIPv4Address)                              {                                  return false;                              }                                i = end;                              if (!IPv4AddressHelper.IsValid(name' lastSequence' ref i' true' false' false))                              {                                  return false;                              }                              // ipv4 address takes 2 slots in ipv6 address' one was just counted meeting the '.'                              ++sequenceCount;                              lastSequence = i - sequenceLength;                              sequenceLength = 0;                              haveIPv4Address = true;                              --i;            // it will be incremented back on the next loop                              break;                            default:                              return false;                      }                      sequenceLength = 0;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,IsValidStrict,The following statement contains a magic number: for (i = start; i < end; ++i)              {                  if (Uri.IsHexDigit(name[i]))                  {                      ++sequenceLength;                      expectingNumber = false;                  }                  else                  {                      if (sequenceLength > 4)                      {                          return false;                      }                      if (sequenceLength != 0)                      {                          ++sequenceCount;                          lastSequence = i - sequenceLength;                          sequenceLength = 0;                      }                      switch (name[i])                      {                          case '%':                              while (i+1 < end)                              {                                  i++;                                  if (name[i] == ']')                                  {                                      goto case ']';                                  }                                  else if (name[i] == '/')                                  {                                      goto case '/';                                  }                                  else if (name[i] < '0' || name[i] > '9')                                  {                                      // scope ID must only contain digits                                      return false;                                  }                              }                              break;                          case ']':                              if (!needsClosingBracket)                              {                                  return false;                              }                              needsClosingBracket = false;                                // If there's more after the closing bracket' it must be a port.                              // We don't use the port' but we still validate it.                              if (i + 1 < end && name[i + 1] != ':')                              {                                  return false;                              }                                // If there is a port' it must either be a hexadecimal or decimal number.                              if (i + 3 < end && name[i + 2] == '0' && name[i + 3] == 'x')                              {                                  i += 4;                                  for (; i < end; i++)                                  {                                      if (!Uri.IsHexDigit(name[i]))                                      {                                          return false;                                      }                                  }                              }                              else                              {                                  i += 2;                                  for (; i < end; i++)                                  {                                      if (name[i] < '0' || name[i] > '9')                                      {                                          return false;                                      }                                  }                              }                              continue;                          case ':':                              if ((i > 0) && (name[i - 1] == ':'))                              {                                  if (haveCompressor)                                  {                                      // can only have one per IPv6 address                                      return false;                                  }                                  haveCompressor = true;                                  expectingNumber = false;                              }                              else                              {                                  expectingNumber = true;                              }                              break;                            case '/':                              return false;                            case '.':                              if (haveIPv4Address)                              {                                  return false;                              }                                i = end;                              if (!IPv4AddressHelper.IsValid(name' lastSequence' ref i' true' false' false))                              {                                  return false;                              }                              // ipv4 address takes 2 slots in ipv6 address' one was just counted meeting the '.'                              ++sequenceCount;                              lastSequence = i - sequenceLength;                              sequenceLength = 0;                              haveIPv4Address = true;                              --i;            // it will be incremented back on the next loop                              break;                            default:                              return false;                      }                      sequenceLength = 0;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,IsValidStrict,The following statement contains a magic number: for (i = start; i < end; ++i)              {                  if (Uri.IsHexDigit(name[i]))                  {                      ++sequenceLength;                      expectingNumber = false;                  }                  else                  {                      if (sequenceLength > 4)                      {                          return false;                      }                      if (sequenceLength != 0)                      {                          ++sequenceCount;                          lastSequence = i - sequenceLength;                          sequenceLength = 0;                      }                      switch (name[i])                      {                          case '%':                              while (i+1 < end)                              {                                  i++;                                  if (name[i] == ']')                                  {                                      goto case ']';                                  }                                  else if (name[i] == '/')                                  {                                      goto case '/';                                  }                                  else if (name[i] < '0' || name[i] > '9')                                  {                                      // scope ID must only contain digits                                      return false;                                  }                              }                              break;                          case ']':                              if (!needsClosingBracket)                              {                                  return false;                              }                              needsClosingBracket = false;                                // If there's more after the closing bracket' it must be a port.                              // We don't use the port' but we still validate it.                              if (i + 1 < end && name[i + 1] != ':')                              {                                  return false;                              }                                // If there is a port' it must either be a hexadecimal or decimal number.                              if (i + 3 < end && name[i + 2] == '0' && name[i + 3] == 'x')                              {                                  i += 4;                                  for (; i < end; i++)                                  {                                      if (!Uri.IsHexDigit(name[i]))                                      {                                          return false;                                      }                                  }                              }                              else                              {                                  i += 2;                                  for (; i < end; i++)                                  {                                      if (name[i] < '0' || name[i] > '9')                                      {                                          return false;                                      }                                  }                              }                              continue;                          case ':':                              if ((i > 0) && (name[i - 1] == ':'))                              {                                  if (haveCompressor)                                  {                                      // can only have one per IPv6 address                                      return false;                                  }                                  haveCompressor = true;                                  expectingNumber = false;                              }                              else                              {                                  expectingNumber = true;                              }                              break;                            case '/':                              return false;                            case '.':                              if (haveIPv4Address)                              {                                  return false;                              }                                i = end;                              if (!IPv4AddressHelper.IsValid(name' lastSequence' ref i' true' false' false))                              {                                  return false;                              }                              // ipv4 address takes 2 slots in ipv6 address' one was just counted meeting the '.'                              ++sequenceCount;                              lastSequence = i - sequenceLength;                              sequenceLength = 0;                              haveIPv4Address = true;                              --i;            // it will be incremented back on the next loop                              break;                            default:                              return false;                      }                      sequenceLength = 0;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,IsValidStrict,The following statement contains a magic number: if (sequenceLength != 0)              {                  if (sequenceLength > 4)                  {                      return false;                  }                    ++sequenceCount;              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,IsValidStrict,The following statement contains a magic number: const int ExpectedSequenceCount = 8;
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,Parse,The following statement contains a magic number: for (int i = start; i < address.Length && address[i] != ']';)              {                  switch (address[i])                  {                      case '%':                          if (numberIsValid)                          {                              numbers[index++] = (ushort)number;                              numberIsValid = false;                          }                            start = i;                          for (++i; i < address.Length && address[i] != ']' && address[i] != '/'; ++i)                          {                          }                          scopeId = new string(address.Slice(start' i - start));                          // ignore prefix if any                          for (; i < address.Length && address[i] != ']'; ++i)                          {                          }                          break;                        case ':':                          numbers[index++] = (ushort)number;                          number = 0;                          ++i;                          if (address[i] == ':')                          {                              compressorIndex = index;                              ++i;                          }                          else if ((compressorIndex < 0) && (index < 6))                          {                              // no point checking for IPv4 address if we don't                              // have a compressor or we haven't seen 6 16-bit                              // numbers yet                              break;                          }                            // check to see if the upcoming number is really an IPv4                          // address. If it is' convert it to 2 ushort numbers                          for (int j = i; j < address.Length &&                                          (address[j] != ']') &&                                          (address[j] != ':') &&                                          (address[j] != '%') &&                                          (address[j] != '/') &&                                          (j < i + 4); ++j)                          {                                if (address[j] == '.')                              {                                  // we have an IPv4 address. Find the end of it:                                  // we know that since we have a valid IPv6                                  // address' the only things that will terminate                                  // the IPv4 address are the prefix delimiter '/'                                  // or the end-of-string (which we conveniently                                  // delimited with ']')                                  while (j < address.Length && (address[j] != ']') && (address[j] != '/') && (address[j] != '%'))                                  {                                      ++j;                                  }                                  number = IPv4AddressHelper.ParseHostNumber(address' i' j);                                  numbers[index++] = (ushort)(number >> 16);                                  numbers[index++] = (ushort)number;                                  i = j;                                    // set this to avoid adding another number to                                  // the array if there's a prefix                                  number = 0;                                  numberIsValid = false;                                  break;                              }                          }                          break;                        case '/':                          if (numberIsValid)                          {                              numbers[index++] = (ushort)number;                              numberIsValid = false;                          }                            // since we have a valid IPv6 address string' the prefix                          // length is the last token in the string                          for (++i; address[i] != ']'; ++i)                          {                              PrefixLength = PrefixLength * 10 + (address[i] - '0');                          }                          break;                        default:                          number = number * 16 + Uri.FromHex(address[i++]);                          break;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,Parse,The following statement contains a magic number: for (int i = start; i < address.Length && address[i] != ']';)              {                  switch (address[i])                  {                      case '%':                          if (numberIsValid)                          {                              numbers[index++] = (ushort)number;                              numberIsValid = false;                          }                            start = i;                          for (++i; i < address.Length && address[i] != ']' && address[i] != '/'; ++i)                          {                          }                          scopeId = new string(address.Slice(start' i - start));                          // ignore prefix if any                          for (; i < address.Length && address[i] != ']'; ++i)                          {                          }                          break;                        case ':':                          numbers[index++] = (ushort)number;                          number = 0;                          ++i;                          if (address[i] == ':')                          {                              compressorIndex = index;                              ++i;                          }                          else if ((compressorIndex < 0) && (index < 6))                          {                              // no point checking for IPv4 address if we don't                              // have a compressor or we haven't seen 6 16-bit                              // numbers yet                              break;                          }                            // check to see if the upcoming number is really an IPv4                          // address. If it is' convert it to 2 ushort numbers                          for (int j = i; j < address.Length &&                                          (address[j] != ']') &&                                          (address[j] != ':') &&                                          (address[j] != '%') &&                                          (address[j] != '/') &&                                          (j < i + 4); ++j)                          {                                if (address[j] == '.')                              {                                  // we have an IPv4 address. Find the end of it:                                  // we know that since we have a valid IPv6                                  // address' the only things that will terminate                                  // the IPv4 address are the prefix delimiter '/'                                  // or the end-of-string (which we conveniently                                  // delimited with ']')                                  while (j < address.Length && (address[j] != ']') && (address[j] != '/') && (address[j] != '%'))                                  {                                      ++j;                                  }                                  number = IPv4AddressHelper.ParseHostNumber(address' i' j);                                  numbers[index++] = (ushort)(number >> 16);                                  numbers[index++] = (ushort)number;                                  i = j;                                    // set this to avoid adding another number to                                  // the array if there's a prefix                                  number = 0;                                  numberIsValid = false;                                  break;                              }                          }                          break;                        case '/':                          if (numberIsValid)                          {                              numbers[index++] = (ushort)number;                              numberIsValid = false;                          }                            // since we have a valid IPv6 address string' the prefix                          // length is the last token in the string                          for (++i; address[i] != ']'; ++i)                          {                              PrefixLength = PrefixLength * 10 + (address[i] - '0');                          }                          break;                        default:                          number = number * 16 + Uri.FromHex(address[i++]);                          break;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,Parse,The following statement contains a magic number: for (int i = start; i < address.Length && address[i] != ']';)              {                  switch (address[i])                  {                      case '%':                          if (numberIsValid)                          {                              numbers[index++] = (ushort)number;                              numberIsValid = false;                          }                            start = i;                          for (++i; i < address.Length && address[i] != ']' && address[i] != '/'; ++i)                          {                          }                          scopeId = new string(address.Slice(start' i - start));                          // ignore prefix if any                          for (; i < address.Length && address[i] != ']'; ++i)                          {                          }                          break;                        case ':':                          numbers[index++] = (ushort)number;                          number = 0;                          ++i;                          if (address[i] == ':')                          {                              compressorIndex = index;                              ++i;                          }                          else if ((compressorIndex < 0) && (index < 6))                          {                              // no point checking for IPv4 address if we don't                              // have a compressor or we haven't seen 6 16-bit                              // numbers yet                              break;                          }                            // check to see if the upcoming number is really an IPv4                          // address. If it is' convert it to 2 ushort numbers                          for (int j = i; j < address.Length &&                                          (address[j] != ']') &&                                          (address[j] != ':') &&                                          (address[j] != '%') &&                                          (address[j] != '/') &&                                          (j < i + 4); ++j)                          {                                if (address[j] == '.')                              {                                  // we have an IPv4 address. Find the end of it:                                  // we know that since we have a valid IPv6                                  // address' the only things that will terminate                                  // the IPv4 address are the prefix delimiter '/'                                  // or the end-of-string (which we conveniently                                  // delimited with ']')                                  while (j < address.Length && (address[j] != ']') && (address[j] != '/') && (address[j] != '%'))                                  {                                      ++j;                                  }                                  number = IPv4AddressHelper.ParseHostNumber(address' i' j);                                  numbers[index++] = (ushort)(number >> 16);                                  numbers[index++] = (ushort)number;                                  i = j;                                    // set this to avoid adding another number to                                  // the array if there's a prefix                                  number = 0;                                  numberIsValid = false;                                  break;                              }                          }                          break;                        case '/':                          if (numberIsValid)                          {                              numbers[index++] = (ushort)number;                              numberIsValid = false;                          }                            // since we have a valid IPv6 address string' the prefix                          // length is the last token in the string                          for (++i; address[i] != ']'; ++i)                          {                              PrefixLength = PrefixLength * 10 + (address[i] - '0');                          }                          break;                        default:                          number = number * 16 + Uri.FromHex(address[i++]);                          break;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,Parse,The following statement contains a magic number: for (int i = start; i < address.Length && address[i] != ']';)              {                  switch (address[i])                  {                      case '%':                          if (numberIsValid)                          {                              numbers[index++] = (ushort)number;                              numberIsValid = false;                          }                            start = i;                          for (++i; i < address.Length && address[i] != ']' && address[i] != '/'; ++i)                          {                          }                          scopeId = new string(address.Slice(start' i - start));                          // ignore prefix if any                          for (; i < address.Length && address[i] != ']'; ++i)                          {                          }                          break;                        case ':':                          numbers[index++] = (ushort)number;                          number = 0;                          ++i;                          if (address[i] == ':')                          {                              compressorIndex = index;                              ++i;                          }                          else if ((compressorIndex < 0) && (index < 6))                          {                              // no point checking for IPv4 address if we don't                              // have a compressor or we haven't seen 6 16-bit                              // numbers yet                              break;                          }                            // check to see if the upcoming number is really an IPv4                          // address. If it is' convert it to 2 ushort numbers                          for (int j = i; j < address.Length &&                                          (address[j] != ']') &&                                          (address[j] != ':') &&                                          (address[j] != '%') &&                                          (address[j] != '/') &&                                          (j < i + 4); ++j)                          {                                if (address[j] == '.')                              {                                  // we have an IPv4 address. Find the end of it:                                  // we know that since we have a valid IPv6                                  // address' the only things that will terminate                                  // the IPv4 address are the prefix delimiter '/'                                  // or the end-of-string (which we conveniently                                  // delimited with ']')                                  while (j < address.Length && (address[j] != ']') && (address[j] != '/') && (address[j] != '%'))                                  {                                      ++j;                                  }                                  number = IPv4AddressHelper.ParseHostNumber(address' i' j);                                  numbers[index++] = (ushort)(number >> 16);                                  numbers[index++] = (ushort)number;                                  i = j;                                    // set this to avoid adding another number to                                  // the array if there's a prefix                                  number = 0;                                  numberIsValid = false;                                  break;                              }                          }                          break;                        case '/':                          if (numberIsValid)                          {                              numbers[index++] = (ushort)number;                              numberIsValid = false;                          }                            // since we have a valid IPv6 address string' the prefix                          // length is the last token in the string                          for (++i; address[i] != ']'; ++i)                          {                              PrefixLength = PrefixLength * 10 + (address[i] - '0');                          }                          break;                        default:                          number = number * 16 + Uri.FromHex(address[i++]);                          break;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\IPv6AddressHelper.cs,Parse,The following statement contains a magic number: for (int i = start; i < address.Length && address[i] != ']';)              {                  switch (address[i])                  {                      case '%':                          if (numberIsValid)                          {                              numbers[index++] = (ushort)number;                              numberIsValid = false;                          }                            start = i;                          for (++i; i < address.Length && address[i] != ']' && address[i] != '/'; ++i)                          {                          }                          scopeId = new string(address.Slice(start' i - start));                          // ignore prefix if any                          for (; i < address.Length && address[i] != ']'; ++i)                          {                          }                          break;                        case ':':                          numbers[index++] = (ushort)number;                          number = 0;                          ++i;                          if (address[i] == ':')                          {                              compressorIndex = index;                              ++i;                          }                          else if ((compressorIndex < 0) && (index < 6))                          {                              // no point checking for IPv4 address if we don't                              // have a compressor or we haven't seen 6 16-bit                              // numbers yet                              break;                          }                            // check to see if the upcoming number is really an IPv4                          // address. If it is' convert it to 2 ushort numbers                          for (int j = i; j < address.Length &&                                          (address[j] != ']') &&                                          (address[j] != ':') &&                                          (address[j] != '%') &&                                          (address[j] != '/') &&                                          (j < i + 4); ++j)                          {                                if (address[j] == '.')                              {                                  // we have an IPv4 address. Find the end of it:                                  // we know that since we have a valid IPv6                                  // address' the only things that will terminate                                  // the IPv4 address are the prefix delimiter '/'                                  // or the end-of-string (which we conveniently                                  // delimited with ']')                                  while (j < address.Length && (address[j] != ']') && (address[j] != '/') && (address[j] != '%'))                                  {                                      ++j;                                  }                                  number = IPv4AddressHelper.ParseHostNumber(address' i' j);                                  numbers[index++] = (ushort)(number >> 16);                                  numbers[index++] = (ushort)number;                                  i = j;                                    // set this to avoid adding another number to                                  // the array if there's a prefix                                  number = 0;                                  numberIsValid = false;                                  break;                              }                          }                          break;                        case '/':                          if (numberIsValid)                          {                              numbers[index++] = (ushort)number;                              numberIsValid = false;                          }                            // since we have a valid IPv6 address string' the prefix                          // length is the last token in the string                          for (++i; address[i] != ']'; ++i)                          {                              PrefixLength = PrefixLength * 10 + (address[i] - '0');                          }                          break;                        default:                          number = number * 16 + Uri.FromHex(address[i++]);                          break;                  }              }
Magic Number,System,Marvin,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Marvin.cs,ComputeHash32,The following statement contains a magic number: return ((int)(hash64 >> 32)) ^ (int)hash64;
Magic Number,System,Marvin,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Marvin.cs,ComputeHash,The following statement contains a magic number: uint p1 = (uint)(seed >> 32);
Magic Number,System,Marvin,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Marvin.cs,ComputeHash,The following statement contains a magic number: if (data.Length >= sizeof(uint))              {                  ReadOnlySpan<uint> uData = data.NonPortableCast<byte' uint>();                    for (int i = 0; i < uData.Length; i++)                  {                      p0 += uData[i];                      Block(ref p0' ref p1);                  }                    // byteOffset = data.Length - data.Length % 4                  // is equivalent to clearing last 2 bits of length                  // Using it directly gives a perf hit for short strings making it at least 5% or more slower.                  int byteOffset = data.Length & (~3);                  data = data.Slice(byteOffset);              }
Magic Number,System,Marvin,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Marvin.cs,ComputeHash,The following statement contains a magic number: switch (data.Length)              {                  case 0:                      p0 += 0x80u;                      break;                    case 1:                      p0 += 0x8000u | data[0];                      break;                    case 2:                      p0 += 0x800000u | data.NonPortableCast<byte' ushort>()[0];                      break;                    case 3:                      p0 += 0x80000000u | (((uint)data[2]) << 16) | (uint)(data.NonPortableCast<byte' ushort>()[0]);                      break;                    default:                      Debug.Fail("Should not get here.");                      break;              }
Magic Number,System,Marvin,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Marvin.cs,ComputeHash,The following statement contains a magic number: switch (data.Length)              {                  case 0:                      p0 += 0x80u;                      break;                    case 1:                      p0 += 0x8000u | data[0];                      break;                    case 2:                      p0 += 0x800000u | data.NonPortableCast<byte' ushort>()[0];                      break;                    case 3:                      p0 += 0x80000000u | (((uint)data[2]) << 16) | (uint)(data.NonPortableCast<byte' ushort>()[0]);                      break;                    default:                      Debug.Fail("Should not get here.");                      break;              }
Magic Number,System,Marvin,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Marvin.cs,ComputeHash,The following statement contains a magic number: switch (data.Length)              {                  case 0:                      p0 += 0x80u;                      break;                    case 1:                      p0 += 0x8000u | data[0];                      break;                    case 2:                      p0 += 0x800000u | data.NonPortableCast<byte' ushort>()[0];                      break;                    case 3:                      p0 += 0x80000000u | (((uint)data[2]) << 16) | (uint)(data.NonPortableCast<byte' ushort>()[0]);                      break;                    default:                      Debug.Fail("Should not get here.");                      break;              }
Magic Number,System,Marvin,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Marvin.cs,ComputeHash,The following statement contains a magic number: switch (data.Length)              {                  case 0:                      p0 += 0x80u;                      break;                    case 1:                      p0 += 0x8000u | data[0];                      break;                    case 2:                      p0 += 0x800000u | data.NonPortableCast<byte' ushort>()[0];                      break;                    case 3:                      p0 += 0x80000000u | (((uint)data[2]) << 16) | (uint)(data.NonPortableCast<byte' ushort>()[0]);                      break;                    default:                      Debug.Fail("Should not get here.");                      break;              }
Magic Number,System,Marvin,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Marvin.cs,ComputeHash,The following statement contains a magic number: return (((long)p1) << 32) | p0;
Magic Number,System,Marvin,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Marvin.cs,Block,The following statement contains a magic number: p0 = _rotl(p0' 20);
Magic Number,System,Marvin,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Marvin.cs,Block,The following statement contains a magic number: p1 = _rotl(p1' 9);
Magic Number,System,Marvin,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Marvin.cs,Block,The following statement contains a magic number: p0 = _rotl(p0' 27);
Magic Number,System,Marvin,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Marvin.cs,Block,The following statement contains a magic number: p1 = _rotl(p1' 19);
Magic Number,System,Marvin,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Marvin.cs,_rotl,The following statement contains a magic number: return (value << shift) | (value >> (32 - shift));
Missing Default,System.Net,CookieContainer,C:\selectedRepos\dotnet_corefx\src\System.Net.Primitives\src\System\Net\CookieContainer.cs,IsLocalDomain,The following switch statement is missing a default case: switch (part.Length)                      {                          case 3:                              if (part[2] < '0' || part[2] > '9')                              {                                  break;                              }                              goto case 2;                            case 2:                              if (part[1] < '0' || part[1] > '9')                              {                                  break;                              }                              goto case 1;                            case 1:                              if (part[0] < '0' || part[0] > '9')                              {                                  break;                              }                              continue;                      }
Missing Default,System.Net,CookieParser,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\CookieParser.cs,Get,The following switch statement is missing a default case: switch (token)                      {                          case CookieToken.NameValuePair:                              switch (_tokenizer.Token)                              {                                  case CookieToken.Comment:                                      if (!commentSet)                                      {                                          commentSet = true;                                          cookie.Comment = _tokenizer.Value;                                      }                                      break;                                    case CookieToken.CommentUrl:                                      if (!commentUriSet)                                      {                                          commentUriSet = true;                                          if (Uri.TryCreate(CheckQuoted(_tokenizer.Value)' UriKind.Absolute' out Uri parsed))                                          {                                              cookie.CommentUri = parsed;                                          }                                      }                                      break;                                    case CookieToken.Domain:                                      if (!domainSet)                                      {                                          domainSet = true;                                          cookie.Domain = CheckQuoted(_tokenizer.Value);                                          IsQuotedDomainField.SetValue(cookie' _tokenizer.Quoted);                                      }                                      break;                                    case CookieToken.Expires:                                      if (!expiresSet)                                      {                                          expiresSet = true;                                            if (DateTime.TryParse(CheckQuoted(_tokenizer.Value)'                                              CultureInfo.InvariantCulture' DateTimeStyles.AllowWhiteSpaces' out DateTime expires))                                          {                                              cookie.Expires = expires;                                          }                                          else                                          {                                              // This cookie will be rejected                                              InternalSetNameMethod(cookie' string.Empty);                                          }                                      }                                      break;                                    case CookieToken.MaxAge:                                      if (!expiresSet)                                      {                                          expiresSet = true;                                          if (int.TryParse(CheckQuoted(_tokenizer.Value)' out int parsed))                                          {                                              cookie.Expires = DateTime.Now.AddSeconds(parsed);                                          }                                          else                                          {                                              // This cookie will be rejected                                              InternalSetNameMethod(cookie' string.Empty);                                          }                                      }                                      break;                                    case CookieToken.Path:                                      if (!pathSet)                                      {                                          pathSet = true;                                          cookie.Path = _tokenizer.Value;                                      }                                      break;                                    case CookieToken.Port:                                      if (!portSet)                                      {                                          portSet = true;                                          try                                          {                                              cookie.Port = _tokenizer.Value;                                          }                                          catch                                          {                                              // This cookie will be rejected                                              InternalSetNameMethod(cookie' string.Empty);                                          }                                      }                                      break;                                    case CookieToken.Version:                                      if (!versionSet)                                      {                                          versionSet = true;                                          int parsed;                                          if (int.TryParse(CheckQuoted(_tokenizer.Value)' out parsed))                                          {                                              cookie.Version = parsed;                                              IsQuotedVersionField.SetValue(cookie' _tokenizer.Quoted);                                          }                                          else                                          {                                              // This cookie will be rejected                                              InternalSetNameMethod(cookie' string.Empty);                                          }                                      }                                      break;                              }                              break;                            case CookieToken.Attribute:                              switch (_tokenizer.Token)                              {                                  case CookieToken.Discard:                                      if (!discardSet)                                      {                                          discardSet = true;                                          cookie.Discard = true;                                      }                                      break;                                    case CookieToken.Secure:                                      if (!secureSet)                                      {                                          secureSet = true;                                          cookie.Secure = true;                                      }                                      break;                                    case CookieToken.HttpOnly:                                      cookie.HttpOnly = true;                                      break;                                    case CookieToken.Port:                                      if (!portSet)                                      {                                          portSet = true;                                          cookie.Port = string.Empty;                                      }                                      break;                              }                              break;                      }
Missing Default,System.Net,CookieParser,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\CookieParser.cs,Get,The following switch statement is missing a default case: switch (_tokenizer.Token)                              {                                  case CookieToken.Comment:                                      if (!commentSet)                                      {                                          commentSet = true;                                          cookie.Comment = _tokenizer.Value;                                      }                                      break;                                    case CookieToken.CommentUrl:                                      if (!commentUriSet)                                      {                                          commentUriSet = true;                                          if (Uri.TryCreate(CheckQuoted(_tokenizer.Value)' UriKind.Absolute' out Uri parsed))                                          {                                              cookie.CommentUri = parsed;                                          }                                      }                                      break;                                    case CookieToken.Domain:                                      if (!domainSet)                                      {                                          domainSet = true;                                          cookie.Domain = CheckQuoted(_tokenizer.Value);                                          IsQuotedDomainField.SetValue(cookie' _tokenizer.Quoted);                                      }                                      break;                                    case CookieToken.Expires:                                      if (!expiresSet)                                      {                                          expiresSet = true;                                            if (DateTime.TryParse(CheckQuoted(_tokenizer.Value)'                                              CultureInfo.InvariantCulture' DateTimeStyles.AllowWhiteSpaces' out DateTime expires))                                          {                                              cookie.Expires = expires;                                          }                                          else                                          {                                              // This cookie will be rejected                                              InternalSetNameMethod(cookie' string.Empty);                                          }                                      }                                      break;                                    case CookieToken.MaxAge:                                      if (!expiresSet)                                      {                                          expiresSet = true;                                          if (int.TryParse(CheckQuoted(_tokenizer.Value)' out int parsed))                                          {                                              cookie.Expires = DateTime.Now.AddSeconds(parsed);                                          }                                          else                                          {                                              // This cookie will be rejected                                              InternalSetNameMethod(cookie' string.Empty);                                          }                                      }                                      break;                                    case CookieToken.Path:                                      if (!pathSet)                                      {                                          pathSet = true;                                          cookie.Path = _tokenizer.Value;                                      }                                      break;                                    case CookieToken.Port:                                      if (!portSet)                                      {                                          portSet = true;                                          try                                          {                                              cookie.Port = _tokenizer.Value;                                          }                                          catch                                          {                                              // This cookie will be rejected                                              InternalSetNameMethod(cookie' string.Empty);                                          }                                      }                                      break;                                    case CookieToken.Version:                                      if (!versionSet)                                      {                                          versionSet = true;                                          int parsed;                                          if (int.TryParse(CheckQuoted(_tokenizer.Value)' out parsed))                                          {                                              cookie.Version = parsed;                                              IsQuotedVersionField.SetValue(cookie' _tokenizer.Quoted);                                          }                                          else                                          {                                              // This cookie will be rejected                                              InternalSetNameMethod(cookie' string.Empty);                                          }                                      }                                      break;                              }
Missing Default,System.Net,CookieParser,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\CookieParser.cs,Get,The following switch statement is missing a default case: switch (_tokenizer.Token)                              {                                  case CookieToken.Discard:                                      if (!discardSet)                                      {                                          discardSet = true;                                          cookie.Discard = true;                                      }                                      break;                                    case CookieToken.Secure:                                      if (!secureSet)                                      {                                          secureSet = true;                                          cookie.Secure = true;                                      }                                      break;                                    case CookieToken.HttpOnly:                                      cookie.HttpOnly = true;                                      break;                                    case CookieToken.Port:                                      if (!portSet)                                      {                                          portSet = true;                                          cookie.Port = string.Empty;                                      }                                      break;                              }
Missing Default,System.Net,CookieParser,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\CookieParser.cs,GetServer,The following switch statement is missing a default case: switch (token)                      {                          case CookieToken.NameValuePair:                              switch (_tokenizer.Token)                              {                                  case CookieToken.Domain:                                      if (!domainSet)                                      {                                          domainSet = true;                                          cookie.Domain = CheckQuoted(_tokenizer.Value);                                          IsQuotedDomainField.SetValue(cookie' _tokenizer.Quoted);                                      }                                      break;                                    case CookieToken.Path:                                      if (!pathSet)                                      {                                          pathSet = true;                                          cookie.Path = _tokenizer.Value;                                      }                                      break;                                    case CookieToken.Port:                                      if (!portSet)                                      {                                          portSet = true;                                          try                                          {                                              cookie.Port = _tokenizer.Value;                                          }                                          catch (CookieException)                                          {                                              // This cookie will be rejected                                              InternalSetNameMethod(cookie' string.Empty);                                          }                                      }                                      break;                                    case CookieToken.Version:                                      // this is a new cookie' this token is for the next cookie.                                      _savedCookie = new Cookie();                                      if (int.TryParse(_tokenizer.Value' out int parsed))                                      {                                          _savedCookie.Version = parsed;                                      }                                      return cookie;                                    case CookieToken.Unknown:                                      // this is a new cookie' the token is for the next cookie.                                      _savedCookie = new Cookie();                                      InternalSetNameMethod(_savedCookie' _tokenizer.Name);                                      _savedCookie.Value = _tokenizer.Value;                                      return cookie;                              }                              break;                            case CookieToken.Attribute:                              if (_tokenizer.Token == CookieToken.Port && !portSet)                              {                                  portSet = true;                                  cookie.Port = string.Empty;                              }                              break;                      }
Missing Default,System.Net,CookieParser,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\CookieParser.cs,GetServer,The following switch statement is missing a default case: switch (_tokenizer.Token)                              {                                  case CookieToken.Domain:                                      if (!domainSet)                                      {                                          domainSet = true;                                          cookie.Domain = CheckQuoted(_tokenizer.Value);                                          IsQuotedDomainField.SetValue(cookie' _tokenizer.Quoted);                                      }                                      break;                                    case CookieToken.Path:                                      if (!pathSet)                                      {                                          pathSet = true;                                          cookie.Path = _tokenizer.Value;                                      }                                      break;                                    case CookieToken.Port:                                      if (!portSet)                                      {                                          portSet = true;                                          try                                          {                                              cookie.Port = _tokenizer.Value;                                          }                                          catch (CookieException)                                          {                                              // This cookie will be rejected                                              InternalSetNameMethod(cookie' string.Empty);                                          }                                      }                                      break;                                    case CookieToken.Version:                                      // this is a new cookie' this token is for the next cookie.                                      _savedCookie = new Cookie();                                      if (int.TryParse(_tokenizer.Value' out int parsed))                                      {                                          _savedCookie.Version = parsed;                                      }                                      return cookie;                                    case CookieToken.Unknown:                                      // this is a new cookie' the token is for the next cookie.                                      _savedCookie = new Cookie();                                      InternalSetNameMethod(_savedCookie' _tokenizer.Name);                                      _savedCookie.Value = _tokenizer.Value;                                      return cookie;                              }
