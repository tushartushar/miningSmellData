Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Threading.Tasks,AsyncInfoToTaskBridge<TResult;TProgress>,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\Tasks\AsyncInfoToTaskBridge.CoreCLR.cs,Complete,The method has 118 lines of code.
Complex Method,System.IO,WinRtToNetFxStreamAdapter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WinRtToNetFxStreamAdapter.cs,Create,Cyclomatic complexity of the method is 9
Complex Method,System.Runtime.InteropServices.WindowsRuntime,WindowsRuntimeBuffer,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\WindowsRuntime\WindowsRuntimeBuffer.cs,Create,Cyclomatic complexity of the method is 8
Complex Method,System.Runtime.InteropServices.WindowsRuntime,WindowsRuntimeBuffer,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\WindowsRuntime\WindowsRuntimeBuffer.cs,WindowsRuntimeBuffer,Cyclomatic complexity of the method is 8
Complex Method,System.Runtime.InteropServices.WindowsRuntime,WindowsRuntimeBufferExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\WindowsRuntime\WindowsRuntimeBufferExtensions.cs,AsBuffer,Cyclomatic complexity of the method is 8
Complex Method,System.Runtime.InteropServices.WindowsRuntime,WindowsRuntimeBufferExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\WindowsRuntime\WindowsRuntimeBufferExtensions.cs,CopyTo,Cyclomatic complexity of the method is 9
Complex Method,System.Runtime.InteropServices.WindowsRuntime,WindowsRuntimeBufferExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\WindowsRuntime\WindowsRuntimeBufferExtensions.cs,CopyTo,Cyclomatic complexity of the method is 10
Complex Method,System.Runtime.InteropServices.WindowsRuntime,WindowsRuntimeBufferExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\WindowsRuntime\WindowsRuntimeBufferExtensions.cs,CopyTo,Cyclomatic complexity of the method is 10
Complex Method,System.Threading.Tasks,AsyncInfoToTaskBridge<TResult;TProgress>,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\Tasks\AsyncInfoToTaskBridge.CoreCLR.cs,Complete,Cyclomatic complexity of the method is 8
Complex Method,System,WindowsRuntimeSystemExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\WindowsRuntimeSystemExtensions.CoreCLR.cs,AsTask,Cyclomatic complexity of the method is 8
Complex Method,System,WindowsRuntimeSystemExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\WindowsRuntimeSystemExtensions.CoreCLR.cs,AsTask,Cyclomatic complexity of the method is 8
Complex Method,System.Resources,WindowsRuntimeResourceManager,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Resources\WindowsRuntimeResourceManager.cs,InitializeStaticsForDependentPackages,Cyclomatic complexity of the method is 9
Complex Method,System.Resources,WindowsRuntimeResourceManager,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Resources\WindowsRuntimeResourceManager.cs,Initialize,Cyclomatic complexity of the method is 9
Long Parameter List,System.IO,IStorageFolderHandleAccess,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\IStorageFolderHandleAccess.cs,Create,The method has 7 parameters. Parameters: fileName' creationOptions' accessOptions' sharingOptions' options' oplockBreakingHandler' interopHandle
Long Parameter List,System.IO,IStorageItemHandleAccess,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\IStorageItemHandleAccess.cs,Create,The method has 5 parameters. Parameters: accessOptions' sharingOptions' options' oplockBreakingHandler' interopHandle
Long Parameter List,System.IO,StreamReadAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\StreamOperationAsyncResult.cs,StreamReadAsyncResult,The method has 5 parameters. Parameters: asyncStreamReadOperation' buffer' userCompletionCallback' userAsyncStateInfo' processCompletedOperationInCallback
Long Parameter List,System.IO,WindowsRuntimeStorageExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WindowsRuntimeStorageExtensions.cs,CreateSafeFileHandle,The method has 6 parameters. Parameters: rootDirectory' relativePath' mode' access' share' options
Long Parameter List,System.IO,WinRtToNetFxStreamAdapter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WinRtToNetFxStreamAdapter.cs,BeginRead,The method has 6 parameters. Parameters: buffer' offset' count' callback' state' usedByBlockingWrapper
Long Parameter List,System.IO,WinRtToNetFxStreamAdapter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WinRtToNetFxStreamAdapter.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.IO,WinRtToNetFxStreamAdapter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WinRtToNetFxStreamAdapter.cs,BeginWrite,The method has 6 parameters. Parameters: buffer' offset' count' callback' state' usedByBlockingWrapper
Long Parameter List,System.Runtime.InteropServices.WindowsRuntime,NotifyCollectionChangedEventArgsMarshaler,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\WindowsRuntime\MarshalingHelpers.cs,CreateNotifyCollectionChangedEventArgs,The method has 5 parameters. Parameters: action' newItems' oldItems' newStartingIndex' oldStartingIndex
Long Parameter List,System.Runtime.InteropServices.WindowsRuntime,WindowsRuntimeBuffer,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\WindowsRuntime\WindowsRuntimeBuffer.cs,GetMarshalSizeMax,The method has 6 parameters. Parameters: riid' pv' dwDestContext' pvDestContext' mshlflags' pSize
Long Parameter List,System.Runtime.InteropServices.WindowsRuntime,WindowsRuntimeBuffer,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\WindowsRuntime\WindowsRuntimeBuffer.cs,GetUnmarshalClass,The method has 6 parameters. Parameters: riid' pv' dwDestContext' pvDestContext' mshlFlags' pCid
Long Parameter List,System.Runtime.InteropServices.WindowsRuntime,WindowsRuntimeBuffer,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\WindowsRuntime\WindowsRuntimeBuffer.cs,MarshalInterface,The method has 6 parameters. Parameters: pStm' riid' pv' dwDestContext' pvDestContext' mshlflags
Long Parameter List,System.Runtime.InteropServices.WindowsRuntime,WindowsRuntimeBufferExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\WindowsRuntime\WindowsRuntimeBufferExtensions.cs,CopyTo,The method has 5 parameters. Parameters: source' sourceIndex' destination' destinationIndex' count
Long Parameter List,System.Runtime.InteropServices.WindowsRuntime,WindowsRuntimeBufferExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\WindowsRuntime\WindowsRuntimeBufferExtensions.cs,CopyTo,The method has 5 parameters. Parameters: source' sourceIndex' destination' destinationIndex' count
Long Parameter List,System.Runtime.InteropServices.WindowsRuntime,WindowsRuntimeBufferExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\WindowsRuntime\WindowsRuntimeBufferExtensions.cs,CopyTo,The method has 5 parameters. Parameters: source' sourceIndex' destination' destinationIndex' count
Long Parameter List,System.Threading.Tasks,TaskToAsyncInfoAdapter<TCompletedHandler;TProgressHandler;TResult;TProgressInfo>,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\Tasks\TaskToAsyncInfoAdapter.cs,SetState,The method has 5 parameters. Parameters: newStateSetMask' newStateIgnoreMask' conditionBitMask' useCondition' conditionFailed
Long Parameter List,System.Runtime.InteropServices,IMarshal,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\IMarshal.cs,GetUnmarshalClass,The method has 6 parameters. Parameters: riid' pv' dwDestContext' pvDestContext' mshlFlags' pCid
Long Parameter List,System.Runtime.InteropServices,IMarshal,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\IMarshal.cs,GetMarshalSizeMax,The method has 6 parameters. Parameters: riid' pv' dwDestContext' pvDestContext' mshlflags' pSize
Long Parameter List,System.Runtime.InteropServices,IMarshal,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\IMarshal.cs,MarshalInterface,The method has 6 parameters. Parameters: pStm' riid' pv' dwDestContext' pvDestContext' mshlflags
Long Identifier,System.IO,StreamOperationAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\StreamOperationAsyncResult.CoreCLR.cs,StreamOperationAsyncResult,The length of the parameter processCompletedOperationInCallback is 35.
Long Identifier,System.IO,StreamOperationAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\StreamOperationAsyncResult.CoreCLR.cs,,The length of the parameter _processCompletedOperationInCallback is 36.
Long Identifier,System.IO,StreamReadAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\StreamOperationAsyncResult.cs,StreamReadAsyncResult,The length of the parameter processCompletedOperationInCallback is 35.
Long Identifier,System.IO,StreamWriteAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\StreamOperationAsyncResult.cs,StreamWriteAsyncResult,The length of the parameter processCompletedOperationInCallback is 35.
Long Identifier,System.IO,StreamFlushAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\StreamOperationAsyncResult.cs,StreamFlushAsyncResult,The length of the parameter processCompletedOperationInCallback is 35.
Long Identifier,System.IO,WindowsRuntimeStreamExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WindowsRuntimeStreamExtensions.cs,AssertMapContains,The length of the parameter valueMayBeWrappedInBufferedStream is 33.
Long Identifier,System.Runtime.InteropServices.WindowsRuntime,WindowsRuntimeBuffer,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\WindowsRuntime\WindowsRuntimeBuffer.cs,GetUnderlyingData,The length of the parameter underlyingDataArrayStartOffset is 30.
Long Identifier,System.Runtime.InteropServices.WindowsRuntime,WindowsRuntimeBufferExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\WindowsRuntime\WindowsRuntimeBufferExtensions.cs,TryGetUnderlyingData,The length of the parameter underlyingDataArrayStartOffset is 30.
Long Identifier,System.Threading.Tasks,TaskToAsyncInfoAdapter<TCompletedHandler;TProgressHandler;TResult;TProgressInfo>,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\Tasks\TaskToAsyncInfoAdapter.cs,,The length of the parameter STATEFLAG_COMPLETED_SYNCHRONOUSLY is 33.
Long Identifier,System.Threading.Tasks,TaskToAsyncInfoAdapter<TCompletedHandler;TProgressHandler;TResult;TProgressInfo>,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\Tasks\TaskToAsyncInfoAdapter.cs,,The length of the parameter STATEFLAG_MUST_RUN_COMPLETION_HNDL_WHEN_SET is 43.
Long Identifier,System.Threading.Tasks,TaskToAsyncInfoAdapter<TCompletedHandler;TProgressHandler;TResult;TProgressInfo>,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\Tasks\TaskToAsyncInfoAdapter.cs,,The length of the parameter STATEFLAG_COMPLETION_HNDL_NOT_YET_INVOKED is 41.
Long Identifier,System.Threading.Tasks,TaskToAsyncInfoAdapter<TCompletedHandler;TProgressHandler;TResult;TProgressInfo>,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\Tasks\TaskToAsyncInfoAdapter.cs,,The length of the parameter STATEMASK_SELECT_ANY_ASYNC_STATE is 32.
Long Identifier,System.Threading.Tasks,TaskToAsyncInfoAdapter<TCompletedHandler;TProgressHandler;TResult;TProgressInfo>,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\Tasks\TaskToAsyncInfoAdapter.cs,,The length of the parameter STATEMASK_CLEAR_ALL_ASYNC_STATES is 32.
Long Identifier,System.Threading,Invoker,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\WindowsRuntimeSynchronizationContext.cs,,The length of the parameter s_EtwFireThreadTransferSendObj is 30.
Long Identifier,System.Threading,Invoker,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\WindowsRuntimeSynchronizationContext.cs,,The length of the parameter s_EtwFireThreadTransferReceiveObj is 33.
Long Identifier,System.Threading,Invoker,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\WindowsRuntimeSynchronizationContext.cs,,The length of the parameter s_EtwFireThreadTransferReceiveHandledObj is 40.
Long Identifier,System.Resources,WindowsRuntimeResourceManager,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Resources\WindowsRuntimeResourceManager.cs,,The length of the parameter _clonedResourceContextFallBackList is 34.
Long Identifier,System.Resources,WindowsRuntimeResourceManager,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Resources\WindowsRuntimeResourceManager.cs,,The length of the parameter s_globalResourceContextFallBackList is 35.
Long Identifier,System.Resources,WindowsRuntimeResourceManager,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Resources\WindowsRuntimeResourceManager.cs,,The length of the parameter s_globalResourceContextBestFitCultureInfo is 41.
Long Statement,System.IO,StreamOperationAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\StreamOperationAsyncResult.CoreCLR.cs,ThrowWithIOExceptionDispatchInfo,The length of the statement  "            WinRtIOHelper.NativeExceptionToIOExceptionInfo(RestrictedErrorInfoHelper.AttachRestrictedErrorInfo(_completedOperation.ErrorCode)).Throw(); " is 139.
Long Statement,System.IO,StreamOperationAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\StreamOperationAsyncResult.CoreCLR.cs,ProcessCompletedOperation,The length of the statement  "                ProcessCompletedOperation_InvalidOperationThrowHelper(_errorInfo' SR.InvalidOperation_CannotCallThisMethodInCurrentState); " is 122.
Long Statement,System.IO,StreamOperationAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\StreamOperationAsyncResult.CoreCLR.cs,ProcessCompletedOperation,The length of the statement  "                ProcessCompletedOperation_InvalidOperationThrowHelper(_errorInfo' SR.InvalidOperation_CannotCallThisMethodInCurrentState); " is 122.
Long Statement,System.IO,StreamOperationAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\StreamOperationAsyncResult.CoreCLR.cs,StreamOperationCompletedCallback,The length of the statement  "                // If we did not do this check' we would either get the same exception without the explaining message when dereferencing " is 120.
Long Statement,System.IO,StreamOperationAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\StreamOperationAsyncResult.CoreCLR.cs,StreamOperationCompletedCallback,The length of the statement  "                // processCompletedOperationInCallback == false indicates that the stream is doing a blocking wait on the waitHandle of this IAsyncResult. " is 138.
Long Statement,System.IO,NetFxToWinRtStreamAdapter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\NetFxToWinRtStreamAdapter.cs,ReadAsync,The length of the statement  "            if (!(options == InputStreamOptions.None || options == InputStreamOptions.Partial || options == InputStreamOptions.ReadAhead)) " is 126.
Long Statement,System.IO,StreamReadAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\StreamOperationAsyncResult.cs,ProcessConcreteCompletedOperation,The length of the statement  "            ProcessConcreteCompletedOperation((IAsyncOperationWithProgress<IBuffer' UInt32>)completedOperation' out bytesCompleted); " is 120.
Long Statement,System.IO,StreamOperationsImplementation,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\StreamOperationsImplementation.cs,ReadAsync_AbstractStream,The length of the statement  "            Debug.Assert(options == InputStreamOptions.None || options == InputStreamOptions.Partial || options == InputStreamOptions.ReadAhead); " is 133.
Long Statement,System.IO,StreamOperationsImplementation,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\StreamOperationsImplementation.cs,ReadAsync_AbstractStream,The length of the statement  "            //         read into a managed array. If we used the user-supplied buffer we would need to copy data into it after every read. " is 126.
Long Statement,System.IO,StreamOperationsImplementation,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\StreamOperationsImplementation.cs,ReadAsync_AbstractStream,The length of the statement  "            //         The spec allows to return a buffer instance that is not the same as passed by the user. So' we will create an own " is 124.
Long Statement,System.IO,StreamOperationsImplementation,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\StreamOperationsImplementation.cs,ReadAsync_AbstractStream,The length of the statement  "            //         Note: the allocation costs we are paying for the new buffer are unavoidable anyway' as we we would need to create " is 124.
Long Statement,System.IO,WindowsRuntimeStorageExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WindowsRuntimeStorageExtensions.cs,OpenStreamForWriteAsyncCore,The length of the statement  "                Stream managedStream = await OpenStreamForWriteAsyncCore(windowsRuntimeFile' offset).ConfigureAwait(continueOnCapturedContext: false); " is 134.
Long Statement,System.IO,WindowsRuntimeStorageExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WindowsRuntimeStorageExtensions.cs,CreateSafeFileHandle,The length of the statement  "                throw Win32Marshal.GetExceptionForWin32Error(Win32Marshal.TryMakeWin32ErrorCodeFromHR(result)' windowsRuntimeFile.Name); " is 120.
Long Statement,System.IO,WindowsRuntimeStorageExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WindowsRuntimeStorageExtensions.cs,CreateSafeFileHandle,The length of the statement  "            return rootDirectory.CreateSafeFileHandle(relativePath' mode' (mode == FileMode.Append ? FileAccess.Write : FileAccess.ReadWrite)); " is 131.
Long Statement,System.IO,WindowsRuntimeStreamExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WindowsRuntimeStreamExtensions.cs,EnsureAdapterBufferSize,The length of the statement  "                    throw new InvalidOperationException(SR.Format(SR.InvalidOperation_CannotChangeBufferSizeOfWinRtStreamAdapterToZero' methodName)); " is 129.
Long Statement,System.IO,WindowsRuntimeStreamExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WindowsRuntimeStreamExtensions.cs,EnsureAdapterBufferSize,The length of the statement  "                throw new InvalidOperationException(SR.Format(SR.InvalidOperation_CannotChangeBufferSizeOfWinRtStreamAdapter' methodName)); " is 123.
Long Statement,System.IO,WindowsRuntimeStreamExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WindowsRuntimeStreamExtensions.cs,AsStreamInternal,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(bufferSize)' SR.ArgumentOutOfRange_WinRtAdapterBufferSizeMayNotBeNegative); " is 120.
Long Statement,System.IO,WindowsRuntimeStreamExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WindowsRuntimeStreamExtensions.cs,WinRtToNetFxAdapterMap_GetValue,The length of the statement  "            return s_winRtToNetFxAdapterMap.GetValue(winRtStream' (wrtStr) => new BufferedStream(WinRtToNetFxStreamAdapter.Create(wrtStr)' bufferSize)); " is 140.
Long Statement,System.IO,WindowsRuntimeStreamExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WindowsRuntimeStreamExtensions.cs,AsWindowsRuntimeStreamInternalFactoryHelper,The length of the statement  "            NetFxToWinRtStreamAdapter adapter = s_netFxToWinRtAdapterMap.GetValue(stream' (str) => NetFxToWinRtStreamAdapter.Create(str)); " is 126.
Long Statement,System.IO,WinRtToNetFxStreamAdapter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WinRtToNetFxStreamAdapter.cs,AssertValidStream,The length of the statement  "                            "This to-NetFx Stream adapter must not be disposed and the underlying WinRT stream must be of compatible type for this operation"); " is 131.
Long Statement,System.IO,WinRtToNetFxStreamAdapter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WinRtToNetFxStreamAdapter.cs,BeginRead,The length of the statement  "            // However' in cases where it is invoked by Read to achieve a blocking (synchronous) IO operation' the ReadAsync-approach may deadlock: " is 135.
Long Statement,System.IO,WinRtToNetFxStreamAdapter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WinRtToNetFxStreamAdapter.cs,BeginRead,The length of the statement  "            // The sync-over-async IO operation will be doing a blocking wait on the completion of the async IO operation assuming that " is 123.
Long Statement,System.IO,WinRtToNetFxStreamAdapter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WinRtToNetFxStreamAdapter.cs,BeginRead,The length of the statement  "            // a wait handle would be signalled by the completion handler. Recall that the IAsyncInfo representing the IO operation may " is 123.
Long Statement,System.IO,WinRtToNetFxStreamAdapter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WinRtToNetFxStreamAdapter.cs,BeginRead,The length of the statement  "            // not be free-threaded and not "free-marshalled"; it may also belong to an ASTA compartment because the underlying WinRT " is 121.
Long Statement,System.IO,WinRtToNetFxStreamAdapter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WinRtToNetFxStreamAdapter.cs,BeginRead,The length of the statement  "            // That handler needs to fetch the results from the async IO operation' which requires a cross-compartment call from MTA into ASTA. " is 131.
Long Statement,System.IO,WinRtToNetFxStreamAdapter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WinRtToNetFxStreamAdapter.cs,BeginRead,The length of the statement  "            // no way of knowing whether or not someone is waiting. So' instead of using ReadAsync here we implement our own IAsyncResult " is 125.
Long Statement,System.IO,WinRtToNetFxStreamAdapter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WinRtToNetFxStreamAdapter.cs,Flush,The length of the statement  "            StreamFlushAsyncResult asyncResult = new StreamFlushAsyncResult(asyncFlushOperation' processCompletedOperationInCallback: false); " is 129.
Long Statement,System.IO,WinRtToNetFxStreamAdapter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WinRtToNetFxStreamAdapter.cs,ReadAsyncInternal,The length of the statement  "                IBuffer resultBuffer = await asyncReadOperation.AsTask(cancellationToken).ConfigureAwait(continueOnCapturedContext: false); " is 123.
Long Statement,System.IO,WinRtToNetFxStreamAdapter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WinRtToNetFxStreamAdapter.cs,ReadAsyncInternal,The length of the statement  "                // If cancellationToken was cancelled until now' then we are currently propagating the corresponding cancellation exception. " is 124.
Long Statement,System.Runtime.InteropServices.WindowsRuntime,WindowsRuntimeBufferExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\WindowsRuntime\WindowsRuntimeBufferExtensions.cs,CopyTo,The length of the statement  "            if (destination.Capacity - destinationIndex < count) throw new ArgumentException(SR.Argument_InsufficientSpaceInTargetBuffer); " is 126.
Long Statement,System.Runtime.InteropServices.WindowsRuntime,WindowsRuntimeBufferExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\WindowsRuntime\WindowsRuntimeBufferExtensions.cs,CopyTo,The length of the statement  "            if (destination.Length - destinationIndex < count) throw new ArgumentException(SR.Argument_InsufficientArrayElementsAfterOffset); " is 129.
Long Statement,System.Runtime.InteropServices.WindowsRuntime,WindowsRuntimeBufferExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\WindowsRuntime\WindowsRuntimeBufferExtensions.cs,CopyTo,The length of the statement  "            if (destination.Capacity - destinationIndex < count) throw new ArgumentException(SR.Argument_InsufficientSpaceInTargetBuffer); " is 126.
Long Statement,System.Runtime.InteropServices.WindowsRuntime,WindowsRuntimeBufferExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\WindowsRuntime\WindowsRuntimeBufferExtensions.cs,CopyTo,The length of the statement  "            // If source are destination are backed by managed arrays' use the arrays instead of the pointers as it does not require pinning: " is 129.
Long Statement,System.Runtime.InteropServices.WindowsRuntime,WindowsRuntimeBufferExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\WindowsRuntime\WindowsRuntimeBufferExtensions.cs,CopyTo,The length of the statement  "                Buffer.BlockCopy(srcDataArr' srcDataOffs + (Int32)sourceIndex' destDataArr' destDataOffs + (Int32)destinationIndex' (Int32)count); " is 130.
Long Statement,System.Runtime.InteropServices.WindowsRuntime,WindowsRuntimeBufferExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\WindowsRuntime\WindowsRuntimeBufferExtensions.cs,GetWindowsRuntimeBuffer,The length of the statement  "            return new WindowsRuntimeBuffer(streamData.Array' (Int32)streamData.Offset' (Int32)underlyingStream.Length' underlyingStream.Capacity); " is 135.
Long Statement,System.Runtime.InteropServices.WindowsRuntime,WindowsRuntimeBufferExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\WindowsRuntime\WindowsRuntimeBufferExtensions.cs,GetByte,The length of the statement  "            if (source.Capacity <= byteOffset) throw new ArgumentException(SR.Argument_BufferIndexExceedsCapacity' nameof(byteOffset)); " is 123.
Long Statement,System.Threading.Tasks,AsyncInfoToTaskBridge<TResult;TProgress>,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\Tasks\AsyncInfoToTaskBridge.CoreCLR.cs,RegisterForCancellation,The length of the statement  "                // Such exceptions should cause the Completed handler to be invoked synchronously and thus the Task should already be completed. " is 128.
Long Statement,System.Threading.Tasks,AsyncInfoToTaskBridge<TResult;TProgress>,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\Tasks\AsyncInfoToTaskBridge.CoreCLR.cs,RegisterForCancellation,The length of the statement  "                    Debug.Assert(false' String.Format("Expected base task to already be faulted but found it in state {0}"' base.Task.Status)); " is 123.
Long Statement,System.Threading.Tasks,AsyncInfoToTaskBridge<TResult;TProgress>,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\Tasks\AsyncInfoToTaskBridge.CoreCLR.cs,Complete,The length of the statement  "                                AsyncCausalityTracer.TraceOperationCompletion(CausalityTraceLevel.Required' base.Task.Id' AsyncCausalityStatus.Completed); " is 122.
Long Statement,System.Threading.Tasks,AsyncInfoIdGenerator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\Tasks\AsyncInfoIdGenerator.cs,CreateNext,The length of the statement  "                Int32 newId = s_idGenerator.Next(1' (Int32)InvalidId);  // Valid IDs will be larger than zero and smaller than InvalidId " is 120.
Long Statement,System.Threading.Tasks,TaskToAsyncInfoAdapter<TCompletedHandler;TProgressHandler;TResult;TProgressInfo>,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\Tasks\TaskToAsyncInfoAdapter.cs,DangerousSetCompleted,The length of the statement  "            // CompletedSynchronously + MustRunCompletionHandleImmediatelyWhenSet + CompletionHandlerNotYetInvoked + RUN_TO_COMPLETION: " is 123.
Long Statement,System.Threading.Tasks,TaskToAsyncInfoAdapter<TCompletedHandler;TProgressHandler;TResult;TProgressInfo>,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\Tasks\TaskToAsyncInfoAdapter.cs,DangerousSetCanceled,The length of the statement  "            // CompletedSynchronously + MustRunCompletionHandleImmediatelyWhenSet + CompletionHandlerNotYetInvoked + CANCELLATION_COMPLETED: " is 128.
Long Statement,System.Threading.Tasks,TaskToAsyncInfoAdapter<TCompletedHandler;TProgressHandler;TResult;TProgressInfo>,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\Tasks\TaskToAsyncInfoAdapter.cs,SetAsyncState,The length of the statement  "            Int32 resultState = SetState(newAsyncState' STATEMASK_CLEAR_ALL_ASYNC_STATES' conditionBitMask' useCondition' out conditionFailed); " is 131.
Long Statement,System.Threading.Tasks,TaskToAsyncInfoAdapter<TCompletedHandler;TProgressHandler;TResult;TProgressInfo>,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\Tasks\TaskToAsyncInfoAdapter.cs,SetState,The length of the statement  "            // If m_state changed concurrently' we want to make sure that the change being made is based on a bitmask that is up to date: " is 125.
Long Statement,System.Threading.Tasks,TaskToAsyncInfoAdapter<TCompletedHandler;TProgressHandler;TResult;TProgressInfo>,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\Tasks\TaskToAsyncInfoAdapter.cs,TransitionToTerminalState,The length of the statement  "            // or faulted' then the state will transition into COMPLETED or ERROR accordingly. If the operation was really cancelled' " is 121.
Long Statement,System.Threading.Tasks,TaskToAsyncInfoAdapter<TCompletedHandler;TProgressHandler;TResult;TProgressInfo>,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\Tasks\TaskToAsyncInfoAdapter.cs,TaskCompleted,The length of the statement  "                        var tuple = (Tuple<TaskToAsyncInfoAdapter<TCompletedHandler' TProgressHandler' TResult' TProgressInfo>' AsyncStatus>)tupleObject; " is 129.
Long Statement,System.Threading.Tasks,TaskToAsyncInfoAdapter<TCompletedHandler;TProgressHandler;TResult;TProgressInfo>,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\Tasks\TaskToAsyncInfoAdapter.cs,GetResultsInternal,The length of the statement  "            //  - it was not converted to Task<TResult>' which means it is a non-generic Task. In that case we cannot get a result from Task. " is 129.
Long Statement,System.Threading.Tasks,TaskToAsyncInfoAdapter<TCompletedHandler;TProgressHandler;TResult;TProgressInfo>,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\Tasks\TaskToAsyncInfoAdapter.cs,TransitionToClosed,The length of the statement  "            // From the finaliser we always call this Close version since finalisation can happen any time' even when STARTED (e.g. process ends) " is 133.
Long Statement,System.Threading.Tasks,TaskToAsyncInfoAdapter<TCompletedHandler;TProgressHandler;TResult;TProgressInfo>,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\Tasks\TaskToAsyncInfoAdapter.cs,Cancel,The length of the statement  "            SetAsyncState(STATE_CANCELLATION_REQUESTED' conditionBitMask: STATE_STARTED' useCondition: true' conditionFailed: out stateWasNotStarted); " is 138.
Long Statement,System.Threading,WinRTSynchronizationContextFactory,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\WindowsRuntimeSynchronizationContext.cs,Create,The length of the statement  "                return s_coreDispatcherContextCache.GetValue(dispatcher' _dispatcher => new WinRTCoreDispatcherBasedSynchronizationContext(_dispatcher)); " is 137.
Long Statement,System.Threading,WinRTSynchronizationContextFactory,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\WindowsRuntimeSynchronizationContext.cs,Create,The length of the statement  "                return s_dispatcherQueueContextCache.GetValue(dispatcherQueue' _dispatcherQueue => new WinRTDispatcherQueueBasedSynchronizationContext(_dispatcherQueue)); " is 154.
Long Statement,System.Threading,Invoker,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\WindowsRuntimeSynchronizationContext.cs,InitEtwMethods,The length of the statement  "                var mi1 = fest.GetMethod("ThreadTransferSendObj"' BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public); " is 120.
Long Statement,System.Threading,Invoker,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\WindowsRuntimeSynchronizationContext.cs,InitEtwMethods,The length of the statement  "                var mi2 = fest.GetMethod("ThreadTransferReceiveObj"' BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public); " is 123.
Long Statement,System.Threading,Invoker,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\WindowsRuntimeSynchronizationContext.cs,InitEtwMethods,The length of the statement  "                var mi3 = fest.GetMethod("ThreadTransferReceiveHandledObj"' BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public); " is 130.
Long Statement,System.Threading,Invoker,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\WindowsRuntimeSynchronizationContext.cs,InitEtwMethods,The length of the statement  "                    s_EtwFireThreadTransferSendObj = (DelEtwFireThreadTransferSendObj)mi1.CreateDelegate(typeof(DelEtwFireThreadTransferSendObj)' " is 125.
Long Statement,System.Threading,Invoker,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\WindowsRuntimeSynchronizationContext.cs,InitEtwMethods,The length of the statement  "                    s_EtwFireThreadTransferReceiveObj = (DelEtwFireThreadTransferObj)mi2.CreateDelegate(typeof(DelEtwFireThreadTransferObj)' " is 120.
Long Statement,System.Threading,Invoker,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\WindowsRuntimeSynchronizationContext.cs,InitEtwMethods,The length of the statement  "                    s_EtwFireThreadTransferReceiveHandledObj = (DelEtwFireThreadTransferObj)mi3.CreateDelegate(typeof(DelEtwFireThreadTransferObj)' " is 127.
Long Statement,System,WindowsRuntimeSystemExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\WindowsRuntimeSystemExtensions.CoreCLR.cs,ConcatenateProgress,The length of the statement  "            // This is separated out into a separate method so that we only pay the costs of compiler-generated closure if progress is non-null. " is 132.
Long Statement,System,WindowsRuntimeSystemExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\WindowsRuntimeSystemExtensions.CoreCLR.cs,ConcatenateProgress,The length of the statement  "            // This is separated out into a separate method so that we only pay the costs of compiler-generated closure if progress is non-null. " is 132.
Long Statement,System,WindowsRuntimeSystemExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\WindowsRuntimeSystemExtensions.CoreCLR.cs,AsTask,The length of the statement  "                    return Task.FromCanceled<TResult>(cancellationToken.IsCancellationRequested ? cancellationToken : new CancellationToken(true)); " is 127.
Long Statement,System,WindowsRuntimeSystemExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\WindowsRuntimeSystemExtensions.CoreCLR.cs,AsTask,The length of the statement  "                    return Task.FromCanceled<TResult>(cancellationToken.IsCancellationRequested ? cancellationToken : new CancellationToken(true)); " is 127.
Long Statement,System,WindowsRuntimeSystemExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\WindowsRuntimeSystemExtensions.CoreCLR.cs,AsTask,The length of the statement  "            source.Completed = new AsyncOperationWithProgressCompletedHandler<TResult' TProgress>(bridge.CompleteFromAsyncOperationWithProgress); " is 133.
Long Statement,System.Resources,WindowsRuntimeResourceManager,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Resources\WindowsRuntimeResourceManager.cs,InitializeStaticGlobalResourceContext,The length of the statement  "                                s_globalResourceContext.QualifierValues.MapChanged += new MapChangedEventHandler<string' string>(GlobalResourceContextChanged); " is 127.
Long Statement,System.Resources,WindowsRuntimeResourceManager,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Resources\WindowsRuntimeResourceManager.cs,LibpathContainsPackagename,The length of the statement  "                   (libpath.EndsWith("ni.dll"' StringComparison.OrdinalIgnoreCase) || libpath.EndsWith("ni.exe"' StringComparison.OrdinalIgnoreCase)); " is 131.
Long Statement,System.Resources,WindowsRuntimeResourceManager,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Resources\WindowsRuntimeResourceManager.cs,FindPackageSimpleNameForFilename,The length of the statement  "                return s_currentPackageInfo.Name; // This may be null' in which case we failed to get the name (in InitializeStatics)' but matched the path' so stop looking. " is 157.
Long Statement,System.Resources,WindowsRuntimeResourceManager,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Resources\WindowsRuntimeResourceManager.cs,FindPackageSimpleNameForFilename,The length of the statement  "                        return dependentPackageInfo.Name; // This may be null' in which case we failed to get the name (in InitializeStaticsForDependentPackages)' but matched the path' so stop looking. " is 177.
Long Statement,System.Resources,WindowsRuntimeResourceManager,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Resources\WindowsRuntimeResourceManager.cs,Initialize,The length of the statement  "                            // will see that we are going to use modern resource manager but we don't have PRI and will thrown an exception indicating " is 122.
Long Statement,System.Resources,WindowsRuntimeResourceManager,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Resources\WindowsRuntimeResourceManager.cs,SetGlobalResourceContextDefaultCulture,The length of the statement  "            if (s_globalResourceContextBestFitCultureInfo != null && s_globalResourceContextBestFitCultureInfo.Name.Equals(ci.Name' StringComparison.OrdinalIgnoreCase)) " is 156.
Long Statement,System.Resources,WindowsRuntimeResourceManager,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Resources\WindowsRuntimeResourceManager.cs,SetGlobalResourceContextDefaultCulture,The length of the statement  "                    // We have same culture name but different reference' we'll need to update s_globalResourceContextBestFitCultureInfo only as ci can  " is 131.
Long Statement,System.Resources,WindowsRuntimeResourceManager,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Resources\WindowsRuntimeResourceManager.cs,GetString,The length of the statement  "                       s_globalResourceContextFallBackList + // Our tests do not test this line of code' so be extra careful if you modify or move it. " is 127.
Complex Conditional,System.Resources,WindowsRuntimeResourceManager,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Resources\WindowsRuntimeResourceManager.cs,InitializeStatics,The conditional expression  "globalResourceManager != null &&                              s_globalResourceContext != null &&                              s_globalResourceContextFallBackList != null &&                              s_globalResourceContextFallBackList.Length > 0 && // Should never be empty                              s_charCultureSeparator != null &&                              s_currentPackageInfo.Path != null"  is complex.
Complex Conditional,System.Resources,UriUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Resources\WindowsRuntimeResourceManager.cs,IsUriUnreservedChar,The conditional expression  "ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9'"  is complex.
Empty Catch Block,System.IO,StreamOperationAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\StreamOperationAsyncResult.CoreCLR.cs,CloseStreamOperation,The method has an empty catch block.
Empty Catch Block,System.Runtime.InteropServices.WindowsRuntime,RestrictedErrorInfoHelper,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Runtime\InteropServices\WindowsRuntime\RestrictedErrorInfoHelper.cs,AttachRestrictedErrorInfo,The method has an empty catch block.
Magic Number,System.IO,WinRtToNetFxStreamAdapter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WinRtToNetFxStreamAdapter.cs,ReadByte,The following statement contains a magic number: Contract.Ensures(Contract.Result<int>() < 256);
Magic Number,System.Threading,Invoker,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\WindowsRuntimeSynchronizationContext.cs,EtwFireThreadTransferSendObj,The following statement contains a magic number: if (s_EtwFireThreadTransferSendObj != null)                      s_EtwFireThreadTransferSendObj(id' 3' string.Empty' false);
Magic Number,System.Threading,Invoker,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\WindowsRuntimeSynchronizationContext.cs,EtwFireThreadTransferReceiveObj,The following statement contains a magic number: if (s_EtwFireThreadTransferReceiveObj != null)                      s_EtwFireThreadTransferReceiveObj(id' 3' string.Empty);
Magic Number,System.Threading,Invoker,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\WindowsRuntimeSynchronizationContext.cs,EtwFireThreadTransferReceiveHandledObj,The following statement contains a magic number: if (s_EtwFireThreadTransferReceiveHandledObj != null)                      s_EtwFireThreadTransferReceiveHandledObj(id' 3' string.Empty);
Magic Number,System.Resources,UriUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Resources\WindowsRuntimeResourceManager.cs,UriEncode,The following statement contains a magic number: if (cBytesToEncode == 0)                  expandedBytes = bytes;              else              {                  // expand not 'safe' characters into %xx                  expandedBytes = new byte[count + cBytesToEncode * 2];                  int pos = 0;                    for (int i = 0; i < count; i++)                  {                      byte b = bytes[i];                        if (IsUriUnreservedChar((char)b))                      {                          expandedBytes[pos++] = b;                      }                      else                      {                          expandedBytes[pos++] = (byte)'%';                          expandedBytes[pos++] = (byte)IntToHex((b >> 4) & 0xf);                          expandedBytes[pos++] = (byte)IntToHex(b & 0xf);                      }                  }              }
Magic Number,System.Resources,UriUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Resources\WindowsRuntimeResourceManager.cs,UriEncode,The following statement contains a magic number: if (cBytesToEncode == 0)                  expandedBytes = bytes;              else              {                  // expand not 'safe' characters into %xx                  expandedBytes = new byte[count + cBytesToEncode * 2];                  int pos = 0;                    for (int i = 0; i < count; i++)                  {                      byte b = bytes[i];                        if (IsUriUnreservedChar((char)b))                      {                          expandedBytes[pos++] = b;                      }                      else                      {                          expandedBytes[pos++] = (byte)'%';                          expandedBytes[pos++] = (byte)IntToHex((b >> 4) & 0xf);                          expandedBytes[pos++] = (byte)IntToHex(b & 0xf);                      }                  }              }
Magic Number,System.Resources,UriUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Resources\WindowsRuntimeResourceManager.cs,IntToHex,The following statement contains a magic number: if (n <= 9)                  return (char)(n + (int)'0');              else                  return (char)(n - 10 + (int)'a');
Magic Number,System.Resources,UriUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Resources\WindowsRuntimeResourceManager.cs,IntToHex,The following statement contains a magic number: if (n <= 9)                  return (char)(n + (int)'0');              else                  return (char)(n - 10 + (int)'a');
Missing Default,System.IO,WindowsRuntimeStorageExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\IO\WindowsRuntimeStorageExtensions.cs,FileAccessToHandleAccessOptions,The following switch statement is missing a default case: switch (access)              {                  case FileAccess.ReadWrite:                      return HANDLE_ACCESS_OPTIONS.HAO_READ | HANDLE_ACCESS_OPTIONS.HAO_WRITE;                  case FileAccess.Read:                      return HANDLE_ACCESS_OPTIONS.HAO_READ;                  case FileAccess.Write:                      return HANDLE_ACCESS_OPTIONS.HAO_WRITE;              }
Missing Default,System.Threading.Tasks,AsyncInfoToTaskBridge<TResult;TProgress>,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\Tasks\AsyncInfoToTaskBridge.CoreCLR.cs,Complete,The following switch statement is missing a default case: switch (asyncStatus)                      {                          case AsyncStatus.Completed:                              if (AsyncCausalityTracer.LoggingOn)                              {                                  AsyncCausalityTracer.TraceOperationCompletion(CausalityTraceLevel.Required' base.Task.Id' AsyncCausalityStatus.Completed);                              }                              success = base.TrySetResult(result);                              break;                            case AsyncStatus.Error:                              Debug.Assert(error != null' "The error should have been retrieved previously.");                              success = base.TrySetException(error);                              break;                            case AsyncStatus.Canceled:                              success = base.TrySetCanceled(_ct.IsCancellationRequested ? _ct : new CancellationToken(true));                              break;                      }
Missing Default,System.Threading.Tasks,TaskToAsyncInfoAdapter<TCompletedHandler;TProgressHandler;TResult;TProgressInfo>,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Threading\Tasks\TaskToAsyncInfoAdapter.cs,GetStatus,The following switch statement is missing a default case: switch (asyncState)              {                  case STATE_NOT_INITIALIZED:                      Debug.Assert(false' "STATE_NOT_INITIALIZED should only occur when this object was not"                                           + " fully constructed' in which case we should never get here");                      return AsyncStatus.Error;                    case STATE_STARTED:                      return AsyncStatus.Started;                    case STATE_RUN_TO_COMPLETION:                      return AsyncStatus.Completed;                    case STATE_CANCELLATION_REQUESTED:                  case STATE_CANCELLATION_COMPLETED:                      return AsyncStatus.Canceled;                    case STATE_ERROR:                      return AsyncStatus.Error;                    case STATE_CLOSED:                      Debug.Assert(false' "This method should never be called is this IAsyncInfo is CLOSED");                      return AsyncStatus.Error;              }
Missing Default,System,WindowsRuntimeSystemExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\WindowsRuntimeSystemExtensions.CoreCLR.cs,AsTask,The following switch statement is missing a default case: switch (source.Status)              {                  case AsyncStatus.Completed:                      return Task.CompletedTask;                    case AsyncStatus.Error:                      return Task.FromException(RestrictedErrorInfoHelper.AttachRestrictedErrorInfo(source.ErrorCode));                    case AsyncStatus.Canceled:                      return Task.FromCanceled(cancellationToken.IsCancellationRequested ? cancellationToken : new CancellationToken(true));              }
Missing Default,System,WindowsRuntimeSystemExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\WindowsRuntimeSystemExtensions.CoreCLR.cs,AsTask,The following switch statement is missing a default case: switch (source.Status)              {                  case AsyncStatus.Completed:                      return Task.FromResult(source.GetResults());                    case AsyncStatus.Error:                      return Task.FromException<TResult>(RestrictedErrorInfoHelper.AttachRestrictedErrorInfo(source.ErrorCode));                    case AsyncStatus.Canceled:                      return Task.FromCanceled<TResult>(cancellationToken.IsCancellationRequested ? cancellationToken : new CancellationToken(true));              }
Missing Default,System,WindowsRuntimeSystemExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\WindowsRuntimeSystemExtensions.CoreCLR.cs,AsTask,The following switch statement is missing a default case: switch (source.Status)              {                  case AsyncStatus.Completed:                      return Task.CompletedTask;                    case AsyncStatus.Error:                      return Task.FromException(RestrictedErrorInfoHelper.AttachRestrictedErrorInfo(source.ErrorCode));                    case AsyncStatus.Canceled:                      return Task.FromCanceled(cancellationToken.IsCancellationRequested ? cancellationToken : new CancellationToken(true));              }
Missing Default,System,WindowsRuntimeSystemExtensions,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\WindowsRuntimeSystemExtensions.CoreCLR.cs,AsTask,The following switch statement is missing a default case: switch (source.Status)              {                  case AsyncStatus.Completed:                      return Task.FromResult(source.GetResults());                    case AsyncStatus.Error:                      return Task.FromException<TResult>(RestrictedErrorInfoHelper.AttachRestrictedErrorInfo(source.ErrorCode));                    case AsyncStatus.Canceled:                      return Task.FromCanceled<TResult>(cancellationToken.IsCancellationRequested ? cancellationToken : new CancellationToken(true));              }
Missing Default,System.Resources,UriUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.WindowsRuntime\src\System\Resources\WindowsRuntimeResourceManager.cs,IsUriUnreservedChar,The following switch statement is missing a default case: switch (ch)              {                  case '-':                  case '_':                  case '.':                  case '~':                      return true;              }
