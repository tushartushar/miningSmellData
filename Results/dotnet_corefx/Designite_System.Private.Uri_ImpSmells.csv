Implementation smell,Namespace,Class,File,Method,Description
Long Method,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,UnicodeEquivalent,The method has 100 lines of code.
Long Method,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseNonCanonical,The method has 130 lines of code.
Long Method,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,InternalIsValid,The method has 126 lines of code.
Long Method,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,Parse,The method has 154 lines of code.
Long Method,System,IriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IriHelper.cs,EscapeUnescapeIri,The method has 198 lines of code.
Long Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,Equals,The method has 190 lines of code.
Long Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,PrivateParseMinimal,The method has 191 lines of code.
Long Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CreateUriInfo,The method has 176 lines of code.
Long Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ReCreateParts,The method has 272 lines of code.
Long Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,GetUriPartsFromUserString,The method has 123 lines of code.
Long Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ParseRemaining,The method has 327 lines of code.
Long Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ParseSchemeCheckImplicitFile,The method has 106 lines of code.
Long Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The method has 136 lines of code.
Long Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckAuthorityHelper,The method has 307 lines of code.
Long Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckCanonical,The method has 132 lines of code.
Long Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,GetCanonicalPath,The method has 148 lines of code.
Long Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,Compress,The method has 125 lines of code.
Long Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CombineUri,The method has 184 lines of code.
Long Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,InitializeUri,The method has 143 lines of code.
Long Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,InternalIsWellFormedOriginalString,The method has 101 lines of code.
Long Method,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,UnescapeString,The method has 211 lines of code.
Long Method,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,MatchUTF8Sequence,The method has 100 lines of code.
Complex Method,System,GenericUriParser,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\GenericUriParser.cs,MapGenericParserOptions,Cyclomatic complexity of the method is 12
Complex Method,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,IsValidCanonical,Cyclomatic complexity of the method is 9
Complex Method,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseNonCanonical,Cyclomatic complexity of the method is 12
Complex Method,System,IriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IriHelper.cs,EscapeUnescapeIri,Cyclomatic complexity of the method is 9
Complex Method,System,UncNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UncNameHelper.cs,IsValid,Cyclomatic complexity of the method is 10
Complex Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,GetLocalPath,Cyclomatic complexity of the method is 11
Complex Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,Equals,Cyclomatic complexity of the method is 27
Complex Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CreateUriInfo,Cyclomatic complexity of the method is 15
Complex Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CreateHostString,Cyclomatic complexity of the method is 10
Complex Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ReCreateParts,Cyclomatic complexity of the method is 27
Complex Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ParseRemaining,Cyclomatic complexity of the method is 21
Complex Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ParseSchemeCheckImplicitFile,Cyclomatic complexity of the method is 15
Complex Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckAuthorityHelper,Cyclomatic complexity of the method is 17
Complex Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,GetCanonicalPath,Cyclomatic complexity of the method is 14
Complex Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,UnescapeOnly,Cyclomatic complexity of the method is 9
Complex Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CombineUri,Cyclomatic complexity of the method is 23
Complex Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,PathDifference,Cyclomatic complexity of the method is 8
Complex Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,InitializeUri,Cyclomatic complexity of the method is 10
Complex Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ResolveHelper,Cyclomatic complexity of the method is 11
Complex Method,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,GetComponentsHelper,Cyclomatic complexity of the method is 10
Complex Method,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,TestForSubPath,Cyclomatic complexity of the method is 12
Long Parameter List,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IsValid,The method has 5 parameters. Parameters: name' pos' returnedEnd' notCanonical' notImplicitFile
Long Parameter List,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IsValidByIri,The method has 5 parameters. Parameters: name' pos' returnedEnd' notCanonical' notImplicitFile
Long Parameter List,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IdnEquivalent,The method has 5 parameters. Parameters: hostname' start' end' allAscii' atLeastOneValidIdn
Long Parameter List,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IdnEquivalent,The method has 5 parameters. Parameters: hostname' start' end' allAscii' bidiStrippedHost
Long Parameter List,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,UnicodeEquivalent,The method has 5 parameters. Parameters: hostname' start' end' allAscii' atLeastOneValidIdn
Long Parameter List,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,IsValid,The method has 6 parameters. Parameters: name' start' end' allowIPv6' notImplicitFile' unknownScheme
Long Parameter List,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,IsValidCanonical,The method has 5 parameters. Parameters: name' start' end' allowIPv6' notImplicitFile
Long Parameter List,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CreateHostStringHelper,The method has 5 parameters. Parameters: str' idx' end' flags' scopeId
Long Parameter List,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ParseSchemeCheckImplicitFile,The method has 5 parameters. Parameters: uriString' length' err' flags' syntax
Long Parameter List,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckAuthorityHelper,The method has 7 parameters. Parameters: pString' idx' length' err' flags' syntax' newHost
Long Parameter List,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckAuthorityHelperHandleDnsIri,The method has 12 parameters. Parameters: pString' start' end' startInput' iriParsing' hasUnicode' syntax' userInfoString' flags' justNormalized' newHost' err
Long Parameter List,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckAuthorityHelperHandleAnyHostIri,The method has 9 parameters. Parameters: pString' startInput' end' iriParsing' hasUnicode' syntax' flags' newHost' err
Long Parameter List,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,UnescapeOnly,The method has 6 parameters. Parameters: pch' start' end' ch1' ch2' ch3
Long Parameter List,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,Compare,The method has 5 parameters. Parameters: uri1' uri2' partsToCompare' compareFormat' comparisonType
Long Parameter List,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ResolveHelper,The method has 5 parameters. Parameters: baseUri' relativeUri' newUriString' userEscaped' e
Long Parameter List,System,UriBuilder,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriBuilder.cs,UriBuilder,The method has 5 parameters. Parameters: scheme' host' port' path' extraValue
Long Parameter List,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,TestForSubPath,The method has 5 parameters. Parameters: selfPtr' selfLength' otherPtr' otherLength' ignoreCase
Long Parameter List,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,EscapeString,The method has 9 parameters. Parameters: input' start' end' dest' destPos' isUriString' force1' force2' rsvd
Long Parameter List,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,EnsureDestinationSize,The method has 7 parameters. Parameters: pStr' dest' currentInputPos' charsToAdd' minReallocateChars' destPos' prevInputPos
Long Parameter List,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,UnescapeString,The method has 11 parameters. Parameters: input' start' end' dest' destPosition' rsvd1' rsvd2' rsvd3' unescapeMode' syntax' isQuery
Long Parameter List,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,UnescapeString,The method has 11 parameters. Parameters: pStr' start' end' dest' destPosition' rsvd1' rsvd2' rsvd3' unescapeMode' syntax' isQuery
Long Parameter List,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,MatchUTF8Sequence,The method has 9 parameters. Parameters: pDest' dest' destOffset' unescapedChars' charCount' bytes' byteCount' isQuery' iriParsing
Long Statement,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IsValidByIri,The length of the statement  "                if (curPos == newPos || (labelHasUnicode ? count + 4 : count) > 63 || ((*curPos++ < 0xA0) && !IsASCIILetterOrDigit(*(curPos - 1)' ref notCanonical))) " is 149.
Long Statement,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IsValidDomainLabelCharacter,The length of the statement  "            if ((character >= 'a' && character <= 'z') || (character >= '0' && character <= '9') || (character == '-') || (character == '_')) " is 129.
Long Statement,System,GenericUriParser,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\GenericUriParser.cs,MapGenericParserOptions,The length of the statement  "                flags &= ~(UriSyntaxFlags.MayHaveUserInfo | UriSyntaxFlags.MayHavePort | UriSyntaxFlags.AllowUncHost | UriSyntaxFlags.AllowAnInternetHost); " is 139.
Long Statement,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,IsValid,The length of the statement  "            // IPv6 can only have canonical IPv4 embedded. Unknown schemes will not attempt parsing of non-canonical IPv4 addresses. " is 120.
Long Statement,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,InternalIsValid,The length of the statement  "            if (!expectingNumber && (sequenceLength <= 4) && (haveCompressor ? (sequenceCount < expectedSequenceCount) : (sequenceCount == expectedSequenceCount))) " is 151.
Long Statement,System,IriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IriHelper.cs,EscapeUnescapeIri,The length of the statement  "                        int encodedBytesCount = Encoding.UTF8.GetBytes(pInput + next' surrogatePair ? 2 : 1' pEncodedBytes' MaxNumberOfBytesEncoded); " is 125.
Long Statement,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,GetObjectData,The length of the statement  "                serializationInfo.AddValue("AbsoluteUri"' GetParts(UriComponents.SerializationInfoString' UriFormat.UriEscaped)); // Do not rename (binary serialization) " is 153.
Long Statement,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,GetObjectData,The length of the statement  "                serializationInfo.AddValue("RelativeUri"' GetParts(UriComponents.SerializationInfoString' UriFormat.UriEscaped)); // Do not rename (binary serialization) " is 153.
Long Statement,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,GetLeftPart,The length of the statement  "            const UriComponents NonPathPart = (UriComponents.Scheme | UriComponents.UserInfo | UriComponents.Host | UriComponents.Port); " is 124.
Long Statement,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,PrivateParseMinimal,The length of the statement  "                        else if (!IsWindowsSystem && hostTerminator == '/' && NotAny(Flags.ImplicitFile) && InFact(Flags.UncPath) && _syntax == UriParser.FileUri) " is 138.
Long Statement,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ParseRemaining,The length of the statement  "            bool buildIriStringFromPath = _iriParsing && ((_flags & Flags.HasUnicode) != 0) && ((_flags & Flags.RestUnicodeNormalized) == 0); " is 129.
Long Statement,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ParseRemaining,The length of the statement  "                    FindEndOfComponent(_originalUnicodeString' ref origIdx' (ushort)_originalUnicodeString.Length' ((syntaxFlags & (UriSyntaxFlags.MayHaveFragment)) != 0) ? '#' : c_EOL); " is 166.
Long Statement,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckAuthorityHelper,The length of the statement  "                IPv4AddressHelper.IsValid(pString' (int)start' ref end' false' StaticNotAny(flags' Flags.ImplicitFile)' syntax.InFact(UriSyntaxFlags.V1_UnknownUri))) " is 149.
Long Statement,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,GetCanonicalPath,The length of the statement  "                if (!IsWindowsSystem && InFact(Flags.BackslashInPath) && _syntax.NotAny(UriSyntaxFlags.ConvertPathSlashes) && _syntax.InFact(UriSyntaxFlags.FileLikeUri) && !IsImplicitFile) " is 172.
Long Statement,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ResolveHelper,The length of the statement  "            Debug.Assert(!baseUri.IsNotAbsoluteUri && !baseUri.UserDrivenParsing' "Uri::ResolveHelper()|baseUri is not Absolute or is controlled by User Parser."); " is 151.
Long Statement,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ResolveHelper,The length of the statement  "            if (relativeStr.Length > 0 && (UriHelper.IsLWS(relativeStr[0]) || UriHelper.IsLWS(relativeStr[relativeStr.Length - 1]))) " is 120.
Complex Conditional,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IsValid,The conditional expression  "ch == '/' || ch == '\\' || (notImplicitFile && (ch == ':' || ch == '?' || ch == '#'))"  is complex.
Complex Conditional,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IsValidByIri,The conditional expression  "ch == '/' || ch == '\\' || (notImplicitFile && (ch == ':' || ch == '?' || ch == '#'))"  is complex.
Complex Conditional,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IsValidByIri,The conditional expression  "(*newPos == '.') ||                          (*newPos == '\u3002') ||    //IDEOGRAPHIC FULL STOP                           (*newPos == '\uFF0E') ||    //FULLWIDTH FULL STOP                          (*newPos == '\uFF61')"  is complex.
Complex Conditional,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IsValidByIri,The conditional expression  "curPos == newPos || (labelHasUnicode ? count + 4 : count) > 63 || ((*curPos++ < 0xA0) && !IsASCIILetterOrDigit(*(curPos - 1)' ref notCanonical))"  is complex.
Complex Conditional,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IdnEquivalent,The conditional expression  "(c == '.') || (c == '\u3002') ||    //IDEOGRAPHIC FULL STOP                                   (c == '\uFF0E') ||                  //FULLWIDTH FULL STOP                                  (c == '\uFF61')"  is complex.
Complex Conditional,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IsIdnAce,The conditional expression  "(input[index] == 'x') &&                  (input[index + 1] == 'n') &&                  (input[index + 2] == '-') &&                  (input[index + 3] == '-')"  is complex.
Complex Conditional,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IsIdnAce,The conditional expression  "(input[index] == 'x') &&                  (input[index + 1] == 'n') &&                  (input[index + 2] == '-') &&                  (input[index + 3] == '-')"  is complex.
Complex Conditional,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,UnicodeEquivalent,The conditional expression  "(c == '.') || (c == '\u3002') ||    //IDEOGRAPHIC FULL STOP                           (c == '\uFF0E') ||                  //FULLWIDTH FULL STOP                          (c == '\uFF61')"  is complex.
Complex Conditional,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IsASCIILetterOrDigit,The conditional expression  "(character >= 'a' && character <= 'z') || (character >= '0' && character <= '9')"  is complex.
Complex Conditional,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IsValidDomainLabelCharacter,The conditional expression  "(character >= 'a' && character <= 'z') || (character >= '0' && character <= '9') || (character == '-') || (character == '_')"  is complex.
Complex Conditional,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,IsValidCanonical,The conditional expression  "ch == '/' || ch == '\\' || (notImplicitFile && (ch == ':' || ch == '?' || ch == '#'))"  is complex.
Complex Conditional,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseNonCanonical,The conditional expression  "(numberBase == Decimal || numberBase == Hex) && '0' <= ch && ch <= '9'"  is complex.
Complex Conditional,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseNonCanonical,The conditional expression  "(ch = name[current]) == '/' || ch == '\\' || (notImplicitFile && (ch == ':' || ch == '?' || ch == '#'))"  is complex.
Complex Conditional,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,ShouldHaveIpv4Embedded,The conditional expression  "numbers[0] == 0 && numbers[1] == 0 && numbers[2] == 0 && numbers[3] == 0 && numbers[6] != 0"  is complex.
Complex Conditional,System,IriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IriHelper.cs,CheckIriUnicodeRange,The conditional expression  "((string.CompareOrdinal(surrPair' "\U00010000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U0001FFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U00020000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U0002FFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U00030000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U0003FFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U00040000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U0004FFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U00050000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U0005FFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U00060000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U0006FFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U00070000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U0007FFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U00080000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U0008FFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U00090000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U0009FFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U000A0000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U000AFFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U000B0000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U000BFFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U000C0000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U000CFFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U000D0000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U000DFFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U000E1000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U000EFFFD") <= 0)) ||                      (isQuery &&                          (((string.CompareOrdinal(surrPair' "\U000F0000") >= 0)                              && (string.CompareOrdinal(surrPair' "\U000FFFFD") <= 0)) ||                              ((string.CompareOrdinal(surrPair' "\U00100000") >= 0)                              && (string.CompareOrdinal(surrPair' "\U0010FFFD") <= 0))))"  is complex.
Complex Conditional,System,IriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IriHelper.cs,CheckIsReserved,The conditional expression  "(component != UriComponents.Scheme) &&                      (component != UriComponents.UserInfo) &&                      (component != UriComponents.Host) &&                      (component != UriComponents.Port) &&                      (component != UriComponents.Path) &&                      (component != UriComponents.Query) &&                      (component != UriComponents.Fragment)"  is complex.
Complex Conditional,System,IriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IriHelper.cs,CheckIsReserved,The conditional expression  "ch == '/' || ch == '?' || ch == '#' || ch == '[' || ch == ']' || ch == '@'"  is complex.
Complex Conditional,System,IriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IriHelper.cs,CheckIsReserved,The conditional expression  "ch == ':' || ch == '/' || ch == '?' || ch == '#' || ch == '[' || ch == ']' || ch == '@'"  is complex.
Complex Conditional,System,IriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IriHelper.cs,CheckIsReserved,The conditional expression  "ch == '/' || ch == '?' || ch == '#' || ch == '[' || ch == ']'"  is complex.
Complex Conditional,System,IriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IriHelper.cs,EscapeUnescapeIri,The conditional expression  "ch == Uri.c_DummyChar || ch == '%' || CheckIsReserved(ch' component) || UriHelper.IsNotSafeForUnescape(ch)"  is complex.
Complex Conditional,System,UncNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UncNameHelper.cs,IsValid,The conditional expression  "name[i] == '/' || name[i] == '\\' || (notImplicitFile && (name[i] == ':' || name[i] == '?' || name[i] == '#'))"  is complex.
Complex Conditional,System,UncNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UncNameHelper.cs,IsValid,The conditional expression  "name[i] == '/' || name[i] == '\\' || (notImplicitFile && (name[i] == ':' || name[i] == '?' || name[i] == '#'))"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,GetCombinedString,The conditional expression  "relativeStr[i] == '/' || relativeStr[i] == '\\' || relativeStr[i] == '?' || relativeStr[i] == '#'"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeName,The conditional expression  "!(UriHelper.IsAsciiLetterOrDigit(schemeName[i])                      || (schemeName[i] == '+')                      || (schemeName[i] == '-')                      || (schemeName[i] == '.'))"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,Equals,The conditional expression  "!UserDrivenParsing && !obj.UserDrivenParsing && Syntax.IsSimple && obj.Syntax.IsSimple"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,PrivateParseMinimal,The conditional expression  "i + 1 < length && ((c = pUriString[i + 1]) == ':' || c == '|') &&                              UriHelper.IsAsciiLetter(pUriString[i])"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,PrivateParseMinimal,The conditional expression  "_syntax.InFact(UriSyntaxFlags.FileLikeUri) && (i - idx >= 2 && i - idx != 3 &&                              i < length && pUriString[i] != '?' && pUriString[i] != '#')"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,PrivateParseMinimal,The conditional expression  "!IsWindowsSystem && _syntax.InFact(UriSyntaxFlags.FileLikeUri) && pUriString[i - 1] == '/' && i - idx == 3"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,PrivateParseMinimal,The conditional expression  "(first == '/' || first == '\\') && (second == '/' || second == '\\')"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,PrivateParseMinimal,The conditional expression  "_syntax.InFact(UriSyntaxFlags.OptionalAuthority) && (InFact(Flags.AuthorityFound) ||                          (first == '/' && second == '/'))"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,PrivateParseMinimal,The conditional expression  "!IsWindowsSystem && hostTerminator == '/' && NotAny(Flags.ImplicitFile) && InFact(Flags.UncPath) && _syntax == UriParser.FileUri"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,PrivateParseMinimalIri,The conditional expression  "(!_iriParsing && AllowIdn && (((_flags & Flags.IdnHost) != 0) || ((_flags & Flags.UnicodeHost) != 0))) ||                  (_iriParsing && ((_flags & Flags.HasUnicode) == 0) && AllowIdn && ((_flags & Flags.IdnHost) != 0))"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,GetUriPartsFromUserString,The conditional expression  "uriParts == UriComponents.Path && InFact(Flags.AuthorityFound) &&                          _info.Offset.End > _info.Offset.Path && _string[_info.Offset.Path] == '/'"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ParseRemaining,The conditional expression  "((_flags & Flags.AuthorityFound) != 0) && (idx + i + 3 >= length || str[idx + i + 1] != '/' ||                          str[idx + i + 2] != '/')"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ParseRemaining,The conditional expression  "((_flags & Flags.AuthorityFound) != 0) && ((syntaxFlags & UriSyntaxFlags.PathIsRooted) != 0)                      && (_info.Offset.Path == length || (str[_info.Offset.Path] != '/' && str[_info.Offset.Path] != '\\'))"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ParseRemaining,The conditional expression  "IsDosPath || (((_flags & Flags.AuthorityFound) != 0) &&                  (((syntaxFlags & (UriSyntaxFlags.CompressPath | UriSyntaxFlags.ConvertPathSlashes)) != 0) ||                  _syntax.InFact(UriSyntaxFlags.UnEscapeDotsAndSlashes)))"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The conditional expression  "ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's'"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The conditional expression  "ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o'"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckAuthorityHelper,The conditional expression  "idx == length || ((ch = pString[idx]) == '/' || (ch == '\\' && StaticIsFile(syntax)) || ch == '#' || ch == '?')"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckAuthorityHelper,The conditional expression  "start == end - 1 || pString[start] == '?' || pString[start] == '#' || pString[start] == '\\' ||                          pString[start] == '/'"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckAuthorityHelper,The conditional expression  "ch <= '9' && ch >= '0' && syntax.InFact(UriSyntaxFlags.AllowIPv4Host) &&                  IPv4AddressHelper.IsValid(pString' (int)start' ref end' false' StaticNotAny(flags' Flags.ImplicitFile)' syntax.InFact(UriSyntaxFlags.V1_UnknownUri))"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckAuthorityHelper,The conditional expression  "((syntaxFlags & UriSyntaxFlags.AllowDnsHost) != 0)                      && ((syntax.InFact(UriSyntaxFlags.AllowIriParsing) && hostNotUnicodeNormalized)                              || syntax.InFact(UriSyntaxFlags.AllowIdn))                      && DomainNameHelper.IsValidByIri(pString' start' ref end' ref dnsNotCanonical'                                              StaticNotAny(flags' Flags.ImplicitFile))"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckAuthorityHelper,The conditional expression  "end < length && pString[end] == '\\' && (flags & Flags.HostTypeMask) != Flags.HostNotParsed                  && !StaticIsFile(syntax)"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckAuthorityHelper,The conditional expression  "dotFound && (pString[end] == '/' || pString[end] == '?' || pString[end] == '#')"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckAuthorityHelperHandleDnsIri,The conditional expression  "allAscii && !atLeastOneIdn && iriParsing && hasUnicode"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckAuthorityHelperHandleAnyHostIri,The conditional expression  "StaticNotAny(flags' Flags.HostUnicodeNormalized) && (AllowIdnStatic(syntax' flags) ||                  (iriParsing && hasUnicode))"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckAuthorityHelperHandleAnyHostIri,The conditional expression  "((allAscii && atLeastOneIdn) || !allAscii) && !(iriParsing && hasUnicode)"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,FindEndOfComponent,The conditional expression  "delim == '?' && c == '#' && (_syntax != null && _syntax.InFact(UriSyntaxFlags.MayHaveFragment))"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckCanonical,The conditional expression  "delim == '?' && c == '#' && (_syntax != null && _syntax.InFact(UriSyntaxFlags.MayHaveFragment))"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckCanonical,The conditional expression  "IsImplicitFile || (_syntax != null && !_syntax.InFact(UriSyntaxFlags.MayHaveQuery)                          && delim != c_EOL)"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckCanonical,The conditional expression  "(res & Check.DotSlashAttn) == 0 && i + 1 != end && (str[i + 1] == '/' || str[i + 1] == '\\')"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckCanonical,The conditional expression  "(res & Check.DotSlashAttn) == 0 && i + 1 == end || str[i + 1] == '.' || str[i + 1] == '/'                          || str[i + 1] == '\\' || str[i + 1] == '?' || str[i + 1] == '#'"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckCanonical,The conditional expression  "!needsEscaping && ((c <= '"' && c != '!') || (c >= '[' && c <= '^') || c == '>'                      || c == '<' || c == '`')"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,GetCanonicalPath,The conditional expression  "!IsWindowsSystem && InFact(Flags.BackslashInPath) && _syntax.NotAny(UriSyntaxFlags.ConvertPathSlashes) && _syntax.InFact(UriSyntaxFlags.FileLikeUri) && !IsImplicitFile"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,Compress,The conditional expression  "(lastSlash == i + dotCount + 1 // "/..../"                                      || (lastSlash == 0 && i + dotCount + 1 == destLength)) // "/..."                                  && (dotCount <= 2)"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CombineUri,The conditional expression  "basePart.IsDosPath &&                  (c1 == '/' || c1 == '\\') &&                  (relativePart.Length == 1 || (relativePart[1] != '/' && relativePart[1] != '\\'))"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,InitializeUri,The conditional expression  "NotAny(Flags.DosPath) &&                          uriKind != UriKind.Absolute &&                         ((uriKind == UriKind.Relative || (_string.Length >= 2 && (_string[0] != '\\' || _string[1] != '\\')))                      || (!IsWindowsSystem && InFact(Flags.UnixPath)))"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckForEscapedUnreserved,The conditional expression  "tempPtr[i] == '%' && IsHexDigit(tempPtr[i + 1]) && IsHexDigit(tempPtr[i + 2])                          && tempPtr[i + 1] >= '0' && tempPtr[i + 1] <= '7'"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,InternalIsWellFormedOriginalString,The conditional expression  "((nonCanonical & Flags.E_CannotDisplayCanonical & (Flags.E_UserNotCanonical | Flags.E_PathNotCanonical |                                          Flags.E_QueryNotCanonical | Flags.E_FragmentNotCanonical)) != Flags.Zero) &&                      (!_iriParsing || (_iriParsing &&                      (((nonCanonical & Flags.E_UserNotCanonical) == 0) || ((nonCanonical & Flags.UserIriCanonical) == 0)) &&                      (((nonCanonical & Flags.E_PathNotCanonical) == 0) || ((nonCanonical & Flags.PathIriCanonical) == 0)) &&                      (((nonCanonical & Flags.E_QueryNotCanonical) == 0) || ((nonCanonical & Flags.QueryIriCanonical) == 0)) &&                      (((nonCanonical & Flags.E_FragmentNotCanonical) == 0) || ((nonCanonical & Flags.FragmentIriCanonical) == 0))))"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,InternalIsWellFormedOriginalString,The conditional expression  "((result & (Check.ReservedFound | Check.BackslashInPath | Check.EscapedCanonical))                          != Check.EscapedCanonical)                          && (!_iriParsing || (_iriParsing                              && ((result & (Check.DisplayCanonical | Check.FoundNonAscii | Check.NotIriCanonical))                                  != (Check.DisplayCanonical | Check.FoundNonAscii))))"  is complex.
Complex Conditional,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ResolveHelper,The conditional expression  "relativeStr.Length >= 3                  && (relativeStr[1] == ':' || relativeStr[1] == '|')                  && UriHelper.IsAsciiLetter(relativeStr[0])                  && (relativeStr[2] == '\\' || relativeStr[2] == '/')"  is complex.
Complex Conditional,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,UnescapeString,The conditional expression  "iriParsing && ((ch <= '\x9F' && IsNotSafeForUnescape(ch)) ||                                                              (ch > '\x9F' && !IriHelper.CheckIriUnicodeRange(ch' isQuery)))"  is complex.
Complex Conditional,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,UnescapeString,The conditional expression  "(unescapeMode & UnescapeMode.V1ToStringFlag) == 0                                      && (ch <= '\x1F' || (ch >= '\x7F' && ch <= '\x9F'))"  is complex.
Complex Conditional,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,EscapedAscii,The conditional expression  "!(((digit >= '0') && (digit <= '9'))                  || ((digit >= 'A') && (digit <= 'F'))                  || ((digit >= 'a') && (digit <= 'f')))"  is complex.
Complex Conditional,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,EscapedAscii,The conditional expression  "!(((next >= '0') && (next <= '9'))                  || ((next >= 'A') && (next <= 'F'))                  || ((next >= 'a') && (next <= 'f')))"  is complex.
Complex Conditional,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,IsNotSafeForUnescape,The conditional expression  "(ch >= ';' && ch <= '@' && (ch | '\x2') != '>') ||                       (ch >= '#' && ch <= '&') ||                       ch == '+' || ch == ''' || ch == '/' || ch == '\\'"  is complex.
Complex Conditional,System,UriParser,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriScheme.cs,CheckSetIsSimpleFlag,The conditional expression  "type == typeof(GenericUriParser)                       ||  type == typeof(HttpStyleUriParser)                     ||  type == typeof(FtpStyleUriParser)                     ||  type == typeof(FileStyleUriParser)                     ||  type == typeof(NewsStyleUriParser)                     ||  type == typeof(GopherStyleUriParser)                   ||  type == typeof(NetPipeStyleUriParser)                   ||  type == typeof(NetTcpStyleUriParser)                   ||  type == typeof(LdapStyleUriParser)"  is complex.
Empty Catch Block,System.Collections.Generic,LowLevelDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\LowLevelDictionary.cs,ExpandBuckets,The method has an empty catch block.
Empty Catch Block,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IdnEquivalent,The method has an empty catch block.
Empty Catch Block,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,UnicodeEquivalent,The method has an empty catch block.
Empty Catch Block,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,UnicodeEquivalent,The method has an empty catch block.
Empty Catch Block,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ReCreateParts,The method has an empty catch block.
Magic Number,System.Collections.Generic,ArrayBuilder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\ArrayBuilder.cs,EnsureCapacity,The following statement contains a magic number: int nextCapacity = capacity == 0 ? DefaultCapacity : 2 * capacity;
Magic Number,System.Collections.Generic,LowLevelDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\LowLevelDictionary.cs,UncheckedAdd,The following statement contains a magic number: if (_numEntries > (_buckets.Length * 2))                  ExpandBuckets();
Magic Number,System.Collections.Generic,LowLevelDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\LowLevelDictionary.cs,ExpandBuckets,The following statement contains a magic number: try              {                  int newNumBuckets = _buckets.Length * 2 + 1;                  Entry[] newBuckets = new Entry[newNumBuckets];                  for (int i = 0; i < _buckets.Length; i++)                  {                      Entry entry = _buckets[i];                      while (entry != null)                      {                          Entry nextEntry = entry._next;                            int bucket = GetBucket(entry._key' newNumBuckets);                          entry._next = newBuckets[bucket];                          newBuckets[bucket] = entry;                            entry = nextEntry;                      }                  }                  _buckets = newBuckets;              }              catch (OutOfMemoryException)              {              }
Magic Number,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IsValid,The following statement contains a magic number: do              {                  //  Determines whether a string is a valid domain name label. In keeping                  //  with RFC 1123' section 2.1' the requirement that the first character                  //  of a label be alphabetic is dropped. Therefore' Domain names are                  //  formed as:                  //                  //      <label> -> <alphanum> [<alphanum> | <hyphen> | <underscore>] * 62                    //find the dot or hit the end                  newPos = curPos;                  while (newPos < end)                  {                      if (*newPos == '.') break;                      ++newPos;                  }                    //check the label start/range                  if (curPos == newPos || newPos - curPos > 63 || !IsASCIILetterOrDigit(*curPos++' ref notCanonical))                  {                      return false;                  }                  //check the label content                  while (curPos < newPos)                  {                      if (!IsValidDomainLabelCharacter(*curPos++' ref notCanonical))                      {                          return false;                      }                  }                  ++curPos;              } while (curPos < end);
Magic Number,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IsValidByIri,The following statement contains a magic number: do              {                  //  Determines whether a string is a valid domain name label. In keeping                  //  with RFC 1123' section 2.1' the requirement that the first character                  //  of a label be alphabetic is dropped. Therefore' Domain names are                  //  formed as:                  //                  //      <label> -> <alphanum> [<alphanum> | <hyphen> | <underscore>] * 62                    //find the dot or hit the end                  newPos = curPos;                  count = 0;                  bool labelHasUnicode = false; // if label has unicode we need to add 4 to label count for xn--                  while (newPos < end)                  {                      if ((*newPos == '.') ||                          (*newPos == '\u3002') ||    //IDEOGRAPHIC FULL STOP                           (*newPos == '\uFF0E') ||    //FULLWIDTH FULL STOP                          (*newPos == '\uFF61'))      //HALFWIDTH IDEOGRAPHIC FULL STOP                          break;                      count++;                      if (*newPos > 0xFF)                          count++; // counts for two octets                      if (*newPos >= 0xA0)                          labelHasUnicode = true;                        ++newPos;                  }                    //check the label start/range                  if (curPos == newPos || (labelHasUnicode ? count + 4 : count) > 63 || ((*curPos++ < 0xA0) && !IsASCIILetterOrDigit(*(curPos - 1)' ref notCanonical)))                  {                      return false;                  }                  //check the label content                  while (curPos < newPos)                  {                      if ((*curPos++ < 0xA0) && !IsValidDomainLabelCharacter(*(curPos - 1)' ref notCanonical))                      {                          return false;                      }                  }                  ++curPos;              } while (curPos < end);
Magic Number,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IsValidByIri,The following statement contains a magic number: do              {                  //  Determines whether a string is a valid domain name label. In keeping                  //  with RFC 1123' section 2.1' the requirement that the first character                  //  of a label be alphabetic is dropped. Therefore' Domain names are                  //  formed as:                  //                  //      <label> -> <alphanum> [<alphanum> | <hyphen> | <underscore>] * 62                    //find the dot or hit the end                  newPos = curPos;                  count = 0;                  bool labelHasUnicode = false; // if label has unicode we need to add 4 to label count for xn--                  while (newPos < end)                  {                      if ((*newPos == '.') ||                          (*newPos == '\u3002') ||    //IDEOGRAPHIC FULL STOP                           (*newPos == '\uFF0E') ||    //FULLWIDTH FULL STOP                          (*newPos == '\uFF61'))      //HALFWIDTH IDEOGRAPHIC FULL STOP                          break;                      count++;                      if (*newPos > 0xFF)                          count++; // counts for two octets                      if (*newPos >= 0xA0)                          labelHasUnicode = true;                        ++newPos;                  }                    //check the label start/range                  if (curPos == newPos || (labelHasUnicode ? count + 4 : count) > 63 || ((*curPos++ < 0xA0) && !IsASCIILetterOrDigit(*(curPos - 1)' ref notCanonical)))                  {                      return false;                  }                  //check the label content                  while (curPos < newPos)                  {                      if ((*curPos++ < 0xA0) && !IsValidDomainLabelCharacter(*(curPos - 1)' ref notCanonical))                      {                          return false;                      }                  }                  ++curPos;              } while (curPos < end);
Magic Number,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IdnEquivalent,The following statement contains a magic number: if (idnEquivalent != null)              {                  string strippedHost = (allAscii ? idnEquivalent : bidiStrippedHost);                    fixed (char* strippedHostPtr = strippedHost)                  {                      int length = strippedHost.Length;                      int newPos = 0;                      int curPos = 0;                      bool foundAce = false;                      bool checkedAce = false;                      bool foundDot = false;                        do                      {                          foundAce = false;                          checkedAce = false;                          foundDot = false;                            //find the dot or hit the end                          newPos = curPos;                          while (newPos < length)                          {                              char c = strippedHostPtr[newPos];                              if (!checkedAce)                              {                                  checkedAce = true;                                  if ((newPos + 3 < length) && IsIdnAce(strippedHostPtr' newPos))                                  {                                      newPos += 4;                                      foundAce = true;                                      continue;                                  }                              }                                if ((c == '.') || (c == '\u3002') ||    //IDEOGRAPHIC FULL STOP                                   (c == '\uFF0E') ||                  //FULLWIDTH FULL STOP                                  (c == '\uFF61'))                    //HALFWIDTH IDEOGRAPHIC FULL STOP                              {                                  foundDot = true;                                  break;                              }                              ++newPos;                          }                            if (foundAce)                          {                              // check ace validity                              try                              {                                  IdnMapping map = new IdnMapping();                                  map.GetUnicode(new string(strippedHostPtr' curPos' newPos - curPos));                                  atLeastOneValidIdn = true;                                  break;                              }                              catch (ArgumentException)                              {                                  // not valid ace so treat it as a normal ascii label                              }                          }                            curPos = newPos + (foundDot ? 1 : 0);                      } while (curPos < length);                  }              }              else              {                  atLeastOneValidIdn = false;              }
Magic Number,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IdnEquivalent,The following statement contains a magic number: if (idnEquivalent != null)              {                  string strippedHost = (allAscii ? idnEquivalent : bidiStrippedHost);                    fixed (char* strippedHostPtr = strippedHost)                  {                      int length = strippedHost.Length;                      int newPos = 0;                      int curPos = 0;                      bool foundAce = false;                      bool checkedAce = false;                      bool foundDot = false;                        do                      {                          foundAce = false;                          checkedAce = false;                          foundDot = false;                            //find the dot or hit the end                          newPos = curPos;                          while (newPos < length)                          {                              char c = strippedHostPtr[newPos];                              if (!checkedAce)                              {                                  checkedAce = true;                                  if ((newPos + 3 < length) && IsIdnAce(strippedHostPtr' newPos))                                  {                                      newPos += 4;                                      foundAce = true;                                      continue;                                  }                              }                                if ((c == '.') || (c == '\u3002') ||    //IDEOGRAPHIC FULL STOP                                   (c == '\uFF0E') ||                  //FULLWIDTH FULL STOP                                  (c == '\uFF61'))                    //HALFWIDTH IDEOGRAPHIC FULL STOP                              {                                  foundDot = true;                                  break;                              }                              ++newPos;                          }                            if (foundAce)                          {                              // check ace validity                              try                              {                                  IdnMapping map = new IdnMapping();                                  map.GetUnicode(new string(strippedHostPtr' curPos' newPos - curPos));                                  atLeastOneValidIdn = true;                                  break;                              }                              catch (ArgumentException)                              {                                  // not valid ace so treat it as a normal ascii label                              }                          }                            curPos = newPos + (foundDot ? 1 : 0);                      } while (curPos < length);                  }              }              else              {                  atLeastOneValidIdn = false;              }
Magic Number,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IsIdnAce,The following statement contains a magic number: if ((input[index] == 'x') &&                  (input[index + 1] == 'n') &&                  (input[index + 2] == '-') &&                  (input[index + 3] == '-'))                  return true;              else                  return false;
Magic Number,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IsIdnAce,The following statement contains a magic number: if ((input[index] == 'x') &&                  (input[index + 1] == 'n') &&                  (input[index + 2] == '-') &&                  (input[index + 3] == '-'))                  return true;              else                  return false;
Magic Number,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IsIdnAce,The following statement contains a magic number: if ((input[index] == 'x') &&                  (input[index + 1] == 'n') &&                  (input[index + 2] == '-') &&                  (input[index + 3] == '-'))                  return true;              else                  return false;
Magic Number,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,IsIdnAce,The following statement contains a magic number: if ((input[index] == 'x') &&                  (input[index + 1] == 'n') &&                  (input[index + 2] == '-') &&                  (input[index + 3] == '-'))                  return true;              else                  return false;
Magic Number,System,DomainNameHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\DomainNameHelper.cs,UnicodeEquivalent,The following statement contains a magic number: do              {                  asciiLabel = true;                  foundAce = false;                  checkedAce = false;                  foundDot = false;                    //find the dot or hit the end                  newPos = curPos;                  while (newPos < length)                  {                      char c = unescapedHostname[newPos];                      if (!checkedAce)                      {                          checkedAce = true;                          if ((newPos + 3 < length) && (c == 'x') && IsIdnAce(unescapedHostname' newPos))                              foundAce = true;                      }                      if (asciiLabel && (c > '\x7F'))                      {                          asciiLabel = false;                          allAscii = false;                      }                      if ((c == '.') || (c == '\u3002') ||    //IDEOGRAPHIC FULL STOP                           (c == '\uFF0E') ||                  //FULLWIDTH FULL STOP                          (c == '\uFF61'))                    //HALFWIDTH IDEOGRAPHIC FULL STOP                      {                          foundDot = true;                          break;                      }                      ++newPos;                  }                    if (!asciiLabel)                  {                      string asciiForm = unescapedHostname.Substring(curPos' newPos - curPos);                      try                      {                          asciiForm = map.GetAscii(asciiForm);                      }                      catch (ArgumentException)                      {                          throw new UriFormatException(SR.net_uri_BadUnicodeHostForIdn);                      }                        unicodeEqvlHost += map.GetUnicode(asciiForm);                      if (foundDot)                          unicodeEqvlHost += ".";                  }                  else                  {                      bool aceValid = false;                      if (foundAce)                      {                          // check ace validity                          try                          {                              unicodeEqvlHost += map.GetUnicode(unescapedHostname.Substring(curPos' newPos - curPos));                              if (foundDot)                                  unicodeEqvlHost += ".";                              aceValid = true;                              atLeastOneValidIdn = true;                          }                          catch (ArgumentException)                          {                              // not valid ace so treat it as a normal ascii label                          }                      }                        if (!aceValid)                      {                          // for invalid aces we just lowercase the label                          unicodeEqvlHost += unescapedHostname.Substring(curPos' newPos - curPos).ToLowerInvariant();                          if (foundDot)                              unicodeEqvlHost += ".";                      }                  }                    curPos = newPos + (foundDot ? 1 : 0);              } while (curPos < length);
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseCanonicalName,The following statement contains a magic number: unsafe              {                  byte* numbers = stackalloc byte[NumberOfLabels];                  isLoopback = Parse(str' numbers' start' end);                  return numbers[0] + "." + numbers[1] + "." + numbers[2] + "." + numbers[3];              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseCanonicalName,The following statement contains a magic number: unsafe              {                  byte* numbers = stackalloc byte[NumberOfLabels];                  isLoopback = Parse(str' numbers' start' end);                  return numbers[0] + "." + numbers[1] + "." + numbers[2] + "." + numbers[3];              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseHostNumber,The following statement contains a magic number: unsafe              {                  byte* numbers = stackalloc byte[NumberOfLabels];                  ParseCanonical(str' numbers' start' end);                  return (numbers[0] << 24) + (numbers[1] << 16) + (numbers[2] << 8) + numbers[3];              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseHostNumber,The following statement contains a magic number: unsafe              {                  byte* numbers = stackalloc byte[NumberOfLabels];                  ParseCanonical(str' numbers' start' end);                  return (numbers[0] << 24) + (numbers[1] << 16) + (numbers[2] << 8) + numbers[3];              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseHostNumber,The following statement contains a magic number: unsafe              {                  byte* numbers = stackalloc byte[NumberOfLabels];                  ParseCanonical(str' numbers' start' end);                  return (numbers[0] << 24) + (numbers[1] << 16) + (numbers[2] << 8) + numbers[3];              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseHostNumber,The following statement contains a magic number: unsafe              {                  byte* numbers = stackalloc byte[NumberOfLabels];                  ParseCanonical(str' numbers' start' end);                  return (numbers[0] << 24) + (numbers[1] << 16) + (numbers[2] << 8) + numbers[3];              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseHostNumber,The following statement contains a magic number: unsafe              {                  byte* numbers = stackalloc byte[NumberOfLabels];                  ParseCanonical(str' numbers' start' end);                  return (numbers[0] << 24) + (numbers[1] << 16) + (numbers[2] << 8) + numbers[3];              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,IsValidCanonical,The following statement contains a magic number: while (start < end)              {                  char ch = name[start];                  if (allowIPv6)                  {                      // for ipv4 inside ipv6 the terminator is either ScopeId' prefix or ipv6 terminator                      if (ch == ']' || ch == '/' || ch == '%') break;                  }                  else if (ch == '/' || ch == '\\' || (notImplicitFile && (ch == ':' || ch == '?' || ch == '#')))                  {                      break;                  }                    if (ch <= '9' && ch >= '0')                  {                      if (!haveNumber && (ch == '0'))                      {                          if ((start + 1 < end) && name[start + 1] == '0')                          {                              // 00 is not allowed as a prefix.                              return false;                          }                            firstCharIsZero = true;                      }                        haveNumber = true;                      number = number * 10 + (name[start] - '0');                      if (number > 255)                      {                          return false;                      }                  }                  else if (ch == '.')                  {                      if (!haveNumber || (number > 0 && firstCharIsZero))                      {                          // 0 is not allowed to prefix a number.                          return false;                      }                      ++dots;                      haveNumber = false;                      number = 0;                      firstCharIsZero = false;                  }                  else                  {                      return false;                  }                  ++start;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,IsValidCanonical,The following statement contains a magic number: while (start < end)              {                  char ch = name[start];                  if (allowIPv6)                  {                      // for ipv4 inside ipv6 the terminator is either ScopeId' prefix or ipv6 terminator                      if (ch == ']' || ch == '/' || ch == '%') break;                  }                  else if (ch == '/' || ch == '\\' || (notImplicitFile && (ch == ':' || ch == '?' || ch == '#')))                  {                      break;                  }                    if (ch <= '9' && ch >= '0')                  {                      if (!haveNumber && (ch == '0'))                      {                          if ((start + 1 < end) && name[start + 1] == '0')                          {                              // 00 is not allowed as a prefix.                              return false;                          }                            firstCharIsZero = true;                      }                        haveNumber = true;                      number = number * 10 + (name[start] - '0');                      if (number > 255)                      {                          return false;                      }                  }                  else if (ch == '.')                  {                      if (!haveNumber || (number > 0 && firstCharIsZero))                      {                          // 0 is not allowed to prefix a number.                          return false;                      }                      ++dots;                      haveNumber = false;                      number = 0;                      firstCharIsZero = false;                  }                  else                  {                      return false;                  }                  ++start;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,IsValidCanonical,The following statement contains a magic number: bool res = (dots == 3) && haveNumber;
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: long[] parts = new long[4];
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: for (; current < end; current++)              {                  ch = name[current];                  currentValue = 0;                    // Figure out what base this section is in                  numberBase = Decimal;                  if (ch == '0')                  {                      numberBase = Octal;                      current++;                      atLeastOneChar = true;                      if (current < end)                      {                          ch = name[current];                          if (ch == 'x' || ch == 'X')                          {                              numberBase = Hex;                              current++;                              atLeastOneChar = false;                          }                      }                  }                    // Parse this section                  for (; current < end; current++)                  {                      ch = name[current];                      int digitValue;                        if ((numberBase == Decimal || numberBase == Hex) && '0' <= ch && ch <= '9')                      {                          digitValue = ch - '0';                      }                      else if (numberBase == Octal && '0' <= ch && ch <= '7')                      {                          digitValue = ch - '0';                      }                      else if (numberBase == Hex && 'a' <= ch && ch <= 'f')                      {                          digitValue = ch + 10 - 'a';                      }                      else if (numberBase == Hex && 'A' <= ch && ch <= 'F')                      {                          digitValue = ch + 10 - 'A';                      }                      else                      {                          break; // Invalid/terminator                      }                        currentValue = (currentValue * numberBase) + digitValue;                        if (currentValue > MaxIPv4Value) // Overflow                      {                          return Invalid;                      }                        atLeastOneChar = true;                  }                    if (current < end && name[current] == '.')                  {                      if (dotCount >= 3 // Max of 3 dots and 4 segments                          || !atLeastOneChar // No empty segments: 1...1                                             // Only the last segment can be more than 255 (if there are less than 3 dots)                          || currentValue > 0xFF)                      {                          return Invalid;                      }                      parts[dotCount] = currentValue;                      dotCount++;                      atLeastOneChar = false;                      continue;                  }                  // We don't get here unless We find an invalid character or a terminator                  break;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: for (; current < end; current++)              {                  ch = name[current];                  currentValue = 0;                    // Figure out what base this section is in                  numberBase = Decimal;                  if (ch == '0')                  {                      numberBase = Octal;                      current++;                      atLeastOneChar = true;                      if (current < end)                      {                          ch = name[current];                          if (ch == 'x' || ch == 'X')                          {                              numberBase = Hex;                              current++;                              atLeastOneChar = false;                          }                      }                  }                    // Parse this section                  for (; current < end; current++)                  {                      ch = name[current];                      int digitValue;                        if ((numberBase == Decimal || numberBase == Hex) && '0' <= ch && ch <= '9')                      {                          digitValue = ch - '0';                      }                      else if (numberBase == Octal && '0' <= ch && ch <= '7')                      {                          digitValue = ch - '0';                      }                      else if (numberBase == Hex && 'a' <= ch && ch <= 'f')                      {                          digitValue = ch + 10 - 'a';                      }                      else if (numberBase == Hex && 'A' <= ch && ch <= 'F')                      {                          digitValue = ch + 10 - 'A';                      }                      else                      {                          break; // Invalid/terminator                      }                        currentValue = (currentValue * numberBase) + digitValue;                        if (currentValue > MaxIPv4Value) // Overflow                      {                          return Invalid;                      }                        atLeastOneChar = true;                  }                    if (current < end && name[current] == '.')                  {                      if (dotCount >= 3 // Max of 3 dots and 4 segments                          || !atLeastOneChar // No empty segments: 1...1                                             // Only the last segment can be more than 255 (if there are less than 3 dots)                          || currentValue > 0xFF)                      {                          return Invalid;                      }                      parts[dotCount] = currentValue;                      dotCount++;                      atLeastOneChar = false;                      continue;                  }                  // We don't get here unless We find an invalid character or a terminator                  break;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: for (; current < end; current++)              {                  ch = name[current];                  currentValue = 0;                    // Figure out what base this section is in                  numberBase = Decimal;                  if (ch == '0')                  {                      numberBase = Octal;                      current++;                      atLeastOneChar = true;                      if (current < end)                      {                          ch = name[current];                          if (ch == 'x' || ch == 'X')                          {                              numberBase = Hex;                              current++;                              atLeastOneChar = false;                          }                      }                  }                    // Parse this section                  for (; current < end; current++)                  {                      ch = name[current];                      int digitValue;                        if ((numberBase == Decimal || numberBase == Hex) && '0' <= ch && ch <= '9')                      {                          digitValue = ch - '0';                      }                      else if (numberBase == Octal && '0' <= ch && ch <= '7')                      {                          digitValue = ch - '0';                      }                      else if (numberBase == Hex && 'a' <= ch && ch <= 'f')                      {                          digitValue = ch + 10 - 'a';                      }                      else if (numberBase == Hex && 'A' <= ch && ch <= 'F')                      {                          digitValue = ch + 10 - 'A';                      }                      else                      {                          break; // Invalid/terminator                      }                        currentValue = (currentValue * numberBase) + digitValue;                        if (currentValue > MaxIPv4Value) // Overflow                      {                          return Invalid;                      }                        atLeastOneChar = true;                  }                    if (current < end && name[current] == '.')                  {                      if (dotCount >= 3 // Max of 3 dots and 4 segments                          || !atLeastOneChar // No empty segments: 1...1                                             // Only the last segment can be more than 255 (if there are less than 3 dots)                          || currentValue > 0xFF)                      {                          return Invalid;                      }                      parts[dotCount] = currentValue;                      dotCount++;                      atLeastOneChar = false;                      continue;                  }                  // We don't get here unless We find an invalid character or a terminator                  break;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseNonCanonical,The following statement contains a magic number: switch (dotCount)              {                  case 0: // 0xFFFFFFFF                      if (parts[0] > MaxIPv4Value)                      {                          return Invalid;                      }                      return parts[0];                  case 1: // 0xFF.0xFFFFFF                      if (parts[1] > 0xffffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | (parts[1] & 0xffffff);                  case 2: // 0xFF.0xFF.0xFFFF                      if (parts[2] > 0xffff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | (parts[2] & 0xffff);                  case 3: // 0xFF.0xFF.0xFF.0xFF                      if (parts[3] > 0xff)                      {                          return Invalid;                      }                      return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);                  default:                      return Invalid;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,Parse,The following statement contains a magic number: fixed (char* ipString = name)              {                  int changedEnd = end;                  long result = IPv4AddressHelper.ParseNonCanonical(ipString' start' ref changedEnd' true);                  // end includes ports' so changedEnd may be different from end                  Debug.Assert(result != Invalid' "Failed to parse after already validated: " + name);                    unchecked                  {                      numbers[0] = (byte)(result >> 24);                      numbers[1] = (byte)(result >> 16);                      numbers[2] = (byte)(result >> 8);                      numbers[3] = (byte)(result);                  }              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,Parse,The following statement contains a magic number: fixed (char* ipString = name)              {                  int changedEnd = end;                  long result = IPv4AddressHelper.ParseNonCanonical(ipString' start' ref changedEnd' true);                  // end includes ports' so changedEnd may be different from end                  Debug.Assert(result != Invalid' "Failed to parse after already validated: " + name);                    unchecked                  {                      numbers[0] = (byte)(result >> 24);                      numbers[1] = (byte)(result >> 16);                      numbers[2] = (byte)(result >> 8);                      numbers[3] = (byte)(result);                  }              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,Parse,The following statement contains a magic number: fixed (char* ipString = name)              {                  int changedEnd = end;                  long result = IPv4AddressHelper.ParseNonCanonical(ipString' start' ref changedEnd' true);                  // end includes ports' so changedEnd may be different from end                  Debug.Assert(result != Invalid' "Failed to parse after already validated: " + name);                    unchecked                  {                      numbers[0] = (byte)(result >> 24);                      numbers[1] = (byte)(result >> 16);                      numbers[2] = (byte)(result >> 8);                      numbers[3] = (byte)(result);                  }              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,Parse,The following statement contains a magic number: fixed (char* ipString = name)              {                  int changedEnd = end;                  long result = IPv4AddressHelper.ParseNonCanonical(ipString' start' ref changedEnd' true);                  // end includes ports' so changedEnd may be different from end                  Debug.Assert(result != Invalid' "Failed to parse after already validated: " + name);                    unchecked                  {                      numbers[0] = (byte)(result >> 24);                      numbers[1] = (byte)(result >> 16);                      numbers[2] = (byte)(result >> 8);                      numbers[3] = (byte)(result);                  }              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,Parse,The following statement contains a magic number: fixed (char* ipString = name)              {                  int changedEnd = end;                  long result = IPv4AddressHelper.ParseNonCanonical(ipString' start' ref changedEnd' true);                  // end includes ports' so changedEnd may be different from end                  Debug.Assert(result != Invalid' "Failed to parse after already validated: " + name);                    unchecked                  {                      numbers[0] = (byte)(result >> 24);                      numbers[1] = (byte)(result >> 16);                      numbers[2] = (byte)(result >> 8);                      numbers[3] = (byte)(result);                  }              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,Parse,The following statement contains a magic number: return numbers[0] == 127;
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseCanonical,The following statement contains a magic number: for (int i = 0; i < NumberOfLabels; ++i)              {                  byte b = 0;                  char ch;                  for (; (start < end) && (ch = name[start]) != '.' && ch != ':'; ++start)                  {                      b = (byte)(b * 10 + (byte)(ch - '0'));                  }                  numbers[i] = b;                  ++start;              }
Magic Number,System,IPv4AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv4AddressHelper.cs,ParseCanonical,The following statement contains a magic number: return numbers[0] == 127;
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,CreateCanonicalName,The following statement contains a magic number: for (int i = 0; i < NumberOfLabels; i++)              {                  if (ipv4Embedded && i == (NumberOfLabels - 2))                  {                      // Write the remaining digits as an IPv4 address                      builder.AppendFormat(CultureInfo.InvariantCulture' EmbeddedIPv4Format'                          numbers[i] >> 8' numbers[i] & 0xFF' numbers[i + 1] >> 8' numbers[i + 1] & 0xFF);                      break;                  }                    // Compression; 1::1' ::1' 1::                  if (range.Key == i)                  { // Start compression' add :                      builder.Append(Separator);                  }                  if (range.Key <= i && range.Value == (NumberOfLabels - 1))                  { // Remainder compressed; 1::                      builder.Append(Separator);                      break;                  }                  if (range.Key <= i && i <= range.Value)                  {                      continue; // Compressed                  }                    if (i != 0)                  {                      builder.Append(Separator);                  }                  builder.AppendFormat(CultureInfo.InvariantCulture' CanonicalNumberFormat' numbers[i]);              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,CreateCanonicalName,The following statement contains a magic number: for (int i = 0; i < NumberOfLabels; i++)              {                  if (ipv4Embedded && i == (NumberOfLabels - 2))                  {                      // Write the remaining digits as an IPv4 address                      builder.AppendFormat(CultureInfo.InvariantCulture' EmbeddedIPv4Format'                          numbers[i] >> 8' numbers[i] & 0xFF' numbers[i + 1] >> 8' numbers[i + 1] & 0xFF);                      break;                  }                    // Compression; 1::1' ::1' 1::                  if (range.Key == i)                  { // Start compression' add :                      builder.Append(Separator);                  }                  if (range.Key <= i && range.Value == (NumberOfLabels - 1))                  { // Remainder compressed; 1::                      builder.Append(Separator);                      break;                  }                  if (range.Key <= i && i <= range.Value)                  {                      continue; // Compressed                  }                    if (i != 0)                  {                      builder.Append(Separator);                  }                  builder.AppendFormat(CultureInfo.InvariantCulture' CanonicalNumberFormat' numbers[i]);              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,CreateCanonicalName,The following statement contains a magic number: for (int i = 0; i < NumberOfLabels; i++)              {                  if (ipv4Embedded && i == (NumberOfLabels - 2))                  {                      // Write the remaining digits as an IPv4 address                      builder.AppendFormat(CultureInfo.InvariantCulture' EmbeddedIPv4Format'                          numbers[i] >> 8' numbers[i] & 0xFF' numbers[i + 1] >> 8' numbers[i + 1] & 0xFF);                      break;                  }                    // Compression; 1::1' ::1' 1::                  if (range.Key == i)                  { // Start compression' add :                      builder.Append(Separator);                  }                  if (range.Key <= i && range.Value == (NumberOfLabels - 1))                  { // Remainder compressed; 1::                      builder.Append(Separator);                      break;                  }                  if (range.Key <= i && i <= range.Value)                  {                      continue; // Compressed                  }                    if (i != 0)                  {                      builder.Append(Separator);                  }                  builder.AppendFormat(CultureInfo.InvariantCulture' CanonicalNumberFormat' numbers[i]);              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,FindCompressionRange,The following statement contains a magic number: if (longestSequenceLength >= 2)              {                  return new KeyValuePair<int' int>(longestSequenceStart'                      longestSequenceStart + longestSequenceLength - 1);              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,ShouldHaveIpv4Embedded,The following statement contains a magic number: if (numbers[0] == 0 && numbers[1] == 0 && numbers[2] == 0 && numbers[3] == 0 && numbers[6] != 0)              {                  // RFC 5952 Section 5 - 0:0 : 0:0 : 0:[0 | FFFF] : x.x.x.x                  if (numbers[4] == 0 && (numbers[5] == 0 || numbers[5] == 0xFFFF))                  {                      return true;                  }                  // SIIT - 0:0 : 0:0 : FFFF:0 : x.x.x.x                  else if (numbers[4] == 0xFFFF && numbers[5] == 0)                  {                      return true;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,ShouldHaveIpv4Embedded,The following statement contains a magic number: if (numbers[0] == 0 && numbers[1] == 0 && numbers[2] == 0 && numbers[3] == 0 && numbers[6] != 0)              {                  // RFC 5952 Section 5 - 0:0 : 0:0 : 0:[0 | FFFF] : x.x.x.x                  if (numbers[4] == 0 && (numbers[5] == 0 || numbers[5] == 0xFFFF))                  {                      return true;                  }                  // SIIT - 0:0 : 0:0 : FFFF:0 : x.x.x.x                  else if (numbers[4] == 0xFFFF && numbers[5] == 0)                  {                      return true;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,ShouldHaveIpv4Embedded,The following statement contains a magic number: if (numbers[0] == 0 && numbers[1] == 0 && numbers[2] == 0 && numbers[3] == 0 && numbers[6] != 0)              {                  // RFC 5952 Section 5 - 0:0 : 0:0 : 0:[0 | FFFF] : x.x.x.x                  if (numbers[4] == 0 && (numbers[5] == 0 || numbers[5] == 0xFFFF))                  {                      return true;                  }                  // SIIT - 0:0 : 0:0 : FFFF:0 : x.x.x.x                  else if (numbers[4] == 0xFFFF && numbers[5] == 0)                  {                      return true;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,ShouldHaveIpv4Embedded,The following statement contains a magic number: if (numbers[0] == 0 && numbers[1] == 0 && numbers[2] == 0 && numbers[3] == 0 && numbers[6] != 0)              {                  // RFC 5952 Section 5 - 0:0 : 0:0 : 0:[0 | FFFF] : x.x.x.x                  if (numbers[4] == 0 && (numbers[5] == 0 || numbers[5] == 0xFFFF))                  {                      return true;                  }                  // SIIT - 0:0 : 0:0 : FFFF:0 : x.x.x.x                  else if (numbers[4] == 0xFFFF && numbers[5] == 0)                  {                      return true;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,ShouldHaveIpv4Embedded,The following statement contains a magic number: if (numbers[0] == 0 && numbers[1] == 0 && numbers[2] == 0 && numbers[3] == 0 && numbers[6] != 0)              {                  // RFC 5952 Section 5 - 0:0 : 0:0 : 0:[0 | FFFF] : x.x.x.x                  if (numbers[4] == 0 && (numbers[5] == 0 || numbers[5] == 0xFFFF))                  {                      return true;                  }                  // SIIT - 0:0 : 0:0 : FFFF:0 : x.x.x.x                  else if (numbers[4] == 0xFFFF && numbers[5] == 0)                  {                      return true;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,ShouldHaveIpv4Embedded,The following statement contains a magic number: if (numbers[0] == 0 && numbers[1] == 0 && numbers[2] == 0 && numbers[3] == 0 && numbers[6] != 0)              {                  // RFC 5952 Section 5 - 0:0 : 0:0 : 0:[0 | FFFF] : x.x.x.x                  if (numbers[4] == 0 && (numbers[5] == 0 || numbers[5] == 0xFFFF))                  {                      return true;                  }                  // SIIT - 0:0 : 0:0 : FFFF:0 : x.x.x.x                  else if (numbers[4] == 0xFFFF && numbers[5] == 0)                  {                      return true;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,ShouldHaveIpv4Embedded,The following statement contains a magic number: if (numbers[0] == 0 && numbers[1] == 0 && numbers[2] == 0 && numbers[3] == 0 && numbers[6] != 0)              {                  // RFC 5952 Section 5 - 0:0 : 0:0 : 0:[0 | FFFF] : x.x.x.x                  if (numbers[4] == 0 && (numbers[5] == 0 || numbers[5] == 0xFFFF))                  {                      return true;                  }                  // SIIT - 0:0 : 0:0 : FFFF:0 : x.x.x.x                  else if (numbers[4] == 0xFFFF && numbers[5] == 0)                  {                      return true;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,ShouldHaveIpv4Embedded,The following statement contains a magic number: if (numbers[0] == 0 && numbers[1] == 0 && numbers[2] == 0 && numbers[3] == 0 && numbers[6] != 0)              {                  // RFC 5952 Section 5 - 0:0 : 0:0 : 0:[0 | FFFF] : x.x.x.x                  if (numbers[4] == 0 && (numbers[5] == 0 || numbers[5] == 0xFFFF))                  {                      return true;                  }                  // SIIT - 0:0 : 0:0 : FFFF:0 : x.x.x.x                  else if (numbers[4] == 0xFFFF && numbers[5] == 0)                  {                      return true;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,ShouldHaveIpv4Embedded,The following statement contains a magic number: if (numbers[4] == 0 && numbers[5] == 0x5EFE)              {                  return true;              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,ShouldHaveIpv4Embedded,The following statement contains a magic number: if (numbers[4] == 0 && numbers[5] == 0x5EFE)              {                  return true;              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,InternalIsValid,The following statement contains a magic number: for (i = start; i < end; ++i)              {                  if (havePrefix ? (name[i] >= '0' && name[i] <= '9') : Uri.IsHexDigit(name[i]))                  {                      ++sequenceLength;                      expectingNumber = false;                  }                  else                  {                      if (sequenceLength > 4)                      {                          return false;                      }                      if (sequenceLength != 0)                      {                          ++sequenceCount;                          lastSequence = i - sequenceLength;                      }                      switch (name[i])                      {                          case '%':                              while (true)                              {                                  //accept anything in scopeID                                  if (++i == end)                                  {                                      // no closing ']'' fail                                      return false;                                  }                                  if (name[i] == ']')                                  {                                      goto case ']';                                  }                                  else if (name[i] == '/')                                  {                                      goto case '/';                                  }                              }                          case ']':                              start = i;                              i = end;                              //this will make i = end+1                              continue;                          case ':':                              if ((i > 0) && (name[i - 1] == ':'))                              {                                  if (haveCompressor)                                  {                                      //                                      // can only have one per IPv6 address                                      //                                        return false;                                  }                                  haveCompressor = true;                                  expectingNumber = false;                              }                              else                              {                                  expectingNumber = true;                              }                              break;                            case '/':                              if (validateStrictAddress)                              {                                  return false;                              }                              if ((sequenceCount == 0) || havePrefix)                              {                                  return false;                              }                              havePrefix = true;                              expectingNumber = true;                              break;                            case '.':                              if (haveIPv4Address)                              {                                  return false;                              }                                i = end;                              if (!IPv4AddressHelper.IsValid(name' lastSequence' ref i' true' false' false))                              {                                  return false;                              }                              // ipv4 address takes 2 slots in ipv6 address' one was just counted meeting the '.'                              ++sequenceCount;                              haveIPv4Address = true;                              --i;            // it will be incremented back on the next loop                              break;                            default:                              return false;                      }                      sequenceLength = 0;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,InternalIsValid,The following statement contains a magic number: if (havePrefix && ((sequenceLength < 1) || (sequenceLength > 2)))              {                  return false;              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,InternalIsValid,The following statement contains a magic number: int expectedSequenceCount = 8 + (havePrefix ? 1 : 0);
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,InternalIsValid,The following statement contains a magic number: if (!expectingNumber && (sequenceLength <= 4) && (haveCompressor ? (sequenceCount < expectedSequenceCount) : (sequenceCount == expectedSequenceCount)))              {                  if (i == end + 1)                  {                      // ']' was found                      end = start + 1;                      return true;                  }                  return false;              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,Parse,The following statement contains a magic number: for (int i = start; i < address.Length && address[i] != ']';)              {                  switch (address[i])                  {                      case '%':                          if (numberIsValid)                          {                              numbers[index++] = (ushort)number;                              numberIsValid = false;                          }                            start = i;                          for (++i; address[i] != ']' && address[i] != '/'; ++i)                          {                              ;                          }                          scopeId = address.Substring(start' i - start);                          // ignore prefix if any                          for (; address[i] != ']'; ++i)                          {                              ;                          }                          break;                        case ':':                          numbers[index++] = (ushort)number;                          number = 0;                          ++i;                          if (address[i] == ':')                          {                              compressorIndex = index;                              ++i;                          }                          else if ((compressorIndex < 0) && (index < 6))                          {                              //                              // no point checking for IPv4 address if we don't                              // have a compressor or we haven't seen 6 16-bit                              // numbers yet                              //                                break;                          }                            //                          // check to see if the upcoming number is really an IPv4                          // address. If it is' convert it to 2 ushort numbers                          //                            for (int j = i; (address[j] != ']') &&                                          (address[j] != ':') &&                                          (address[j] != '%') &&                                          (address[j] != '/') &&                                          (j < i + 4); ++j)                          {                              if (address[j] == '.')                              {                                  //                                  // we have an IPv4 address. Find the end of it:                                  // we know that since we have a valid IPv6                                  // address' the only things that will terminate                                  // the IPv4 address are the prefix delimiter '/'                                  // or the end-of-string (which we conveniently                                  // delimited with ']')                                  //                                    while ((address[j] != ']') && (address[j] != '/') && (address[j] != '%'))                                  {                                      ++j;                                  }                                  number = IPv4AddressHelper.ParseHostNumber(address' i' j);                                  unchecked                                  {                                      numbers[index++] = (ushort)(number >> 16);                                      numbers[index++] = (ushort)number;                                  }                                  i = j;                                    //                                  // set this to avoid adding another number to                                  // the array if there's a prefix                                  //                                    number = 0;                                  numberIsValid = false;                                  break;                              }                          }                          break;                        case '/':                          if (numberIsValid)                          {                              numbers[index++] = (ushort)number;                              numberIsValid = false;                          }                            //                          // since we have a valid IPv6 address string' the prefix                          // length is the last token in the string                          //                            for (++i; address[i] != ']'; ++i)                          {                              PrefixLength = PrefixLength * 10 + (address[i] - '0');                          }                          break;                        default:                          number = number * 16 + Uri.FromHex(address[i++]);                          break;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,Parse,The following statement contains a magic number: for (int i = start; i < address.Length && address[i] != ']';)              {                  switch (address[i])                  {                      case '%':                          if (numberIsValid)                          {                              numbers[index++] = (ushort)number;                              numberIsValid = false;                          }                            start = i;                          for (++i; address[i] != ']' && address[i] != '/'; ++i)                          {                              ;                          }                          scopeId = address.Substring(start' i - start);                          // ignore prefix if any                          for (; address[i] != ']'; ++i)                          {                              ;                          }                          break;                        case ':':                          numbers[index++] = (ushort)number;                          number = 0;                          ++i;                          if (address[i] == ':')                          {                              compressorIndex = index;                              ++i;                          }                          else if ((compressorIndex < 0) && (index < 6))                          {                              //                              // no point checking for IPv4 address if we don't                              // have a compressor or we haven't seen 6 16-bit                              // numbers yet                              //                                break;                          }                            //                          // check to see if the upcoming number is really an IPv4                          // address. If it is' convert it to 2 ushort numbers                          //                            for (int j = i; (address[j] != ']') &&                                          (address[j] != ':') &&                                          (address[j] != '%') &&                                          (address[j] != '/') &&                                          (j < i + 4); ++j)                          {                              if (address[j] == '.')                              {                                  //                                  // we have an IPv4 address. Find the end of it:                                  // we know that since we have a valid IPv6                                  // address' the only things that will terminate                                  // the IPv4 address are the prefix delimiter '/'                                  // or the end-of-string (which we conveniently                                  // delimited with ']')                                  //                                    while ((address[j] != ']') && (address[j] != '/') && (address[j] != '%'))                                  {                                      ++j;                                  }                                  number = IPv4AddressHelper.ParseHostNumber(address' i' j);                                  unchecked                                  {                                      numbers[index++] = (ushort)(number >> 16);                                      numbers[index++] = (ushort)number;                                  }                                  i = j;                                    //                                  // set this to avoid adding another number to                                  // the array if there's a prefix                                  //                                    number = 0;                                  numberIsValid = false;                                  break;                              }                          }                          break;                        case '/':                          if (numberIsValid)                          {                              numbers[index++] = (ushort)number;                              numberIsValid = false;                          }                            //                          // since we have a valid IPv6 address string' the prefix                          // length is the last token in the string                          //                            for (++i; address[i] != ']'; ++i)                          {                              PrefixLength = PrefixLength * 10 + (address[i] - '0');                          }                          break;                        default:                          number = number * 16 + Uri.FromHex(address[i++]);                          break;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,Parse,The following statement contains a magic number: for (int i = start; i < address.Length && address[i] != ']';)              {                  switch (address[i])                  {                      case '%':                          if (numberIsValid)                          {                              numbers[index++] = (ushort)number;                              numberIsValid = false;                          }                            start = i;                          for (++i; address[i] != ']' && address[i] != '/'; ++i)                          {                              ;                          }                          scopeId = address.Substring(start' i - start);                          // ignore prefix if any                          for (; address[i] != ']'; ++i)                          {                              ;                          }                          break;                        case ':':                          numbers[index++] = (ushort)number;                          number = 0;                          ++i;                          if (address[i] == ':')                          {                              compressorIndex = index;                              ++i;                          }                          else if ((compressorIndex < 0) && (index < 6))                          {                              //                              // no point checking for IPv4 address if we don't                              // have a compressor or we haven't seen 6 16-bit                              // numbers yet                              //                                break;                          }                            //                          // check to see if the upcoming number is really an IPv4                          // address. If it is' convert it to 2 ushort numbers                          //                            for (int j = i; (address[j] != ']') &&                                          (address[j] != ':') &&                                          (address[j] != '%') &&                                          (address[j] != '/') &&                                          (j < i + 4); ++j)                          {                              if (address[j] == '.')                              {                                  //                                  // we have an IPv4 address. Find the end of it:                                  // we know that since we have a valid IPv6                                  // address' the only things that will terminate                                  // the IPv4 address are the prefix delimiter '/'                                  // or the end-of-string (which we conveniently                                  // delimited with ']')                                  //                                    while ((address[j] != ']') && (address[j] != '/') && (address[j] != '%'))                                  {                                      ++j;                                  }                                  number = IPv4AddressHelper.ParseHostNumber(address' i' j);                                  unchecked                                  {                                      numbers[index++] = (ushort)(number >> 16);                                      numbers[index++] = (ushort)number;                                  }                                  i = j;                                    //                                  // set this to avoid adding another number to                                  // the array if there's a prefix                                  //                                    number = 0;                                  numberIsValid = false;                                  break;                              }                          }                          break;                        case '/':                          if (numberIsValid)                          {                              numbers[index++] = (ushort)number;                              numberIsValid = false;                          }                            //                          // since we have a valid IPv6 address string' the prefix                          // length is the last token in the string                          //                            for (++i; address[i] != ']'; ++i)                          {                              PrefixLength = PrefixLength * 10 + (address[i] - '0');                          }                          break;                        default:                          number = number * 16 + Uri.FromHex(address[i++]);                          break;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,Parse,The following statement contains a magic number: for (int i = start; i < address.Length && address[i] != ']';)              {                  switch (address[i])                  {                      case '%':                          if (numberIsValid)                          {                              numbers[index++] = (ushort)number;                              numberIsValid = false;                          }                            start = i;                          for (++i; address[i] != ']' && address[i] != '/'; ++i)                          {                              ;                          }                          scopeId = address.Substring(start' i - start);                          // ignore prefix if any                          for (; address[i] != ']'; ++i)                          {                              ;                          }                          break;                        case ':':                          numbers[index++] = (ushort)number;                          number = 0;                          ++i;                          if (address[i] == ':')                          {                              compressorIndex = index;                              ++i;                          }                          else if ((compressorIndex < 0) && (index < 6))                          {                              //                              // no point checking for IPv4 address if we don't                              // have a compressor or we haven't seen 6 16-bit                              // numbers yet                              //                                break;                          }                            //                          // check to see if the upcoming number is really an IPv4                          // address. If it is' convert it to 2 ushort numbers                          //                            for (int j = i; (address[j] != ']') &&                                          (address[j] != ':') &&                                          (address[j] != '%') &&                                          (address[j] != '/') &&                                          (j < i + 4); ++j)                          {                              if (address[j] == '.')                              {                                  //                                  // we have an IPv4 address. Find the end of it:                                  // we know that since we have a valid IPv6                                  // address' the only things that will terminate                                  // the IPv4 address are the prefix delimiter '/'                                  // or the end-of-string (which we conveniently                                  // delimited with ']')                                  //                                    while ((address[j] != ']') && (address[j] != '/') && (address[j] != '%'))                                  {                                      ++j;                                  }                                  number = IPv4AddressHelper.ParseHostNumber(address' i' j);                                  unchecked                                  {                                      numbers[index++] = (ushort)(number >> 16);                                      numbers[index++] = (ushort)number;                                  }                                  i = j;                                    //                                  // set this to avoid adding another number to                                  // the array if there's a prefix                                  //                                    number = 0;                                  numberIsValid = false;                                  break;                              }                          }                          break;                        case '/':                          if (numberIsValid)                          {                              numbers[index++] = (ushort)number;                              numberIsValid = false;                          }                            //                          // since we have a valid IPv6 address string' the prefix                          // length is the last token in the string                          //                            for (++i; address[i] != ']'; ++i)                          {                              PrefixLength = PrefixLength * 10 + (address[i] - '0');                          }                          break;                        default:                          number = number * 16 + Uri.FromHex(address[i++]);                          break;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,Parse,The following statement contains a magic number: for (int i = start; i < address.Length && address[i] != ']';)              {                  switch (address[i])                  {                      case '%':                          if (numberIsValid)                          {                              numbers[index++] = (ushort)number;                              numberIsValid = false;                          }                            start = i;                          for (++i; address[i] != ']' && address[i] != '/'; ++i)                          {                              ;                          }                          scopeId = address.Substring(start' i - start);                          // ignore prefix if any                          for (; address[i] != ']'; ++i)                          {                              ;                          }                          break;                        case ':':                          numbers[index++] = (ushort)number;                          number = 0;                          ++i;                          if (address[i] == ':')                          {                              compressorIndex = index;                              ++i;                          }                          else if ((compressorIndex < 0) && (index < 6))                          {                              //                              // no point checking for IPv4 address if we don't                              // have a compressor or we haven't seen 6 16-bit                              // numbers yet                              //                                break;                          }                            //                          // check to see if the upcoming number is really an IPv4                          // address. If it is' convert it to 2 ushort numbers                          //                            for (int j = i; (address[j] != ']') &&                                          (address[j] != ':') &&                                          (address[j] != '%') &&                                          (address[j] != '/') &&                                          (j < i + 4); ++j)                          {                              if (address[j] == '.')                              {                                  //                                  // we have an IPv4 address. Find the end of it:                                  // we know that since we have a valid IPv6                                  // address' the only things that will terminate                                  // the IPv4 address are the prefix delimiter '/'                                  // or the end-of-string (which we conveniently                                  // delimited with ']')                                  //                                    while ((address[j] != ']') && (address[j] != '/') && (address[j] != '%'))                                  {                                      ++j;                                  }                                  number = IPv4AddressHelper.ParseHostNumber(address' i' j);                                  unchecked                                  {                                      numbers[index++] = (ushort)(number >> 16);                                      numbers[index++] = (ushort)number;                                  }                                  i = j;                                    //                                  // set this to avoid adding another number to                                  // the array if there's a prefix                                  //                                    number = 0;                                  numberIsValid = false;                                  break;                              }                          }                          break;                        case '/':                          if (numberIsValid)                          {                              numbers[index++] = (ushort)number;                              numberIsValid = false;                          }                            //                          // since we have a valid IPv6 address string' the prefix                          // length is the last token in the string                          //                            for (++i; address[i] != ']'; ++i)                          {                              PrefixLength = PrefixLength * 10 + (address[i] - '0');                          }                          break;                        default:                          number = number * 16 + Uri.FromHex(address[i++]);                          break;                  }              }
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,Parse,The following statement contains a magic number: return ((numbers[0] == 0)                              && (numbers[1] == 0)                              && (numbers[2] == 0)                              && (numbers[3] == 0)                              && (numbers[4] == 0))                             && (((numbers[5] == 0)                                  && (numbers[6] == 0)                                  && (numbers[7] == 1))                                 || (((numbers[6] == 0x7F00)                                      && (numbers[7] == 0x0001))                                     && ((numbers[5] == 0)                                         || (numbers[5] == 0xFFFF))));
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,Parse,The following statement contains a magic number: return ((numbers[0] == 0)                              && (numbers[1] == 0)                              && (numbers[2] == 0)                              && (numbers[3] == 0)                              && (numbers[4] == 0))                             && (((numbers[5] == 0)                                  && (numbers[6] == 0)                                  && (numbers[7] == 1))                                 || (((numbers[6] == 0x7F00)                                      && (numbers[7] == 0x0001))                                     && ((numbers[5] == 0)                                         || (numbers[5] == 0xFFFF))));
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,Parse,The following statement contains a magic number: return ((numbers[0] == 0)                              && (numbers[1] == 0)                              && (numbers[2] == 0)                              && (numbers[3] == 0)                              && (numbers[4] == 0))                             && (((numbers[5] == 0)                                  && (numbers[6] == 0)                                  && (numbers[7] == 1))                                 || (((numbers[6] == 0x7F00)                                      && (numbers[7] == 0x0001))                                     && ((numbers[5] == 0)                                         || (numbers[5] == 0xFFFF))));
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,Parse,The following statement contains a magic number: return ((numbers[0] == 0)                              && (numbers[1] == 0)                              && (numbers[2] == 0)                              && (numbers[3] == 0)                              && (numbers[4] == 0))                             && (((numbers[5] == 0)                                  && (numbers[6] == 0)                                  && (numbers[7] == 1))                                 || (((numbers[6] == 0x7F00)                                      && (numbers[7] == 0x0001))                                     && ((numbers[5] == 0)                                         || (numbers[5] == 0xFFFF))));
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,Parse,The following statement contains a magic number: return ((numbers[0] == 0)                              && (numbers[1] == 0)                              && (numbers[2] == 0)                              && (numbers[3] == 0)                              && (numbers[4] == 0))                             && (((numbers[5] == 0)                                  && (numbers[6] == 0)                                  && (numbers[7] == 1))                                 || (((numbers[6] == 0x7F00)                                      && (numbers[7] == 0x0001))                                     && ((numbers[5] == 0)                                         || (numbers[5] == 0xFFFF))));
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,Parse,The following statement contains a magic number: return ((numbers[0] == 0)                              && (numbers[1] == 0)                              && (numbers[2] == 0)                              && (numbers[3] == 0)                              && (numbers[4] == 0))                             && (((numbers[5] == 0)                                  && (numbers[6] == 0)                                  && (numbers[7] == 1))                                 || (((numbers[6] == 0x7F00)                                      && (numbers[7] == 0x0001))                                     && ((numbers[5] == 0)                                         || (numbers[5] == 0xFFFF))));
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,Parse,The following statement contains a magic number: return ((numbers[0] == 0)                              && (numbers[1] == 0)                              && (numbers[2] == 0)                              && (numbers[3] == 0)                              && (numbers[4] == 0))                             && (((numbers[5] == 0)                                  && (numbers[6] == 0)                                  && (numbers[7] == 1))                                 || (((numbers[6] == 0x7F00)                                      && (numbers[7] == 0x0001))                                     && ((numbers[5] == 0)                                         || (numbers[5] == 0xFFFF))));
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,Parse,The following statement contains a magic number: return ((numbers[0] == 0)                              && (numbers[1] == 0)                              && (numbers[2] == 0)                              && (numbers[3] == 0)                              && (numbers[4] == 0))                             && (((numbers[5] == 0)                                  && (numbers[6] == 0)                                  && (numbers[7] == 1))                                 || (((numbers[6] == 0x7F00)                                      && (numbers[7] == 0x0001))                                     && ((numbers[5] == 0)                                         || (numbers[5] == 0xFFFF))));
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,Parse,The following statement contains a magic number: return ((numbers[0] == 0)                              && (numbers[1] == 0)                              && (numbers[2] == 0)                              && (numbers[3] == 0)                              && (numbers[4] == 0))                             && (((numbers[5] == 0)                                  && (numbers[6] == 0)                                  && (numbers[7] == 1))                                 || (((numbers[6] == 0x7F00)                                      && (numbers[7] == 0x0001))                                     && ((numbers[5] == 0)                                         || (numbers[5] == 0xFFFF))));
Magic Number,System,IPv6AddressHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IPv6AddressHelper.cs,Parse,The following statement contains a magic number: return ((numbers[0] == 0)                              && (numbers[1] == 0)                              && (numbers[2] == 0)                              && (numbers[3] == 0)                              && (numbers[4] == 0))                             && (((numbers[5] == 0)                                  && (numbers[6] == 0)                                  && (numbers[7] == 1))                                 || (((numbers[6] == 0x7F00)                                      && (numbers[7] == 0x0001))                                     && ((numbers[5] == 0)                                         || (numbers[5] == 0xFFFF))));
Magic Number,System,IriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IriHelper.cs,CheckIriUnicodeRange,The following statement contains a magic number: if (char.IsSurrogatePair(highSurr' lowSurr))              {                  surrogatePair = true;                  char[] chars = new char[2] { highSurr' lowSurr };                  string surrPair = new string(chars);                  if (((string.CompareOrdinal(surrPair' "\U00010000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U0001FFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U00020000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U0002FFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U00030000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U0003FFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U00040000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U0004FFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U00050000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U0005FFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U00060000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U0006FFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U00070000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U0007FFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U00080000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U0008FFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U00090000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U0009FFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U000A0000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U000AFFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U000B0000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U000BFFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U000C0000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U000CFFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U000D0000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U000DFFFD") <= 0)) ||                      ((string.CompareOrdinal(surrPair' "\U000E1000") >= 0)                          && (string.CompareOrdinal(surrPair' "\U000EFFFD") <= 0)) ||                      (isQuery &&                          (((string.CompareOrdinal(surrPair' "\U000F0000") >= 0)                              && (string.CompareOrdinal(surrPair' "\U000FFFFD") <= 0)) ||                              ((string.CompareOrdinal(surrPair' "\U00100000") >= 0)                              && (string.CompareOrdinal(surrPair' "\U0010FFFD") <= 0)))))                  {                      inRange = true;                  }              }
Magic Number,System,IriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IriHelper.cs,EscapeUnescapeIri,The following statement contains a magic number: const int percentEncodingLen = 3;
Magic Number,System,IriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IriHelper.cs,EscapeUnescapeIri,The following statement contains a magic number: const int bufferCapacityIncrease = 30 * percentEncodingLen;
Magic Number,System,IriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IriHelper.cs,EscapeUnescapeIri,The following statement contains a magic number: for (; next < end; ++next)              {                  escape = false;                  surrogatePair = false;                    if ((ch = pInput[next]) == '%')                  {                      if (next + 2 < end)                      {                          ch = UriHelper.EscapedAscii(pInput[next + 1]' pInput[next + 2]);                            // Do not unescape a reserved char                          if (ch == Uri.c_DummyChar || ch == '%' || CheckIsReserved(ch' component) || UriHelper.IsNotSafeForUnescape(ch))                          {                              // keep as is                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next];                              continue;                          }                          else if (ch <= '\x7F')                          {                              Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              //ASCII                              pDest[destOffset++] = ch;                              next += 2;                              continue;                          }                          else                          {                              // possibly utf8 encoded sequence of unicode                                // check if safe to unescape according to Iri rules                                Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                                int startSeq = next;                              int byteCount = 1;                              // lazy initialization of max size' will reuse the array for next sequences                              if ((object)bytes == null)                                  bytes = new byte[end - next];                                bytes[0] = (byte)ch;                              next += 3;                              while (next < end)                              {                                  // Check on exit criterion                                  if ((ch = pInput[next]) != '%' || next + 2 >= end)                                      break;                                    // already made sure we have 3 characters in str                                  ch = UriHelper.EscapedAscii(pInput[next + 1]' pInput[next + 2]);                                    //invalid hex sequence ?                                  if (ch == Uri.c_DummyChar)                                      break;                                  // character is not part of a UTF-8 sequence ?                                  else if (ch < '\x80')                                      break;                                  else                                  {                                      //a UTF-8 sequence                                      bytes[byteCount++] = (byte)ch;                                      next += 3;                                  }                                    Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                              }                              next--; // for loop will increment                                  // Using encoder with no replacement fall-back will skip all invalid UTF-8 sequences.                              Encoding noFallbackCharUTF8 = Encoding.GetEncoding(                                                                                  Encoding.UTF8.CodePage'                                                                                  new EncoderReplacementFallback("")'                                                                                  new DecoderReplacementFallback(""));                                char[] unescapedChars = new char[bytes.Length];                              int charCount = noFallbackCharUTF8.GetChars(bytes' 0' byteCount' unescapedChars' 0);                                  if (charCount != 0)                              {                                  // If invalid sequences were present in the original escaped string' we need to                                   // copy the escaped versions of those sequences.                                  // Decoded Unicode values will be kept only when they are allowed by the URI/IRI RFC                                  // rules.                                  UriHelper.MatchUTF8Sequence(pDest' dest' ref destOffset' unescapedChars' charCount' bytes'                                      byteCount' component == UriComponents.Query' true);                              }                              else                              {                                  // copy escaped sequence as is                                  for (int i = startSeq; i <= next; ++i)                                  {                                      Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                      pDest[destOffset++] = pInput[i];                                  }                              }                          }                      }                      else                      {                          Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                          pDest[destOffset++] = pInput[next];                      }                  }                  else if (ch > '\x7f')                  {                      // unicode                        char ch2;                        if ((char.IsHighSurrogate(ch)) && (next + 1 < end))                      {                          ch2 = pInput[next + 1];                          escape = !CheckIriUnicodeRange(ch' ch2' ref surrogatePair' component == UriComponents.Query);                          if (!escape)                          {                              // copy the two chars                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next];                          }                      }                      else                      {                          if (CheckIriUnicodeRange(ch' component == UriComponents.Query))                          {                              if (!UriHelper.IsBidiControlCharacter(ch))                              {                                  // copy it                                  Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                  pDest[destOffset++] = pInput[next];                              }                          }                          else                          {                              // escape it                              escape = true;                          }                      }                  }                  else                  {                      // just copy the character                      Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                      pDest[destOffset++] = pInput[next];                  }                    if (escape)                  {                      const int MaxNumberOfBytesEncoded = 4;                        if (bufferRemaining < MaxNumberOfBytesEncoded * percentEncodingLen)                      {                          int newBufferLength = 0;                            checked                          {                              // may need more memory since we didn't anticipate escaping                              newBufferLength = dest.Length + bufferCapacityIncrease;                              bufferRemaining += bufferCapacityIncrease;                          }                            char[] newDest = new char[newBufferLength];                            fixed (char* pNewDest = newDest)                          {                              Buffer.MemoryCopy((byte*)pDest' (byte*)pNewDest' newBufferLength * sizeof(char)' destOffset * sizeof(char));                          }                            if (destHandle.IsAllocated)                          {                              destHandle.Free();                          }                            dest = newDest;                            // re-pin new dest[] array                          destHandle = GCHandle.Alloc(dest' GCHandleType.Pinned);                          pDest = (char*)destHandle.AddrOfPinnedObject();                      }                        byte[] encodedBytes = new byte[MaxNumberOfBytesEncoded];                      fixed (byte* pEncodedBytes = &encodedBytes[0])                      {                          int encodedBytesCount = Encoding.UTF8.GetBytes(pInput + next' surrogatePair ? 2 : 1' pEncodedBytes' MaxNumberOfBytesEncoded);                          Debug.Assert(encodedBytesCount <= MaxNumberOfBytesEncoded' "UTF8 encoder should not exceed specified byteCount");                            bufferRemaining -= encodedBytesCount * percentEncodingLen;                            for (int count = 0; count < encodedBytesCount; ++count)                          {                              UriHelper.EscapeAsciiChar((char)encodedBytes[count]' dest' ref destOffset);                          }                      }                  }              }
Magic Number,System,IriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IriHelper.cs,EscapeUnescapeIri,The following statement contains a magic number: for (; next < end; ++next)              {                  escape = false;                  surrogatePair = false;                    if ((ch = pInput[next]) == '%')                  {                      if (next + 2 < end)                      {                          ch = UriHelper.EscapedAscii(pInput[next + 1]' pInput[next + 2]);                            // Do not unescape a reserved char                          if (ch == Uri.c_DummyChar || ch == '%' || CheckIsReserved(ch' component) || UriHelper.IsNotSafeForUnescape(ch))                          {                              // keep as is                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next];                              continue;                          }                          else if (ch <= '\x7F')                          {                              Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              //ASCII                              pDest[destOffset++] = ch;                              next += 2;                              continue;                          }                          else                          {                              // possibly utf8 encoded sequence of unicode                                // check if safe to unescape according to Iri rules                                Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                                int startSeq = next;                              int byteCount = 1;                              // lazy initialization of max size' will reuse the array for next sequences                              if ((object)bytes == null)                                  bytes = new byte[end - next];                                bytes[0] = (byte)ch;                              next += 3;                              while (next < end)                              {                                  // Check on exit criterion                                  if ((ch = pInput[next]) != '%' || next + 2 >= end)                                      break;                                    // already made sure we have 3 characters in str                                  ch = UriHelper.EscapedAscii(pInput[next + 1]' pInput[next + 2]);                                    //invalid hex sequence ?                                  if (ch == Uri.c_DummyChar)                                      break;                                  // character is not part of a UTF-8 sequence ?                                  else if (ch < '\x80')                                      break;                                  else                                  {                                      //a UTF-8 sequence                                      bytes[byteCount++] = (byte)ch;                                      next += 3;                                  }                                    Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                              }                              next--; // for loop will increment                                  // Using encoder with no replacement fall-back will skip all invalid UTF-8 sequences.                              Encoding noFallbackCharUTF8 = Encoding.GetEncoding(                                                                                  Encoding.UTF8.CodePage'                                                                                  new EncoderReplacementFallback("")'                                                                                  new DecoderReplacementFallback(""));                                char[] unescapedChars = new char[bytes.Length];                              int charCount = noFallbackCharUTF8.GetChars(bytes' 0' byteCount' unescapedChars' 0);                                  if (charCount != 0)                              {                                  // If invalid sequences were present in the original escaped string' we need to                                   // copy the escaped versions of those sequences.                                  // Decoded Unicode values will be kept only when they are allowed by the URI/IRI RFC                                  // rules.                                  UriHelper.MatchUTF8Sequence(pDest' dest' ref destOffset' unescapedChars' charCount' bytes'                                      byteCount' component == UriComponents.Query' true);                              }                              else                              {                                  // copy escaped sequence as is                                  for (int i = startSeq; i <= next; ++i)                                  {                                      Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                      pDest[destOffset++] = pInput[i];                                  }                              }                          }                      }                      else                      {                          Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                          pDest[destOffset++] = pInput[next];                      }                  }                  else if (ch > '\x7f')                  {                      // unicode                        char ch2;                        if ((char.IsHighSurrogate(ch)) && (next + 1 < end))                      {                          ch2 = pInput[next + 1];                          escape = !CheckIriUnicodeRange(ch' ch2' ref surrogatePair' component == UriComponents.Query);                          if (!escape)                          {                              // copy the two chars                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next];                          }                      }                      else                      {                          if (CheckIriUnicodeRange(ch' component == UriComponents.Query))                          {                              if (!UriHelper.IsBidiControlCharacter(ch))                              {                                  // copy it                                  Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                  pDest[destOffset++] = pInput[next];                              }                          }                          else                          {                              // escape it                              escape = true;                          }                      }                  }                  else                  {                      // just copy the character                      Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                      pDest[destOffset++] = pInput[next];                  }                    if (escape)                  {                      const int MaxNumberOfBytesEncoded = 4;                        if (bufferRemaining < MaxNumberOfBytesEncoded * percentEncodingLen)                      {                          int newBufferLength = 0;                            checked                          {                              // may need more memory since we didn't anticipate escaping                              newBufferLength = dest.Length + bufferCapacityIncrease;                              bufferRemaining += bufferCapacityIncrease;                          }                            char[] newDest = new char[newBufferLength];                            fixed (char* pNewDest = newDest)                          {                              Buffer.MemoryCopy((byte*)pDest' (byte*)pNewDest' newBufferLength * sizeof(char)' destOffset * sizeof(char));                          }                            if (destHandle.IsAllocated)                          {                              destHandle.Free();                          }                            dest = newDest;                            // re-pin new dest[] array                          destHandle = GCHandle.Alloc(dest' GCHandleType.Pinned);                          pDest = (char*)destHandle.AddrOfPinnedObject();                      }                        byte[] encodedBytes = new byte[MaxNumberOfBytesEncoded];                      fixed (byte* pEncodedBytes = &encodedBytes[0])                      {                          int encodedBytesCount = Encoding.UTF8.GetBytes(pInput + next' surrogatePair ? 2 : 1' pEncodedBytes' MaxNumberOfBytesEncoded);                          Debug.Assert(encodedBytesCount <= MaxNumberOfBytesEncoded' "UTF8 encoder should not exceed specified byteCount");                            bufferRemaining -= encodedBytesCount * percentEncodingLen;                            for (int count = 0; count < encodedBytesCount; ++count)                          {                              UriHelper.EscapeAsciiChar((char)encodedBytes[count]' dest' ref destOffset);                          }                      }                  }              }
Magic Number,System,IriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IriHelper.cs,EscapeUnescapeIri,The following statement contains a magic number: for (; next < end; ++next)              {                  escape = false;                  surrogatePair = false;                    if ((ch = pInput[next]) == '%')                  {                      if (next + 2 < end)                      {                          ch = UriHelper.EscapedAscii(pInput[next + 1]' pInput[next + 2]);                            // Do not unescape a reserved char                          if (ch == Uri.c_DummyChar || ch == '%' || CheckIsReserved(ch' component) || UriHelper.IsNotSafeForUnescape(ch))                          {                              // keep as is                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next];                              continue;                          }                          else if (ch <= '\x7F')                          {                              Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              //ASCII                              pDest[destOffset++] = ch;                              next += 2;                              continue;                          }                          else                          {                              // possibly utf8 encoded sequence of unicode                                // check if safe to unescape according to Iri rules                                Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                                int startSeq = next;                              int byteCount = 1;                              // lazy initialization of max size' will reuse the array for next sequences                              if ((object)bytes == null)                                  bytes = new byte[end - next];                                bytes[0] = (byte)ch;                              next += 3;                              while (next < end)                              {                                  // Check on exit criterion                                  if ((ch = pInput[next]) != '%' || next + 2 >= end)                                      break;                                    // already made sure we have 3 characters in str                                  ch = UriHelper.EscapedAscii(pInput[next + 1]' pInput[next + 2]);                                    //invalid hex sequence ?                                  if (ch == Uri.c_DummyChar)                                      break;                                  // character is not part of a UTF-8 sequence ?                                  else if (ch < '\x80')                                      break;                                  else                                  {                                      //a UTF-8 sequence                                      bytes[byteCount++] = (byte)ch;                                      next += 3;                                  }                                    Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                              }                              next--; // for loop will increment                                  // Using encoder with no replacement fall-back will skip all invalid UTF-8 sequences.                              Encoding noFallbackCharUTF8 = Encoding.GetEncoding(                                                                                  Encoding.UTF8.CodePage'                                                                                  new EncoderReplacementFallback("")'                                                                                  new DecoderReplacementFallback(""));                                char[] unescapedChars = new char[bytes.Length];                              int charCount = noFallbackCharUTF8.GetChars(bytes' 0' byteCount' unescapedChars' 0);                                  if (charCount != 0)                              {                                  // If invalid sequences were present in the original escaped string' we need to                                   // copy the escaped versions of those sequences.                                  // Decoded Unicode values will be kept only when they are allowed by the URI/IRI RFC                                  // rules.                                  UriHelper.MatchUTF8Sequence(pDest' dest' ref destOffset' unescapedChars' charCount' bytes'                                      byteCount' component == UriComponents.Query' true);                              }                              else                              {                                  // copy escaped sequence as is                                  for (int i = startSeq; i <= next; ++i)                                  {                                      Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                      pDest[destOffset++] = pInput[i];                                  }                              }                          }                      }                      else                      {                          Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                          pDest[destOffset++] = pInput[next];                      }                  }                  else if (ch > '\x7f')                  {                      // unicode                        char ch2;                        if ((char.IsHighSurrogate(ch)) && (next + 1 < end))                      {                          ch2 = pInput[next + 1];                          escape = !CheckIriUnicodeRange(ch' ch2' ref surrogatePair' component == UriComponents.Query);                          if (!escape)                          {                              // copy the two chars                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next];                          }                      }                      else                      {                          if (CheckIriUnicodeRange(ch' component == UriComponents.Query))                          {                              if (!UriHelper.IsBidiControlCharacter(ch))                              {                                  // copy it                                  Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                  pDest[destOffset++] = pInput[next];                              }                          }                          else                          {                              // escape it                              escape = true;                          }                      }                  }                  else                  {                      // just copy the character                      Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                      pDest[destOffset++] = pInput[next];                  }                    if (escape)                  {                      const int MaxNumberOfBytesEncoded = 4;                        if (bufferRemaining < MaxNumberOfBytesEncoded * percentEncodingLen)                      {                          int newBufferLength = 0;                            checked                          {                              // may need more memory since we didn't anticipate escaping                              newBufferLength = dest.Length + bufferCapacityIncrease;                              bufferRemaining += bufferCapacityIncrease;                          }                            char[] newDest = new char[newBufferLength];                            fixed (char* pNewDest = newDest)                          {                              Buffer.MemoryCopy((byte*)pDest' (byte*)pNewDest' newBufferLength * sizeof(char)' destOffset * sizeof(char));                          }                            if (destHandle.IsAllocated)                          {                              destHandle.Free();                          }                            dest = newDest;                            // re-pin new dest[] array                          destHandle = GCHandle.Alloc(dest' GCHandleType.Pinned);                          pDest = (char*)destHandle.AddrOfPinnedObject();                      }                        byte[] encodedBytes = new byte[MaxNumberOfBytesEncoded];                      fixed (byte* pEncodedBytes = &encodedBytes[0])                      {                          int encodedBytesCount = Encoding.UTF8.GetBytes(pInput + next' surrogatePair ? 2 : 1' pEncodedBytes' MaxNumberOfBytesEncoded);                          Debug.Assert(encodedBytesCount <= MaxNumberOfBytesEncoded' "UTF8 encoder should not exceed specified byteCount");                            bufferRemaining -= encodedBytesCount * percentEncodingLen;                            for (int count = 0; count < encodedBytesCount; ++count)                          {                              UriHelper.EscapeAsciiChar((char)encodedBytes[count]' dest' ref destOffset);                          }                      }                  }              }
Magic Number,System,IriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IriHelper.cs,EscapeUnescapeIri,The following statement contains a magic number: for (; next < end; ++next)              {                  escape = false;                  surrogatePair = false;                    if ((ch = pInput[next]) == '%')                  {                      if (next + 2 < end)                      {                          ch = UriHelper.EscapedAscii(pInput[next + 1]' pInput[next + 2]);                            // Do not unescape a reserved char                          if (ch == Uri.c_DummyChar || ch == '%' || CheckIsReserved(ch' component) || UriHelper.IsNotSafeForUnescape(ch))                          {                              // keep as is                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next];                              continue;                          }                          else if (ch <= '\x7F')                          {                              Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              //ASCII                              pDest[destOffset++] = ch;                              next += 2;                              continue;                          }                          else                          {                              // possibly utf8 encoded sequence of unicode                                // check if safe to unescape according to Iri rules                                Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                                int startSeq = next;                              int byteCount = 1;                              // lazy initialization of max size' will reuse the array for next sequences                              if ((object)bytes == null)                                  bytes = new byte[end - next];                                bytes[0] = (byte)ch;                              next += 3;                              while (next < end)                              {                                  // Check on exit criterion                                  if ((ch = pInput[next]) != '%' || next + 2 >= end)                                      break;                                    // already made sure we have 3 characters in str                                  ch = UriHelper.EscapedAscii(pInput[next + 1]' pInput[next + 2]);                                    //invalid hex sequence ?                                  if (ch == Uri.c_DummyChar)                                      break;                                  // character is not part of a UTF-8 sequence ?                                  else if (ch < '\x80')                                      break;                                  else                                  {                                      //a UTF-8 sequence                                      bytes[byteCount++] = (byte)ch;                                      next += 3;                                  }                                    Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                              }                              next--; // for loop will increment                                  // Using encoder with no replacement fall-back will skip all invalid UTF-8 sequences.                              Encoding noFallbackCharUTF8 = Encoding.GetEncoding(                                                                                  Encoding.UTF8.CodePage'                                                                                  new EncoderReplacementFallback("")'                                                                                  new DecoderReplacementFallback(""));                                char[] unescapedChars = new char[bytes.Length];                              int charCount = noFallbackCharUTF8.GetChars(bytes' 0' byteCount' unescapedChars' 0);                                  if (charCount != 0)                              {                                  // If invalid sequences were present in the original escaped string' we need to                                   // copy the escaped versions of those sequences.                                  // Decoded Unicode values will be kept only when they are allowed by the URI/IRI RFC                                  // rules.                                  UriHelper.MatchUTF8Sequence(pDest' dest' ref destOffset' unescapedChars' charCount' bytes'                                      byteCount' component == UriComponents.Query' true);                              }                              else                              {                                  // copy escaped sequence as is                                  for (int i = startSeq; i <= next; ++i)                                  {                                      Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                      pDest[destOffset++] = pInput[i];                                  }                              }                          }                      }                      else                      {                          Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                          pDest[destOffset++] = pInput[next];                      }                  }                  else if (ch > '\x7f')                  {                      // unicode                        char ch2;                        if ((char.IsHighSurrogate(ch)) && (next + 1 < end))                      {                          ch2 = pInput[next + 1];                          escape = !CheckIriUnicodeRange(ch' ch2' ref surrogatePair' component == UriComponents.Query);                          if (!escape)                          {                              // copy the two chars                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next];                          }                      }                      else                      {                          if (CheckIriUnicodeRange(ch' component == UriComponents.Query))                          {                              if (!UriHelper.IsBidiControlCharacter(ch))                              {                                  // copy it                                  Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                  pDest[destOffset++] = pInput[next];                              }                          }                          else                          {                              // escape it                              escape = true;                          }                      }                  }                  else                  {                      // just copy the character                      Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                      pDest[destOffset++] = pInput[next];                  }                    if (escape)                  {                      const int MaxNumberOfBytesEncoded = 4;                        if (bufferRemaining < MaxNumberOfBytesEncoded * percentEncodingLen)                      {                          int newBufferLength = 0;                            checked                          {                              // may need more memory since we didn't anticipate escaping                              newBufferLength = dest.Length + bufferCapacityIncrease;                              bufferRemaining += bufferCapacityIncrease;                          }                            char[] newDest = new char[newBufferLength];                            fixed (char* pNewDest = newDest)                          {                              Buffer.MemoryCopy((byte*)pDest' (byte*)pNewDest' newBufferLength * sizeof(char)' destOffset * sizeof(char));                          }                            if (destHandle.IsAllocated)                          {                              destHandle.Free();                          }                            dest = newDest;                            // re-pin new dest[] array                          destHandle = GCHandle.Alloc(dest' GCHandleType.Pinned);                          pDest = (char*)destHandle.AddrOfPinnedObject();                      }                        byte[] encodedBytes = new byte[MaxNumberOfBytesEncoded];                      fixed (byte* pEncodedBytes = &encodedBytes[0])                      {                          int encodedBytesCount = Encoding.UTF8.GetBytes(pInput + next' surrogatePair ? 2 : 1' pEncodedBytes' MaxNumberOfBytesEncoded);                          Debug.Assert(encodedBytesCount <= MaxNumberOfBytesEncoded' "UTF8 encoder should not exceed specified byteCount");                            bufferRemaining -= encodedBytesCount * percentEncodingLen;                            for (int count = 0; count < encodedBytesCount; ++count)                          {                              UriHelper.EscapeAsciiChar((char)encodedBytes[count]' dest' ref destOffset);                          }                      }                  }              }
Magic Number,System,IriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IriHelper.cs,EscapeUnescapeIri,The following statement contains a magic number: for (; next < end; ++next)              {                  escape = false;                  surrogatePair = false;                    if ((ch = pInput[next]) == '%')                  {                      if (next + 2 < end)                      {                          ch = UriHelper.EscapedAscii(pInput[next + 1]' pInput[next + 2]);                            // Do not unescape a reserved char                          if (ch == Uri.c_DummyChar || ch == '%' || CheckIsReserved(ch' component) || UriHelper.IsNotSafeForUnescape(ch))                          {                              // keep as is                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next];                              continue;                          }                          else if (ch <= '\x7F')                          {                              Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              //ASCII                              pDest[destOffset++] = ch;                              next += 2;                              continue;                          }                          else                          {                              // possibly utf8 encoded sequence of unicode                                // check if safe to unescape according to Iri rules                                Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                                int startSeq = next;                              int byteCount = 1;                              // lazy initialization of max size' will reuse the array for next sequences                              if ((object)bytes == null)                                  bytes = new byte[end - next];                                bytes[0] = (byte)ch;                              next += 3;                              while (next < end)                              {                                  // Check on exit criterion                                  if ((ch = pInput[next]) != '%' || next + 2 >= end)                                      break;                                    // already made sure we have 3 characters in str                                  ch = UriHelper.EscapedAscii(pInput[next + 1]' pInput[next + 2]);                                    //invalid hex sequence ?                                  if (ch == Uri.c_DummyChar)                                      break;                                  // character is not part of a UTF-8 sequence ?                                  else if (ch < '\x80')                                      break;                                  else                                  {                                      //a UTF-8 sequence                                      bytes[byteCount++] = (byte)ch;                                      next += 3;                                  }                                    Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                              }                              next--; // for loop will increment                                  // Using encoder with no replacement fall-back will skip all invalid UTF-8 sequences.                              Encoding noFallbackCharUTF8 = Encoding.GetEncoding(                                                                                  Encoding.UTF8.CodePage'                                                                                  new EncoderReplacementFallback("")'                                                                                  new DecoderReplacementFallback(""));                                char[] unescapedChars = new char[bytes.Length];                              int charCount = noFallbackCharUTF8.GetChars(bytes' 0' byteCount' unescapedChars' 0);                                  if (charCount != 0)                              {                                  // If invalid sequences were present in the original escaped string' we need to                                   // copy the escaped versions of those sequences.                                  // Decoded Unicode values will be kept only when they are allowed by the URI/IRI RFC                                  // rules.                                  UriHelper.MatchUTF8Sequence(pDest' dest' ref destOffset' unescapedChars' charCount' bytes'                                      byteCount' component == UriComponents.Query' true);                              }                              else                              {                                  // copy escaped sequence as is                                  for (int i = startSeq; i <= next; ++i)                                  {                                      Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                      pDest[destOffset++] = pInput[i];                                  }                              }                          }                      }                      else                      {                          Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                          pDest[destOffset++] = pInput[next];                      }                  }                  else if (ch > '\x7f')                  {                      // unicode                        char ch2;                        if ((char.IsHighSurrogate(ch)) && (next + 1 < end))                      {                          ch2 = pInput[next + 1];                          escape = !CheckIriUnicodeRange(ch' ch2' ref surrogatePair' component == UriComponents.Query);                          if (!escape)                          {                              // copy the two chars                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next];                          }                      }                      else                      {                          if (CheckIriUnicodeRange(ch' component == UriComponents.Query))                          {                              if (!UriHelper.IsBidiControlCharacter(ch))                              {                                  // copy it                                  Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                  pDest[destOffset++] = pInput[next];                              }                          }                          else                          {                              // escape it                              escape = true;                          }                      }                  }                  else                  {                      // just copy the character                      Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                      pDest[destOffset++] = pInput[next];                  }                    if (escape)                  {                      const int MaxNumberOfBytesEncoded = 4;                        if (bufferRemaining < MaxNumberOfBytesEncoded * percentEncodingLen)                      {                          int newBufferLength = 0;                            checked                          {                              // may need more memory since we didn't anticipate escaping                              newBufferLength = dest.Length + bufferCapacityIncrease;                              bufferRemaining += bufferCapacityIncrease;                          }                            char[] newDest = new char[newBufferLength];                            fixed (char* pNewDest = newDest)                          {                              Buffer.MemoryCopy((byte*)pDest' (byte*)pNewDest' newBufferLength * sizeof(char)' destOffset * sizeof(char));                          }                            if (destHandle.IsAllocated)                          {                              destHandle.Free();                          }                            dest = newDest;                            // re-pin new dest[] array                          destHandle = GCHandle.Alloc(dest' GCHandleType.Pinned);                          pDest = (char*)destHandle.AddrOfPinnedObject();                      }                        byte[] encodedBytes = new byte[MaxNumberOfBytesEncoded];                      fixed (byte* pEncodedBytes = &encodedBytes[0])                      {                          int encodedBytesCount = Encoding.UTF8.GetBytes(pInput + next' surrogatePair ? 2 : 1' pEncodedBytes' MaxNumberOfBytesEncoded);                          Debug.Assert(encodedBytesCount <= MaxNumberOfBytesEncoded' "UTF8 encoder should not exceed specified byteCount");                            bufferRemaining -= encodedBytesCount * percentEncodingLen;                            for (int count = 0; count < encodedBytesCount; ++count)                          {                              UriHelper.EscapeAsciiChar((char)encodedBytes[count]' dest' ref destOffset);                          }                      }                  }              }
Magic Number,System,IriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IriHelper.cs,EscapeUnescapeIri,The following statement contains a magic number: for (; next < end; ++next)              {                  escape = false;                  surrogatePair = false;                    if ((ch = pInput[next]) == '%')                  {                      if (next + 2 < end)                      {                          ch = UriHelper.EscapedAscii(pInput[next + 1]' pInput[next + 2]);                            // Do not unescape a reserved char                          if (ch == Uri.c_DummyChar || ch == '%' || CheckIsReserved(ch' component) || UriHelper.IsNotSafeForUnescape(ch))                          {                              // keep as is                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next];                              continue;                          }                          else if (ch <= '\x7F')                          {                              Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              //ASCII                              pDest[destOffset++] = ch;                              next += 2;                              continue;                          }                          else                          {                              // possibly utf8 encoded sequence of unicode                                // check if safe to unescape according to Iri rules                                Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                                int startSeq = next;                              int byteCount = 1;                              // lazy initialization of max size' will reuse the array for next sequences                              if ((object)bytes == null)                                  bytes = new byte[end - next];                                bytes[0] = (byte)ch;                              next += 3;                              while (next < end)                              {                                  // Check on exit criterion                                  if ((ch = pInput[next]) != '%' || next + 2 >= end)                                      break;                                    // already made sure we have 3 characters in str                                  ch = UriHelper.EscapedAscii(pInput[next + 1]' pInput[next + 2]);                                    //invalid hex sequence ?                                  if (ch == Uri.c_DummyChar)                                      break;                                  // character is not part of a UTF-8 sequence ?                                  else if (ch < '\x80')                                      break;                                  else                                  {                                      //a UTF-8 sequence                                      bytes[byteCount++] = (byte)ch;                                      next += 3;                                  }                                    Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                              }                              next--; // for loop will increment                                  // Using encoder with no replacement fall-back will skip all invalid UTF-8 sequences.                              Encoding noFallbackCharUTF8 = Encoding.GetEncoding(                                                                                  Encoding.UTF8.CodePage'                                                                                  new EncoderReplacementFallback("")'                                                                                  new DecoderReplacementFallback(""));                                char[] unescapedChars = new char[bytes.Length];                              int charCount = noFallbackCharUTF8.GetChars(bytes' 0' byteCount' unescapedChars' 0);                                  if (charCount != 0)                              {                                  // If invalid sequences were present in the original escaped string' we need to                                   // copy the escaped versions of those sequences.                                  // Decoded Unicode values will be kept only when they are allowed by the URI/IRI RFC                                  // rules.                                  UriHelper.MatchUTF8Sequence(pDest' dest' ref destOffset' unescapedChars' charCount' bytes'                                      byteCount' component == UriComponents.Query' true);                              }                              else                              {                                  // copy escaped sequence as is                                  for (int i = startSeq; i <= next; ++i)                                  {                                      Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                      pDest[destOffset++] = pInput[i];                                  }                              }                          }                      }                      else                      {                          Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                          pDest[destOffset++] = pInput[next];                      }                  }                  else if (ch > '\x7f')                  {                      // unicode                        char ch2;                        if ((char.IsHighSurrogate(ch)) && (next + 1 < end))                      {                          ch2 = pInput[next + 1];                          escape = !CheckIriUnicodeRange(ch' ch2' ref surrogatePair' component == UriComponents.Query);                          if (!escape)                          {                              // copy the two chars                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next];                          }                      }                      else                      {                          if (CheckIriUnicodeRange(ch' component == UriComponents.Query))                          {                              if (!UriHelper.IsBidiControlCharacter(ch))                              {                                  // copy it                                  Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                  pDest[destOffset++] = pInput[next];                              }                          }                          else                          {                              // escape it                              escape = true;                          }                      }                  }                  else                  {                      // just copy the character                      Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                      pDest[destOffset++] = pInput[next];                  }                    if (escape)                  {                      const int MaxNumberOfBytesEncoded = 4;                        if (bufferRemaining < MaxNumberOfBytesEncoded * percentEncodingLen)                      {                          int newBufferLength = 0;                            checked                          {                              // may need more memory since we didn't anticipate escaping                              newBufferLength = dest.Length + bufferCapacityIncrease;                              bufferRemaining += bufferCapacityIncrease;                          }                            char[] newDest = new char[newBufferLength];                            fixed (char* pNewDest = newDest)                          {                              Buffer.MemoryCopy((byte*)pDest' (byte*)pNewDest' newBufferLength * sizeof(char)' destOffset * sizeof(char));                          }                            if (destHandle.IsAllocated)                          {                              destHandle.Free();                          }                            dest = newDest;                            // re-pin new dest[] array                          destHandle = GCHandle.Alloc(dest' GCHandleType.Pinned);                          pDest = (char*)destHandle.AddrOfPinnedObject();                      }                        byte[] encodedBytes = new byte[MaxNumberOfBytesEncoded];                      fixed (byte* pEncodedBytes = &encodedBytes[0])                      {                          int encodedBytesCount = Encoding.UTF8.GetBytes(pInput + next' surrogatePair ? 2 : 1' pEncodedBytes' MaxNumberOfBytesEncoded);                          Debug.Assert(encodedBytesCount <= MaxNumberOfBytesEncoded' "UTF8 encoder should not exceed specified byteCount");                            bufferRemaining -= encodedBytesCount * percentEncodingLen;                            for (int count = 0; count < encodedBytesCount; ++count)                          {                              UriHelper.EscapeAsciiChar((char)encodedBytes[count]' dest' ref destOffset);                          }                      }                  }              }
Magic Number,System,IriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IriHelper.cs,EscapeUnescapeIri,The following statement contains a magic number: for (; next < end; ++next)              {                  escape = false;                  surrogatePair = false;                    if ((ch = pInput[next]) == '%')                  {                      if (next + 2 < end)                      {                          ch = UriHelper.EscapedAscii(pInput[next + 1]' pInput[next + 2]);                            // Do not unescape a reserved char                          if (ch == Uri.c_DummyChar || ch == '%' || CheckIsReserved(ch' component) || UriHelper.IsNotSafeForUnescape(ch))                          {                              // keep as is                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next];                              continue;                          }                          else if (ch <= '\x7F')                          {                              Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              //ASCII                              pDest[destOffset++] = ch;                              next += 2;                              continue;                          }                          else                          {                              // possibly utf8 encoded sequence of unicode                                // check if safe to unescape according to Iri rules                                Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                                int startSeq = next;                              int byteCount = 1;                              // lazy initialization of max size' will reuse the array for next sequences                              if ((object)bytes == null)                                  bytes = new byte[end - next];                                bytes[0] = (byte)ch;                              next += 3;                              while (next < end)                              {                                  // Check on exit criterion                                  if ((ch = pInput[next]) != '%' || next + 2 >= end)                                      break;                                    // already made sure we have 3 characters in str                                  ch = UriHelper.EscapedAscii(pInput[next + 1]' pInput[next + 2]);                                    //invalid hex sequence ?                                  if (ch == Uri.c_DummyChar)                                      break;                                  // character is not part of a UTF-8 sequence ?                                  else if (ch < '\x80')                                      break;                                  else                                  {                                      //a UTF-8 sequence                                      bytes[byteCount++] = (byte)ch;                                      next += 3;                                  }                                    Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                              }                              next--; // for loop will increment                                  // Using encoder with no replacement fall-back will skip all invalid UTF-8 sequences.                              Encoding noFallbackCharUTF8 = Encoding.GetEncoding(                                                                                  Encoding.UTF8.CodePage'                                                                                  new EncoderReplacementFallback("")'                                                                                  new DecoderReplacementFallback(""));                                char[] unescapedChars = new char[bytes.Length];                              int charCount = noFallbackCharUTF8.GetChars(bytes' 0' byteCount' unescapedChars' 0);                                  if (charCount != 0)                              {                                  // If invalid sequences were present in the original escaped string' we need to                                   // copy the escaped versions of those sequences.                                  // Decoded Unicode values will be kept only when they are allowed by the URI/IRI RFC                                  // rules.                                  UriHelper.MatchUTF8Sequence(pDest' dest' ref destOffset' unescapedChars' charCount' bytes'                                      byteCount' component == UriComponents.Query' true);                              }                              else                              {                                  // copy escaped sequence as is                                  for (int i = startSeq; i <= next; ++i)                                  {                                      Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                      pDest[destOffset++] = pInput[i];                                  }                              }                          }                      }                      else                      {                          Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                          pDest[destOffset++] = pInput[next];                      }                  }                  else if (ch > '\x7f')                  {                      // unicode                        char ch2;                        if ((char.IsHighSurrogate(ch)) && (next + 1 < end))                      {                          ch2 = pInput[next + 1];                          escape = !CheckIriUnicodeRange(ch' ch2' ref surrogatePair' component == UriComponents.Query);                          if (!escape)                          {                              // copy the two chars                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next];                          }                      }                      else                      {                          if (CheckIriUnicodeRange(ch' component == UriComponents.Query))                          {                              if (!UriHelper.IsBidiControlCharacter(ch))                              {                                  // copy it                                  Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                  pDest[destOffset++] = pInput[next];                              }                          }                          else                          {                              // escape it                              escape = true;                          }                      }                  }                  else                  {                      // just copy the character                      Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                      pDest[destOffset++] = pInput[next];                  }                    if (escape)                  {                      const int MaxNumberOfBytesEncoded = 4;                        if (bufferRemaining < MaxNumberOfBytesEncoded * percentEncodingLen)                      {                          int newBufferLength = 0;                            checked                          {                              // may need more memory since we didn't anticipate escaping                              newBufferLength = dest.Length + bufferCapacityIncrease;                              bufferRemaining += bufferCapacityIncrease;                          }                            char[] newDest = new char[newBufferLength];                            fixed (char* pNewDest = newDest)                          {                              Buffer.MemoryCopy((byte*)pDest' (byte*)pNewDest' newBufferLength * sizeof(char)' destOffset * sizeof(char));                          }                            if (destHandle.IsAllocated)                          {                              destHandle.Free();                          }                            dest = newDest;                            // re-pin new dest[] array                          destHandle = GCHandle.Alloc(dest' GCHandleType.Pinned);                          pDest = (char*)destHandle.AddrOfPinnedObject();                      }                        byte[] encodedBytes = new byte[MaxNumberOfBytesEncoded];                      fixed (byte* pEncodedBytes = &encodedBytes[0])                      {                          int encodedBytesCount = Encoding.UTF8.GetBytes(pInput + next' surrogatePair ? 2 : 1' pEncodedBytes' MaxNumberOfBytesEncoded);                          Debug.Assert(encodedBytesCount <= MaxNumberOfBytesEncoded' "UTF8 encoder should not exceed specified byteCount");                            bufferRemaining -= encodedBytesCount * percentEncodingLen;                            for (int count = 0; count < encodedBytesCount; ++count)                          {                              UriHelper.EscapeAsciiChar((char)encodedBytes[count]' dest' ref destOffset);                          }                      }                  }              }
Magic Number,System,IriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IriHelper.cs,EscapeUnescapeIri,The following statement contains a magic number: for (; next < end; ++next)              {                  escape = false;                  surrogatePair = false;                    if ((ch = pInput[next]) == '%')                  {                      if (next + 2 < end)                      {                          ch = UriHelper.EscapedAscii(pInput[next + 1]' pInput[next + 2]);                            // Do not unescape a reserved char                          if (ch == Uri.c_DummyChar || ch == '%' || CheckIsReserved(ch' component) || UriHelper.IsNotSafeForUnescape(ch))                          {                              // keep as is                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next];                              continue;                          }                          else if (ch <= '\x7F')                          {                              Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              //ASCII                              pDest[destOffset++] = ch;                              next += 2;                              continue;                          }                          else                          {                              // possibly utf8 encoded sequence of unicode                                // check if safe to unescape according to Iri rules                                Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                                int startSeq = next;                              int byteCount = 1;                              // lazy initialization of max size' will reuse the array for next sequences                              if ((object)bytes == null)                                  bytes = new byte[end - next];                                bytes[0] = (byte)ch;                              next += 3;                              while (next < end)                              {                                  // Check on exit criterion                                  if ((ch = pInput[next]) != '%' || next + 2 >= end)                                      break;                                    // already made sure we have 3 characters in str                                  ch = UriHelper.EscapedAscii(pInput[next + 1]' pInput[next + 2]);                                    //invalid hex sequence ?                                  if (ch == Uri.c_DummyChar)                                      break;                                  // character is not part of a UTF-8 sequence ?                                  else if (ch < '\x80')                                      break;                                  else                                  {                                      //a UTF-8 sequence                                      bytes[byteCount++] = (byte)ch;                                      next += 3;                                  }                                    Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                              }                              next--; // for loop will increment                                  // Using encoder with no replacement fall-back will skip all invalid UTF-8 sequences.                              Encoding noFallbackCharUTF8 = Encoding.GetEncoding(                                                                                  Encoding.UTF8.CodePage'                                                                                  new EncoderReplacementFallback("")'                                                                                  new DecoderReplacementFallback(""));                                char[] unescapedChars = new char[bytes.Length];                              int charCount = noFallbackCharUTF8.GetChars(bytes' 0' byteCount' unescapedChars' 0);                                  if (charCount != 0)                              {                                  // If invalid sequences were present in the original escaped string' we need to                                   // copy the escaped versions of those sequences.                                  // Decoded Unicode values will be kept only when they are allowed by the URI/IRI RFC                                  // rules.                                  UriHelper.MatchUTF8Sequence(pDest' dest' ref destOffset' unescapedChars' charCount' bytes'                                      byteCount' component == UriComponents.Query' true);                              }                              else                              {                                  // copy escaped sequence as is                                  for (int i = startSeq; i <= next; ++i)                                  {                                      Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                      pDest[destOffset++] = pInput[i];                                  }                              }                          }                      }                      else                      {                          Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                          pDest[destOffset++] = pInput[next];                      }                  }                  else if (ch > '\x7f')                  {                      // unicode                        char ch2;                        if ((char.IsHighSurrogate(ch)) && (next + 1 < end))                      {                          ch2 = pInput[next + 1];                          escape = !CheckIriUnicodeRange(ch' ch2' ref surrogatePair' component == UriComponents.Query);                          if (!escape)                          {                              // copy the two chars                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next];                          }                      }                      else                      {                          if (CheckIriUnicodeRange(ch' component == UriComponents.Query))                          {                              if (!UriHelper.IsBidiControlCharacter(ch))                              {                                  // copy it                                  Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                  pDest[destOffset++] = pInput[next];                              }                          }                          else                          {                              // escape it                              escape = true;                          }                      }                  }                  else                  {                      // just copy the character                      Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                      pDest[destOffset++] = pInput[next];                  }                    if (escape)                  {                      const int MaxNumberOfBytesEncoded = 4;                        if (bufferRemaining < MaxNumberOfBytesEncoded * percentEncodingLen)                      {                          int newBufferLength = 0;                            checked                          {                              // may need more memory since we didn't anticipate escaping                              newBufferLength = dest.Length + bufferCapacityIncrease;                              bufferRemaining += bufferCapacityIncrease;                          }                            char[] newDest = new char[newBufferLength];                            fixed (char* pNewDest = newDest)                          {                              Buffer.MemoryCopy((byte*)pDest' (byte*)pNewDest' newBufferLength * sizeof(char)' destOffset * sizeof(char));                          }                            if (destHandle.IsAllocated)                          {                              destHandle.Free();                          }                            dest = newDest;                            // re-pin new dest[] array                          destHandle = GCHandle.Alloc(dest' GCHandleType.Pinned);                          pDest = (char*)destHandle.AddrOfPinnedObject();                      }                        byte[] encodedBytes = new byte[MaxNumberOfBytesEncoded];                      fixed (byte* pEncodedBytes = &encodedBytes[0])                      {                          int encodedBytesCount = Encoding.UTF8.GetBytes(pInput + next' surrogatePair ? 2 : 1' pEncodedBytes' MaxNumberOfBytesEncoded);                          Debug.Assert(encodedBytesCount <= MaxNumberOfBytesEncoded' "UTF8 encoder should not exceed specified byteCount");                            bufferRemaining -= encodedBytesCount * percentEncodingLen;                            for (int count = 0; count < encodedBytesCount; ++count)                          {                              UriHelper.EscapeAsciiChar((char)encodedBytes[count]' dest' ref destOffset);                          }                      }                  }              }
Magic Number,System,IriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\IriHelper.cs,EscapeUnescapeIri,The following statement contains a magic number: for (; next < end; ++next)              {                  escape = false;                  surrogatePair = false;                    if ((ch = pInput[next]) == '%')                  {                      if (next + 2 < end)                      {                          ch = UriHelper.EscapedAscii(pInput[next + 1]' pInput[next + 2]);                            // Do not unescape a reserved char                          if (ch == Uri.c_DummyChar || ch == '%' || CheckIsReserved(ch' component) || UriHelper.IsNotSafeForUnescape(ch))                          {                              // keep as is                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next];                              continue;                          }                          else if (ch <= '\x7F')                          {                              Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              //ASCII                              pDest[destOffset++] = ch;                              next += 2;                              continue;                          }                          else                          {                              // possibly utf8 encoded sequence of unicode                                // check if safe to unescape according to Iri rules                                Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                                int startSeq = next;                              int byteCount = 1;                              // lazy initialization of max size' will reuse the array for next sequences                              if ((object)bytes == null)                                  bytes = new byte[end - next];                                bytes[0] = (byte)ch;                              next += 3;                              while (next < end)                              {                                  // Check on exit criterion                                  if ((ch = pInput[next]) != '%' || next + 2 >= end)                                      break;                                    // already made sure we have 3 characters in str                                  ch = UriHelper.EscapedAscii(pInput[next + 1]' pInput[next + 2]);                                    //invalid hex sequence ?                                  if (ch == Uri.c_DummyChar)                                      break;                                  // character is not part of a UTF-8 sequence ?                                  else if (ch < '\x80')                                      break;                                  else                                  {                                      //a UTF-8 sequence                                      bytes[byteCount++] = (byte)ch;                                      next += 3;                                  }                                    Debug.Assert(ch < 0xFF' "Expecting ASCII character.");                              }                              next--; // for loop will increment                                  // Using encoder with no replacement fall-back will skip all invalid UTF-8 sequences.                              Encoding noFallbackCharUTF8 = Encoding.GetEncoding(                                                                                  Encoding.UTF8.CodePage'                                                                                  new EncoderReplacementFallback("")'                                                                                  new DecoderReplacementFallback(""));                                char[] unescapedChars = new char[bytes.Length];                              int charCount = noFallbackCharUTF8.GetChars(bytes' 0' byteCount' unescapedChars' 0);                                  if (charCount != 0)                              {                                  // If invalid sequences were present in the original escaped string' we need to                                   // copy the escaped versions of those sequences.                                  // Decoded Unicode values will be kept only when they are allowed by the URI/IRI RFC                                  // rules.                                  UriHelper.MatchUTF8Sequence(pDest' dest' ref destOffset' unescapedChars' charCount' bytes'                                      byteCount' component == UriComponents.Query' true);                              }                              else                              {                                  // copy escaped sequence as is                                  for (int i = startSeq; i <= next; ++i)                                  {                                      Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                      pDest[destOffset++] = pInput[i];                                  }                              }                          }                      }                      else                      {                          Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                          pDest[destOffset++] = pInput[next];                      }                  }                  else if (ch > '\x7f')                  {                      // unicode                        char ch2;                        if ((char.IsHighSurrogate(ch)) && (next + 1 < end))                      {                          ch2 = pInput[next + 1];                          escape = !CheckIriUnicodeRange(ch' ch2' ref surrogatePair' component == UriComponents.Query);                          if (!escape)                          {                              // copy the two chars                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next++];                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              pDest[destOffset++] = pInput[next];                          }                      }                      else                      {                          if (CheckIriUnicodeRange(ch' component == UriComponents.Query))                          {                              if (!UriHelper.IsBidiControlCharacter(ch))                              {                                  // copy it                                  Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                  pDest[destOffset++] = pInput[next];                              }                          }                          else                          {                              // escape it                              escape = true;                          }                      }                  }                  else                  {                      // just copy the character                      Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                      pDest[destOffset++] = pInput[next];                  }                    if (escape)                  {                      const int MaxNumberOfBytesEncoded = 4;                        if (bufferRemaining < MaxNumberOfBytesEncoded * percentEncodingLen)                      {                          int newBufferLength = 0;                            checked                          {                              // may need more memory since we didn't anticipate escaping                              newBufferLength = dest.Length + bufferCapacityIncrease;                              bufferRemaining += bufferCapacityIncrease;                          }                            char[] newDest = new char[newBufferLength];                            fixed (char* pNewDest = newDest)                          {                              Buffer.MemoryCopy((byte*)pDest' (byte*)pNewDest' newBufferLength * sizeof(char)' destOffset * sizeof(char));                          }                            if (destHandle.IsAllocated)                          {                              destHandle.Free();                          }                            dest = newDest;                            // re-pin new dest[] array                          destHandle = GCHandle.Alloc(dest' GCHandleType.Pinned);                          pDest = (char*)destHandle.AddrOfPinnedObject();                      }                        byte[] encodedBytes = new byte[MaxNumberOfBytesEncoded];                      fixed (byte* pEncodedBytes = &encodedBytes[0])                      {                          int encodedBytesCount = Encoding.UTF8.GetBytes(pInput + next' surrogatePair ? 2 : 1' pEncodedBytes' MaxNumberOfBytesEncoded);                          Debug.Assert(encodedBytesCount <= MaxNumberOfBytesEncoded' "UTF8 encoder should not exceed specified byteCount");                            bufferRemaining -= encodedBytesCount * percentEncodingLen;                            for (int count = 0; count < encodedBytesCount; ++count)                          {                              UriHelper.EscapeAsciiChar((char)encodedBytes[count]' dest' ref destOffset);                          }                      }                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,GetCombinedString,The following statement contains a magic number: for (int i = 0; i < relativeStr.Length; ++i)              {                  if (relativeStr[i] == '/' || relativeStr[i] == '\\' || relativeStr[i] == '?' || relativeStr[i] == '#')                  {                      break;                  }                  else if (relativeStr[i] == ':')                  {                      if (i < 2)                      {                          // Note we don't support one-letter Uri schemes.                          // Hence anything like x:sdsd is a relative path and be added to the baseUri Path                          break;                      }                      string scheme = relativeStr.Substring(0' i);                      fixed (char* sptr = scheme)                      {                          UriParser syntax = null;                          if (CheckSchemeSyntax(sptr' (ushort)scheme.Length' ref syntax) == ParsingError.None)                          {                              if (baseUri.Syntax == syntax)                              {                                  //Remove the scheme for backward Uri parsers compatibility                                  if (i + 1 < relativeStr.Length)                                  {                                      relativeStr = relativeStr.Substring(i + 1);                                  }                                  else                                  {                                      relativeStr = string.Empty;                                  }                              }                              else                              {                                  // This is the place where we switch the scheme.                                  // Return relative part as the result Uri.                                  result = relativeStr;                                  return ParsingError.None;                              }                          }                      }                      break;                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,GetLocalPath,The following statement contains a magic number: if (IsUncOrDosPath)              {                  EnsureHostString(false);                  int start;                    // Do we have a valid local path right in m_string?                  if (NotAny(Flags.HostNotCanonical | Flags.PathNotCanonical | Flags.ShouldBeCompressed))                  {                      start = IsUncPath ? _info.Offset.Host - 2 : _info.Offset.Path;                        string str = (IsImplicitFile && _info.Offset.Host == (IsDosPath ? 0 : 2) &&                          _info.Offset.Query == _info.Offset.End)                              ? _string                              : (IsDosPath && (_string[start] == '/' || _string[start] == '\\'))                                  ? _string.Substring(start + 1' _info.Offset.Query - start - 1)                                  : _string.Substring(start' _info.Offset.Query - start);                        // Should be a rare case' convert c|\ into c:\                      if (IsDosPath && str[1] == '|')                      {                          // Sadly' today there is no method for replacing just one occurrence                          str = str.Remove(1' 1);                          str = str.Insert(1' ":");                      }                        // check for all back slashes                      for (int i = 0; i < str.Length; ++i)                      {                          if (str[i] == '/')                          {                              str = str.Replace('/'' '\\');                              break;                          }                      }                        return str;                  }                    char[] result;                  int count = 0;                  start = _info.Offset.Path;                    string host = _info.Host;                  result = new char[host.Length + 3 + _info.Offset.Fragment - _info.Offset.Path];                    if (IsUncPath)                  {                      result[0] = '\\';                      result[1] = '\\';                      count = 2;                        UriHelper.UnescapeString(host' 0' host.Length' result' ref count' c_DummyChar' c_DummyChar'                          c_DummyChar' UnescapeMode.CopyOnly' _syntax' false);                  }                  else                  {                      // Dos path                      if (_string[start] == '/' || _string[start] == '\\')                      {                          // Skip leading slash for a DOS path                          ++start;                      }                  }                      ushort pathStart = (ushort)count; //save for optional Compress() call                    UnescapeMode mode = (InFact(Flags.PathNotCanonical) && !IsImplicitFile)                      ? (UnescapeMode.Unescape | UnescapeMode.UnescapeAll) : UnescapeMode.CopyOnly;                  UriHelper.UnescapeString(_string' start' _info.Offset.Query' result' ref count' c_DummyChar'                      c_DummyChar' c_DummyChar' mode' _syntax' true);                    // Possibly convert c|\ into c:\                  if (result[1] == '|')                      result[1] = ':';                    if (InFact(Flags.ShouldBeCompressed))                  {                      // suspecting not compressed path                      // For a dos path we won't compress the "x:" part if found /../ sequences                      result = Compress(result' (ushort)(IsDosPath ? pathStart + 2 : pathStart)' ref count' _syntax);                  }                    // We don't know whether all slashes were the back ones                  // Plus going through Compress will turn them into / anyway                  // Converting / back into \                  for (ushort i = 0; i < (ushort)count; ++i)                  {                      if (result[i] == '/')                      {                          result[i] = '\\';                      }                  }                    return new string(result' 0' count);              }              else              {                  // Return unescaped canonical path                  // Note we cannot call GetParts here because it has circular dependency on GelLocalPath method                  return GetUnescapedParts(UriComponents.Path | UriComponents.KeepDelimiter' UriFormat.Unescaped);              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,GetLocalPath,The following statement contains a magic number: if (IsUncOrDosPath)              {                  EnsureHostString(false);                  int start;                    // Do we have a valid local path right in m_string?                  if (NotAny(Flags.HostNotCanonical | Flags.PathNotCanonical | Flags.ShouldBeCompressed))                  {                      start = IsUncPath ? _info.Offset.Host - 2 : _info.Offset.Path;                        string str = (IsImplicitFile && _info.Offset.Host == (IsDosPath ? 0 : 2) &&                          _info.Offset.Query == _info.Offset.End)                              ? _string                              : (IsDosPath && (_string[start] == '/' || _string[start] == '\\'))                                  ? _string.Substring(start + 1' _info.Offset.Query - start - 1)                                  : _string.Substring(start' _info.Offset.Query - start);                        // Should be a rare case' convert c|\ into c:\                      if (IsDosPath && str[1] == '|')                      {                          // Sadly' today there is no method for replacing just one occurrence                          str = str.Remove(1' 1);                          str = str.Insert(1' ":");                      }                        // check for all back slashes                      for (int i = 0; i < str.Length; ++i)                      {                          if (str[i] == '/')                          {                              str = str.Replace('/'' '\\');                              break;                          }                      }                        return str;                  }                    char[] result;                  int count = 0;                  start = _info.Offset.Path;                    string host = _info.Host;                  result = new char[host.Length + 3 + _info.Offset.Fragment - _info.Offset.Path];                    if (IsUncPath)                  {                      result[0] = '\\';                      result[1] = '\\';                      count = 2;                        UriHelper.UnescapeString(host' 0' host.Length' result' ref count' c_DummyChar' c_DummyChar'                          c_DummyChar' UnescapeMode.CopyOnly' _syntax' false);                  }                  else                  {                      // Dos path                      if (_string[start] == '/' || _string[start] == '\\')                      {                          // Skip leading slash for a DOS path                          ++start;                      }                  }                      ushort pathStart = (ushort)count; //save for optional Compress() call                    UnescapeMode mode = (InFact(Flags.PathNotCanonical) && !IsImplicitFile)                      ? (UnescapeMode.Unescape | UnescapeMode.UnescapeAll) : UnescapeMode.CopyOnly;                  UriHelper.UnescapeString(_string' start' _info.Offset.Query' result' ref count' c_DummyChar'                      c_DummyChar' c_DummyChar' mode' _syntax' true);                    // Possibly convert c|\ into c:\                  if (result[1] == '|')                      result[1] = ':';                    if (InFact(Flags.ShouldBeCompressed))                  {                      // suspecting not compressed path                      // For a dos path we won't compress the "x:" part if found /../ sequences                      result = Compress(result' (ushort)(IsDosPath ? pathStart + 2 : pathStart)' ref count' _syntax);                  }                    // We don't know whether all slashes were the back ones                  // Plus going through Compress will turn them into / anyway                  // Converting / back into \                  for (ushort i = 0; i < (ushort)count; ++i)                  {                      if (result[i] == '/')                      {                          result[i] = '\\';                      }                  }                    return new string(result' 0' count);              }              else              {                  // Return unescaped canonical path                  // Note we cannot call GetParts here because it has circular dependency on GelLocalPath method                  return GetUnescapedParts(UriComponents.Path | UriComponents.KeepDelimiter' UriFormat.Unescaped);              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,GetLocalPath,The following statement contains a magic number: if (IsUncOrDosPath)              {                  EnsureHostString(false);                  int start;                    // Do we have a valid local path right in m_string?                  if (NotAny(Flags.HostNotCanonical | Flags.PathNotCanonical | Flags.ShouldBeCompressed))                  {                      start = IsUncPath ? _info.Offset.Host - 2 : _info.Offset.Path;                        string str = (IsImplicitFile && _info.Offset.Host == (IsDosPath ? 0 : 2) &&                          _info.Offset.Query == _info.Offset.End)                              ? _string                              : (IsDosPath && (_string[start] == '/' || _string[start] == '\\'))                                  ? _string.Substring(start + 1' _info.Offset.Query - start - 1)                                  : _string.Substring(start' _info.Offset.Query - start);                        // Should be a rare case' convert c|\ into c:\                      if (IsDosPath && str[1] == '|')                      {                          // Sadly' today there is no method for replacing just one occurrence                          str = str.Remove(1' 1);                          str = str.Insert(1' ":");                      }                        // check for all back slashes                      for (int i = 0; i < str.Length; ++i)                      {                          if (str[i] == '/')                          {                              str = str.Replace('/'' '\\');                              break;                          }                      }                        return str;                  }                    char[] result;                  int count = 0;                  start = _info.Offset.Path;                    string host = _info.Host;                  result = new char[host.Length + 3 + _info.Offset.Fragment - _info.Offset.Path];                    if (IsUncPath)                  {                      result[0] = '\\';                      result[1] = '\\';                      count = 2;                        UriHelper.UnescapeString(host' 0' host.Length' result' ref count' c_DummyChar' c_DummyChar'                          c_DummyChar' UnescapeMode.CopyOnly' _syntax' false);                  }                  else                  {                      // Dos path                      if (_string[start] == '/' || _string[start] == '\\')                      {                          // Skip leading slash for a DOS path                          ++start;                      }                  }                      ushort pathStart = (ushort)count; //save for optional Compress() call                    UnescapeMode mode = (InFact(Flags.PathNotCanonical) && !IsImplicitFile)                      ? (UnescapeMode.Unescape | UnescapeMode.UnescapeAll) : UnescapeMode.CopyOnly;                  UriHelper.UnescapeString(_string' start' _info.Offset.Query' result' ref count' c_DummyChar'                      c_DummyChar' c_DummyChar' mode' _syntax' true);                    // Possibly convert c|\ into c:\                  if (result[1] == '|')                      result[1] = ':';                    if (InFact(Flags.ShouldBeCompressed))                  {                      // suspecting not compressed path                      // For a dos path we won't compress the "x:" part if found /../ sequences                      result = Compress(result' (ushort)(IsDosPath ? pathStart + 2 : pathStart)' ref count' _syntax);                  }                    // We don't know whether all slashes were the back ones                  // Plus going through Compress will turn them into / anyway                  // Converting / back into \                  for (ushort i = 0; i < (ushort)count; ++i)                  {                      if (result[i] == '/')                      {                          result[i] = '\\';                      }                  }                    return new string(result' 0' count);              }              else              {                  // Return unescaped canonical path                  // Note we cannot call GetParts here because it has circular dependency on GelLocalPath method                  return GetUnescapedParts(UriComponents.Path | UriComponents.KeepDelimiter' UriFormat.Unescaped);              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,GetLocalPath,The following statement contains a magic number: if (IsUncOrDosPath)              {                  EnsureHostString(false);                  int start;                    // Do we have a valid local path right in m_string?                  if (NotAny(Flags.HostNotCanonical | Flags.PathNotCanonical | Flags.ShouldBeCompressed))                  {                      start = IsUncPath ? _info.Offset.Host - 2 : _info.Offset.Path;                        string str = (IsImplicitFile && _info.Offset.Host == (IsDosPath ? 0 : 2) &&                          _info.Offset.Query == _info.Offset.End)                              ? _string                              : (IsDosPath && (_string[start] == '/' || _string[start] == '\\'))                                  ? _string.Substring(start + 1' _info.Offset.Query - start - 1)                                  : _string.Substring(start' _info.Offset.Query - start);                        // Should be a rare case' convert c|\ into c:\                      if (IsDosPath && str[1] == '|')                      {                          // Sadly' today there is no method for replacing just one occurrence                          str = str.Remove(1' 1);                          str = str.Insert(1' ":");                      }                        // check for all back slashes                      for (int i = 0; i < str.Length; ++i)                      {                          if (str[i] == '/')                          {                              str = str.Replace('/'' '\\');                              break;                          }                      }                        return str;                  }                    char[] result;                  int count = 0;                  start = _info.Offset.Path;                    string host = _info.Host;                  result = new char[host.Length + 3 + _info.Offset.Fragment - _info.Offset.Path];                    if (IsUncPath)                  {                      result[0] = '\\';                      result[1] = '\\';                      count = 2;                        UriHelper.UnescapeString(host' 0' host.Length' result' ref count' c_DummyChar' c_DummyChar'                          c_DummyChar' UnescapeMode.CopyOnly' _syntax' false);                  }                  else                  {                      // Dos path                      if (_string[start] == '/' || _string[start] == '\\')                      {                          // Skip leading slash for a DOS path                          ++start;                      }                  }                      ushort pathStart = (ushort)count; //save for optional Compress() call                    UnescapeMode mode = (InFact(Flags.PathNotCanonical) && !IsImplicitFile)                      ? (UnescapeMode.Unescape | UnescapeMode.UnescapeAll) : UnescapeMode.CopyOnly;                  UriHelper.UnescapeString(_string' start' _info.Offset.Query' result' ref count' c_DummyChar'                      c_DummyChar' c_DummyChar' mode' _syntax' true);                    // Possibly convert c|\ into c:\                  if (result[1] == '|')                      result[1] = ':';                    if (InFact(Flags.ShouldBeCompressed))                  {                      // suspecting not compressed path                      // For a dos path we won't compress the "x:" part if found /../ sequences                      result = Compress(result' (ushort)(IsDosPath ? pathStart + 2 : pathStart)' ref count' _syntax);                  }                    // We don't know whether all slashes were the back ones                  // Plus going through Compress will turn them into / anyway                  // Converting / back into \                  for (ushort i = 0; i < (ushort)count; ++i)                  {                      if (result[i] == '/')                      {                          result[i] = '\\';                      }                  }                    return new string(result' 0' count);              }              else              {                  // Return unescaped canonical path                  // Note we cannot call GetParts here because it has circular dependency on GelLocalPath method                  return GetUnescapedParts(UriComponents.Path | UriComponents.KeepDelimiter' UriFormat.Unescaped);              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,GetLocalPath,The following statement contains a magic number: if (IsUncOrDosPath)              {                  EnsureHostString(false);                  int start;                    // Do we have a valid local path right in m_string?                  if (NotAny(Flags.HostNotCanonical | Flags.PathNotCanonical | Flags.ShouldBeCompressed))                  {                      start = IsUncPath ? _info.Offset.Host - 2 : _info.Offset.Path;                        string str = (IsImplicitFile && _info.Offset.Host == (IsDosPath ? 0 : 2) &&                          _info.Offset.Query == _info.Offset.End)                              ? _string                              : (IsDosPath && (_string[start] == '/' || _string[start] == '\\'))                                  ? _string.Substring(start + 1' _info.Offset.Query - start - 1)                                  : _string.Substring(start' _info.Offset.Query - start);                        // Should be a rare case' convert c|\ into c:\                      if (IsDosPath && str[1] == '|')                      {                          // Sadly' today there is no method for replacing just one occurrence                          str = str.Remove(1' 1);                          str = str.Insert(1' ":");                      }                        // check for all back slashes                      for (int i = 0; i < str.Length; ++i)                      {                          if (str[i] == '/')                          {                              str = str.Replace('/'' '\\');                              break;                          }                      }                        return str;                  }                    char[] result;                  int count = 0;                  start = _info.Offset.Path;                    string host = _info.Host;                  result = new char[host.Length + 3 + _info.Offset.Fragment - _info.Offset.Path];                    if (IsUncPath)                  {                      result[0] = '\\';                      result[1] = '\\';                      count = 2;                        UriHelper.UnescapeString(host' 0' host.Length' result' ref count' c_DummyChar' c_DummyChar'                          c_DummyChar' UnescapeMode.CopyOnly' _syntax' false);                  }                  else                  {                      // Dos path                      if (_string[start] == '/' || _string[start] == '\\')                      {                          // Skip leading slash for a DOS path                          ++start;                      }                  }                      ushort pathStart = (ushort)count; //save for optional Compress() call                    UnescapeMode mode = (InFact(Flags.PathNotCanonical) && !IsImplicitFile)                      ? (UnescapeMode.Unescape | UnescapeMode.UnescapeAll) : UnescapeMode.CopyOnly;                  UriHelper.UnescapeString(_string' start' _info.Offset.Query' result' ref count' c_DummyChar'                      c_DummyChar' c_DummyChar' mode' _syntax' true);                    // Possibly convert c|\ into c:\                  if (result[1] == '|')                      result[1] = ':';                    if (InFact(Flags.ShouldBeCompressed))                  {                      // suspecting not compressed path                      // For a dos path we won't compress the "x:" part if found /../ sequences                      result = Compress(result' (ushort)(IsDosPath ? pathStart + 2 : pathStart)' ref count' _syntax);                  }                    // We don't know whether all slashes were the back ones                  // Plus going through Compress will turn them into / anyway                  // Converting / back into \                  for (ushort i = 0; i < (ushort)count; ++i)                  {                      if (result[i] == '/')                      {                          result[i] = '\\';                      }                  }                    return new string(result' 0' count);              }              else              {                  // Return unescaped canonical path                  // Note we cannot call GetParts here because it has circular dependency on GelLocalPath method                  return GetUnescapedParts(UriComponents.Path | UriComponents.KeepDelimiter' UriFormat.Unescaped);              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckHostName,The following statement contains a magic number: unsafe              {                  fixed (char* fixedName = name)                  {                      if (name[0] == '[' && name[name.Length - 1] == ']')                      {                          // we require that _entire_ name is recognized as ipv6 address                          if (IPv6AddressHelper.IsValid(fixedName' 1' ref end) && end == name.Length)                          {                              return UriHostNameType.IPv6;                          }                      }                      end = name.Length;                      if (IPv4AddressHelper.IsValid(fixedName' 0' ref end' false' false' false) && end == name.Length)                      {                          return UriHostNameType.IPv4;                      }                      end = name.Length;                      bool dummyBool = false;                      if (DomainNameHelper.IsValid(fixedName' 0' ref end' ref dummyBool' false) && end == name.Length)                      {                          return UriHostNameType.Dns;                      }                        end = name.Length;                      dummyBool = false;                      if (DomainNameHelper.IsValidByIri(fixedName' 0' ref end' ref dummyBool' false)                          && end == name.Length)                      {                          return UriHostNameType.Dns;                      }                  }                    //This checks the form without []                  end = name.Length + 2;                  // we require that _entire_ name is recognized as ipv6 address                  name = "[" + name + "]";                  fixed (char* newFixedName = name)                  {                      if (IPv6AddressHelper.IsValid(newFixedName' 1' ref end) && end == name.Length)                      {                          return UriHostNameType.IPv6;                      }                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,HexEscape,The following statement contains a magic number: unsafe              {                  char* chars = stackalloc char[3];                  chars[0] = '%';                  chars[1] = UriHelper.s_hexUpperChars[(character & 0xf0) >> 4];                  chars[2] = UriHelper.s_hexUpperChars[character & 0xf];                  return new string(chars' 0' 3);              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,HexEscape,The following statement contains a magic number: unsafe              {                  char* chars = stackalloc char[3];                  chars[0] = '%';                  chars[1] = UriHelper.s_hexUpperChars[(character & 0xf0) >> 4];                  chars[2] = UriHelper.s_hexUpperChars[character & 0xf];                  return new string(chars' 0' 3);              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,HexEscape,The following statement contains a magic number: unsafe              {                  char* chars = stackalloc char[3];                  chars[0] = '%';                  chars[1] = UriHelper.s_hexUpperChars[(character & 0xf0) >> 4];                  chars[2] = UriHelper.s_hexUpperChars[character & 0xf];                  return new string(chars' 0' 3);              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,HexEscape,The following statement contains a magic number: unsafe              {                  char* chars = stackalloc char[3];                  chars[0] = '%';                  chars[1] = UriHelper.s_hexUpperChars[(character & 0xf0) >> 4];                  chars[2] = UriHelper.s_hexUpperChars[character & 0xf];                  return new string(chars' 0' 3);              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,HexUnescape,The following statement contains a magic number: if ((pattern[index] == '%')                  && (pattern.Length - index >= 3))              {                  char ret = UriHelper.EscapedAscii(pattern[index + 1]' pattern[index + 2]);                  if (ret != c_DummyChar)                  {                      index += 3;                      return ret;                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,HexUnescape,The following statement contains a magic number: if ((pattern[index] == '%')                  && (pattern.Length - index >= 3))              {                  char ret = UriHelper.EscapedAscii(pattern[index + 1]' pattern[index + 2]);                  if (ret != c_DummyChar)                  {                      index += 3;                      return ret;                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,HexUnescape,The following statement contains a magic number: if ((pattern[index] == '%')                  && (pattern.Length - index >= 3))              {                  char ret = UriHelper.EscapedAscii(pattern[index + 1]' pattern[index + 2]);                  if (ret != c_DummyChar)                  {                      index += 3;                      return ret;                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,IsHexEncoding,The following statement contains a magic number: return                  (pattern.Length - index) >= 3 &&                  pattern[index] == '%' &&                  IsHexDigit(pattern[index + 1]) &&                  IsHexDigit(pattern[index + 2]);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,IsHexEncoding,The following statement contains a magic number: return                  (pattern.Length - index) >= 3 &&                  pattern[index] == '%' &&                  IsHexDigit(pattern[index + 1]) &&                  IsHexDigit(pattern[index + 2]);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,PrivateParseMinimal,The following statement contains a magic number: fixed (char* pUriString = ((_iriParsing &&                                          ((_flags & Flags.HasUnicode) != 0) &&                                          ((_flags & Flags.HostUnicodeNormalized) == 0)) ? _originalUnicodeString : _string))              {                  // Cut trailing spaces in m_String                  if (length > idx && UriHelper.IsLWS(pUriString[length - 1]))                  {                      --length;                      while (length != idx && UriHelper.IsLWS(pUriString[--length]))                          ;                      ++length;                  }                    // Unix Path                  if (!IsWindowsSystem && InFact(Flags.UnixPath))                  {                      _flags |= Flags.BasicHostType;                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    // Old Uri parser tries to figure out on a DosPath in all cases.                  // Hence http://c:/ is treated as DosPath without the host while it should be a host "c"' port 80                  //                  // This block is compatible with Old Uri parser in terms it will look for the DosPath if the scheme                  // syntax allows both empty hostnames and DosPath                  //                  if (_syntax.IsAllSet(UriSyntaxFlags.AllowEmptyHost | UriSyntaxFlags.AllowDOSPath)                      && NotAny(Flags.ImplicitFile) && (idx + 1 < length))                  {                      char c;                      ushort i = idx;                        // V1 Compat: Allow _compression_ of > 3 slashes only for File scheme.                      // This will skip all slashes and if their number is 2+ it sets the AuthorityFound flag                      for (; i < length; ++i)                      {                          if (!((c = pUriString[i]) == '\\' || c == '/'))                              break;                      }                        if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) || i - idx <= 3)                      {                          // if more than one slash after the scheme' the authority is present                          if (i - idx >= 2)                          {                              _flags |= Flags.AuthorityFound;                          }                          // DOS-like path?                          if (i + 1 < length && ((c = pUriString[i + 1]) == ':' || c == '|') &&                              UriHelper.IsAsciiLetter(pUriString[i]))                          {                              if (i + 2 >= length || ((c = pUriString[i + 2]) != '\\' && c != '/'))                              {                                  // report an error but only for a file: scheme                                  if (_syntax.InFact(UriSyntaxFlags.FileLikeUri))                                      return ParsingError.MustRootedPath;                              }                              else                              {                                  // This will set IsDosPath                                  _flags |= Flags.DosPath;                                    if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                                  {                                      // when DosPath found and Authority is required' set this flag even if Authority is empty                                      _flags |= Flags.AuthorityFound;                                  }                                  if (i != idx && i - idx != 2)                                  {                                      //This will remember that DosPath is rooted                                      idx = (ushort)(i - 1);                                  }                                  else                                  {                                      idx = i;                                  }                              }                          }                          // UNC share?                          else if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) && (i - idx >= 2 && i - idx != 3 &&                              i < length && pUriString[i] != '?' && pUriString[i] != '#'))                          {                              // V1.0 did not support file:///' fixing it with minimal behavior change impact                              // Only FILE scheme may have UNC Path flag set                              _flags |= Flags.UncPath;                              idx = i;                          }                          else if (!IsWindowsSystem && _syntax.InFact(UriSyntaxFlags.FileLikeUri) && pUriString[i - 1] == '/' && i - idx == 3)                          {                              _syntax = UriParser.UnixFileUri;                              _flags |= Flags.UnixPath | Flags.AuthorityFound;                              idx += 2;                          }                      }                  }                  //                  //STEP 1.5 decide on the Authority component                  //                  if ((_flags & (Flags.UncPath | Flags.DosPath | Flags.UnixPath)) != 0)                  {                  }                  else if ((idx + 2) <= length)                  {                      char first = pUriString[idx];                      char second = pUriString[idx + 1];                        if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                      {                          // (V1.0 compatibility) This will allow http:\\ http:\/ http:/\                          if ((first == '/' || first == '\\') && (second == '/' || second == '\\'))                          {                              _flags |= Flags.AuthorityFound;                              idx += 2;                          }                          else                          {                              return ParsingError.BadAuthority;                          }                      }                      else if (_syntax.InFact(UriSyntaxFlags.OptionalAuthority) && (InFact(Flags.AuthorityFound) ||                          (first == '/' && second == '/')))                      {                          _flags |= Flags.AuthorityFound;                          idx += 2;                      }                      else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                      {                          // There is no Authority component' save the Path index                          // Note: mailto is the only guy who is treated specially' should be not.                          _flags |= ((Flags)idx | Flags.UnknownHostType);                          return ParsingError.None;                      }                  }                  else if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                  {                      return ParsingError.BadAuthority;                  }                  else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                  {                      // There is no Authority component' save the Path index                      // mailto is treated specially.                      _flags |= ((Flags)idx | Flags.UnknownHostType);                      return ParsingError.None;                  }                    // vsmacros://c:\path\file                  // Note that two slashes say there must be an Authority but instead the path goes                  // Fro V1 compat the next block allow this case but not for schemes like http                  if (InFact(Flags.DosPath))                  {                      _flags |= (((_flags & Flags.AuthorityFound) != 0) ? Flags.BasicHostType : Flags.UnknownHostType);                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    //STEP 2: Check the syntax of authority expecting at least one character in it                  //                  // Note here we do know that there is an authority in the string OR it's a DOS path                    // We may find a userInfo and the port when parsing an authority                  // Also we may find a registry based authority.                  // We must ensure that known schemes do use a server-based authority                  {                      ParsingError err = ParsingError.None;                      idx = CheckAuthorityHelper(pUriString' idx' length' ref err' ref _flags' _syntax' ref newHost);                      if (err != ParsingError.None)                          return err;                        if (idx < (ushort)length)                      {                          char hostTerminator = pUriString[idx];                            // This will disallow '\' as the host terminator for any scheme that is not implicitFile or cannot have a Dos Path                          if (hostTerminator == '\\' && NotAny(Flags.ImplicitFile) && _syntax.NotAny(UriSyntaxFlags.AllowDOSPath))                          {                              return ParsingError.BadAuthorityTerminator;                          }                          // When the hostTerminator is '/' on Unix' use the UnixFile syntax (preserve backslashes)                          else if (!IsWindowsSystem && hostTerminator == '/' && NotAny(Flags.ImplicitFile) && InFact(Flags.UncPath) && _syntax == UriParser.FileUri)                          {                              _syntax = UriParser.UnixFileUri;                          }                      }                  }                    // The Path (or Port) parsing index is reloaded on demand in CreateUriInfo when accessing a Uri property                  _flags |= (Flags)idx;                    // The rest of the string will be parsed on demand                  // The Host/Authority is all checked' the type is known but the host value string                  // is not created/canonicalized at this point.              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,PrivateParseMinimal,The following statement contains a magic number: fixed (char* pUriString = ((_iriParsing &&                                          ((_flags & Flags.HasUnicode) != 0) &&                                          ((_flags & Flags.HostUnicodeNormalized) == 0)) ? _originalUnicodeString : _string))              {                  // Cut trailing spaces in m_String                  if (length > idx && UriHelper.IsLWS(pUriString[length - 1]))                  {                      --length;                      while (length != idx && UriHelper.IsLWS(pUriString[--length]))                          ;                      ++length;                  }                    // Unix Path                  if (!IsWindowsSystem && InFact(Flags.UnixPath))                  {                      _flags |= Flags.BasicHostType;                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    // Old Uri parser tries to figure out on a DosPath in all cases.                  // Hence http://c:/ is treated as DosPath without the host while it should be a host "c"' port 80                  //                  // This block is compatible with Old Uri parser in terms it will look for the DosPath if the scheme                  // syntax allows both empty hostnames and DosPath                  //                  if (_syntax.IsAllSet(UriSyntaxFlags.AllowEmptyHost | UriSyntaxFlags.AllowDOSPath)                      && NotAny(Flags.ImplicitFile) && (idx + 1 < length))                  {                      char c;                      ushort i = idx;                        // V1 Compat: Allow _compression_ of > 3 slashes only for File scheme.                      // This will skip all slashes and if their number is 2+ it sets the AuthorityFound flag                      for (; i < length; ++i)                      {                          if (!((c = pUriString[i]) == '\\' || c == '/'))                              break;                      }                        if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) || i - idx <= 3)                      {                          // if more than one slash after the scheme' the authority is present                          if (i - idx >= 2)                          {                              _flags |= Flags.AuthorityFound;                          }                          // DOS-like path?                          if (i + 1 < length && ((c = pUriString[i + 1]) == ':' || c == '|') &&                              UriHelper.IsAsciiLetter(pUriString[i]))                          {                              if (i + 2 >= length || ((c = pUriString[i + 2]) != '\\' && c != '/'))                              {                                  // report an error but only for a file: scheme                                  if (_syntax.InFact(UriSyntaxFlags.FileLikeUri))                                      return ParsingError.MustRootedPath;                              }                              else                              {                                  // This will set IsDosPath                                  _flags |= Flags.DosPath;                                    if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                                  {                                      // when DosPath found and Authority is required' set this flag even if Authority is empty                                      _flags |= Flags.AuthorityFound;                                  }                                  if (i != idx && i - idx != 2)                                  {                                      //This will remember that DosPath is rooted                                      idx = (ushort)(i - 1);                                  }                                  else                                  {                                      idx = i;                                  }                              }                          }                          // UNC share?                          else if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) && (i - idx >= 2 && i - idx != 3 &&                              i < length && pUriString[i] != '?' && pUriString[i] != '#'))                          {                              // V1.0 did not support file:///' fixing it with minimal behavior change impact                              // Only FILE scheme may have UNC Path flag set                              _flags |= Flags.UncPath;                              idx = i;                          }                          else if (!IsWindowsSystem && _syntax.InFact(UriSyntaxFlags.FileLikeUri) && pUriString[i - 1] == '/' && i - idx == 3)                          {                              _syntax = UriParser.UnixFileUri;                              _flags |= Flags.UnixPath | Flags.AuthorityFound;                              idx += 2;                          }                      }                  }                  //                  //STEP 1.5 decide on the Authority component                  //                  if ((_flags & (Flags.UncPath | Flags.DosPath | Flags.UnixPath)) != 0)                  {                  }                  else if ((idx + 2) <= length)                  {                      char first = pUriString[idx];                      char second = pUriString[idx + 1];                        if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                      {                          // (V1.0 compatibility) This will allow http:\\ http:\/ http:/\                          if ((first == '/' || first == '\\') && (second == '/' || second == '\\'))                          {                              _flags |= Flags.AuthorityFound;                              idx += 2;                          }                          else                          {                              return ParsingError.BadAuthority;                          }                      }                      else if (_syntax.InFact(UriSyntaxFlags.OptionalAuthority) && (InFact(Flags.AuthorityFound) ||                          (first == '/' && second == '/')))                      {                          _flags |= Flags.AuthorityFound;                          idx += 2;                      }                      else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                      {                          // There is no Authority component' save the Path index                          // Note: mailto is the only guy who is treated specially' should be not.                          _flags |= ((Flags)idx | Flags.UnknownHostType);                          return ParsingError.None;                      }                  }                  else if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                  {                      return ParsingError.BadAuthority;                  }                  else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                  {                      // There is no Authority component' save the Path index                      // mailto is treated specially.                      _flags |= ((Flags)idx | Flags.UnknownHostType);                      return ParsingError.None;                  }                    // vsmacros://c:\path\file                  // Note that two slashes say there must be an Authority but instead the path goes                  // Fro V1 compat the next block allow this case but not for schemes like http                  if (InFact(Flags.DosPath))                  {                      _flags |= (((_flags & Flags.AuthorityFound) != 0) ? Flags.BasicHostType : Flags.UnknownHostType);                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    //STEP 2: Check the syntax of authority expecting at least one character in it                  //                  // Note here we do know that there is an authority in the string OR it's a DOS path                    // We may find a userInfo and the port when parsing an authority                  // Also we may find a registry based authority.                  // We must ensure that known schemes do use a server-based authority                  {                      ParsingError err = ParsingError.None;                      idx = CheckAuthorityHelper(pUriString' idx' length' ref err' ref _flags' _syntax' ref newHost);                      if (err != ParsingError.None)                          return err;                        if (idx < (ushort)length)                      {                          char hostTerminator = pUriString[idx];                            // This will disallow '\' as the host terminator for any scheme that is not implicitFile or cannot have a Dos Path                          if (hostTerminator == '\\' && NotAny(Flags.ImplicitFile) && _syntax.NotAny(UriSyntaxFlags.AllowDOSPath))                          {                              return ParsingError.BadAuthorityTerminator;                          }                          // When the hostTerminator is '/' on Unix' use the UnixFile syntax (preserve backslashes)                          else if (!IsWindowsSystem && hostTerminator == '/' && NotAny(Flags.ImplicitFile) && InFact(Flags.UncPath) && _syntax == UriParser.FileUri)                          {                              _syntax = UriParser.UnixFileUri;                          }                      }                  }                    // The Path (or Port) parsing index is reloaded on demand in CreateUriInfo when accessing a Uri property                  _flags |= (Flags)idx;                    // The rest of the string will be parsed on demand                  // The Host/Authority is all checked' the type is known but the host value string                  // is not created/canonicalized at this point.              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,PrivateParseMinimal,The following statement contains a magic number: fixed (char* pUriString = ((_iriParsing &&                                          ((_flags & Flags.HasUnicode) != 0) &&                                          ((_flags & Flags.HostUnicodeNormalized) == 0)) ? _originalUnicodeString : _string))              {                  // Cut trailing spaces in m_String                  if (length > idx && UriHelper.IsLWS(pUriString[length - 1]))                  {                      --length;                      while (length != idx && UriHelper.IsLWS(pUriString[--length]))                          ;                      ++length;                  }                    // Unix Path                  if (!IsWindowsSystem && InFact(Flags.UnixPath))                  {                      _flags |= Flags.BasicHostType;                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    // Old Uri parser tries to figure out on a DosPath in all cases.                  // Hence http://c:/ is treated as DosPath without the host while it should be a host "c"' port 80                  //                  // This block is compatible with Old Uri parser in terms it will look for the DosPath if the scheme                  // syntax allows both empty hostnames and DosPath                  //                  if (_syntax.IsAllSet(UriSyntaxFlags.AllowEmptyHost | UriSyntaxFlags.AllowDOSPath)                      && NotAny(Flags.ImplicitFile) && (idx + 1 < length))                  {                      char c;                      ushort i = idx;                        // V1 Compat: Allow _compression_ of > 3 slashes only for File scheme.                      // This will skip all slashes and if their number is 2+ it sets the AuthorityFound flag                      for (; i < length; ++i)                      {                          if (!((c = pUriString[i]) == '\\' || c == '/'))                              break;                      }                        if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) || i - idx <= 3)                      {                          // if more than one slash after the scheme' the authority is present                          if (i - idx >= 2)                          {                              _flags |= Flags.AuthorityFound;                          }                          // DOS-like path?                          if (i + 1 < length && ((c = pUriString[i + 1]) == ':' || c == '|') &&                              UriHelper.IsAsciiLetter(pUriString[i]))                          {                              if (i + 2 >= length || ((c = pUriString[i + 2]) != '\\' && c != '/'))                              {                                  // report an error but only for a file: scheme                                  if (_syntax.InFact(UriSyntaxFlags.FileLikeUri))                                      return ParsingError.MustRootedPath;                              }                              else                              {                                  // This will set IsDosPath                                  _flags |= Flags.DosPath;                                    if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                                  {                                      // when DosPath found and Authority is required' set this flag even if Authority is empty                                      _flags |= Flags.AuthorityFound;                                  }                                  if (i != idx && i - idx != 2)                                  {                                      //This will remember that DosPath is rooted                                      idx = (ushort)(i - 1);                                  }                                  else                                  {                                      idx = i;                                  }                              }                          }                          // UNC share?                          else if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) && (i - idx >= 2 && i - idx != 3 &&                              i < length && pUriString[i] != '?' && pUriString[i] != '#'))                          {                              // V1.0 did not support file:///' fixing it with minimal behavior change impact                              // Only FILE scheme may have UNC Path flag set                              _flags |= Flags.UncPath;                              idx = i;                          }                          else if (!IsWindowsSystem && _syntax.InFact(UriSyntaxFlags.FileLikeUri) && pUriString[i - 1] == '/' && i - idx == 3)                          {                              _syntax = UriParser.UnixFileUri;                              _flags |= Flags.UnixPath | Flags.AuthorityFound;                              idx += 2;                          }                      }                  }                  //                  //STEP 1.5 decide on the Authority component                  //                  if ((_flags & (Flags.UncPath | Flags.DosPath | Flags.UnixPath)) != 0)                  {                  }                  else if ((idx + 2) <= length)                  {                      char first = pUriString[idx];                      char second = pUriString[idx + 1];                        if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                      {                          // (V1.0 compatibility) This will allow http:\\ http:\/ http:/\                          if ((first == '/' || first == '\\') && (second == '/' || second == '\\'))                          {                              _flags |= Flags.AuthorityFound;                              idx += 2;                          }                          else                          {                              return ParsingError.BadAuthority;                          }                      }                      else if (_syntax.InFact(UriSyntaxFlags.OptionalAuthority) && (InFact(Flags.AuthorityFound) ||                          (first == '/' && second == '/')))                      {                          _flags |= Flags.AuthorityFound;                          idx += 2;                      }                      else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                      {                          // There is no Authority component' save the Path index                          // Note: mailto is the only guy who is treated specially' should be not.                          _flags |= ((Flags)idx | Flags.UnknownHostType);                          return ParsingError.None;                      }                  }                  else if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                  {                      return ParsingError.BadAuthority;                  }                  else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                  {                      // There is no Authority component' save the Path index                      // mailto is treated specially.                      _flags |= ((Flags)idx | Flags.UnknownHostType);                      return ParsingError.None;                  }                    // vsmacros://c:\path\file                  // Note that two slashes say there must be an Authority but instead the path goes                  // Fro V1 compat the next block allow this case but not for schemes like http                  if (InFact(Flags.DosPath))                  {                      _flags |= (((_flags & Flags.AuthorityFound) != 0) ? Flags.BasicHostType : Flags.UnknownHostType);                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    //STEP 2: Check the syntax of authority expecting at least one character in it                  //                  // Note here we do know that there is an authority in the string OR it's a DOS path                    // We may find a userInfo and the port when parsing an authority                  // Also we may find a registry based authority.                  // We must ensure that known schemes do use a server-based authority                  {                      ParsingError err = ParsingError.None;                      idx = CheckAuthorityHelper(pUriString' idx' length' ref err' ref _flags' _syntax' ref newHost);                      if (err != ParsingError.None)                          return err;                        if (idx < (ushort)length)                      {                          char hostTerminator = pUriString[idx];                            // This will disallow '\' as the host terminator for any scheme that is not implicitFile or cannot have a Dos Path                          if (hostTerminator == '\\' && NotAny(Flags.ImplicitFile) && _syntax.NotAny(UriSyntaxFlags.AllowDOSPath))                          {                              return ParsingError.BadAuthorityTerminator;                          }                          // When the hostTerminator is '/' on Unix' use the UnixFile syntax (preserve backslashes)                          else if (!IsWindowsSystem && hostTerminator == '/' && NotAny(Flags.ImplicitFile) && InFact(Flags.UncPath) && _syntax == UriParser.FileUri)                          {                              _syntax = UriParser.UnixFileUri;                          }                      }                  }                    // The Path (or Port) parsing index is reloaded on demand in CreateUriInfo when accessing a Uri property                  _flags |= (Flags)idx;                    // The rest of the string will be parsed on demand                  // The Host/Authority is all checked' the type is known but the host value string                  // is not created/canonicalized at this point.              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,PrivateParseMinimal,The following statement contains a magic number: fixed (char* pUriString = ((_iriParsing &&                                          ((_flags & Flags.HasUnicode) != 0) &&                                          ((_flags & Flags.HostUnicodeNormalized) == 0)) ? _originalUnicodeString : _string))              {                  // Cut trailing spaces in m_String                  if (length > idx && UriHelper.IsLWS(pUriString[length - 1]))                  {                      --length;                      while (length != idx && UriHelper.IsLWS(pUriString[--length]))                          ;                      ++length;                  }                    // Unix Path                  if (!IsWindowsSystem && InFact(Flags.UnixPath))                  {                      _flags |= Flags.BasicHostType;                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    // Old Uri parser tries to figure out on a DosPath in all cases.                  // Hence http://c:/ is treated as DosPath without the host while it should be a host "c"' port 80                  //                  // This block is compatible with Old Uri parser in terms it will look for the DosPath if the scheme                  // syntax allows both empty hostnames and DosPath                  //                  if (_syntax.IsAllSet(UriSyntaxFlags.AllowEmptyHost | UriSyntaxFlags.AllowDOSPath)                      && NotAny(Flags.ImplicitFile) && (idx + 1 < length))                  {                      char c;                      ushort i = idx;                        // V1 Compat: Allow _compression_ of > 3 slashes only for File scheme.                      // This will skip all slashes and if their number is 2+ it sets the AuthorityFound flag                      for (; i < length; ++i)                      {                          if (!((c = pUriString[i]) == '\\' || c == '/'))                              break;                      }                        if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) || i - idx <= 3)                      {                          // if more than one slash after the scheme' the authority is present                          if (i - idx >= 2)                          {                              _flags |= Flags.AuthorityFound;                          }                          // DOS-like path?                          if (i + 1 < length && ((c = pUriString[i + 1]) == ':' || c == '|') &&                              UriHelper.IsAsciiLetter(pUriString[i]))                          {                              if (i + 2 >= length || ((c = pUriString[i + 2]) != '\\' && c != '/'))                              {                                  // report an error but only for a file: scheme                                  if (_syntax.InFact(UriSyntaxFlags.FileLikeUri))                                      return ParsingError.MustRootedPath;                              }                              else                              {                                  // This will set IsDosPath                                  _flags |= Flags.DosPath;                                    if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                                  {                                      // when DosPath found and Authority is required' set this flag even if Authority is empty                                      _flags |= Flags.AuthorityFound;                                  }                                  if (i != idx && i - idx != 2)                                  {                                      //This will remember that DosPath is rooted                                      idx = (ushort)(i - 1);                                  }                                  else                                  {                                      idx = i;                                  }                              }                          }                          // UNC share?                          else if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) && (i - idx >= 2 && i - idx != 3 &&                              i < length && pUriString[i] != '?' && pUriString[i] != '#'))                          {                              // V1.0 did not support file:///' fixing it with minimal behavior change impact                              // Only FILE scheme may have UNC Path flag set                              _flags |= Flags.UncPath;                              idx = i;                          }                          else if (!IsWindowsSystem && _syntax.InFact(UriSyntaxFlags.FileLikeUri) && pUriString[i - 1] == '/' && i - idx == 3)                          {                              _syntax = UriParser.UnixFileUri;                              _flags |= Flags.UnixPath | Flags.AuthorityFound;                              idx += 2;                          }                      }                  }                  //                  //STEP 1.5 decide on the Authority component                  //                  if ((_flags & (Flags.UncPath | Flags.DosPath | Flags.UnixPath)) != 0)                  {                  }                  else if ((idx + 2) <= length)                  {                      char first = pUriString[idx];                      char second = pUriString[idx + 1];                        if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                      {                          // (V1.0 compatibility) This will allow http:\\ http:\/ http:/\                          if ((first == '/' || first == '\\') && (second == '/' || second == '\\'))                          {                              _flags |= Flags.AuthorityFound;                              idx += 2;                          }                          else                          {                              return ParsingError.BadAuthority;                          }                      }                      else if (_syntax.InFact(UriSyntaxFlags.OptionalAuthority) && (InFact(Flags.AuthorityFound) ||                          (first == '/' && second == '/')))                      {                          _flags |= Flags.AuthorityFound;                          idx += 2;                      }                      else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                      {                          // There is no Authority component' save the Path index                          // Note: mailto is the only guy who is treated specially' should be not.                          _flags |= ((Flags)idx | Flags.UnknownHostType);                          return ParsingError.None;                      }                  }                  else if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                  {                      return ParsingError.BadAuthority;                  }                  else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                  {                      // There is no Authority component' save the Path index                      // mailto is treated specially.                      _flags |= ((Flags)idx | Flags.UnknownHostType);                      return ParsingError.None;                  }                    // vsmacros://c:\path\file                  // Note that two slashes say there must be an Authority but instead the path goes                  // Fro V1 compat the next block allow this case but not for schemes like http                  if (InFact(Flags.DosPath))                  {                      _flags |= (((_flags & Flags.AuthorityFound) != 0) ? Flags.BasicHostType : Flags.UnknownHostType);                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    //STEP 2: Check the syntax of authority expecting at least one character in it                  //                  // Note here we do know that there is an authority in the string OR it's a DOS path                    // We may find a userInfo and the port when parsing an authority                  // Also we may find a registry based authority.                  // We must ensure that known schemes do use a server-based authority                  {                      ParsingError err = ParsingError.None;                      idx = CheckAuthorityHelper(pUriString' idx' length' ref err' ref _flags' _syntax' ref newHost);                      if (err != ParsingError.None)                          return err;                        if (idx < (ushort)length)                      {                          char hostTerminator = pUriString[idx];                            // This will disallow '\' as the host terminator for any scheme that is not implicitFile or cannot have a Dos Path                          if (hostTerminator == '\\' && NotAny(Flags.ImplicitFile) && _syntax.NotAny(UriSyntaxFlags.AllowDOSPath))                          {                              return ParsingError.BadAuthorityTerminator;                          }                          // When the hostTerminator is '/' on Unix' use the UnixFile syntax (preserve backslashes)                          else if (!IsWindowsSystem && hostTerminator == '/' && NotAny(Flags.ImplicitFile) && InFact(Flags.UncPath) && _syntax == UriParser.FileUri)                          {                              _syntax = UriParser.UnixFileUri;                          }                      }                  }                    // The Path (or Port) parsing index is reloaded on demand in CreateUriInfo when accessing a Uri property                  _flags |= (Flags)idx;                    // The rest of the string will be parsed on demand                  // The Host/Authority is all checked' the type is known but the host value string                  // is not created/canonicalized at this point.              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,PrivateParseMinimal,The following statement contains a magic number: fixed (char* pUriString = ((_iriParsing &&                                          ((_flags & Flags.HasUnicode) != 0) &&                                          ((_flags & Flags.HostUnicodeNormalized) == 0)) ? _originalUnicodeString : _string))              {                  // Cut trailing spaces in m_String                  if (length > idx && UriHelper.IsLWS(pUriString[length - 1]))                  {                      --length;                      while (length != idx && UriHelper.IsLWS(pUriString[--length]))                          ;                      ++length;                  }                    // Unix Path                  if (!IsWindowsSystem && InFact(Flags.UnixPath))                  {                      _flags |= Flags.BasicHostType;                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    // Old Uri parser tries to figure out on a DosPath in all cases.                  // Hence http://c:/ is treated as DosPath without the host while it should be a host "c"' port 80                  //                  // This block is compatible with Old Uri parser in terms it will look for the DosPath if the scheme                  // syntax allows both empty hostnames and DosPath                  //                  if (_syntax.IsAllSet(UriSyntaxFlags.AllowEmptyHost | UriSyntaxFlags.AllowDOSPath)                      && NotAny(Flags.ImplicitFile) && (idx + 1 < length))                  {                      char c;                      ushort i = idx;                        // V1 Compat: Allow _compression_ of > 3 slashes only for File scheme.                      // This will skip all slashes and if their number is 2+ it sets the AuthorityFound flag                      for (; i < length; ++i)                      {                          if (!((c = pUriString[i]) == '\\' || c == '/'))                              break;                      }                        if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) || i - idx <= 3)                      {                          // if more than one slash after the scheme' the authority is present                          if (i - idx >= 2)                          {                              _flags |= Flags.AuthorityFound;                          }                          // DOS-like path?                          if (i + 1 < length && ((c = pUriString[i + 1]) == ':' || c == '|') &&                              UriHelper.IsAsciiLetter(pUriString[i]))                          {                              if (i + 2 >= length || ((c = pUriString[i + 2]) != '\\' && c != '/'))                              {                                  // report an error but only for a file: scheme                                  if (_syntax.InFact(UriSyntaxFlags.FileLikeUri))                                      return ParsingError.MustRootedPath;                              }                              else                              {                                  // This will set IsDosPath                                  _flags |= Flags.DosPath;                                    if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                                  {                                      // when DosPath found and Authority is required' set this flag even if Authority is empty                                      _flags |= Flags.AuthorityFound;                                  }                                  if (i != idx && i - idx != 2)                                  {                                      //This will remember that DosPath is rooted                                      idx = (ushort)(i - 1);                                  }                                  else                                  {                                      idx = i;                                  }                              }                          }                          // UNC share?                          else if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) && (i - idx >= 2 && i - idx != 3 &&                              i < length && pUriString[i] != '?' && pUriString[i] != '#'))                          {                              // V1.0 did not support file:///' fixing it with minimal behavior change impact                              // Only FILE scheme may have UNC Path flag set                              _flags |= Flags.UncPath;                              idx = i;                          }                          else if (!IsWindowsSystem && _syntax.InFact(UriSyntaxFlags.FileLikeUri) && pUriString[i - 1] == '/' && i - idx == 3)                          {                              _syntax = UriParser.UnixFileUri;                              _flags |= Flags.UnixPath | Flags.AuthorityFound;                              idx += 2;                          }                      }                  }                  //                  //STEP 1.5 decide on the Authority component                  //                  if ((_flags & (Flags.UncPath | Flags.DosPath | Flags.UnixPath)) != 0)                  {                  }                  else if ((idx + 2) <= length)                  {                      char first = pUriString[idx];                      char second = pUriString[idx + 1];                        if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                      {                          // (V1.0 compatibility) This will allow http:\\ http:\/ http:/\                          if ((first == '/' || first == '\\') && (second == '/' || second == '\\'))                          {                              _flags |= Flags.AuthorityFound;                              idx += 2;                          }                          else                          {                              return ParsingError.BadAuthority;                          }                      }                      else if (_syntax.InFact(UriSyntaxFlags.OptionalAuthority) && (InFact(Flags.AuthorityFound) ||                          (first == '/' && second == '/')))                      {                          _flags |= Flags.AuthorityFound;                          idx += 2;                      }                      else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                      {                          // There is no Authority component' save the Path index                          // Note: mailto is the only guy who is treated specially' should be not.                          _flags |= ((Flags)idx | Flags.UnknownHostType);                          return ParsingError.None;                      }                  }                  else if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                  {                      return ParsingError.BadAuthority;                  }                  else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                  {                      // There is no Authority component' save the Path index                      // mailto is treated specially.                      _flags |= ((Flags)idx | Flags.UnknownHostType);                      return ParsingError.None;                  }                    // vsmacros://c:\path\file                  // Note that two slashes say there must be an Authority but instead the path goes                  // Fro V1 compat the next block allow this case but not for schemes like http                  if (InFact(Flags.DosPath))                  {                      _flags |= (((_flags & Flags.AuthorityFound) != 0) ? Flags.BasicHostType : Flags.UnknownHostType);                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    //STEP 2: Check the syntax of authority expecting at least one character in it                  //                  // Note here we do know that there is an authority in the string OR it's a DOS path                    // We may find a userInfo and the port when parsing an authority                  // Also we may find a registry based authority.                  // We must ensure that known schemes do use a server-based authority                  {                      ParsingError err = ParsingError.None;                      idx = CheckAuthorityHelper(pUriString' idx' length' ref err' ref _flags' _syntax' ref newHost);                      if (err != ParsingError.None)                          return err;                        if (idx < (ushort)length)                      {                          char hostTerminator = pUriString[idx];                            // This will disallow '\' as the host terminator for any scheme that is not implicitFile or cannot have a Dos Path                          if (hostTerminator == '\\' && NotAny(Flags.ImplicitFile) && _syntax.NotAny(UriSyntaxFlags.AllowDOSPath))                          {                              return ParsingError.BadAuthorityTerminator;                          }                          // When the hostTerminator is '/' on Unix' use the UnixFile syntax (preserve backslashes)                          else if (!IsWindowsSystem && hostTerminator == '/' && NotAny(Flags.ImplicitFile) && InFact(Flags.UncPath) && _syntax == UriParser.FileUri)                          {                              _syntax = UriParser.UnixFileUri;                          }                      }                  }                    // The Path (or Port) parsing index is reloaded on demand in CreateUriInfo when accessing a Uri property                  _flags |= (Flags)idx;                    // The rest of the string will be parsed on demand                  // The Host/Authority is all checked' the type is known but the host value string                  // is not created/canonicalized at this point.              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,PrivateParseMinimal,The following statement contains a magic number: fixed (char* pUriString = ((_iriParsing &&                                          ((_flags & Flags.HasUnicode) != 0) &&                                          ((_flags & Flags.HostUnicodeNormalized) == 0)) ? _originalUnicodeString : _string))              {                  // Cut trailing spaces in m_String                  if (length > idx && UriHelper.IsLWS(pUriString[length - 1]))                  {                      --length;                      while (length != idx && UriHelper.IsLWS(pUriString[--length]))                          ;                      ++length;                  }                    // Unix Path                  if (!IsWindowsSystem && InFact(Flags.UnixPath))                  {                      _flags |= Flags.BasicHostType;                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    // Old Uri parser tries to figure out on a DosPath in all cases.                  // Hence http://c:/ is treated as DosPath without the host while it should be a host "c"' port 80                  //                  // This block is compatible with Old Uri parser in terms it will look for the DosPath if the scheme                  // syntax allows both empty hostnames and DosPath                  //                  if (_syntax.IsAllSet(UriSyntaxFlags.AllowEmptyHost | UriSyntaxFlags.AllowDOSPath)                      && NotAny(Flags.ImplicitFile) && (idx + 1 < length))                  {                      char c;                      ushort i = idx;                        // V1 Compat: Allow _compression_ of > 3 slashes only for File scheme.                      // This will skip all slashes and if their number is 2+ it sets the AuthorityFound flag                      for (; i < length; ++i)                      {                          if (!((c = pUriString[i]) == '\\' || c == '/'))                              break;                      }                        if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) || i - idx <= 3)                      {                          // if more than one slash after the scheme' the authority is present                          if (i - idx >= 2)                          {                              _flags |= Flags.AuthorityFound;                          }                          // DOS-like path?                          if (i + 1 < length && ((c = pUriString[i + 1]) == ':' || c == '|') &&                              UriHelper.IsAsciiLetter(pUriString[i]))                          {                              if (i + 2 >= length || ((c = pUriString[i + 2]) != '\\' && c != '/'))                              {                                  // report an error but only for a file: scheme                                  if (_syntax.InFact(UriSyntaxFlags.FileLikeUri))                                      return ParsingError.MustRootedPath;                              }                              else                              {                                  // This will set IsDosPath                                  _flags |= Flags.DosPath;                                    if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                                  {                                      // when DosPath found and Authority is required' set this flag even if Authority is empty                                      _flags |= Flags.AuthorityFound;                                  }                                  if (i != idx && i - idx != 2)                                  {                                      //This will remember that DosPath is rooted                                      idx = (ushort)(i - 1);                                  }                                  else                                  {                                      idx = i;                                  }                              }                          }                          // UNC share?                          else if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) && (i - idx >= 2 && i - idx != 3 &&                              i < length && pUriString[i] != '?' && pUriString[i] != '#'))                          {                              // V1.0 did not support file:///' fixing it with minimal behavior change impact                              // Only FILE scheme may have UNC Path flag set                              _flags |= Flags.UncPath;                              idx = i;                          }                          else if (!IsWindowsSystem && _syntax.InFact(UriSyntaxFlags.FileLikeUri) && pUriString[i - 1] == '/' && i - idx == 3)                          {                              _syntax = UriParser.UnixFileUri;                              _flags |= Flags.UnixPath | Flags.AuthorityFound;                              idx += 2;                          }                      }                  }                  //                  //STEP 1.5 decide on the Authority component                  //                  if ((_flags & (Flags.UncPath | Flags.DosPath | Flags.UnixPath)) != 0)                  {                  }                  else if ((idx + 2) <= length)                  {                      char first = pUriString[idx];                      char second = pUriString[idx + 1];                        if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                      {                          // (V1.0 compatibility) This will allow http:\\ http:\/ http:/\                          if ((first == '/' || first == '\\') && (second == '/' || second == '\\'))                          {                              _flags |= Flags.AuthorityFound;                              idx += 2;                          }                          else                          {                              return ParsingError.BadAuthority;                          }                      }                      else if (_syntax.InFact(UriSyntaxFlags.OptionalAuthority) && (InFact(Flags.AuthorityFound) ||                          (first == '/' && second == '/')))                      {                          _flags |= Flags.AuthorityFound;                          idx += 2;                      }                      else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                      {                          // There is no Authority component' save the Path index                          // Note: mailto is the only guy who is treated specially' should be not.                          _flags |= ((Flags)idx | Flags.UnknownHostType);                          return ParsingError.None;                      }                  }                  else if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                  {                      return ParsingError.BadAuthority;                  }                  else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                  {                      // There is no Authority component' save the Path index                      // mailto is treated specially.                      _flags |= ((Flags)idx | Flags.UnknownHostType);                      return ParsingError.None;                  }                    // vsmacros://c:\path\file                  // Note that two slashes say there must be an Authority but instead the path goes                  // Fro V1 compat the next block allow this case but not for schemes like http                  if (InFact(Flags.DosPath))                  {                      _flags |= (((_flags & Flags.AuthorityFound) != 0) ? Flags.BasicHostType : Flags.UnknownHostType);                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    //STEP 2: Check the syntax of authority expecting at least one character in it                  //                  // Note here we do know that there is an authority in the string OR it's a DOS path                    // We may find a userInfo and the port when parsing an authority                  // Also we may find a registry based authority.                  // We must ensure that known schemes do use a server-based authority                  {                      ParsingError err = ParsingError.None;                      idx = CheckAuthorityHelper(pUriString' idx' length' ref err' ref _flags' _syntax' ref newHost);                      if (err != ParsingError.None)                          return err;                        if (idx < (ushort)length)                      {                          char hostTerminator = pUriString[idx];                            // This will disallow '\' as the host terminator for any scheme that is not implicitFile or cannot have a Dos Path                          if (hostTerminator == '\\' && NotAny(Flags.ImplicitFile) && _syntax.NotAny(UriSyntaxFlags.AllowDOSPath))                          {                              return ParsingError.BadAuthorityTerminator;                          }                          // When the hostTerminator is '/' on Unix' use the UnixFile syntax (preserve backslashes)                          else if (!IsWindowsSystem && hostTerminator == '/' && NotAny(Flags.ImplicitFile) && InFact(Flags.UncPath) && _syntax == UriParser.FileUri)                          {                              _syntax = UriParser.UnixFileUri;                          }                      }                  }                    // The Path (or Port) parsing index is reloaded on demand in CreateUriInfo when accessing a Uri property                  _flags |= (Flags)idx;                    // The rest of the string will be parsed on demand                  // The Host/Authority is all checked' the type is known but the host value string                  // is not created/canonicalized at this point.              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,PrivateParseMinimal,The following statement contains a magic number: fixed (char* pUriString = ((_iriParsing &&                                          ((_flags & Flags.HasUnicode) != 0) &&                                          ((_flags & Flags.HostUnicodeNormalized) == 0)) ? _originalUnicodeString : _string))              {                  // Cut trailing spaces in m_String                  if (length > idx && UriHelper.IsLWS(pUriString[length - 1]))                  {                      --length;                      while (length != idx && UriHelper.IsLWS(pUriString[--length]))                          ;                      ++length;                  }                    // Unix Path                  if (!IsWindowsSystem && InFact(Flags.UnixPath))                  {                      _flags |= Flags.BasicHostType;                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    // Old Uri parser tries to figure out on a DosPath in all cases.                  // Hence http://c:/ is treated as DosPath without the host while it should be a host "c"' port 80                  //                  // This block is compatible with Old Uri parser in terms it will look for the DosPath if the scheme                  // syntax allows both empty hostnames and DosPath                  //                  if (_syntax.IsAllSet(UriSyntaxFlags.AllowEmptyHost | UriSyntaxFlags.AllowDOSPath)                      && NotAny(Flags.ImplicitFile) && (idx + 1 < length))                  {                      char c;                      ushort i = idx;                        // V1 Compat: Allow _compression_ of > 3 slashes only for File scheme.                      // This will skip all slashes and if their number is 2+ it sets the AuthorityFound flag                      for (; i < length; ++i)                      {                          if (!((c = pUriString[i]) == '\\' || c == '/'))                              break;                      }                        if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) || i - idx <= 3)                      {                          // if more than one slash after the scheme' the authority is present                          if (i - idx >= 2)                          {                              _flags |= Flags.AuthorityFound;                          }                          // DOS-like path?                          if (i + 1 < length && ((c = pUriString[i + 1]) == ':' || c == '|') &&                              UriHelper.IsAsciiLetter(pUriString[i]))                          {                              if (i + 2 >= length || ((c = pUriString[i + 2]) != '\\' && c != '/'))                              {                                  // report an error but only for a file: scheme                                  if (_syntax.InFact(UriSyntaxFlags.FileLikeUri))                                      return ParsingError.MustRootedPath;                              }                              else                              {                                  // This will set IsDosPath                                  _flags |= Flags.DosPath;                                    if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                                  {                                      // when DosPath found and Authority is required' set this flag even if Authority is empty                                      _flags |= Flags.AuthorityFound;                                  }                                  if (i != idx && i - idx != 2)                                  {                                      //This will remember that DosPath is rooted                                      idx = (ushort)(i - 1);                                  }                                  else                                  {                                      idx = i;                                  }                              }                          }                          // UNC share?                          else if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) && (i - idx >= 2 && i - idx != 3 &&                              i < length && pUriString[i] != '?' && pUriString[i] != '#'))                          {                              // V1.0 did not support file:///' fixing it with minimal behavior change impact                              // Only FILE scheme may have UNC Path flag set                              _flags |= Flags.UncPath;                              idx = i;                          }                          else if (!IsWindowsSystem && _syntax.InFact(UriSyntaxFlags.FileLikeUri) && pUriString[i - 1] == '/' && i - idx == 3)                          {                              _syntax = UriParser.UnixFileUri;                              _flags |= Flags.UnixPath | Flags.AuthorityFound;                              idx += 2;                          }                      }                  }                  //                  //STEP 1.5 decide on the Authority component                  //                  if ((_flags & (Flags.UncPath | Flags.DosPath | Flags.UnixPath)) != 0)                  {                  }                  else if ((idx + 2) <= length)                  {                      char first = pUriString[idx];                      char second = pUriString[idx + 1];                        if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                      {                          // (V1.0 compatibility) This will allow http:\\ http:\/ http:/\                          if ((first == '/' || first == '\\') && (second == '/' || second == '\\'))                          {                              _flags |= Flags.AuthorityFound;                              idx += 2;                          }                          else                          {                              return ParsingError.BadAuthority;                          }                      }                      else if (_syntax.InFact(UriSyntaxFlags.OptionalAuthority) && (InFact(Flags.AuthorityFound) ||                          (first == '/' && second == '/')))                      {                          _flags |= Flags.AuthorityFound;                          idx += 2;                      }                      else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                      {                          // There is no Authority component' save the Path index                          // Note: mailto is the only guy who is treated specially' should be not.                          _flags |= ((Flags)idx | Flags.UnknownHostType);                          return ParsingError.None;                      }                  }                  else if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                  {                      return ParsingError.BadAuthority;                  }                  else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                  {                      // There is no Authority component' save the Path index                      // mailto is treated specially.                      _flags |= ((Flags)idx | Flags.UnknownHostType);                      return ParsingError.None;                  }                    // vsmacros://c:\path\file                  // Note that two slashes say there must be an Authority but instead the path goes                  // Fro V1 compat the next block allow this case but not for schemes like http                  if (InFact(Flags.DosPath))                  {                      _flags |= (((_flags & Flags.AuthorityFound) != 0) ? Flags.BasicHostType : Flags.UnknownHostType);                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    //STEP 2: Check the syntax of authority expecting at least one character in it                  //                  // Note here we do know that there is an authority in the string OR it's a DOS path                    // We may find a userInfo and the port when parsing an authority                  // Also we may find a registry based authority.                  // We must ensure that known schemes do use a server-based authority                  {                      ParsingError err = ParsingError.None;                      idx = CheckAuthorityHelper(pUriString' idx' length' ref err' ref _flags' _syntax' ref newHost);                      if (err != ParsingError.None)                          return err;                        if (idx < (ushort)length)                      {                          char hostTerminator = pUriString[idx];                            // This will disallow '\' as the host terminator for any scheme that is not implicitFile or cannot have a Dos Path                          if (hostTerminator == '\\' && NotAny(Flags.ImplicitFile) && _syntax.NotAny(UriSyntaxFlags.AllowDOSPath))                          {                              return ParsingError.BadAuthorityTerminator;                          }                          // When the hostTerminator is '/' on Unix' use the UnixFile syntax (preserve backslashes)                          else if (!IsWindowsSystem && hostTerminator == '/' && NotAny(Flags.ImplicitFile) && InFact(Flags.UncPath) && _syntax == UriParser.FileUri)                          {                              _syntax = UriParser.UnixFileUri;                          }                      }                  }                    // The Path (or Port) parsing index is reloaded on demand in CreateUriInfo when accessing a Uri property                  _flags |= (Flags)idx;                    // The rest of the string will be parsed on demand                  // The Host/Authority is all checked' the type is known but the host value string                  // is not created/canonicalized at this point.              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,PrivateParseMinimal,The following statement contains a magic number: fixed (char* pUriString = ((_iriParsing &&                                          ((_flags & Flags.HasUnicode) != 0) &&                                          ((_flags & Flags.HostUnicodeNormalized) == 0)) ? _originalUnicodeString : _string))              {                  // Cut trailing spaces in m_String                  if (length > idx && UriHelper.IsLWS(pUriString[length - 1]))                  {                      --length;                      while (length != idx && UriHelper.IsLWS(pUriString[--length]))                          ;                      ++length;                  }                    // Unix Path                  if (!IsWindowsSystem && InFact(Flags.UnixPath))                  {                      _flags |= Flags.BasicHostType;                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    // Old Uri parser tries to figure out on a DosPath in all cases.                  // Hence http://c:/ is treated as DosPath without the host while it should be a host "c"' port 80                  //                  // This block is compatible with Old Uri parser in terms it will look for the DosPath if the scheme                  // syntax allows both empty hostnames and DosPath                  //                  if (_syntax.IsAllSet(UriSyntaxFlags.AllowEmptyHost | UriSyntaxFlags.AllowDOSPath)                      && NotAny(Flags.ImplicitFile) && (idx + 1 < length))                  {                      char c;                      ushort i = idx;                        // V1 Compat: Allow _compression_ of > 3 slashes only for File scheme.                      // This will skip all slashes and if their number is 2+ it sets the AuthorityFound flag                      for (; i < length; ++i)                      {                          if (!((c = pUriString[i]) == '\\' || c == '/'))                              break;                      }                        if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) || i - idx <= 3)                      {                          // if more than one slash after the scheme' the authority is present                          if (i - idx >= 2)                          {                              _flags |= Flags.AuthorityFound;                          }                          // DOS-like path?                          if (i + 1 < length && ((c = pUriString[i + 1]) == ':' || c == '|') &&                              UriHelper.IsAsciiLetter(pUriString[i]))                          {                              if (i + 2 >= length || ((c = pUriString[i + 2]) != '\\' && c != '/'))                              {                                  // report an error but only for a file: scheme                                  if (_syntax.InFact(UriSyntaxFlags.FileLikeUri))                                      return ParsingError.MustRootedPath;                              }                              else                              {                                  // This will set IsDosPath                                  _flags |= Flags.DosPath;                                    if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                                  {                                      // when DosPath found and Authority is required' set this flag even if Authority is empty                                      _flags |= Flags.AuthorityFound;                                  }                                  if (i != idx && i - idx != 2)                                  {                                      //This will remember that DosPath is rooted                                      idx = (ushort)(i - 1);                                  }                                  else                                  {                                      idx = i;                                  }                              }                          }                          // UNC share?                          else if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) && (i - idx >= 2 && i - idx != 3 &&                              i < length && pUriString[i] != '?' && pUriString[i] != '#'))                          {                              // V1.0 did not support file:///' fixing it with minimal behavior change impact                              // Only FILE scheme may have UNC Path flag set                              _flags |= Flags.UncPath;                              idx = i;                          }                          else if (!IsWindowsSystem && _syntax.InFact(UriSyntaxFlags.FileLikeUri) && pUriString[i - 1] == '/' && i - idx == 3)                          {                              _syntax = UriParser.UnixFileUri;                              _flags |= Flags.UnixPath | Flags.AuthorityFound;                              idx += 2;                          }                      }                  }                  //                  //STEP 1.5 decide on the Authority component                  //                  if ((_flags & (Flags.UncPath | Flags.DosPath | Flags.UnixPath)) != 0)                  {                  }                  else if ((idx + 2) <= length)                  {                      char first = pUriString[idx];                      char second = pUriString[idx + 1];                        if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                      {                          // (V1.0 compatibility) This will allow http:\\ http:\/ http:/\                          if ((first == '/' || first == '\\') && (second == '/' || second == '\\'))                          {                              _flags |= Flags.AuthorityFound;                              idx += 2;                          }                          else                          {                              return ParsingError.BadAuthority;                          }                      }                      else if (_syntax.InFact(UriSyntaxFlags.OptionalAuthority) && (InFact(Flags.AuthorityFound) ||                          (first == '/' && second == '/')))                      {                          _flags |= Flags.AuthorityFound;                          idx += 2;                      }                      else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                      {                          // There is no Authority component' save the Path index                          // Note: mailto is the only guy who is treated specially' should be not.                          _flags |= ((Flags)idx | Flags.UnknownHostType);                          return ParsingError.None;                      }                  }                  else if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                  {                      return ParsingError.BadAuthority;                  }                  else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                  {                      // There is no Authority component' save the Path index                      // mailto is treated specially.                      _flags |= ((Flags)idx | Flags.UnknownHostType);                      return ParsingError.None;                  }                    // vsmacros://c:\path\file                  // Note that two slashes say there must be an Authority but instead the path goes                  // Fro V1 compat the next block allow this case but not for schemes like http                  if (InFact(Flags.DosPath))                  {                      _flags |= (((_flags & Flags.AuthorityFound) != 0) ? Flags.BasicHostType : Flags.UnknownHostType);                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    //STEP 2: Check the syntax of authority expecting at least one character in it                  //                  // Note here we do know that there is an authority in the string OR it's a DOS path                    // We may find a userInfo and the port when parsing an authority                  // Also we may find a registry based authority.                  // We must ensure that known schemes do use a server-based authority                  {                      ParsingError err = ParsingError.None;                      idx = CheckAuthorityHelper(pUriString' idx' length' ref err' ref _flags' _syntax' ref newHost);                      if (err != ParsingError.None)                          return err;                        if (idx < (ushort)length)                      {                          char hostTerminator = pUriString[idx];                            // This will disallow '\' as the host terminator for any scheme that is not implicitFile or cannot have a Dos Path                          if (hostTerminator == '\\' && NotAny(Flags.ImplicitFile) && _syntax.NotAny(UriSyntaxFlags.AllowDOSPath))                          {                              return ParsingError.BadAuthorityTerminator;                          }                          // When the hostTerminator is '/' on Unix' use the UnixFile syntax (preserve backslashes)                          else if (!IsWindowsSystem && hostTerminator == '/' && NotAny(Flags.ImplicitFile) && InFact(Flags.UncPath) && _syntax == UriParser.FileUri)                          {                              _syntax = UriParser.UnixFileUri;                          }                      }                  }                    // The Path (or Port) parsing index is reloaded on demand in CreateUriInfo when accessing a Uri property                  _flags |= (Flags)idx;                    // The rest of the string will be parsed on demand                  // The Host/Authority is all checked' the type is known but the host value string                  // is not created/canonicalized at this point.              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,PrivateParseMinimal,The following statement contains a magic number: fixed (char* pUriString = ((_iriParsing &&                                          ((_flags & Flags.HasUnicode) != 0) &&                                          ((_flags & Flags.HostUnicodeNormalized) == 0)) ? _originalUnicodeString : _string))              {                  // Cut trailing spaces in m_String                  if (length > idx && UriHelper.IsLWS(pUriString[length - 1]))                  {                      --length;                      while (length != idx && UriHelper.IsLWS(pUriString[--length]))                          ;                      ++length;                  }                    // Unix Path                  if (!IsWindowsSystem && InFact(Flags.UnixPath))                  {                      _flags |= Flags.BasicHostType;                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    // Old Uri parser tries to figure out on a DosPath in all cases.                  // Hence http://c:/ is treated as DosPath without the host while it should be a host "c"' port 80                  //                  // This block is compatible with Old Uri parser in terms it will look for the DosPath if the scheme                  // syntax allows both empty hostnames and DosPath                  //                  if (_syntax.IsAllSet(UriSyntaxFlags.AllowEmptyHost | UriSyntaxFlags.AllowDOSPath)                      && NotAny(Flags.ImplicitFile) && (idx + 1 < length))                  {                      char c;                      ushort i = idx;                        // V1 Compat: Allow _compression_ of > 3 slashes only for File scheme.                      // This will skip all slashes and if their number is 2+ it sets the AuthorityFound flag                      for (; i < length; ++i)                      {                          if (!((c = pUriString[i]) == '\\' || c == '/'))                              break;                      }                        if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) || i - idx <= 3)                      {                          // if more than one slash after the scheme' the authority is present                          if (i - idx >= 2)                          {                              _flags |= Flags.AuthorityFound;                          }                          // DOS-like path?                          if (i + 1 < length && ((c = pUriString[i + 1]) == ':' || c == '|') &&                              UriHelper.IsAsciiLetter(pUriString[i]))                          {                              if (i + 2 >= length || ((c = pUriString[i + 2]) != '\\' && c != '/'))                              {                                  // report an error but only for a file: scheme                                  if (_syntax.InFact(UriSyntaxFlags.FileLikeUri))                                      return ParsingError.MustRootedPath;                              }                              else                              {                                  // This will set IsDosPath                                  _flags |= Flags.DosPath;                                    if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                                  {                                      // when DosPath found and Authority is required' set this flag even if Authority is empty                                      _flags |= Flags.AuthorityFound;                                  }                                  if (i != idx && i - idx != 2)                                  {                                      //This will remember that DosPath is rooted                                      idx = (ushort)(i - 1);                                  }                                  else                                  {                                      idx = i;                                  }                              }                          }                          // UNC share?                          else if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) && (i - idx >= 2 && i - idx != 3 &&                              i < length && pUriString[i] != '?' && pUriString[i] != '#'))                          {                              // V1.0 did not support file:///' fixing it with minimal behavior change impact                              // Only FILE scheme may have UNC Path flag set                              _flags |= Flags.UncPath;                              idx = i;                          }                          else if (!IsWindowsSystem && _syntax.InFact(UriSyntaxFlags.FileLikeUri) && pUriString[i - 1] == '/' && i - idx == 3)                          {                              _syntax = UriParser.UnixFileUri;                              _flags |= Flags.UnixPath | Flags.AuthorityFound;                              idx += 2;                          }                      }                  }                  //                  //STEP 1.5 decide on the Authority component                  //                  if ((_flags & (Flags.UncPath | Flags.DosPath | Flags.UnixPath)) != 0)                  {                  }                  else if ((idx + 2) <= length)                  {                      char first = pUriString[idx];                      char second = pUriString[idx + 1];                        if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                      {                          // (V1.0 compatibility) This will allow http:\\ http:\/ http:/\                          if ((first == '/' || first == '\\') && (second == '/' || second == '\\'))                          {                              _flags |= Flags.AuthorityFound;                              idx += 2;                          }                          else                          {                              return ParsingError.BadAuthority;                          }                      }                      else if (_syntax.InFact(UriSyntaxFlags.OptionalAuthority) && (InFact(Flags.AuthorityFound) ||                          (first == '/' && second == '/')))                      {                          _flags |= Flags.AuthorityFound;                          idx += 2;                      }                      else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                      {                          // There is no Authority component' save the Path index                          // Note: mailto is the only guy who is treated specially' should be not.                          _flags |= ((Flags)idx | Flags.UnknownHostType);                          return ParsingError.None;                      }                  }                  else if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                  {                      return ParsingError.BadAuthority;                  }                  else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                  {                      // There is no Authority component' save the Path index                      // mailto is treated specially.                      _flags |= ((Flags)idx | Flags.UnknownHostType);                      return ParsingError.None;                  }                    // vsmacros://c:\path\file                  // Note that two slashes say there must be an Authority but instead the path goes                  // Fro V1 compat the next block allow this case but not for schemes like http                  if (InFact(Flags.DosPath))                  {                      _flags |= (((_flags & Flags.AuthorityFound) != 0) ? Flags.BasicHostType : Flags.UnknownHostType);                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    //STEP 2: Check the syntax of authority expecting at least one character in it                  //                  // Note here we do know that there is an authority in the string OR it's a DOS path                    // We may find a userInfo and the port when parsing an authority                  // Also we may find a registry based authority.                  // We must ensure that known schemes do use a server-based authority                  {                      ParsingError err = ParsingError.None;                      idx = CheckAuthorityHelper(pUriString' idx' length' ref err' ref _flags' _syntax' ref newHost);                      if (err != ParsingError.None)                          return err;                        if (idx < (ushort)length)                      {                          char hostTerminator = pUriString[idx];                            // This will disallow '\' as the host terminator for any scheme that is not implicitFile or cannot have a Dos Path                          if (hostTerminator == '\\' && NotAny(Flags.ImplicitFile) && _syntax.NotAny(UriSyntaxFlags.AllowDOSPath))                          {                              return ParsingError.BadAuthorityTerminator;                          }                          // When the hostTerminator is '/' on Unix' use the UnixFile syntax (preserve backslashes)                          else if (!IsWindowsSystem && hostTerminator == '/' && NotAny(Flags.ImplicitFile) && InFact(Flags.UncPath) && _syntax == UriParser.FileUri)                          {                              _syntax = UriParser.UnixFileUri;                          }                      }                  }                    // The Path (or Port) parsing index is reloaded on demand in CreateUriInfo when accessing a Uri property                  _flags |= (Flags)idx;                    // The rest of the string will be parsed on demand                  // The Host/Authority is all checked' the type is known but the host value string                  // is not created/canonicalized at this point.              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,PrivateParseMinimal,The following statement contains a magic number: fixed (char* pUriString = ((_iriParsing &&                                          ((_flags & Flags.HasUnicode) != 0) &&                                          ((_flags & Flags.HostUnicodeNormalized) == 0)) ? _originalUnicodeString : _string))              {                  // Cut trailing spaces in m_String                  if (length > idx && UriHelper.IsLWS(pUriString[length - 1]))                  {                      --length;                      while (length != idx && UriHelper.IsLWS(pUriString[--length]))                          ;                      ++length;                  }                    // Unix Path                  if (!IsWindowsSystem && InFact(Flags.UnixPath))                  {                      _flags |= Flags.BasicHostType;                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    // Old Uri parser tries to figure out on a DosPath in all cases.                  // Hence http://c:/ is treated as DosPath without the host while it should be a host "c"' port 80                  //                  // This block is compatible with Old Uri parser in terms it will look for the DosPath if the scheme                  // syntax allows both empty hostnames and DosPath                  //                  if (_syntax.IsAllSet(UriSyntaxFlags.AllowEmptyHost | UriSyntaxFlags.AllowDOSPath)                      && NotAny(Flags.ImplicitFile) && (idx + 1 < length))                  {                      char c;                      ushort i = idx;                        // V1 Compat: Allow _compression_ of > 3 slashes only for File scheme.                      // This will skip all slashes and if their number is 2+ it sets the AuthorityFound flag                      for (; i < length; ++i)                      {                          if (!((c = pUriString[i]) == '\\' || c == '/'))                              break;                      }                        if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) || i - idx <= 3)                      {                          // if more than one slash after the scheme' the authority is present                          if (i - idx >= 2)                          {                              _flags |= Flags.AuthorityFound;                          }                          // DOS-like path?                          if (i + 1 < length && ((c = pUriString[i + 1]) == ':' || c == '|') &&                              UriHelper.IsAsciiLetter(pUriString[i]))                          {                              if (i + 2 >= length || ((c = pUriString[i + 2]) != '\\' && c != '/'))                              {                                  // report an error but only for a file: scheme                                  if (_syntax.InFact(UriSyntaxFlags.FileLikeUri))                                      return ParsingError.MustRootedPath;                              }                              else                              {                                  // This will set IsDosPath                                  _flags |= Flags.DosPath;                                    if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                                  {                                      // when DosPath found and Authority is required' set this flag even if Authority is empty                                      _flags |= Flags.AuthorityFound;                                  }                                  if (i != idx && i - idx != 2)                                  {                                      //This will remember that DosPath is rooted                                      idx = (ushort)(i - 1);                                  }                                  else                                  {                                      idx = i;                                  }                              }                          }                          // UNC share?                          else if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) && (i - idx >= 2 && i - idx != 3 &&                              i < length && pUriString[i] != '?' && pUriString[i] != '#'))                          {                              // V1.0 did not support file:///' fixing it with minimal behavior change impact                              // Only FILE scheme may have UNC Path flag set                              _flags |= Flags.UncPath;                              idx = i;                          }                          else if (!IsWindowsSystem && _syntax.InFact(UriSyntaxFlags.FileLikeUri) && pUriString[i - 1] == '/' && i - idx == 3)                          {                              _syntax = UriParser.UnixFileUri;                              _flags |= Flags.UnixPath | Flags.AuthorityFound;                              idx += 2;                          }                      }                  }                  //                  //STEP 1.5 decide on the Authority component                  //                  if ((_flags & (Flags.UncPath | Flags.DosPath | Flags.UnixPath)) != 0)                  {                  }                  else if ((idx + 2) <= length)                  {                      char first = pUriString[idx];                      char second = pUriString[idx + 1];                        if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                      {                          // (V1.0 compatibility) This will allow http:\\ http:\/ http:/\                          if ((first == '/' || first == '\\') && (second == '/' || second == '\\'))                          {                              _flags |= Flags.AuthorityFound;                              idx += 2;                          }                          else                          {                              return ParsingError.BadAuthority;                          }                      }                      else if (_syntax.InFact(UriSyntaxFlags.OptionalAuthority) && (InFact(Flags.AuthorityFound) ||                          (first == '/' && second == '/')))                      {                          _flags |= Flags.AuthorityFound;                          idx += 2;                      }                      else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                      {                          // There is no Authority component' save the Path index                          // Note: mailto is the only guy who is treated specially' should be not.                          _flags |= ((Flags)idx | Flags.UnknownHostType);                          return ParsingError.None;                      }                  }                  else if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                  {                      return ParsingError.BadAuthority;                  }                  else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                  {                      // There is no Authority component' save the Path index                      // mailto is treated specially.                      _flags |= ((Flags)idx | Flags.UnknownHostType);                      return ParsingError.None;                  }                    // vsmacros://c:\path\file                  // Note that two slashes say there must be an Authority but instead the path goes                  // Fro V1 compat the next block allow this case but not for schemes like http                  if (InFact(Flags.DosPath))                  {                      _flags |= (((_flags & Flags.AuthorityFound) != 0) ? Flags.BasicHostType : Flags.UnknownHostType);                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    //STEP 2: Check the syntax of authority expecting at least one character in it                  //                  // Note here we do know that there is an authority in the string OR it's a DOS path                    // We may find a userInfo and the port when parsing an authority                  // Also we may find a registry based authority.                  // We must ensure that known schemes do use a server-based authority                  {                      ParsingError err = ParsingError.None;                      idx = CheckAuthorityHelper(pUriString' idx' length' ref err' ref _flags' _syntax' ref newHost);                      if (err != ParsingError.None)                          return err;                        if (idx < (ushort)length)                      {                          char hostTerminator = pUriString[idx];                            // This will disallow '\' as the host terminator for any scheme that is not implicitFile or cannot have a Dos Path                          if (hostTerminator == '\\' && NotAny(Flags.ImplicitFile) && _syntax.NotAny(UriSyntaxFlags.AllowDOSPath))                          {                              return ParsingError.BadAuthorityTerminator;                          }                          // When the hostTerminator is '/' on Unix' use the UnixFile syntax (preserve backslashes)                          else if (!IsWindowsSystem && hostTerminator == '/' && NotAny(Flags.ImplicitFile) && InFact(Flags.UncPath) && _syntax == UriParser.FileUri)                          {                              _syntax = UriParser.UnixFileUri;                          }                      }                  }                    // The Path (or Port) parsing index is reloaded on demand in CreateUriInfo when accessing a Uri property                  _flags |= (Flags)idx;                    // The rest of the string will be parsed on demand                  // The Host/Authority is all checked' the type is known but the host value string                  // is not created/canonicalized at this point.              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,PrivateParseMinimal,The following statement contains a magic number: fixed (char* pUriString = ((_iriParsing &&                                          ((_flags & Flags.HasUnicode) != 0) &&                                          ((_flags & Flags.HostUnicodeNormalized) == 0)) ? _originalUnicodeString : _string))              {                  // Cut trailing spaces in m_String                  if (length > idx && UriHelper.IsLWS(pUriString[length - 1]))                  {                      --length;                      while (length != idx && UriHelper.IsLWS(pUriString[--length]))                          ;                      ++length;                  }                    // Unix Path                  if (!IsWindowsSystem && InFact(Flags.UnixPath))                  {                      _flags |= Flags.BasicHostType;                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    // Old Uri parser tries to figure out on a DosPath in all cases.                  // Hence http://c:/ is treated as DosPath without the host while it should be a host "c"' port 80                  //                  // This block is compatible with Old Uri parser in terms it will look for the DosPath if the scheme                  // syntax allows both empty hostnames and DosPath                  //                  if (_syntax.IsAllSet(UriSyntaxFlags.AllowEmptyHost | UriSyntaxFlags.AllowDOSPath)                      && NotAny(Flags.ImplicitFile) && (idx + 1 < length))                  {                      char c;                      ushort i = idx;                        // V1 Compat: Allow _compression_ of > 3 slashes only for File scheme.                      // This will skip all slashes and if their number is 2+ it sets the AuthorityFound flag                      for (; i < length; ++i)                      {                          if (!((c = pUriString[i]) == '\\' || c == '/'))                              break;                      }                        if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) || i - idx <= 3)                      {                          // if more than one slash after the scheme' the authority is present                          if (i - idx >= 2)                          {                              _flags |= Flags.AuthorityFound;                          }                          // DOS-like path?                          if (i + 1 < length && ((c = pUriString[i + 1]) == ':' || c == '|') &&                              UriHelper.IsAsciiLetter(pUriString[i]))                          {                              if (i + 2 >= length || ((c = pUriString[i + 2]) != '\\' && c != '/'))                              {                                  // report an error but only for a file: scheme                                  if (_syntax.InFact(UriSyntaxFlags.FileLikeUri))                                      return ParsingError.MustRootedPath;                              }                              else                              {                                  // This will set IsDosPath                                  _flags |= Flags.DosPath;                                    if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                                  {                                      // when DosPath found and Authority is required' set this flag even if Authority is empty                                      _flags |= Flags.AuthorityFound;                                  }                                  if (i != idx && i - idx != 2)                                  {                                      //This will remember that DosPath is rooted                                      idx = (ushort)(i - 1);                                  }                                  else                                  {                                      idx = i;                                  }                              }                          }                          // UNC share?                          else if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) && (i - idx >= 2 && i - idx != 3 &&                              i < length && pUriString[i] != '?' && pUriString[i] != '#'))                          {                              // V1.0 did not support file:///' fixing it with minimal behavior change impact                              // Only FILE scheme may have UNC Path flag set                              _flags |= Flags.UncPath;                              idx = i;                          }                          else if (!IsWindowsSystem && _syntax.InFact(UriSyntaxFlags.FileLikeUri) && pUriString[i - 1] == '/' && i - idx == 3)                          {                              _syntax = UriParser.UnixFileUri;                              _flags |= Flags.UnixPath | Flags.AuthorityFound;                              idx += 2;                          }                      }                  }                  //                  //STEP 1.5 decide on the Authority component                  //                  if ((_flags & (Flags.UncPath | Flags.DosPath | Flags.UnixPath)) != 0)                  {                  }                  else if ((idx + 2) <= length)                  {                      char first = pUriString[idx];                      char second = pUriString[idx + 1];                        if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                      {                          // (V1.0 compatibility) This will allow http:\\ http:\/ http:/\                          if ((first == '/' || first == '\\') && (second == '/' || second == '\\'))                          {                              _flags |= Flags.AuthorityFound;                              idx += 2;                          }                          else                          {                              return ParsingError.BadAuthority;                          }                      }                      else if (_syntax.InFact(UriSyntaxFlags.OptionalAuthority) && (InFact(Flags.AuthorityFound) ||                          (first == '/' && second == '/')))                      {                          _flags |= Flags.AuthorityFound;                          idx += 2;                      }                      else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                      {                          // There is no Authority component' save the Path index                          // Note: mailto is the only guy who is treated specially' should be not.                          _flags |= ((Flags)idx | Flags.UnknownHostType);                          return ParsingError.None;                      }                  }                  else if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                  {                      return ParsingError.BadAuthority;                  }                  else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                  {                      // There is no Authority component' save the Path index                      // mailto is treated specially.                      _flags |= ((Flags)idx | Flags.UnknownHostType);                      return ParsingError.None;                  }                    // vsmacros://c:\path\file                  // Note that two slashes say there must be an Authority but instead the path goes                  // Fro V1 compat the next block allow this case but not for schemes like http                  if (InFact(Flags.DosPath))                  {                      _flags |= (((_flags & Flags.AuthorityFound) != 0) ? Flags.BasicHostType : Flags.UnknownHostType);                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    //STEP 2: Check the syntax of authority expecting at least one character in it                  //                  // Note here we do know that there is an authority in the string OR it's a DOS path                    // We may find a userInfo and the port when parsing an authority                  // Also we may find a registry based authority.                  // We must ensure that known schemes do use a server-based authority                  {                      ParsingError err = ParsingError.None;                      idx = CheckAuthorityHelper(pUriString' idx' length' ref err' ref _flags' _syntax' ref newHost);                      if (err != ParsingError.None)                          return err;                        if (idx < (ushort)length)                      {                          char hostTerminator = pUriString[idx];                            // This will disallow '\' as the host terminator for any scheme that is not implicitFile or cannot have a Dos Path                          if (hostTerminator == '\\' && NotAny(Flags.ImplicitFile) && _syntax.NotAny(UriSyntaxFlags.AllowDOSPath))                          {                              return ParsingError.BadAuthorityTerminator;                          }                          // When the hostTerminator is '/' on Unix' use the UnixFile syntax (preserve backslashes)                          else if (!IsWindowsSystem && hostTerminator == '/' && NotAny(Flags.ImplicitFile) && InFact(Flags.UncPath) && _syntax == UriParser.FileUri)                          {                              _syntax = UriParser.UnixFileUri;                          }                      }                  }                    // The Path (or Port) parsing index is reloaded on demand in CreateUriInfo when accessing a Uri property                  _flags |= (Flags)idx;                    // The rest of the string will be parsed on demand                  // The Host/Authority is all checked' the type is known but the host value string                  // is not created/canonicalized at this point.              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,PrivateParseMinimal,The following statement contains a magic number: fixed (char* pUriString = ((_iriParsing &&                                          ((_flags & Flags.HasUnicode) != 0) &&                                          ((_flags & Flags.HostUnicodeNormalized) == 0)) ? _originalUnicodeString : _string))              {                  // Cut trailing spaces in m_String                  if (length > idx && UriHelper.IsLWS(pUriString[length - 1]))                  {                      --length;                      while (length != idx && UriHelper.IsLWS(pUriString[--length]))                          ;                      ++length;                  }                    // Unix Path                  if (!IsWindowsSystem && InFact(Flags.UnixPath))                  {                      _flags |= Flags.BasicHostType;                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    // Old Uri parser tries to figure out on a DosPath in all cases.                  // Hence http://c:/ is treated as DosPath without the host while it should be a host "c"' port 80                  //                  // This block is compatible with Old Uri parser in terms it will look for the DosPath if the scheme                  // syntax allows both empty hostnames and DosPath                  //                  if (_syntax.IsAllSet(UriSyntaxFlags.AllowEmptyHost | UriSyntaxFlags.AllowDOSPath)                      && NotAny(Flags.ImplicitFile) && (idx + 1 < length))                  {                      char c;                      ushort i = idx;                        // V1 Compat: Allow _compression_ of > 3 slashes only for File scheme.                      // This will skip all slashes and if their number is 2+ it sets the AuthorityFound flag                      for (; i < length; ++i)                      {                          if (!((c = pUriString[i]) == '\\' || c == '/'))                              break;                      }                        if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) || i - idx <= 3)                      {                          // if more than one slash after the scheme' the authority is present                          if (i - idx >= 2)                          {                              _flags |= Flags.AuthorityFound;                          }                          // DOS-like path?                          if (i + 1 < length && ((c = pUriString[i + 1]) == ':' || c == '|') &&                              UriHelper.IsAsciiLetter(pUriString[i]))                          {                              if (i + 2 >= length || ((c = pUriString[i + 2]) != '\\' && c != '/'))                              {                                  // report an error but only for a file: scheme                                  if (_syntax.InFact(UriSyntaxFlags.FileLikeUri))                                      return ParsingError.MustRootedPath;                              }                              else                              {                                  // This will set IsDosPath                                  _flags |= Flags.DosPath;                                    if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                                  {                                      // when DosPath found and Authority is required' set this flag even if Authority is empty                                      _flags |= Flags.AuthorityFound;                                  }                                  if (i != idx && i - idx != 2)                                  {                                      //This will remember that DosPath is rooted                                      idx = (ushort)(i - 1);                                  }                                  else                                  {                                      idx = i;                                  }                              }                          }                          // UNC share?                          else if (_syntax.InFact(UriSyntaxFlags.FileLikeUri) && (i - idx >= 2 && i - idx != 3 &&                              i < length && pUriString[i] != '?' && pUriString[i] != '#'))                          {                              // V1.0 did not support file:///' fixing it with minimal behavior change impact                              // Only FILE scheme may have UNC Path flag set                              _flags |= Flags.UncPath;                              idx = i;                          }                          else if (!IsWindowsSystem && _syntax.InFact(UriSyntaxFlags.FileLikeUri) && pUriString[i - 1] == '/' && i - idx == 3)                          {                              _syntax = UriParser.UnixFileUri;                              _flags |= Flags.UnixPath | Flags.AuthorityFound;                              idx += 2;                          }                      }                  }                  //                  //STEP 1.5 decide on the Authority component                  //                  if ((_flags & (Flags.UncPath | Flags.DosPath | Flags.UnixPath)) != 0)                  {                  }                  else if ((idx + 2) <= length)                  {                      char first = pUriString[idx];                      char second = pUriString[idx + 1];                        if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                      {                          // (V1.0 compatibility) This will allow http:\\ http:\/ http:/\                          if ((first == '/' || first == '\\') && (second == '/' || second == '\\'))                          {                              _flags |= Flags.AuthorityFound;                              idx += 2;                          }                          else                          {                              return ParsingError.BadAuthority;                          }                      }                      else if (_syntax.InFact(UriSyntaxFlags.OptionalAuthority) && (InFact(Flags.AuthorityFound) ||                          (first == '/' && second == '/')))                      {                          _flags |= Flags.AuthorityFound;                          idx += 2;                      }                      else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                      {                          // There is no Authority component' save the Path index                          // Note: mailto is the only guy who is treated specially' should be not.                          _flags |= ((Flags)idx | Flags.UnknownHostType);                          return ParsingError.None;                      }                  }                  else if (_syntax.InFact(UriSyntaxFlags.MustHaveAuthority))                  {                      return ParsingError.BadAuthority;                  }                  else if (_syntax.NotAny(UriSyntaxFlags.MailToLikeUri))                  {                      // There is no Authority component' save the Path index                      // mailto is treated specially.                      _flags |= ((Flags)idx | Flags.UnknownHostType);                      return ParsingError.None;                  }                    // vsmacros://c:\path\file                  // Note that two slashes say there must be an Authority but instead the path goes                  // Fro V1 compat the next block allow this case but not for schemes like http                  if (InFact(Flags.DosPath))                  {                      _flags |= (((_flags & Flags.AuthorityFound) != 0) ? Flags.BasicHostType : Flags.UnknownHostType);                      _flags |= (Flags)idx;                      return ParsingError.None;                  }                    //STEP 2: Check the syntax of authority expecting at least one character in it                  //                  // Note here we do know that there is an authority in the string OR it's a DOS path                    // We may find a userInfo and the port when parsing an authority                  // Also we may find a registry based authority.                  // We must ensure that known schemes do use a server-based authority                  {                      ParsingError err = ParsingError.None;                      idx = CheckAuthorityHelper(pUriString' idx' length' ref err' ref _flags' _syntax' ref newHost);                      if (err != ParsingError.None)                          return err;                        if (idx < (ushort)length)                      {                          char hostTerminator = pUriString[idx];                            // This will disallow '\' as the host terminator for any scheme that is not implicitFile or cannot have a Dos Path                          if (hostTerminator == '\\' && NotAny(Flags.ImplicitFile) && _syntax.NotAny(UriSyntaxFlags.AllowDOSPath))                          {                              return ParsingError.BadAuthorityTerminator;                          }                          // When the hostTerminator is '/' on Unix' use the UnixFile syntax (preserve backslashes)                          else if (!IsWindowsSystem && hostTerminator == '/' && NotAny(Flags.ImplicitFile) && InFact(Flags.UncPath) && _syntax == UriParser.FileUri)                          {                              _syntax = UriParser.UnixFileUri;                          }                      }                  }                    // The Path (or Port) parsing index is reloaded on demand in CreateUriInfo when accessing a Uri property                  _flags |= (Flags)idx;                    // The rest of the string will be parsed on demand                  // The Host/Authority is all checked' the type is known but the host value string                  // is not created/canonicalized at this point.              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CreateUriInfo,The following statement contains a magic number: if ((cF & Flags.ImplicitFile) != 0)              {                  idx = (ushort)0;                  while (UriHelper.IsLWS(_string[idx]))                  {                      ++idx;                      ++info.Offset.Scheme;                  }                    if (StaticInFact(cF' Flags.UncPath))                  {                      // For implicit file AND Unc only                      idx += 2;                      //skip any other slashes (compatibility with V1.0 parser)                      while (idx < (ushort)(cF & Flags.IndexMask) && (_string[idx] == '/' || _string[idx] == '\\'))                      {                          ++idx;                      }                  }              }              else              {                  // This is NOT an ImplicitFile uri                  idx = (ushort)_syntax.SchemeName.Length;                    while (_string[idx++] != ':')                  {                      ++info.Offset.Scheme;                  }                    if ((cF & Flags.AuthorityFound) != 0)                  {                      if (_string[idx] == '\\' || _string[idx + 1] == '\\')                          notCanonicalScheme = true;                        idx += 2;                      if ((cF & (Flags.UncPath | Flags.DosPath)) != 0)                      {                          // Skip slashes if it was allowed during ctor time                          // NB: Today this is only allowed if a Unc or DosPath was found after the scheme                          while (idx < (ushort)(cF & Flags.IndexMask) && (_string[idx] == '/' || _string[idx] == '\\'))                          {                              notCanonicalScheme = true;                              ++idx;                          }                      }                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CreateUriInfo,The following statement contains a magic number: if ((cF & Flags.ImplicitFile) != 0)              {                  idx = (ushort)0;                  while (UriHelper.IsLWS(_string[idx]))                  {                      ++idx;                      ++info.Offset.Scheme;                  }                    if (StaticInFact(cF' Flags.UncPath))                  {                      // For implicit file AND Unc only                      idx += 2;                      //skip any other slashes (compatibility with V1.0 parser)                      while (idx < (ushort)(cF & Flags.IndexMask) && (_string[idx] == '/' || _string[idx] == '\\'))                      {                          ++idx;                      }                  }              }              else              {                  // This is NOT an ImplicitFile uri                  idx = (ushort)_syntax.SchemeName.Length;                    while (_string[idx++] != ':')                  {                      ++info.Offset.Scheme;                  }                    if ((cF & Flags.AuthorityFound) != 0)                  {                      if (_string[idx] == '\\' || _string[idx + 1] == '\\')                          notCanonicalScheme = true;                        idx += 2;                      if ((cF & (Flags.UncPath | Flags.DosPath)) != 0)                      {                          // Skip slashes if it was allowed during ctor time                          // NB: Today this is only allowed if a Unc or DosPath was found after the scheme                          while (idx < (ushort)(cF & Flags.IndexMask) && (_string[idx] == '/' || _string[idx] == '\\'))                          {                              notCanonicalScheme = true;                              ++idx;                          }                      }                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CreateUriInfo,The following statement contains a magic number: if (idx < info.Offset.End)              {                  fixed (char* userString = UseOrigUnicodeStrOffset ? _originalUnicodeString : _string)                  {                      if (userString[idx] == ':')                      {                          int port = 0;                            //Check on some non-canonical cases http://host:0324/' http://host:03' http://host:0' etc                          if (++idx < info.Offset.End)                          {                              port = unchecked((ushort)(userString[idx] - '0'));                              if (!(port == unchecked((ushort)('/' - '0')) || port == (ushort)('?' - '0') ||                                  port == unchecked((ushort)('#' - '0'))))                              {                                  notEmpty = true;                                  if (port == 0)                                  {                                      cF |= (Flags.PortNotCanonical | Flags.E_PortNotCanonical);                                  }                                  for (++idx; idx < info.Offset.End; ++idx)                                  {                                      ushort val = unchecked((ushort)((ushort)userString[idx] - (ushort)'0'));                                      if (val == unchecked((ushort)('/' - '0')) || val == (ushort)('?' - '0') ||                                          val == unchecked((ushort)('#' - '0')))                                      {                                          break;                                      }                                      port = (port * 10 + val);                                  }                              }                          }                          if (notEmpty && info.Offset.PortValue != (ushort)port)                          {                              info.Offset.PortValue = (ushort)port;                              cF |= Flags.NotDefaultPort;                          }                          else                          {                              //This will tell that we do have a ':' but the port value does                              //not follow to canonical rules                              cF |= (Flags.PortNotCanonical | Flags.E_PortNotCanonical);                          }                          info.Offset.Path = (ushort)idx;                      }                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,GetHostViaCustomSyntax,The following statement contains a magic number: if ((object)portStr == null || portStr.Length == 0)              {                  // It's like no port                  _flags &= ~Flags.NotDefaultPort;                  _flags |= (Flags.PortNotCanonical | Flags.E_PortNotCanonical);                  _info.Offset.PortValue = 0;              }              else              {                  for (int idx = 0; idx < portStr.Length; ++idx)                  {                      int val = portStr[idx] - '0';                      if (val < 0 || val > 9 || (port = (port * 10 + val)) > 0xFFFF)                          throw new UriFormatException(SR.Format(SR.net_uri_PortOutOfRange' _syntax.GetType().ToString()' portStr));                  }                  if (port != _info.Offset.PortValue)                  {                      if (port == _syntax.DefaultPort)                          _flags &= ~Flags.NotDefaultPort;                      else                          _flags |= Flags.NotDefaultPort;                        _flags |= (Flags.PortNotCanonical | Flags.E_PortNotCanonical);                      _info.Offset.PortValue = (ushort)port;                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,GetHostViaCustomSyntax,The following statement contains a magic number: if ((object)portStr == null || portStr.Length == 0)              {                  // It's like no port                  _flags &= ~Flags.NotDefaultPort;                  _flags |= (Flags.PortNotCanonical | Flags.E_PortNotCanonical);                  _info.Offset.PortValue = 0;              }              else              {                  for (int idx = 0; idx < portStr.Length; ++idx)                  {                      int val = portStr[idx] - '0';                      if (val < 0 || val > 9 || (port = (port * 10 + val)) > 0xFFFF)                          throw new UriFormatException(SR.Format(SR.net_uri_PortOutOfRange' _syntax.GetType().ToString()' portStr));                  }                  if (port != _info.Offset.PortValue)                  {                      if (port == _syntax.DefaultPort)                          _flags &= ~Flags.NotDefaultPort;                      else                          _flags |= Flags.NotDefaultPort;                        _flags |= (Flags.PortNotCanonical | Flags.E_PortNotCanonical);                      _info.Offset.PortValue = (ushort)port;                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,GetEscapedParts,The following statement contains a magic number: ushort nonCanonical = unchecked((ushort)(((ushort)_flags & ((ushort)Flags.CannotDisplayCanonical << 7)) >> 6));
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,GetEscapedParts,The following statement contains a magic number: ushort nonCanonical = unchecked((ushort)(((ushort)_flags & ((ushort)Flags.CannotDisplayCanonical << 7)) >> 6));
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ReCreateParts,The following statement contains a magic number: int count = (_info.Offset.End - _info.Offset.User) * (formatAs == UriFormat.UriEscaped ? 12 : 1);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ReCreateParts,The following statement contains a magic number: char[] chars = new char[stemp.Length + count + _syntax.SchemeName.Length + 3 + 1];
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ParseRemaining,The following statement contains a magic number: fixed (char* str = _string)              {                  // Cut trailing spaces in m_String                  if (length > idx && UriHelper.IsLWS(str[length - 1]))                  {                      --length;                      while (length != idx && UriHelper.IsLWS(str[--length]))                          ;                      ++length;                  }                    if (IsImplicitFile)                  {                      cF |= Flags.SchemeNotCanonical;                  }                  else                  {                      ushort i = 0;                      ushort syntaxLength = (ushort)_syntax.SchemeName.Length;                      for (; i < syntaxLength; ++i)                      {                          if (_syntax.SchemeName[i] != str[idx + i])                              cF |= Flags.SchemeNotCanonical;                      }                      // For an authority Uri only // after the scheme would be canonical                      // (for compatibility with: http:\\host)                      if (((_flags & Flags.AuthorityFound) != 0) && (idx + i + 3 >= length || str[idx + i + 1] != '/' ||                          str[idx + i + 2] != '/'))                      {                          cF |= Flags.SchemeNotCanonical;                      }                  }                      //Check the form of the user info                  if ((_flags & Flags.HasUserInfo) != 0)                  {                      idx = _info.Offset.User;                      result = CheckCanonical(str' ref idx' _info.Offset.Host' '@');                      if ((result & Check.DisplayCanonical) == 0)                      {                          cF |= Flags.UserNotCanonical;                      }                      if ((result & (Check.EscapedCanonical | Check.BackslashInPath)) != Check.EscapedCanonical)                      {                          cF |= Flags.E_UserNotCanonical;                      }                      if (_iriParsing && ((result & (Check.DisplayCanonical | Check.EscapedCanonical | Check.BackslashInPath                                                      | Check.FoundNonAscii | Check.NotIriCanonical))                                                      == (Check.DisplayCanonical | Check.FoundNonAscii)))                      {                          cF |= Flags.UserIriCanonical;                      }                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ParseRemaining,The following statement contains a magic number: fixed (char* str = _string)              {                  // Cut trailing spaces in m_String                  if (length > idx && UriHelper.IsLWS(str[length - 1]))                  {                      --length;                      while (length != idx && UriHelper.IsLWS(str[--length]))                          ;                      ++length;                  }                    if (IsImplicitFile)                  {                      cF |= Flags.SchemeNotCanonical;                  }                  else                  {                      ushort i = 0;                      ushort syntaxLength = (ushort)_syntax.SchemeName.Length;                      for (; i < syntaxLength; ++i)                      {                          if (_syntax.SchemeName[i] != str[idx + i])                              cF |= Flags.SchemeNotCanonical;                      }                      // For an authority Uri only // after the scheme would be canonical                      // (for compatibility with: http:\\host)                      if (((_flags & Flags.AuthorityFound) != 0) && (idx + i + 3 >= length || str[idx + i + 1] != '/' ||                          str[idx + i + 2] != '/'))                      {                          cF |= Flags.SchemeNotCanonical;                      }                  }                      //Check the form of the user info                  if ((_flags & Flags.HasUserInfo) != 0)                  {                      idx = _info.Offset.User;                      result = CheckCanonical(str' ref idx' _info.Offset.Host' '@');                      if ((result & Check.DisplayCanonical) == 0)                      {                          cF |= Flags.UserNotCanonical;                      }                      if ((result & (Check.EscapedCanonical | Check.BackslashInPath)) != Check.EscapedCanonical)                      {                          cF |= Flags.E_UserNotCanonical;                      }                      if (_iriParsing && ((result & (Check.DisplayCanonical | Check.EscapedCanonical | Check.BackslashInPath                                                      | Check.FoundNonAscii | Check.NotIriCanonical))                                                      == (Check.DisplayCanonical | Check.FoundNonAscii)))                      {                          cF |= Flags.UserIriCanonical;                      }                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ParseSchemeCheckImplicitFile,The following statement contains a magic number: if (IntPtr.Size == 4)              {                  // long = 4chars: The minimal size of a known scheme is 2 + ':'                  if (end != length && end >= idx + 2 &&                      CheckKnownSchemes((long*)(uriString + idx)' (ushort)(end - idx)' ref syntax))                  {                      return (ushort)(end + 1);                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ParseSchemeCheckImplicitFile,The following statement contains a magic number: if (IntPtr.Size == 4)              {                  // long = 4chars: The minimal size of a known scheme is 2 + ':'                  if (end != length && end >= idx + 2 &&                      CheckKnownSchemes((long*)(uriString + idx)' (ushort)(end - idx)' ref syntax))                  {                      return (ushort)(end + 1);                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ParseSchemeCheckImplicitFile,The following statement contains a magic number: if (idx + 2 >= length || end == idx)              {                  err = ParsingError.BadFormat;                  return 0;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ParseSchemeCheckImplicitFile,The following statement contains a magic number: {                  char c;                  if ((c = uriString[idx + 1]) == ':' || c == '|')                  {                      //DOS-like path?                      if (UriHelper.IsAsciiLetter(uriString[idx]))                      {                          if ((c = uriString[idx + 2]) == '\\' || c == '/')                          {                              flags |= (Flags.DosPath | Flags.ImplicitFile | Flags.AuthorityFound);                              syntax = UriParser.FileUri;                              return idx;                          }                          err = ParsingError.MustRootedPath;                          return 0;                      }                      if (c == ':')                          err = ParsingError.BadScheme;                      else                          err = ParsingError.BadFormat;                      return 0;                  }                  else if ((c = uriString[idx]) == '/' || c == '\\')                  {                      //UNC share?                      if ((c = uriString[idx + 1]) == '\\' || c == '/')                      {                          flags |= (Flags.UncPath | Flags.ImplicitFile | Flags.AuthorityFound);                          syntax = UriParser.FileUri;                          idx += 2;                          // V1.1 compat this will simply eat any slashes prepended to a UNC path                          while (idx < length && ((c = uriString[idx]) == '/' || c == '\\'))                              ++idx;                            return idx;                      }                      err = ParsingError.BadFormat;                      return 0;                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ParseSchemeCheckImplicitFile,The following statement contains a magic number: {                  char c;                  if ((c = uriString[idx + 1]) == ':' || c == '|')                  {                      //DOS-like path?                      if (UriHelper.IsAsciiLetter(uriString[idx]))                      {                          if ((c = uriString[idx + 2]) == '\\' || c == '/')                          {                              flags |= (Flags.DosPath | Flags.ImplicitFile | Flags.AuthorityFound);                              syntax = UriParser.FileUri;                              return idx;                          }                          err = ParsingError.MustRootedPath;                          return 0;                      }                      if (c == ':')                          err = ParsingError.BadScheme;                      else                          err = ParsingError.BadFormat;                      return 0;                  }                  else if ((c = uriString[idx]) == '/' || c == '\\')                  {                      //UNC share?                      if ((c = uriString[idx + 1]) == '\\' || c == '/')                      {                          flags |= (Flags.UncPath | Flags.ImplicitFile | Flags.AuthorityFound);                          syntax = UriParser.FileUri;                          idx += 2;                          // V1.1 compat this will simply eat any slashes prepended to a UNC path                          while (idx < length && ((c = uriString[idx]) == '/' || c == '\\'))                              ++idx;                            return idx;                      }                      err = ParsingError.BadFormat;                      return 0;                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _HTTP_Mask0 = 'h' | ('t' << 16) | ((long)'t' << 32) | ((long)'p' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _HTTP_Mask0 = 'h' | ('t' << 16) | ((long)'t' << 32) | ((long)'p' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _HTTP_Mask0 = 'h' | ('t' << 16) | ((long)'t' << 32) | ((long)'p' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const int _WS_Mask = 'w' | ('s' << 16);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _WSS_Mask = 'w' | ('s' << 16) | ((long)'s' << 32) | ((long)':' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _WSS_Mask = 'w' | ('s' << 16) | ((long)'s' << 32) | ((long)':' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _WSS_Mask = 'w' | ('s' << 16) | ((long)'s' << 32) | ((long)':' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _FTP_Mask = 'f' | ('t' << 16) | ((long)'p' << 32) | ((long)':' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _FTP_Mask = 'f' | ('t' << 16) | ((long)'p' << 32) | ((long)':' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _FTP_Mask = 'f' | ('t' << 16) | ((long)'p' << 32) | ((long)':' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _FILE_Mask0 = 'f' | ('i' << 16) | ((long)'l' << 32) | ((long)'e' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _FILE_Mask0 = 'f' | ('i' << 16) | ((long)'l' << 32) | ((long)'e' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _FILE_Mask0 = 'f' | ('i' << 16) | ((long)'l' << 32) | ((long)'e' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _GOPHER_Mask0 = 'g' | ('o' << 16) | ((long)'p' << 32) | ((long)'h' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _GOPHER_Mask0 = 'g' | ('o' << 16) | ((long)'p' << 32) | ((long)'h' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _GOPHER_Mask0 = 'g' | ('o' << 16) | ((long)'p' << 32) | ((long)'h' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const int _GOPHER_Mask1 = 'e' | ('r' << 16);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _MAILTO_Mask0 = 'm' | ('a' << 16) | ((long)'i' << 32) | ((long)'l' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _MAILTO_Mask0 = 'm' | ('a' << 16) | ((long)'i' << 32) | ((long)'l' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _MAILTO_Mask0 = 'm' | ('a' << 16) | ((long)'i' << 32) | ((long)'l' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const int _MAILTO_Mask1 = 't' | ('o' << 16);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _NEWS_Mask0 = 'n' | ('e' << 16) | ((long)'w' << 32) | ((long)'s' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _NEWS_Mask0 = 'n' | ('e' << 16) | ((long)'w' << 32) | ((long)'s' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _NEWS_Mask0 = 'n' | ('e' << 16) | ((long)'w' << 32) | ((long)'s' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _NNTP_Mask0 = 'n' | ('n' << 16) | ((long)'t' << 32) | ((long)'p' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _NNTP_Mask0 = 'n' | ('n' << 16) | ((long)'t' << 32) | ((long)'p' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _NNTP_Mask0 = 'n' | ('n' << 16) | ((long)'t' << 32) | ((long)'p' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _UUID_Mask0 = 'u' | ('u' << 16) | ((long)'i' << 32) | ((long)'d' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _UUID_Mask0 = 'u' | ('u' << 16) | ((long)'i' << 32) | ((long)'d' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _UUID_Mask0 = 'u' | ('u' << 16) | ((long)'i' << 32) | ((long)'d' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _TELNET_Mask0 = 't' | ('e' << 16) | ((long)'l' << 32) | ((long)'n' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _TELNET_Mask0 = 't' | ('e' << 16) | ((long)'l' << 32) | ((long)'n' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _TELNET_Mask0 = 't' | ('e' << 16) | ((long)'l' << 32) | ((long)'n' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const int _TELNET_Mask1 = 'e' | ('t' << 16);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _NETXXX_Mask0 = 'n' | ('e' << 16) | ((long)'t' << 32) | ((long)'.' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _NETXXX_Mask0 = 'n' | ('e' << 16) | ((long)'t' << 32) | ((long)'.' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _NETXXX_Mask0 = 'n' | ('e' << 16) | ((long)'t' << 32) | ((long)'.' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _NETTCP_Mask1 = 't' | ('c' << 16) | ((long)'p' << 32) | ((long)':' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _NETTCP_Mask1 = 't' | ('c' << 16) | ((long)'p' << 32) | ((long)':' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _NETTCP_Mask1 = 't' | ('c' << 16) | ((long)'p' << 32) | ((long)':' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _NETPIPE_Mask1 = 'p' | ('i' << 16) | ((long)'p' << 32) | ((long)'e' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _NETPIPE_Mask1 = 'p' | ('i' << 16) | ((long)'p' << 32) | ((long)'e' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _NETPIPE_Mask1 = 'p' | ('i' << 16) | ((long)'p' << 32) | ((long)'e' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _LDAP_Mask0 = 'l' | ('d' << 16) | ((long)'a' << 32) | ((long)'p' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _LDAP_Mask0 = 'l' | ('d' << 16) | ((long)'a' << 32) | ((long)'p' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: const long _LDAP_Mask0 = 'l' | ('d' << 16) | ((long)'a' << 32) | ((long)'p' << 48);
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: if (nChars == 2)              {                  // This is the only known scheme of length 2                  if ((unchecked((int)*lptr) | _INT_LOWERCASE_Mask) == _WS_Mask)                  {                      syntax = UriParser.WsUri;                      return true;                  }                  return false;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: switch (*lptr | _LOWERCASE_Mask)              {                  case _HTTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.HttpUri;                          return true;                      }                      if (nChars == 5 && ((*(char*)(lptr + 1)) | 0x20) == _HTTPS_Mask1)                      {                          syntax = UriParser.HttpsUri;                          return true;                      }                      break;                  case _WSS_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.WssUri;                          return true;                      }                      break;                  case _FILE_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.FileUri;                          return true;                      }                      break;                  case _FTP_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.FtpUri;                          return true;                      }                      break;                    case _NEWS_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NewsUri;                          return true;                      }                      break;                    case _NNTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NntpUri;                          return true;                      }                      break;                    case _UUID_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.UuidUri;                          return true;                      }                      break;                    case _GOPHER_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _GOPHER_Mask1)                      {                          syntax = UriParser.GopherUri;                          return true;                      }                      break;                  case _MAILTO_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _MAILTO_Mask1)                      {                          syntax = UriParser.MailToUri;                          return true;                      }                      break;                    case _TELNET_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _TELNET_Mask1)                      {                          syntax = UriParser.TelnetUri;                          return true;                      }                      break;                    case _NETXXX_Mask0:                      if (nChars == 8 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETPIPE_Mask1)                      {                          syntax = UriParser.NetPipeUri;                          return true;                      }                      else if (nChars == 7 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETTCP_Mask1)                      {                          syntax = UriParser.NetTcpUri;                          return true;                      }                      break;                    case _LDAP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.LdapUri;                          return true;                      }                      break;                  default: break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: switch (*lptr | _LOWERCASE_Mask)              {                  case _HTTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.HttpUri;                          return true;                      }                      if (nChars == 5 && ((*(char*)(lptr + 1)) | 0x20) == _HTTPS_Mask1)                      {                          syntax = UriParser.HttpsUri;                          return true;                      }                      break;                  case _WSS_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.WssUri;                          return true;                      }                      break;                  case _FILE_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.FileUri;                          return true;                      }                      break;                  case _FTP_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.FtpUri;                          return true;                      }                      break;                    case _NEWS_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NewsUri;                          return true;                      }                      break;                    case _NNTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NntpUri;                          return true;                      }                      break;                    case _UUID_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.UuidUri;                          return true;                      }                      break;                    case _GOPHER_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _GOPHER_Mask1)                      {                          syntax = UriParser.GopherUri;                          return true;                      }                      break;                  case _MAILTO_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _MAILTO_Mask1)                      {                          syntax = UriParser.MailToUri;                          return true;                      }                      break;                    case _TELNET_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _TELNET_Mask1)                      {                          syntax = UriParser.TelnetUri;                          return true;                      }                      break;                    case _NETXXX_Mask0:                      if (nChars == 8 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETPIPE_Mask1)                      {                          syntax = UriParser.NetPipeUri;                          return true;                      }                      else if (nChars == 7 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETTCP_Mask1)                      {                          syntax = UriParser.NetTcpUri;                          return true;                      }                      break;                    case _LDAP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.LdapUri;                          return true;                      }                      break;                  default: break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: switch (*lptr | _LOWERCASE_Mask)              {                  case _HTTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.HttpUri;                          return true;                      }                      if (nChars == 5 && ((*(char*)(lptr + 1)) | 0x20) == _HTTPS_Mask1)                      {                          syntax = UriParser.HttpsUri;                          return true;                      }                      break;                  case _WSS_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.WssUri;                          return true;                      }                      break;                  case _FILE_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.FileUri;                          return true;                      }                      break;                  case _FTP_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.FtpUri;                          return true;                      }                      break;                    case _NEWS_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NewsUri;                          return true;                      }                      break;                    case _NNTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NntpUri;                          return true;                      }                      break;                    case _UUID_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.UuidUri;                          return true;                      }                      break;                    case _GOPHER_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _GOPHER_Mask1)                      {                          syntax = UriParser.GopherUri;                          return true;                      }                      break;                  case _MAILTO_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _MAILTO_Mask1)                      {                          syntax = UriParser.MailToUri;                          return true;                      }                      break;                    case _TELNET_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _TELNET_Mask1)                      {                          syntax = UriParser.TelnetUri;                          return true;                      }                      break;                    case _NETXXX_Mask0:                      if (nChars == 8 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETPIPE_Mask1)                      {                          syntax = UriParser.NetPipeUri;                          return true;                      }                      else if (nChars == 7 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETTCP_Mask1)                      {                          syntax = UriParser.NetTcpUri;                          return true;                      }                      break;                    case _LDAP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.LdapUri;                          return true;                      }                      break;                  default: break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: switch (*lptr | _LOWERCASE_Mask)              {                  case _HTTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.HttpUri;                          return true;                      }                      if (nChars == 5 && ((*(char*)(lptr + 1)) | 0x20) == _HTTPS_Mask1)                      {                          syntax = UriParser.HttpsUri;                          return true;                      }                      break;                  case _WSS_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.WssUri;                          return true;                      }                      break;                  case _FILE_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.FileUri;                          return true;                      }                      break;                  case _FTP_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.FtpUri;                          return true;                      }                      break;                    case _NEWS_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NewsUri;                          return true;                      }                      break;                    case _NNTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NntpUri;                          return true;                      }                      break;                    case _UUID_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.UuidUri;                          return true;                      }                      break;                    case _GOPHER_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _GOPHER_Mask1)                      {                          syntax = UriParser.GopherUri;                          return true;                      }                      break;                  case _MAILTO_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _MAILTO_Mask1)                      {                          syntax = UriParser.MailToUri;                          return true;                      }                      break;                    case _TELNET_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _TELNET_Mask1)                      {                          syntax = UriParser.TelnetUri;                          return true;                      }                      break;                    case _NETXXX_Mask0:                      if (nChars == 8 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETPIPE_Mask1)                      {                          syntax = UriParser.NetPipeUri;                          return true;                      }                      else if (nChars == 7 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETTCP_Mask1)                      {                          syntax = UriParser.NetTcpUri;                          return true;                      }                      break;                    case _LDAP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.LdapUri;                          return true;                      }                      break;                  default: break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: switch (*lptr | _LOWERCASE_Mask)              {                  case _HTTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.HttpUri;                          return true;                      }                      if (nChars == 5 && ((*(char*)(lptr + 1)) | 0x20) == _HTTPS_Mask1)                      {                          syntax = UriParser.HttpsUri;                          return true;                      }                      break;                  case _WSS_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.WssUri;                          return true;                      }                      break;                  case _FILE_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.FileUri;                          return true;                      }                      break;                  case _FTP_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.FtpUri;                          return true;                      }                      break;                    case _NEWS_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NewsUri;                          return true;                      }                      break;                    case _NNTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NntpUri;                          return true;                      }                      break;                    case _UUID_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.UuidUri;                          return true;                      }                      break;                    case _GOPHER_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _GOPHER_Mask1)                      {                          syntax = UriParser.GopherUri;                          return true;                      }                      break;                  case _MAILTO_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _MAILTO_Mask1)                      {                          syntax = UriParser.MailToUri;                          return true;                      }                      break;                    case _TELNET_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _TELNET_Mask1)                      {                          syntax = UriParser.TelnetUri;                          return true;                      }                      break;                    case _NETXXX_Mask0:                      if (nChars == 8 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETPIPE_Mask1)                      {                          syntax = UriParser.NetPipeUri;                          return true;                      }                      else if (nChars == 7 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETTCP_Mask1)                      {                          syntax = UriParser.NetTcpUri;                          return true;                      }                      break;                    case _LDAP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.LdapUri;                          return true;                      }                      break;                  default: break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: switch (*lptr | _LOWERCASE_Mask)              {                  case _HTTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.HttpUri;                          return true;                      }                      if (nChars == 5 && ((*(char*)(lptr + 1)) | 0x20) == _HTTPS_Mask1)                      {                          syntax = UriParser.HttpsUri;                          return true;                      }                      break;                  case _WSS_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.WssUri;                          return true;                      }                      break;                  case _FILE_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.FileUri;                          return true;                      }                      break;                  case _FTP_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.FtpUri;                          return true;                      }                      break;                    case _NEWS_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NewsUri;                          return true;                      }                      break;                    case _NNTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NntpUri;                          return true;                      }                      break;                    case _UUID_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.UuidUri;                          return true;                      }                      break;                    case _GOPHER_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _GOPHER_Mask1)                      {                          syntax = UriParser.GopherUri;                          return true;                      }                      break;                  case _MAILTO_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _MAILTO_Mask1)                      {                          syntax = UriParser.MailToUri;                          return true;                      }                      break;                    case _TELNET_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _TELNET_Mask1)                      {                          syntax = UriParser.TelnetUri;                          return true;                      }                      break;                    case _NETXXX_Mask0:                      if (nChars == 8 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETPIPE_Mask1)                      {                          syntax = UriParser.NetPipeUri;                          return true;                      }                      else if (nChars == 7 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETTCP_Mask1)                      {                          syntax = UriParser.NetTcpUri;                          return true;                      }                      break;                    case _LDAP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.LdapUri;                          return true;                      }                      break;                  default: break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: switch (*lptr | _LOWERCASE_Mask)              {                  case _HTTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.HttpUri;                          return true;                      }                      if (nChars == 5 && ((*(char*)(lptr + 1)) | 0x20) == _HTTPS_Mask1)                      {                          syntax = UriParser.HttpsUri;                          return true;                      }                      break;                  case _WSS_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.WssUri;                          return true;                      }                      break;                  case _FILE_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.FileUri;                          return true;                      }                      break;                  case _FTP_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.FtpUri;                          return true;                      }                      break;                    case _NEWS_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NewsUri;                          return true;                      }                      break;                    case _NNTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NntpUri;                          return true;                      }                      break;                    case _UUID_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.UuidUri;                          return true;                      }                      break;                    case _GOPHER_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _GOPHER_Mask1)                      {                          syntax = UriParser.GopherUri;                          return true;                      }                      break;                  case _MAILTO_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _MAILTO_Mask1)                      {                          syntax = UriParser.MailToUri;                          return true;                      }                      break;                    case _TELNET_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _TELNET_Mask1)                      {                          syntax = UriParser.TelnetUri;                          return true;                      }                      break;                    case _NETXXX_Mask0:                      if (nChars == 8 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETPIPE_Mask1)                      {                          syntax = UriParser.NetPipeUri;                          return true;                      }                      else if (nChars == 7 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETTCP_Mask1)                      {                          syntax = UriParser.NetTcpUri;                          return true;                      }                      break;                    case _LDAP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.LdapUri;                          return true;                      }                      break;                  default: break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: switch (*lptr | _LOWERCASE_Mask)              {                  case _HTTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.HttpUri;                          return true;                      }                      if (nChars == 5 && ((*(char*)(lptr + 1)) | 0x20) == _HTTPS_Mask1)                      {                          syntax = UriParser.HttpsUri;                          return true;                      }                      break;                  case _WSS_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.WssUri;                          return true;                      }                      break;                  case _FILE_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.FileUri;                          return true;                      }                      break;                  case _FTP_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.FtpUri;                          return true;                      }                      break;                    case _NEWS_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NewsUri;                          return true;                      }                      break;                    case _NNTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NntpUri;                          return true;                      }                      break;                    case _UUID_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.UuidUri;                          return true;                      }                      break;                    case _GOPHER_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _GOPHER_Mask1)                      {                          syntax = UriParser.GopherUri;                          return true;                      }                      break;                  case _MAILTO_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _MAILTO_Mask1)                      {                          syntax = UriParser.MailToUri;                          return true;                      }                      break;                    case _TELNET_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _TELNET_Mask1)                      {                          syntax = UriParser.TelnetUri;                          return true;                      }                      break;                    case _NETXXX_Mask0:                      if (nChars == 8 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETPIPE_Mask1)                      {                          syntax = UriParser.NetPipeUri;                          return true;                      }                      else if (nChars == 7 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETTCP_Mask1)                      {                          syntax = UriParser.NetTcpUri;                          return true;                      }                      break;                    case _LDAP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.LdapUri;                          return true;                      }                      break;                  default: break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: switch (*lptr | _LOWERCASE_Mask)              {                  case _HTTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.HttpUri;                          return true;                      }                      if (nChars == 5 && ((*(char*)(lptr + 1)) | 0x20) == _HTTPS_Mask1)                      {                          syntax = UriParser.HttpsUri;                          return true;                      }                      break;                  case _WSS_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.WssUri;                          return true;                      }                      break;                  case _FILE_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.FileUri;                          return true;                      }                      break;                  case _FTP_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.FtpUri;                          return true;                      }                      break;                    case _NEWS_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NewsUri;                          return true;                      }                      break;                    case _NNTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NntpUri;                          return true;                      }                      break;                    case _UUID_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.UuidUri;                          return true;                      }                      break;                    case _GOPHER_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _GOPHER_Mask1)                      {                          syntax = UriParser.GopherUri;                          return true;                      }                      break;                  case _MAILTO_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _MAILTO_Mask1)                      {                          syntax = UriParser.MailToUri;                          return true;                      }                      break;                    case _TELNET_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _TELNET_Mask1)                      {                          syntax = UriParser.TelnetUri;                          return true;                      }                      break;                    case _NETXXX_Mask0:                      if (nChars == 8 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETPIPE_Mask1)                      {                          syntax = UriParser.NetPipeUri;                          return true;                      }                      else if (nChars == 7 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETTCP_Mask1)                      {                          syntax = UriParser.NetTcpUri;                          return true;                      }                      break;                    case _LDAP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.LdapUri;                          return true;                      }                      break;                  default: break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: switch (*lptr | _LOWERCASE_Mask)              {                  case _HTTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.HttpUri;                          return true;                      }                      if (nChars == 5 && ((*(char*)(lptr + 1)) | 0x20) == _HTTPS_Mask1)                      {                          syntax = UriParser.HttpsUri;                          return true;                      }                      break;                  case _WSS_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.WssUri;                          return true;                      }                      break;                  case _FILE_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.FileUri;                          return true;                      }                      break;                  case _FTP_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.FtpUri;                          return true;                      }                      break;                    case _NEWS_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NewsUri;                          return true;                      }                      break;                    case _NNTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NntpUri;                          return true;                      }                      break;                    case _UUID_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.UuidUri;                          return true;                      }                      break;                    case _GOPHER_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _GOPHER_Mask1)                      {                          syntax = UriParser.GopherUri;                          return true;                      }                      break;                  case _MAILTO_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _MAILTO_Mask1)                      {                          syntax = UriParser.MailToUri;                          return true;                      }                      break;                    case _TELNET_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _TELNET_Mask1)                      {                          syntax = UriParser.TelnetUri;                          return true;                      }                      break;                    case _NETXXX_Mask0:                      if (nChars == 8 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETPIPE_Mask1)                      {                          syntax = UriParser.NetPipeUri;                          return true;                      }                      else if (nChars == 7 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETTCP_Mask1)                      {                          syntax = UriParser.NetTcpUri;                          return true;                      }                      break;                    case _LDAP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.LdapUri;                          return true;                      }                      break;                  default: break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: switch (*lptr | _LOWERCASE_Mask)              {                  case _HTTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.HttpUri;                          return true;                      }                      if (nChars == 5 && ((*(char*)(lptr + 1)) | 0x20) == _HTTPS_Mask1)                      {                          syntax = UriParser.HttpsUri;                          return true;                      }                      break;                  case _WSS_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.WssUri;                          return true;                      }                      break;                  case _FILE_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.FileUri;                          return true;                      }                      break;                  case _FTP_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.FtpUri;                          return true;                      }                      break;                    case _NEWS_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NewsUri;                          return true;                      }                      break;                    case _NNTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NntpUri;                          return true;                      }                      break;                    case _UUID_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.UuidUri;                          return true;                      }                      break;                    case _GOPHER_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _GOPHER_Mask1)                      {                          syntax = UriParser.GopherUri;                          return true;                      }                      break;                  case _MAILTO_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _MAILTO_Mask1)                      {                          syntax = UriParser.MailToUri;                          return true;                      }                      break;                    case _TELNET_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _TELNET_Mask1)                      {                          syntax = UriParser.TelnetUri;                          return true;                      }                      break;                    case _NETXXX_Mask0:                      if (nChars == 8 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETPIPE_Mask1)                      {                          syntax = UriParser.NetPipeUri;                          return true;                      }                      else if (nChars == 7 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETTCP_Mask1)                      {                          syntax = UriParser.NetTcpUri;                          return true;                      }                      break;                    case _LDAP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.LdapUri;                          return true;                      }                      break;                  default: break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: switch (*lptr | _LOWERCASE_Mask)              {                  case _HTTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.HttpUri;                          return true;                      }                      if (nChars == 5 && ((*(char*)(lptr + 1)) | 0x20) == _HTTPS_Mask1)                      {                          syntax = UriParser.HttpsUri;                          return true;                      }                      break;                  case _WSS_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.WssUri;                          return true;                      }                      break;                  case _FILE_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.FileUri;                          return true;                      }                      break;                  case _FTP_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.FtpUri;                          return true;                      }                      break;                    case _NEWS_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NewsUri;                          return true;                      }                      break;                    case _NNTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NntpUri;                          return true;                      }                      break;                    case _UUID_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.UuidUri;                          return true;                      }                      break;                    case _GOPHER_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _GOPHER_Mask1)                      {                          syntax = UriParser.GopherUri;                          return true;                      }                      break;                  case _MAILTO_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _MAILTO_Mask1)                      {                          syntax = UriParser.MailToUri;                          return true;                      }                      break;                    case _TELNET_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _TELNET_Mask1)                      {                          syntax = UriParser.TelnetUri;                          return true;                      }                      break;                    case _NETXXX_Mask0:                      if (nChars == 8 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETPIPE_Mask1)                      {                          syntax = UriParser.NetPipeUri;                          return true;                      }                      else if (nChars == 7 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETTCP_Mask1)                      {                          syntax = UriParser.NetTcpUri;                          return true;                      }                      break;                    case _LDAP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.LdapUri;                          return true;                      }                      break;                  default: break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: switch (*lptr | _LOWERCASE_Mask)              {                  case _HTTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.HttpUri;                          return true;                      }                      if (nChars == 5 && ((*(char*)(lptr + 1)) | 0x20) == _HTTPS_Mask1)                      {                          syntax = UriParser.HttpsUri;                          return true;                      }                      break;                  case _WSS_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.WssUri;                          return true;                      }                      break;                  case _FILE_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.FileUri;                          return true;                      }                      break;                  case _FTP_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.FtpUri;                          return true;                      }                      break;                    case _NEWS_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NewsUri;                          return true;                      }                      break;                    case _NNTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NntpUri;                          return true;                      }                      break;                    case _UUID_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.UuidUri;                          return true;                      }                      break;                    case _GOPHER_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _GOPHER_Mask1)                      {                          syntax = UriParser.GopherUri;                          return true;                      }                      break;                  case _MAILTO_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _MAILTO_Mask1)                      {                          syntax = UriParser.MailToUri;                          return true;                      }                      break;                    case _TELNET_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _TELNET_Mask1)                      {                          syntax = UriParser.TelnetUri;                          return true;                      }                      break;                    case _NETXXX_Mask0:                      if (nChars == 8 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETPIPE_Mask1)                      {                          syntax = UriParser.NetPipeUri;                          return true;                      }                      else if (nChars == 7 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETTCP_Mask1)                      {                          syntax = UriParser.NetTcpUri;                          return true;                      }                      break;                    case _LDAP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.LdapUri;                          return true;                      }                      break;                  default: break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckKnownSchemes,The following statement contains a magic number: switch (*lptr | _LOWERCASE_Mask)              {                  case _HTTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.HttpUri;                          return true;                      }                      if (nChars == 5 && ((*(char*)(lptr + 1)) | 0x20) == _HTTPS_Mask1)                      {                          syntax = UriParser.HttpsUri;                          return true;                      }                      break;                  case _WSS_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.WssUri;                          return true;                      }                      break;                  case _FILE_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.FileUri;                          return true;                      }                      break;                  case _FTP_Mask:                      if (nChars == 3)                      {                          syntax = UriParser.FtpUri;                          return true;                      }                      break;                    case _NEWS_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NewsUri;                          return true;                      }                      break;                    case _NNTP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.NntpUri;                          return true;                      }                      break;                    case _UUID_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.UuidUri;                          return true;                      }                      break;                    case _GOPHER_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _GOPHER_Mask1)                      {                          syntax = UriParser.GopherUri;                          return true;                      }                      break;                  case _MAILTO_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _MAILTO_Mask1)                      {                          syntax = UriParser.MailToUri;                          return true;                      }                      break;                    case _TELNET_Mask0:                      if (nChars == 6 && (*(int*)(lptr + 1) | _INT_LOWERCASE_Mask) == _TELNET_Mask1)                      {                          syntax = UriParser.TelnetUri;                          return true;                      }                      break;                    case _NETXXX_Mask0:                      if (nChars == 8 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETPIPE_Mask1)                      {                          syntax = UriParser.NetPipeUri;                          return true;                      }                      else if (nChars == 7 && (*(lptr + 1) | _LOWERCASE_Mask) == _NETTCP_Mask1)                      {                          syntax = UriParser.NetTcpUri;                          return true;                      }                      break;                    case _LDAP_Mask0:                      if (nChars == 4)                      {                          syntax = UriParser.LdapUri;                          return true;                      }                      break;                  default: break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following statement contains a magic number: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckAuthorityHelper,The following statement contains a magic number: if (end < length && pString[end] == '\\' && (flags & Flags.HostTypeMask) != Flags.HostNotParsed                  && !StaticIsFile(syntax))              {                  if (syntax.InFact(UriSyntaxFlags.V1_UnknownUri))                  {                      err = ParsingError.BadHostName;                      flags |= Flags.UnknownHostType;                      return (ushort)end;                  }                  flags &= ~Flags.HostTypeMask;              }              // Here we have checked the syntax up to the end of host              // The only thing that can cause an exception is the port value              // Spend some (duplicated) cycles on that.              else if (end < length && pString[end] == ':')              {                  if (syntax.InFact(UriSyntaxFlags.MayHavePort))                  {                      int port = 0;                      int startPort = end;                      for (idx = (ushort)(end + 1); idx < length; ++idx)                      {                          ushort val = unchecked((ushort)((ushort)pString[idx] - (ushort)'0'));                          if ((val >= 0) && (val <= 9))                          {                              if ((port = (port * 10 + val)) > 0xFFFF)                                  break;                          }                          else if (val == unchecked((ushort)('/' - '0')) || val == (ushort)('?' - '0')                              || val == unchecked((ushort)('#' - '0')))                          {                              break;                          }                          else                          {                              // The second check is to keep compatibility with V1 until the UriParser is registered                              if (syntax.InFact(UriSyntaxFlags.AllowAnyOtherHost)                                  && syntax.NotAny(UriSyntaxFlags.V1_UnknownUri))                              {                                  flags &= ~Flags.HostTypeMask;                                  break;                              }                              else                              {                                  err = ParsingError.BadPort;                                  return idx;                              }                          }                      }                      // check on 0-ffff range                      if (port > 0xFFFF)                      {                          if (syntax.InFact(UriSyntaxFlags.AllowAnyOtherHost))                          {                              flags &= ~Flags.HostTypeMask;                          }                          else                          {                              err = ParsingError.BadPort;                              return idx;                          }                      }                        if (iriParsing && hasUnicode && justNormalized)                      {                          newHost += new string(pString' startPort' idx - startPort);                      }                  }                  else                  {                      flags &= ~Flags.HostTypeMask;                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckAuthorityHelper,The following statement contains a magic number: if (end < length && pString[end] == '\\' && (flags & Flags.HostTypeMask) != Flags.HostNotParsed                  && !StaticIsFile(syntax))              {                  if (syntax.InFact(UriSyntaxFlags.V1_UnknownUri))                  {                      err = ParsingError.BadHostName;                      flags |= Flags.UnknownHostType;                      return (ushort)end;                  }                  flags &= ~Flags.HostTypeMask;              }              // Here we have checked the syntax up to the end of host              // The only thing that can cause an exception is the port value              // Spend some (duplicated) cycles on that.              else if (end < length && pString[end] == ':')              {                  if (syntax.InFact(UriSyntaxFlags.MayHavePort))                  {                      int port = 0;                      int startPort = end;                      for (idx = (ushort)(end + 1); idx < length; ++idx)                      {                          ushort val = unchecked((ushort)((ushort)pString[idx] - (ushort)'0'));                          if ((val >= 0) && (val <= 9))                          {                              if ((port = (port * 10 + val)) > 0xFFFF)                                  break;                          }                          else if (val == unchecked((ushort)('/' - '0')) || val == (ushort)('?' - '0')                              || val == unchecked((ushort)('#' - '0')))                          {                              break;                          }                          else                          {                              // The second check is to keep compatibility with V1 until the UriParser is registered                              if (syntax.InFact(UriSyntaxFlags.AllowAnyOtherHost)                                  && syntax.NotAny(UriSyntaxFlags.V1_UnknownUri))                              {                                  flags &= ~Flags.HostTypeMask;                                  break;                              }                              else                              {                                  err = ParsingError.BadPort;                                  return idx;                              }                          }                      }                      // check on 0-ffff range                      if (port > 0xFFFF)                      {                          if (syntax.InFact(UriSyntaxFlags.AllowAnyOtherHost))                          {                              flags &= ~Flags.HostTypeMask;                          }                          else                          {                              err = ParsingError.BadPort;                              return idx;                          }                      }                        if (iriParsing && hasUnicode && justNormalized)                      {                          newHost += new string(pString' startPort' idx - startPort);                      }                  }                  else                  {                      flags &= ~Flags.HostTypeMask;                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckAuthorityHelper,The following statement contains a magic number: if ((flags & Flags.HostTypeMask) == Flags.HostNotParsed)              {                  //No user info for a Basic hostname                  flags &= ~Flags.HasUserInfo;                  // Some schemes do not allow HostType = Basic (plus V1 almost never understands this issue)                  //                  if (syntax.InFact(UriSyntaxFlags.AllowAnyOtherHost))                  {                      flags |= Flags.BasicHostType;                      for (end = idx; end < length; ++end)                      {                          if (pString[end] == '/' || (pString[end] == '?' || pString[end] == '#'))                          {                              break;                          }                      }                      CheckAuthorityHelperHandleAnyHostIri(pString' startInput' end' iriParsing' hasUnicode' syntax'                                                              ref flags' ref newHost' ref err);                  }                  else                  {                      //                      // ATTN V1 compat: V1 supports hostnames like ".." and "."' and so we do but only for unknown schemes.                      //                      if (syntax.InFact(UriSyntaxFlags.V1_UnknownUri))                      {                          // Can assert here that the host is not empty so we will set dotFound                          // at least once or fail before exiting the loop                          bool dotFound = false;                          int startOtherHost = idx;                          for (end = idx; end < length; ++end)                          {                              if (dotFound && (pString[end] == '/' || pString[end] == '?' || pString[end] == '#'))                                  break;                              else if (end < (idx + 2) && pString[end] == '.')                              {                                  // allow one or two dots                                  dotFound = true;                              }                              else                              {                                  //failure                                  err = ParsingError.BadHostName;                                  flags |= Flags.UnknownHostType;                                  return idx;                              }                          }                          //success                          flags |= Flags.BasicHostType;                            if (iriParsing && hasUnicode                              && StaticNotAny(flags' Flags.HostUnicodeNormalized))                          {                              // Normalize any other host                              string user = new string(pString' startOtherHost' end - startOtherHost);                              try                              {                                  newHost += user.Normalize(NormalizationForm.FormC);                              }                              catch (ArgumentException)                              {                                  err = ParsingError.BadFormat;                                  return idx;                              }                                flags |= Flags.HostUnicodeNormalized;                          }                      }                      else if (syntax.InFact(UriSyntaxFlags.MustHaveAuthority) ||                               (syntax.InFact(UriSyntaxFlags.MailToLikeUri)))                      {                          err = ParsingError.BadHostName;                          flags |= Flags.UnknownHostType;                          return idx;                      }                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckCanonical,The following statement contains a magic number: for (; i < end; ++i)              {                  c = str[i];                  // Control chars usually should be escaped in any case                  if (c <= '\x1F' || (c >= '\x7F' && c <= '\x9F'))                  {                      needsEscaping = true;                      foundEscaping = true;                      res |= Check.ReservedFound;                  }                  else if (c > 'z' && c != '~')                  {                      if (_iriParsing)                      {                          bool valid = false;                          res |= Check.FoundNonAscii;                            if (char.IsHighSurrogate(c))                          {                              if ((i + 1) < end)                              {                                  bool surrPair = false;                                  valid = IriHelper.CheckIriUnicodeRange(c' str[i + 1]' ref surrPair' true);                              }                          }                          else                          {                              valid = IriHelper.CheckIriUnicodeRange(c' true);                          }                          if (!valid) res |= Check.NotIriCanonical;                      }                        if (!needsEscaping) needsEscaping = true;                  }                  else if (c == delim)                  {                      break;                  }                  else if (delim == '?' && c == '#' && (_syntax != null && _syntax.InFact(UriSyntaxFlags.MayHaveFragment)))                  {                      // this is a special case when deciding on Query/Fragment                      break;                  }                  else if (c == '?')                  {                      if (IsImplicitFile || (_syntax != null && !_syntax.InFact(UriSyntaxFlags.MayHaveQuery)                          && delim != c_EOL))                      {                          // If found as reserved this char is not suitable for safe unescaped display                          // Will need to escape it when both escaping and unescaping the string                          res |= Check.ReservedFound;                          foundEscaping = true;                          needsEscaping = true;                      }                  }                  else if (c == '#')                  {                      needsEscaping = true;                      if (IsImplicitFile || (_syntax != null && !_syntax.InFact(UriSyntaxFlags.MayHaveFragment)))                      {                          // If found as reserved this char is not suitable for safe unescaped display                          // Will need to escape it when both escaping and unescaping the string                          res |= Check.ReservedFound;                          foundEscaping = true;                      }                  }                  else if (c == '/' || c == '\\')                  {                      if ((res & Check.BackslashInPath) == 0 && c == '\\')                      {                          res |= Check.BackslashInPath;                      }                      if ((res & Check.DotSlashAttn) == 0 && i + 1 != end && (str[i + 1] == '/' || str[i + 1] == '\\'))                      {                          res |= Check.DotSlashAttn;                      }                  }                  else if (c == '.')                  {                      if ((res & Check.DotSlashAttn) == 0 && i + 1 == end || str[i + 1] == '.' || str[i + 1] == '/'                          || str[i + 1] == '\\' || str[i + 1] == '?' || str[i + 1] == '#')                      {                          res |= Check.DotSlashAttn;                      }                  }                  else if (!needsEscaping && ((c <= '"' && c != '!') || (c >= '[' && c <= '^') || c == '>'                      || c == '<' || c == '`'))                  {                      needsEscaping = true;                  }                  else if (c == '%')                  {                      if (!foundEscaping) foundEscaping = true;                      //try unescape a byte hex escaping                      if (i + 2 < end && (c = UriHelper.EscapedAscii(str[i + 1]' str[i + 2])) != c_DummyChar)                      {                          if (c == '.' || c == '/' || c == '\\')                          {                              res |= Check.DotSlashEscaped;                          }                          i += 2;                          continue;                      }                      // otherwise we follow to non escaped case                      if (!needsEscaping)                      {                          needsEscaping = true;                      }                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckCanonical,The following statement contains a magic number: for (; i < end; ++i)              {                  c = str[i];                  // Control chars usually should be escaped in any case                  if (c <= '\x1F' || (c >= '\x7F' && c <= '\x9F'))                  {                      needsEscaping = true;                      foundEscaping = true;                      res |= Check.ReservedFound;                  }                  else if (c > 'z' && c != '~')                  {                      if (_iriParsing)                      {                          bool valid = false;                          res |= Check.FoundNonAscii;                            if (char.IsHighSurrogate(c))                          {                              if ((i + 1) < end)                              {                                  bool surrPair = false;                                  valid = IriHelper.CheckIriUnicodeRange(c' str[i + 1]' ref surrPair' true);                              }                          }                          else                          {                              valid = IriHelper.CheckIriUnicodeRange(c' true);                          }                          if (!valid) res |= Check.NotIriCanonical;                      }                        if (!needsEscaping) needsEscaping = true;                  }                  else if (c == delim)                  {                      break;                  }                  else if (delim == '?' && c == '#' && (_syntax != null && _syntax.InFact(UriSyntaxFlags.MayHaveFragment)))                  {                      // this is a special case when deciding on Query/Fragment                      break;                  }                  else if (c == '?')                  {                      if (IsImplicitFile || (_syntax != null && !_syntax.InFact(UriSyntaxFlags.MayHaveQuery)                          && delim != c_EOL))                      {                          // If found as reserved this char is not suitable for safe unescaped display                          // Will need to escape it when both escaping and unescaping the string                          res |= Check.ReservedFound;                          foundEscaping = true;                          needsEscaping = true;                      }                  }                  else if (c == '#')                  {                      needsEscaping = true;                      if (IsImplicitFile || (_syntax != null && !_syntax.InFact(UriSyntaxFlags.MayHaveFragment)))                      {                          // If found as reserved this char is not suitable for safe unescaped display                          // Will need to escape it when both escaping and unescaping the string                          res |= Check.ReservedFound;                          foundEscaping = true;                      }                  }                  else if (c == '/' || c == '\\')                  {                      if ((res & Check.BackslashInPath) == 0 && c == '\\')                      {                          res |= Check.BackslashInPath;                      }                      if ((res & Check.DotSlashAttn) == 0 && i + 1 != end && (str[i + 1] == '/' || str[i + 1] == '\\'))                      {                          res |= Check.DotSlashAttn;                      }                  }                  else if (c == '.')                  {                      if ((res & Check.DotSlashAttn) == 0 && i + 1 == end || str[i + 1] == '.' || str[i + 1] == '/'                          || str[i + 1] == '\\' || str[i + 1] == '?' || str[i + 1] == '#')                      {                          res |= Check.DotSlashAttn;                      }                  }                  else if (!needsEscaping && ((c <= '"' && c != '!') || (c >= '[' && c <= '^') || c == '>'                      || c == '<' || c == '`'))                  {                      needsEscaping = true;                  }                  else if (c == '%')                  {                      if (!foundEscaping) foundEscaping = true;                      //try unescape a byte hex escaping                      if (i + 2 < end && (c = UriHelper.EscapedAscii(str[i + 1]' str[i + 2])) != c_DummyChar)                      {                          if (c == '.' || c == '/' || c == '\\')                          {                              res |= Check.DotSlashEscaped;                          }                          i += 2;                          continue;                      }                      // otherwise we follow to non escaped case                      if (!needsEscaping)                      {                          needsEscaping = true;                      }                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckCanonical,The following statement contains a magic number: for (; i < end; ++i)              {                  c = str[i];                  // Control chars usually should be escaped in any case                  if (c <= '\x1F' || (c >= '\x7F' && c <= '\x9F'))                  {                      needsEscaping = true;                      foundEscaping = true;                      res |= Check.ReservedFound;                  }                  else if (c > 'z' && c != '~')                  {                      if (_iriParsing)                      {                          bool valid = false;                          res |= Check.FoundNonAscii;                            if (char.IsHighSurrogate(c))                          {                              if ((i + 1) < end)                              {                                  bool surrPair = false;                                  valid = IriHelper.CheckIriUnicodeRange(c' str[i + 1]' ref surrPair' true);                              }                          }                          else                          {                              valid = IriHelper.CheckIriUnicodeRange(c' true);                          }                          if (!valid) res |= Check.NotIriCanonical;                      }                        if (!needsEscaping) needsEscaping = true;                  }                  else if (c == delim)                  {                      break;                  }                  else if (delim == '?' && c == '#' && (_syntax != null && _syntax.InFact(UriSyntaxFlags.MayHaveFragment)))                  {                      // this is a special case when deciding on Query/Fragment                      break;                  }                  else if (c == '?')                  {                      if (IsImplicitFile || (_syntax != null && !_syntax.InFact(UriSyntaxFlags.MayHaveQuery)                          && delim != c_EOL))                      {                          // If found as reserved this char is not suitable for safe unescaped display                          // Will need to escape it when both escaping and unescaping the string                          res |= Check.ReservedFound;                          foundEscaping = true;                          needsEscaping = true;                      }                  }                  else if (c == '#')                  {                      needsEscaping = true;                      if (IsImplicitFile || (_syntax != null && !_syntax.InFact(UriSyntaxFlags.MayHaveFragment)))                      {                          // If found as reserved this char is not suitable for safe unescaped display                          // Will need to escape it when both escaping and unescaping the string                          res |= Check.ReservedFound;                          foundEscaping = true;                      }                  }                  else if (c == '/' || c == '\\')                  {                      if ((res & Check.BackslashInPath) == 0 && c == '\\')                      {                          res |= Check.BackslashInPath;                      }                      if ((res & Check.DotSlashAttn) == 0 && i + 1 != end && (str[i + 1] == '/' || str[i + 1] == '\\'))                      {                          res |= Check.DotSlashAttn;                      }                  }                  else if (c == '.')                  {                      if ((res & Check.DotSlashAttn) == 0 && i + 1 == end || str[i + 1] == '.' || str[i + 1] == '/'                          || str[i + 1] == '\\' || str[i + 1] == '?' || str[i + 1] == '#')                      {                          res |= Check.DotSlashAttn;                      }                  }                  else if (!needsEscaping && ((c <= '"' && c != '!') || (c >= '[' && c <= '^') || c == '>'                      || c == '<' || c == '`'))                  {                      needsEscaping = true;                  }                  else if (c == '%')                  {                      if (!foundEscaping) foundEscaping = true;                      //try unescape a byte hex escaping                      if (i + 2 < end && (c = UriHelper.EscapedAscii(str[i + 1]' str[i + 2])) != c_DummyChar)                      {                          if (c == '.' || c == '/' || c == '\\')                          {                              res |= Check.DotSlashEscaped;                          }                          i += 2;                          continue;                      }                      // otherwise we follow to non escaped case                      if (!needsEscaping)                      {                          needsEscaping = true;                      }                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,UnescapeOnly,The following statement contains a magic number: if (end - start < 3)              {                  //no chance that something is escaped                  return;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,UnescapeOnly,The following statement contains a magic number: char* pend = pch + end - 2;
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,UnescapeOnly,The following statement contains a magic number: pnew = pch - 2;
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,UnescapeOnly,The following statement contains a magic number: pnew -= 2;
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,UnescapeOnly,The following statement contains a magic number: done:              pend += 2;
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,Compress,The following statement contains a magic number: unchecked              {                  //ushort i == -1 and start == -1 overflow is ok here                  ushort i = (ushort)((ushort)destLength - (ushort)1);                  start = (ushort)(start - 1);                    for (; i != start; --i)                  {                      char ch = dest[i];                      if (ch == '\\' && syntax.InFact(UriSyntaxFlags.ConvertPathSlashes))                      {                          dest[i] = ch = '/';                      }                        //                      // compress multiple '/' for file URI                      //                      if (ch == '/')                      {                          ++slashCount;                      }                      else                      {                          if (slashCount > 1)                          {                              // else preserve repeated slashes                              lastSlash = (ushort)(i + 1);                          }                          slashCount = 0;                      }                        if (ch == '.')                      {                          ++dotCount;                          continue;                      }                      else if (dotCount != 0)                      {                          bool skipSegment = syntax.NotAny(UriSyntaxFlags.CanonicalizeAsFilePath)                              && (dotCount > 2 || ch != '/' || i == start);                            //                          // Cases:                          // /./                  = remove this segment                           // /../                 = remove this segment' mark next for removal                          // /....x               = DO NOT TOUCH' leave as is                          // x.../                = DO NOT TOUCH' leave as is' except for V2 legacy mode                          //                          if (!skipSegment && ch == '/')                          {                              if ((lastSlash == i + dotCount + 1 // "/..../"                                      || (lastSlash == 0 && i + dotCount + 1 == destLength)) // "/..."                                  && (dotCount <= 2))                              {                                  //                                  //  /./ or /.<eos> or /../ or /..<eos>                                  //                                  // just reusing a variable slot we perform //dest.Remove(i+1' dotCount + (lastSlash==0?0:1));                                  lastSlash = (ushort)(i + 1 + dotCount + (lastSlash == 0 ? 0 : 1));                                  Buffer.BlockCopy(dest' lastSlash << 1' dest' (i + 1) << 1' (destLength - lastSlash) << 1);                                  destLength -= (lastSlash - i - 1);                                    lastSlash = i;                                  if (dotCount == 2)                                  {                                      //                                      // We have 2 dots in between like /../ or /..<eos>'                                      // Mark next segment for removal and remove this /../ or /..                                      //                                      ++removeSegments;                                  }                                  dotCount = 0;                                  continue;                              }                          }                          // .NET 4.5 no longer removes trailing dots in a path segment x.../  or  x...<eos>                          dotCount = 0;                            //                          // Here all other cases go such as                          // x.[..]y or /.[..]x or (/x.[...][/] && removeSegments !=0)                      }                        //                      // Now we may want to remove a segment because of previous /../                      //                      if (ch == '/')                      {                          if (removeSegments != 0)                          {                              --removeSegments;                                // just reusing a variable slot we perform //dest.Remove(i+1' lastSlash - i);                              lastSlash = (ushort)(lastSlash + 1);                              Buffer.BlockCopy(dest' lastSlash << 1' dest' (i + 1) << 1' (destLength - lastSlash) << 1);                              destLength -= (lastSlash - i - 1);                          }                          lastSlash = i;                      }                  }                    start = (ushort)((ushort)start + (ushort)1);              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,Compress,The following statement contains a magic number: unchecked              {                  //ushort i == -1 and start == -1 overflow is ok here                  ushort i = (ushort)((ushort)destLength - (ushort)1);                  start = (ushort)(start - 1);                    for (; i != start; --i)                  {                      char ch = dest[i];                      if (ch == '\\' && syntax.InFact(UriSyntaxFlags.ConvertPathSlashes))                      {                          dest[i] = ch = '/';                      }                        //                      // compress multiple '/' for file URI                      //                      if (ch == '/')                      {                          ++slashCount;                      }                      else                      {                          if (slashCount > 1)                          {                              // else preserve repeated slashes                              lastSlash = (ushort)(i + 1);                          }                          slashCount = 0;                      }                        if (ch == '.')                      {                          ++dotCount;                          continue;                      }                      else if (dotCount != 0)                      {                          bool skipSegment = syntax.NotAny(UriSyntaxFlags.CanonicalizeAsFilePath)                              && (dotCount > 2 || ch != '/' || i == start);                            //                          // Cases:                          // /./                  = remove this segment                           // /../                 = remove this segment' mark next for removal                          // /....x               = DO NOT TOUCH' leave as is                          // x.../                = DO NOT TOUCH' leave as is' except for V2 legacy mode                          //                          if (!skipSegment && ch == '/')                          {                              if ((lastSlash == i + dotCount + 1 // "/..../"                                      || (lastSlash == 0 && i + dotCount + 1 == destLength)) // "/..."                                  && (dotCount <= 2))                              {                                  //                                  //  /./ or /.<eos> or /../ or /..<eos>                                  //                                  // just reusing a variable slot we perform //dest.Remove(i+1' dotCount + (lastSlash==0?0:1));                                  lastSlash = (ushort)(i + 1 + dotCount + (lastSlash == 0 ? 0 : 1));                                  Buffer.BlockCopy(dest' lastSlash << 1' dest' (i + 1) << 1' (destLength - lastSlash) << 1);                                  destLength -= (lastSlash - i - 1);                                    lastSlash = i;                                  if (dotCount == 2)                                  {                                      //                                      // We have 2 dots in between like /../ or /..<eos>'                                      // Mark next segment for removal and remove this /../ or /..                                      //                                      ++removeSegments;                                  }                                  dotCount = 0;                                  continue;                              }                          }                          // .NET 4.5 no longer removes trailing dots in a path segment x.../  or  x...<eos>                          dotCount = 0;                            //                          // Here all other cases go such as                          // x.[..]y or /.[..]x or (/x.[...][/] && removeSegments !=0)                      }                        //                      // Now we may want to remove a segment because of previous /../                      //                      if (ch == '/')                      {                          if (removeSegments != 0)                          {                              --removeSegments;                                // just reusing a variable slot we perform //dest.Remove(i+1' lastSlash - i);                              lastSlash = (ushort)(lastSlash + 1);                              Buffer.BlockCopy(dest' lastSlash << 1' dest' (i + 1) << 1' (destLength - lastSlash) << 1);                              destLength -= (lastSlash - i - 1);                          }                          lastSlash = i;                      }                  }                    start = (ushort)((ushort)start + (ushort)1);              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,Compress,The following statement contains a magic number: unchecked              {                  //ushort i == -1 and start == -1 overflow is ok here                  ushort i = (ushort)((ushort)destLength - (ushort)1);                  start = (ushort)(start - 1);                    for (; i != start; --i)                  {                      char ch = dest[i];                      if (ch == '\\' && syntax.InFact(UriSyntaxFlags.ConvertPathSlashes))                      {                          dest[i] = ch = '/';                      }                        //                      // compress multiple '/' for file URI                      //                      if (ch == '/')                      {                          ++slashCount;                      }                      else                      {                          if (slashCount > 1)                          {                              // else preserve repeated slashes                              lastSlash = (ushort)(i + 1);                          }                          slashCount = 0;                      }                        if (ch == '.')                      {                          ++dotCount;                          continue;                      }                      else if (dotCount != 0)                      {                          bool skipSegment = syntax.NotAny(UriSyntaxFlags.CanonicalizeAsFilePath)                              && (dotCount > 2 || ch != '/' || i == start);                            //                          // Cases:                          // /./                  = remove this segment                           // /../                 = remove this segment' mark next for removal                          // /....x               = DO NOT TOUCH' leave as is                          // x.../                = DO NOT TOUCH' leave as is' except for V2 legacy mode                          //                          if (!skipSegment && ch == '/')                          {                              if ((lastSlash == i + dotCount + 1 // "/..../"                                      || (lastSlash == 0 && i + dotCount + 1 == destLength)) // "/..."                                  && (dotCount <= 2))                              {                                  //                                  //  /./ or /.<eos> or /../ or /..<eos>                                  //                                  // just reusing a variable slot we perform //dest.Remove(i+1' dotCount + (lastSlash==0?0:1));                                  lastSlash = (ushort)(i + 1 + dotCount + (lastSlash == 0 ? 0 : 1));                                  Buffer.BlockCopy(dest' lastSlash << 1' dest' (i + 1) << 1' (destLength - lastSlash) << 1);                                  destLength -= (lastSlash - i - 1);                                    lastSlash = i;                                  if (dotCount == 2)                                  {                                      //                                      // We have 2 dots in between like /../ or /..<eos>'                                      // Mark next segment for removal and remove this /../ or /..                                      //                                      ++removeSegments;                                  }                                  dotCount = 0;                                  continue;                              }                          }                          // .NET 4.5 no longer removes trailing dots in a path segment x.../  or  x...<eos>                          dotCount = 0;                            //                          // Here all other cases go such as                          // x.[..]y or /.[..]x or (/x.[...][/] && removeSegments !=0)                      }                        //                      // Now we may want to remove a segment because of previous /../                      //                      if (ch == '/')                      {                          if (removeSegments != 0)                          {                              --removeSegments;                                // just reusing a variable slot we perform //dest.Remove(i+1' lastSlash - i);                              lastSlash = (ushort)(lastSlash + 1);                              Buffer.BlockCopy(dest' lastSlash << 1' dest' (i + 1) << 1' (destLength - lastSlash) << 1);                              destLength -= (lastSlash - i - 1);                          }                          lastSlash = i;                      }                  }                    start = (ushort)((ushort)start + (ushort)1);              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CombineUri,The following statement contains a magic number: if (StaticIsFile(basePart.Syntax))              {                  if (c1 == '\\' || c1 == '/')                  {                      if (relativePart.Length >= 2 && (relativePart[1] == '\\' || relativePart[1] == '/'))                      {                          //Assuming relative is a Unc path and base is a file uri.                          return basePart.IsImplicitFile ? relativePart : "file:" + relativePart;                      }                        // here we got an absolute path in relativePart'                      // For compatibility with V1.0 parser we restrict the compression scope to Unc Share' i.e. \\host\share\                      if (basePart.IsUnc)                      {                          string share = basePart.GetParts(UriComponents.Path | UriComponents.KeepDelimiter'                              UriFormat.Unescaped);                          for (int i = 1; i < share.Length; ++i)                          {                              if (share[i] == '/')                              {                                  share = share.Substring(0' i);                                  break;                              }                          }                          if (basePart.IsImplicitFile)                          {                              return @"\\"                                      + basePart.GetParts(UriComponents.Host' UriFormat.Unescaped)                                      + share                                      + relativePart;                          }                          return "file://"                                  + basePart.GetParts(UriComponents.Host' uriFormat)                                  + share                                  + relativePart;                      }                      // It's not obvious but we've checked (for this relativePart format) that baseUti is nor UNC nor DOS path                      //                      // Means base is a Unix style path and' btw' IsImplicitFile cannot be the case either                      return "file://" + relativePart;                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CombineUri,The following statement contains a magic number: if (c1 == '/' || (c1 == '\\' && convBackSlashes))              {                  if (relativePart.Length >= 2 && relativePart[1] == '/')                  {                      // got an authority in relative path and the base scheme is not file (checked)                      return basePart.Scheme + ':' + relativePart;                  }                    // Got absolute relative path' and the base is nor FILE nor a DOS path (checked at the method start)                  if (basePart.HostType == Flags.IPv6HostType)                  {                      left = basePart.GetParts(UriComponents.Scheme | UriComponents.UserInfo' uriFormat)                                       + '[' + basePart.DnsSafeHost + ']'                                       + basePart.GetParts(UriComponents.KeepDelimiter | UriComponents.Port' uriFormat);                  }                  else                  {                      left = basePart.GetParts(UriComponents.SchemeAndServer | UriComponents.UserInfo' uriFormat);                  }                    if (convBackSlashes && c1 == '\\')                      relativePart = '/' + relativePart.Substring(1);                    return left + relativePart;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CombineUri,The following statement contains a magic number: if (basePart.HostType == Flags.IPv6HostType)              {                  if (basePart.IsImplicitFile)                  {                      left = @"\\[" + basePart.DnsSafeHost + ']';                  }                  else                  {                      left = basePart.GetParts(UriComponents.Scheme | UriComponents.UserInfo' uriFormat)                              + '[' + basePart.DnsSafeHost + ']'                              + basePart.GetParts(UriComponents.KeepDelimiter | UriComponents.Port' uriFormat);                  }              }              else              {                  if (basePart.IsImplicitFile)                  {                      if (basePart.IsDosPath)                      {                          // The FILE DOS path comes as /c:/path' we have to exclude first 3 chars from compression                          path = Compress(path' 3' ref length' basePart.Syntax);                          return new string(path' 1' length - 1) + extra;                      }                      else if (!IsWindowsSystem && basePart.IsUnixPath)                      {                          left = basePart.GetParts(UriComponents.Host' UriFormat.Unescaped);                      }                      else                      {                          left = @"\\" + basePart.GetParts(UriComponents.Host' UriFormat.Unescaped);                      }                  }                  else                  {                      left = basePart.GetParts(UriComponents.SchemeAndServer | UriComponents.UserInfo' uriFormat);                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,InitializeUri,The following statement contains a magic number: if (err == ParsingError.None)              {                  if (IsImplicitFile)                  {                      // V1 compat                      // A relative Uri wins over implicit UNC path unless the UNC path is of the form "\\something" and                       // uriKind != Absolute                      // A relative Uri wins over implicit Unix path unless uriKind == Absolute                      if (NotAny(Flags.DosPath) &&                          uriKind != UriKind.Absolute &&                         ((uriKind == UriKind.Relative || (_string.Length >= 2 && (_string[0] != '\\' || _string[1] != '\\')))                      || (!IsWindowsSystem && InFact(Flags.UnixPath))))                      {                          _syntax = null; //make it be relative Uri                          _flags &= Flags.UserEscaped; // the only flag that makes sense for a relative uri                          e = null;                          return;                          // Otherwise an absolute file Uri wins when it's of the form "\\something"                      }                      //                      // V1 compat issue                      // We should support relative Uris of the form c:\bla or c:/bla                      //                      else if (uriKind == UriKind.Relative && InFact(Flags.DosPath))                      {                          _syntax = null; //make it be relative Uri                          _flags &= Flags.UserEscaped; // the only flag that makes sense for a relative uri                          e = null;                          return;                          // Otherwise an absolute file Uri wins when it's of the form "c:\something"                      }                  }              }              else if (err > ParsingError.LastRelativeUriOkErrIndex)              {                  //This is a fatal error based solely on scheme name parsing                  _string = null; // make it be invalid Uri                  e = GetException(err);                  return;              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckForUnicode,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  char c = data[i];                  if (c == '%')                  {                      if (i + 2 < data.Length)                      {                          if (UriHelper.EscapedAscii(data[i + 1]' data[i + 2]) > 0x7F)                          {                              return true;                          }                          i += 2;                      }                  }                  else if (c > 0x7F)                  {                      return true;                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckForUnicode,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  char c = data[i];                  if (c == '%')                  {                      if (i + 2 < data.Length)                      {                          if (UriHelper.EscapedAscii(data[i + 1]' data[i + 2]) > 0x7F)                          {                              return true;                          }                          i += 2;                      }                  }                  else if (c > 0x7F)                  {                      return true;                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckForUnicode,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  char c = data[i];                  if (c == '%')                  {                      if (i + 2 < data.Length)                      {                          if (UriHelper.EscapedAscii(data[i + 1]' data[i + 2]) > 0x7F)                          {                              return true;                          }                          i += 2;                      }                  }                  else if (c > 0x7F)                  {                      return true;                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckForEscapedUnreserved,The following statement contains a magic number: fixed (char* tempPtr = data)              {                  for (int i = 0; i < data.Length - 2; ++i)                  {                      if (tempPtr[i] == '%' && IsHexDigit(tempPtr[i + 1]) && IsHexDigit(tempPtr[i + 2])                          && tempPtr[i + 1] >= '0' && tempPtr[i + 1] <= '7') // max 0x7F                      {                          char ch = UriHelper.EscapedAscii(tempPtr[i + 1]' tempPtr[i + 2]);                          if (ch != c_DummyChar && UriHelper.Is3986Unreserved(ch))                          {                              return true;                          }                      }                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckForEscapedUnreserved,The following statement contains a magic number: fixed (char* tempPtr = data)              {                  for (int i = 0; i < data.Length - 2; ++i)                  {                      if (tempPtr[i] == '%' && IsHexDigit(tempPtr[i + 1]) && IsHexDigit(tempPtr[i + 2])                          && tempPtr[i + 1] >= '0' && tempPtr[i + 1] <= '7') // max 0x7F                      {                          char ch = UriHelper.EscapedAscii(tempPtr[i + 1]' tempPtr[i + 2]);                          if (ch != c_DummyChar && UriHelper.Is3986Unreserved(ch))                          {                              return true;                          }                      }                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckForEscapedUnreserved,The following statement contains a magic number: fixed (char* tempPtr = data)              {                  for (int i = 0; i < data.Length - 2; ++i)                  {                      if (tempPtr[i] == '%' && IsHexDigit(tempPtr[i + 1]) && IsHexDigit(tempPtr[i + 2])                          && tempPtr[i + 1] >= '0' && tempPtr[i + 1] <= '7') // max 0x7F                      {                          char ch = UriHelper.EscapedAscii(tempPtr[i + 1]' tempPtr[i + 2]);                          if (ch != c_DummyChar && UriHelper.Is3986Unreserved(ch))                          {                              return true;                          }                      }                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,InternalIsWellFormedOriginalString,The following statement contains a magic number: fixed (char* str = _string)              {                  ushort idx = 0;                  //                  // For a relative Uri we only care about escaping and backslashes                  //                  if (!IsAbsoluteUri)                  {                      // my:scheme/path?query is not well formed because the colon is ambiguous                      if (CheckForColonInFirstPathSegment(_string))                      {                          return false;                      }                      return (CheckCanonical(str' ref idx' (ushort)_string.Length' c_EOL)                              & (Check.BackslashInPath | Check.EscapedCanonical)) == Check.EscapedCanonical;                  }                    //                  // (2) or is an absolute Uri that represents implicit file Uri "c:\dir\file"                  //                  if (IsImplicitFile)                      return false;                    //This will get all the offsets' a Host name will be checked separately below                  EnsureParseRemaining();                    Flags nonCanonical = (_flags & (Flags.E_CannotDisplayCanonical | Flags.IriCanonical));                  // User' Path' Query or Fragment may have some non escaped characters                  if (((nonCanonical & Flags.E_CannotDisplayCanonical & (Flags.E_UserNotCanonical | Flags.E_PathNotCanonical |                                          Flags.E_QueryNotCanonical | Flags.E_FragmentNotCanonical)) != Flags.Zero) &&                      (!_iriParsing || (_iriParsing &&                      (((nonCanonical & Flags.E_UserNotCanonical) == 0) || ((nonCanonical & Flags.UserIriCanonical) == 0)) &&                      (((nonCanonical & Flags.E_PathNotCanonical) == 0) || ((nonCanonical & Flags.PathIriCanonical) == 0)) &&                      (((nonCanonical & Flags.E_QueryNotCanonical) == 0) || ((nonCanonical & Flags.QueryIriCanonical) == 0)) &&                      (((nonCanonical & Flags.E_FragmentNotCanonical) == 0) || ((nonCanonical & Flags.FragmentIriCanonical) == 0)))))                  {                      return false;                  }                    // checking on scheme:\\ or file:////                  if (InFact(Flags.AuthorityFound))                  {                      idx = (ushort)(_info.Offset.Scheme + _syntax.SchemeName.Length + 2);                      if (idx >= _info.Offset.User || _string[idx - 1] == '\\' || _string[idx] == '\\')                          return false;                        if (InFact(Flags.UncPath | Flags.DosPath))                      {                          while (++idx < _info.Offset.User && (_string[idx] == '/' || _string[idx] == '\\'))                              return false;                      }                  }                      // (3) or is an absolute Uri that misses a slash before path "file://c:/dir/file"                  // Note that for this check to be more general we assert that if Path is non empty and if it requires a first slash                  // (which looks absent) then the method has to fail.                  // Today it's only possible for a Dos like path' i.e. file://c:/bla would fail below check.                  if (InFact(Flags.FirstSlashAbsent) && _info.Offset.Query > _info.Offset.Path)                      return false;                    // (4) or contains unescaped backslashes even if they will be treated                  //     as forward slashes like http:\\host/path\file or file:\\\c:\path                  // Note we do not check for Flags.ShouldBeCompressed i.e. allow // /./ and alike as valid                  if (InFact(Flags.BackslashInPath))                      return false;                    // Capturing a rare case like file:///c|/dir                  if (IsDosPath && _string[_info.Offset.Path + SecuredPathIndex - 1] == '|')                      return false;                    //                  // May need some real CPU processing to answer the request                  //                  //                  // Check escaping for authority                  //                  // IPv6 hosts cannot be properly validated by CheckCannonical                  if ((_flags & Flags.CanonicalDnsHost) == 0 && HostType != Flags.IPv6HostType)                  {                      idx = _info.Offset.User;                      Check result = CheckCanonical(str' ref idx' (ushort)_info.Offset.Path' '/');                      if (((result & (Check.ReservedFound | Check.BackslashInPath | Check.EscapedCanonical))                          != Check.EscapedCanonical)                          && (!_iriParsing || (_iriParsing                              && ((result & (Check.DisplayCanonical | Check.FoundNonAscii | Check.NotIriCanonical))                                  != (Check.DisplayCanonical | Check.FoundNonAscii)))))                      {                          return false;                      }                  }                    // Want to ensure there are slashes after the scheme                  if ((_flags & (Flags.SchemeNotCanonical | Flags.AuthorityFound))                      == (Flags.SchemeNotCanonical | Flags.AuthorityFound))                  {                      idx = (ushort)_syntax.SchemeName.Length;                      while (str[idx++] != ':') ;                      if (idx + 1 >= _string.Length || str[idx] != '/' || str[idx + 1] != '/')                          return false;                  }              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ResolveHelper,The following statement contains a magic number: if (relativeStr.Length >= 3                  && (relativeStr[1] == ':' || relativeStr[1] == '|')                  && UriHelper.IsAsciiLetter(relativeStr[0])                  && (relativeStr[2] == '\\' || relativeStr[2] == '/'))              {                  if (baseUri.IsImplicitFile)                  {                      // It could have file:/// prepended to the result but we want to keep it as *Implicit* File Uri                      newUriString = relativeStr;                      return null;                  }                  else if (baseUri.Syntax.InFact(UriSyntaxFlags.AllowDOSPath))                  {                      // The scheme is not changed just the path gets replaced                      string prefix;                      if (baseUri.InFact(Flags.AuthorityFound))                          prefix = baseUri.Syntax.InFact(UriSyntaxFlags.PathIsRooted) ? ":///" : "://";                      else                          prefix = baseUri.Syntax.InFact(UriSyntaxFlags.PathIsRooted) ? ":/" : ":";                        newUriString = baseUri.Scheme + prefix + relativeStr;                      return null;                  }                  // If we are here then input like "http://host/path/" + "C:\x" will produce the result  http://host/path/c:/x              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ResolveHelper,The following statement contains a magic number: if (relativeStr.Length >= 3                  && (relativeStr[1] == ':' || relativeStr[1] == '|')                  && UriHelper.IsAsciiLetter(relativeStr[0])                  && (relativeStr[2] == '\\' || relativeStr[2] == '/'))              {                  if (baseUri.IsImplicitFile)                  {                      // It could have file:/// prepended to the result but we want to keep it as *Implicit* File Uri                      newUriString = relativeStr;                      return null;                  }                  else if (baseUri.Syntax.InFact(UriSyntaxFlags.AllowDOSPath))                  {                      // The scheme is not changed just the path gets replaced                      string prefix;                      if (baseUri.InFact(Flags.AuthorityFound))                          prefix = baseUri.Syntax.InFact(UriSyntaxFlags.PathIsRooted) ? ":///" : "://";                      else                          prefix = baseUri.Syntax.InFact(UriSyntaxFlags.PathIsRooted) ? ":/" : ":";                        newUriString = baseUri.Scheme + prefix + relativeStr;                      return null;                  }                  // If we are here then input like "http://host/path/" + "C:\x" will produce the result  http://host/path/c:/x              }
Magic Number,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,ResolveHelper,The following statement contains a magic number: if (relativeStr.Length >= 3                  && (relativeStr[1] == ':' || relativeStr[1] == '|')                  && UriHelper.IsAsciiLetter(relativeStr[0])                  && (relativeStr[2] == '\\' || relativeStr[2] == '/'))              {                  if (baseUri.IsImplicitFile)                  {                      // It could have file:/// prepended to the result but we want to keep it as *Implicit* File Uri                      newUriString = relativeStr;                      return null;                  }                  else if (baseUri.Syntax.InFact(UriSyntaxFlags.AllowDOSPath))                  {                      // The scheme is not changed just the path gets replaced                      string prefix;                      if (baseUri.InFact(Flags.AuthorityFound))                          prefix = baseUri.Syntax.InFact(UriSyntaxFlags.PathIsRooted) ? ":///" : "://";                      else                          prefix = baseUri.Syntax.InFact(UriSyntaxFlags.PathIsRooted) ? ":/" : ":";                        newUriString = baseUri.Scheme + prefix + relativeStr;                      return null;                  }                  // If we are here then input like "http://host/path/" + "C:\x" will produce the result  http://host/path/c:/x              }
Magic Number,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,EscapeString,The following statement contains a magic number: fixed (char* pStr = input)              {                  for (; i < end; ++i)                  {                      char ch = pStr[i];                        // a Unicode ?                      if (ch > '\x7F')                      {                          short maxSize = (short)Math.Min(end - i' (int)c_MaxUnicodeCharsReallocate - 1);                            short count = 1;                          for (; count < maxSize && pStr[i + count] > '\x7f'; ++count)                              ;                            // Is the last a high surrogate?                          if (pStr[i + count - 1] >= 0xD800 && pStr[i + count - 1] <= 0xDBFF)                          {                              // Should be a rare case where the app tries to feed an invalid Unicode surrogates pair                              if (count == 1 || count == end - i)                                  throw new UriFormatException(SR.net_uri_BadString);                              // need to grab one more char as a Surrogate except when it's a bogus input                              ++count;                          }                            dest = EnsureDestinationSize(pStr' dest' i'                              (short)(count * c_MaxUTF_8BytesPerUnicodeChar * c_EncodedCharsPerByte)'                              c_MaxUnicodeCharsReallocate * c_MaxUTF_8BytesPerUnicodeChar * c_EncodedCharsPerByte'                              ref destPos' prevInputPos);                            short numberOfBytes = (short)Encoding.UTF8.GetBytes(pStr + i' count' bytes'                              c_MaxUnicodeCharsReallocate * c_MaxUTF_8BytesPerUnicodeChar);                            // This is the only exception that built in UriParser can throw after a Uri ctor.                          // Should not happen unless the app tries to feed an invalid Unicode String                          if (numberOfBytes == 0)                              throw new UriFormatException(SR.net_uri_BadString);                            i += (count - 1);                            for (count = 0; count < numberOfBytes; ++count)                              EscapeAsciiChar((char)bytes[count]' dest' ref destPos);                            prevInputPos = i + 1;                      }                      else if (ch == '%' && rsvd == '%')                      {                          // Means we don't reEncode '%' but check for the possible escaped sequence                          dest = EnsureDestinationSize(pStr' dest' i' c_EncodedCharsPerByte'                              c_MaxAsciiCharsReallocate * c_EncodedCharsPerByte' ref destPos' prevInputPos);                          if (i + 2 < end && EscapedAscii(pStr[i + 1]' pStr[i + 2]) != Uri.c_DummyChar)                          {                              // leave it escaped                              dest[destPos++] = '%';                              dest[destPos++] = pStr[i + 1];                              dest[destPos++] = pStr[i + 2];                              i += 2;                          }                          else                          {                              EscapeAsciiChar('%'' dest' ref destPos);                          }                          prevInputPos = i + 1;                      }                      else if (ch == force1 || ch == force2)                      {                          dest = EnsureDestinationSize(pStr' dest' i' c_EncodedCharsPerByte'                              c_MaxAsciiCharsReallocate * c_EncodedCharsPerByte' ref destPos' prevInputPos);                          EscapeAsciiChar(ch' dest' ref destPos);                          prevInputPos = i + 1;                      }                      else if (ch != rsvd && (isUriString ? !IsReservedUnreservedOrHash(ch) : !IsUnreserved(ch)))                      {                          dest = EnsureDestinationSize(pStr' dest' i' c_EncodedCharsPerByte'                              c_MaxAsciiCharsReallocate * c_EncodedCharsPerByte' ref destPos' prevInputPos);                          EscapeAsciiChar(ch' dest' ref destPos);                          prevInputPos = i + 1;                      }                  }                    if (prevInputPos != i)                  {                      // need to fill up the dest array ?                      if (prevInputPos != start || dest != null)                          dest = EnsureDestinationSize(pStr' dest' i' 0' 0' ref destPos' prevInputPos);                  }              }
Magic Number,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,EscapeString,The following statement contains a magic number: fixed (char* pStr = input)              {                  for (; i < end; ++i)                  {                      char ch = pStr[i];                        // a Unicode ?                      if (ch > '\x7F')                      {                          short maxSize = (short)Math.Min(end - i' (int)c_MaxUnicodeCharsReallocate - 1);                            short count = 1;                          for (; count < maxSize && pStr[i + count] > '\x7f'; ++count)                              ;                            // Is the last a high surrogate?                          if (pStr[i + count - 1] >= 0xD800 && pStr[i + count - 1] <= 0xDBFF)                          {                              // Should be a rare case where the app tries to feed an invalid Unicode surrogates pair                              if (count == 1 || count == end - i)                                  throw new UriFormatException(SR.net_uri_BadString);                              // need to grab one more char as a Surrogate except when it's a bogus input                              ++count;                          }                            dest = EnsureDestinationSize(pStr' dest' i'                              (short)(count * c_MaxUTF_8BytesPerUnicodeChar * c_EncodedCharsPerByte)'                              c_MaxUnicodeCharsReallocate * c_MaxUTF_8BytesPerUnicodeChar * c_EncodedCharsPerByte'                              ref destPos' prevInputPos);                            short numberOfBytes = (short)Encoding.UTF8.GetBytes(pStr + i' count' bytes'                              c_MaxUnicodeCharsReallocate * c_MaxUTF_8BytesPerUnicodeChar);                            // This is the only exception that built in UriParser can throw after a Uri ctor.                          // Should not happen unless the app tries to feed an invalid Unicode String                          if (numberOfBytes == 0)                              throw new UriFormatException(SR.net_uri_BadString);                            i += (count - 1);                            for (count = 0; count < numberOfBytes; ++count)                              EscapeAsciiChar((char)bytes[count]' dest' ref destPos);                            prevInputPos = i + 1;                      }                      else if (ch == '%' && rsvd == '%')                      {                          // Means we don't reEncode '%' but check for the possible escaped sequence                          dest = EnsureDestinationSize(pStr' dest' i' c_EncodedCharsPerByte'                              c_MaxAsciiCharsReallocate * c_EncodedCharsPerByte' ref destPos' prevInputPos);                          if (i + 2 < end && EscapedAscii(pStr[i + 1]' pStr[i + 2]) != Uri.c_DummyChar)                          {                              // leave it escaped                              dest[destPos++] = '%';                              dest[destPos++] = pStr[i + 1];                              dest[destPos++] = pStr[i + 2];                              i += 2;                          }                          else                          {                              EscapeAsciiChar('%'' dest' ref destPos);                          }                          prevInputPos = i + 1;                      }                      else if (ch == force1 || ch == force2)                      {                          dest = EnsureDestinationSize(pStr' dest' i' c_EncodedCharsPerByte'                              c_MaxAsciiCharsReallocate * c_EncodedCharsPerByte' ref destPos' prevInputPos);                          EscapeAsciiChar(ch' dest' ref destPos);                          prevInputPos = i + 1;                      }                      else if (ch != rsvd && (isUriString ? !IsReservedUnreservedOrHash(ch) : !IsUnreserved(ch)))                      {                          dest = EnsureDestinationSize(pStr' dest' i' c_EncodedCharsPerByte'                              c_MaxAsciiCharsReallocate * c_EncodedCharsPerByte' ref destPos' prevInputPos);                          EscapeAsciiChar(ch' dest' ref destPos);                          prevInputPos = i + 1;                      }                  }                    if (prevInputPos != i)                  {                      // need to fill up the dest array ?                      if (prevInputPos != start || dest != null)                          dest = EnsureDestinationSize(pStr' dest' i' 0' 0' ref destPos' prevInputPos);                  }              }
Magic Number,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,EscapeString,The following statement contains a magic number: fixed (char* pStr = input)              {                  for (; i < end; ++i)                  {                      char ch = pStr[i];                        // a Unicode ?                      if (ch > '\x7F')                      {                          short maxSize = (short)Math.Min(end - i' (int)c_MaxUnicodeCharsReallocate - 1);                            short count = 1;                          for (; count < maxSize && pStr[i + count] > '\x7f'; ++count)                              ;                            // Is the last a high surrogate?                          if (pStr[i + count - 1] >= 0xD800 && pStr[i + count - 1] <= 0xDBFF)                          {                              // Should be a rare case where the app tries to feed an invalid Unicode surrogates pair                              if (count == 1 || count == end - i)                                  throw new UriFormatException(SR.net_uri_BadString);                              // need to grab one more char as a Surrogate except when it's a bogus input                              ++count;                          }                            dest = EnsureDestinationSize(pStr' dest' i'                              (short)(count * c_MaxUTF_8BytesPerUnicodeChar * c_EncodedCharsPerByte)'                              c_MaxUnicodeCharsReallocate * c_MaxUTF_8BytesPerUnicodeChar * c_EncodedCharsPerByte'                              ref destPos' prevInputPos);                            short numberOfBytes = (short)Encoding.UTF8.GetBytes(pStr + i' count' bytes'                              c_MaxUnicodeCharsReallocate * c_MaxUTF_8BytesPerUnicodeChar);                            // This is the only exception that built in UriParser can throw after a Uri ctor.                          // Should not happen unless the app tries to feed an invalid Unicode String                          if (numberOfBytes == 0)                              throw new UriFormatException(SR.net_uri_BadString);                            i += (count - 1);                            for (count = 0; count < numberOfBytes; ++count)                              EscapeAsciiChar((char)bytes[count]' dest' ref destPos);                            prevInputPos = i + 1;                      }                      else if (ch == '%' && rsvd == '%')                      {                          // Means we don't reEncode '%' but check for the possible escaped sequence                          dest = EnsureDestinationSize(pStr' dest' i' c_EncodedCharsPerByte'                              c_MaxAsciiCharsReallocate * c_EncodedCharsPerByte' ref destPos' prevInputPos);                          if (i + 2 < end && EscapedAscii(pStr[i + 1]' pStr[i + 2]) != Uri.c_DummyChar)                          {                              // leave it escaped                              dest[destPos++] = '%';                              dest[destPos++] = pStr[i + 1];                              dest[destPos++] = pStr[i + 2];                              i += 2;                          }                          else                          {                              EscapeAsciiChar('%'' dest' ref destPos);                          }                          prevInputPos = i + 1;                      }                      else if (ch == force1 || ch == force2)                      {                          dest = EnsureDestinationSize(pStr' dest' i' c_EncodedCharsPerByte'                              c_MaxAsciiCharsReallocate * c_EncodedCharsPerByte' ref destPos' prevInputPos);                          EscapeAsciiChar(ch' dest' ref destPos);                          prevInputPos = i + 1;                      }                      else if (ch != rsvd && (isUriString ? !IsReservedUnreservedOrHash(ch) : !IsUnreserved(ch)))                      {                          dest = EnsureDestinationSize(pStr' dest' i' c_EncodedCharsPerByte'                              c_MaxAsciiCharsReallocate * c_EncodedCharsPerByte' ref destPos' prevInputPos);                          EscapeAsciiChar(ch' dest' ref destPos);                          prevInputPos = i + 1;                      }                  }                    if (prevInputPos != i)                  {                      // need to fill up the dest array ?                      if (prevInputPos != start || dest != null)                          dest = EnsureDestinationSize(pStr' dest' i' 0' 0' ref destPos' prevInputPos);                  }              }
Magic Number,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,EscapeString,The following statement contains a magic number: fixed (char* pStr = input)              {                  for (; i < end; ++i)                  {                      char ch = pStr[i];                        // a Unicode ?                      if (ch > '\x7F')                      {                          short maxSize = (short)Math.Min(end - i' (int)c_MaxUnicodeCharsReallocate - 1);                            short count = 1;                          for (; count < maxSize && pStr[i + count] > '\x7f'; ++count)                              ;                            // Is the last a high surrogate?                          if (pStr[i + count - 1] >= 0xD800 && pStr[i + count - 1] <= 0xDBFF)                          {                              // Should be a rare case where the app tries to feed an invalid Unicode surrogates pair                              if (count == 1 || count == end - i)                                  throw new UriFormatException(SR.net_uri_BadString);                              // need to grab one more char as a Surrogate except when it's a bogus input                              ++count;                          }                            dest = EnsureDestinationSize(pStr' dest' i'                              (short)(count * c_MaxUTF_8BytesPerUnicodeChar * c_EncodedCharsPerByte)'                              c_MaxUnicodeCharsReallocate * c_MaxUTF_8BytesPerUnicodeChar * c_EncodedCharsPerByte'                              ref destPos' prevInputPos);                            short numberOfBytes = (short)Encoding.UTF8.GetBytes(pStr + i' count' bytes'                              c_MaxUnicodeCharsReallocate * c_MaxUTF_8BytesPerUnicodeChar);                            // This is the only exception that built in UriParser can throw after a Uri ctor.                          // Should not happen unless the app tries to feed an invalid Unicode String                          if (numberOfBytes == 0)                              throw new UriFormatException(SR.net_uri_BadString);                            i += (count - 1);                            for (count = 0; count < numberOfBytes; ++count)                              EscapeAsciiChar((char)bytes[count]' dest' ref destPos);                            prevInputPos = i + 1;                      }                      else if (ch == '%' && rsvd == '%')                      {                          // Means we don't reEncode '%' but check for the possible escaped sequence                          dest = EnsureDestinationSize(pStr' dest' i' c_EncodedCharsPerByte'                              c_MaxAsciiCharsReallocate * c_EncodedCharsPerByte' ref destPos' prevInputPos);                          if (i + 2 < end && EscapedAscii(pStr[i + 1]' pStr[i + 2]) != Uri.c_DummyChar)                          {                              // leave it escaped                              dest[destPos++] = '%';                              dest[destPos++] = pStr[i + 1];                              dest[destPos++] = pStr[i + 2];                              i += 2;                          }                          else                          {                              EscapeAsciiChar('%'' dest' ref destPos);                          }                          prevInputPos = i + 1;                      }                      else if (ch == force1 || ch == force2)                      {                          dest = EnsureDestinationSize(pStr' dest' i' c_EncodedCharsPerByte'                              c_MaxAsciiCharsReallocate * c_EncodedCharsPerByte' ref destPos' prevInputPos);                          EscapeAsciiChar(ch' dest' ref destPos);                          prevInputPos = i + 1;                      }                      else if (ch != rsvd && (isUriString ? !IsReservedUnreservedOrHash(ch) : !IsUnreserved(ch)))                      {                          dest = EnsureDestinationSize(pStr' dest' i' c_EncodedCharsPerByte'                              c_MaxAsciiCharsReallocate * c_EncodedCharsPerByte' ref destPos' prevInputPos);                          EscapeAsciiChar(ch' dest' ref destPos);                          prevInputPos = i + 1;                      }                  }                    if (prevInputPos != i)                  {                      // need to fill up the dest array ?                      if (prevInputPos != start || dest != null)                          dest = EnsureDestinationSize(pStr' dest' i' 0' 0' ref destPos' prevInputPos);                  }              }
Magic Number,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,UnescapeString,The following statement contains a magic number: while (true)              {                  // we may need to re-pin dest[]                  fixed (char* pDest = dest)                  {                      if ((unescapeMode & UnescapeMode.EscapeUnescape) == UnescapeMode.CopyOnly)                      {                          while (start < end)                              pDest[destPosition++] = pStr[start++];                          return dest;                      }                        while (true)                      {                          char ch = (char)0;                            for (; next < end; ++next)                          {                              if ((ch = pStr[next]) == '%')                              {                                  if ((unescapeMode & UnescapeMode.Unescape) == 0)                                  {                                      // re-escape' don't check anything else                                      escapeReserved = true;                                  }                                  else if (next + 2 < end)                                  {                                      ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                      // Unescape a good sequence if full unescape is requested                                      if (unescapeMode >= UnescapeMode.UnescapeAll)                                      {                                          if (ch == Uri.c_DummyChar)                                          {                                              if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                              {                                                  // Should be a rare case where the app tries to feed an invalid escaped sequence                                                  throw new UriFormatException(SR.net_uri_BadString);                                              }                                              continue;                                          }                                      }                                      // re-escape % from an invalid sequence                                      else if (ch == Uri.c_DummyChar)                                      {                                          if ((unescapeMode & UnescapeMode.Escape) != 0)                                              escapeReserved = true;                                          else                                              continue;   // we should throw instead but since v1.0 would just print '%'                                      }                                      // Do not unescape '%' itself unless full unescape is requested                                      else if (ch == '%')                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a reserved char unless full unescape is requested                                      else if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a dangerous char unless it's V1ToStringFlags mode                                      else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0 && IsNotSafeForUnescape(ch))                                      {                                          next += 2;                                          continue;                                      }                                      else if (iriParsing && ((ch <= '\x9F' && IsNotSafeForUnescape(ch)) ||                                                              (ch > '\x9F' && !IriHelper.CheckIriUnicodeRange(ch' isQuery))))                                      {                                          // check if unenscaping gives a char outside iri range                                           // if it does then keep it escaped                                          next += 2;                                          continue;                                      }                                      // unescape escaped char or escape %                                      break;                                  }                                  else if (unescapeMode >= UnescapeMode.UnescapeAll)                                  {                                      if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                      {                                          // Should be a rare case where the app tries to feed an invalid escaped sequence                                          throw new UriFormatException(SR.net_uri_BadString);                                      }                                      // keep a '%' as part of a bogus sequence                                       continue;                                  }                                  else                                  {                                      escapeReserved = true;                                  }                                  // escape (escapeReserved==true) or otherwise unescape the sequence                                  break;                              }                              else if ((unescapeMode & (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                                  == (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                              {                                  continue;                              }                              else if ((unescapeMode & UnescapeMode.Escape) != 0)                              {                                  // Could actually escape some of the characters                                  if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                                  else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0                                      && (ch <= '\x1F' || (ch >= '\x7F' && ch <= '\x9F')))                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                              }                          }                            //copy off previous characters from input                          while (start < next)                              pDest[destPosition++] = pStr[start++];                            if (next != end)                          {                              if (escapeReserved)                              {                                  //escape that char                                  // Since this should be _really_ rare case' reallocate with constant size increase of 30 rsvd-type characters.                                  if (escapedReallocations == 0)                                  {                                      escapedReallocations = 30;                                      char[] newDest = new char[dest.Length + escapedReallocations * 3];                                      fixed (char* pNewDest = &newDest[0])                                      {                                          for (int i = 0; i < destPosition; ++i)                                              pNewDest[i] = pDest[i];                                      }                                      dest = newDest;                                      // re-pin new dest[] array                                      goto dest_fixed_loop_break;                                  }                                  else                                  {                                      --escapedReallocations;                                      EscapeAsciiChar(pStr[next]' dest' ref destPosition);                                      escapeReserved = false;                                      start = ++next;                                      continue;                                  }                              }                                // unescaping either one Ascii or possibly multiple Unicode                                if (ch <= '\x7F')                              {                                  //ASCII                                  dest[destPosition++] = ch;                                  next += 3;                                  start = next;                                  continue;                              }                                // Unicode                                int byteCount = 1;                              // lazy initialization of max size' will reuse the array for next sequences                              if ((object)bytes == null)                                  bytes = new byte[end - next];                                bytes[0] = (byte)ch;                              next += 3;                              while (next < end)                              {                                  // Check on exit criterion                                  if ((ch = pStr[next]) != '%' || next + 2 >= end)                                      break;                                    // already made sure we have 3 characters in str                                  ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                    //invalid hex sequence ?                                  if (ch == Uri.c_DummyChar)                                      break;                                  // character is not part of a UTF-8 sequence ?                                  else if (ch < '\x80')                                      break;                                  else                                  {                                      //a UTF-8 sequence                                      bytes[byteCount++] = (byte)ch;                                      next += 3;                                  }                              }                                Encoding noFallbackCharUTF8 = Encoding.GetEncoding(                                                                                  Encoding.UTF8.CodePage'                                                                                  new EncoderReplacementFallback("")'                                                                                  new DecoderReplacementFallback(""));                                char[] unescapedChars = new char[bytes.Length];                              int charCount = noFallbackCharUTF8.GetChars(bytes' 0' byteCount' unescapedChars' 0);                                start = next;                                // match exact bytes                              // Do not unescape chars not allowed by Iri                              // need to check for invalid utf sequences that may not have given any chars                                MatchUTF8Sequence(pDest' dest' ref destPosition' unescapedChars' charCount' bytes'                                  byteCount' isQuery' iriParsing);                          }                            if (next == end)                              goto done;                      }                  dest_fixed_loop_break:;                  }              }
Magic Number,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,UnescapeString,The following statement contains a magic number: while (true)              {                  // we may need to re-pin dest[]                  fixed (char* pDest = dest)                  {                      if ((unescapeMode & UnescapeMode.EscapeUnescape) == UnescapeMode.CopyOnly)                      {                          while (start < end)                              pDest[destPosition++] = pStr[start++];                          return dest;                      }                        while (true)                      {                          char ch = (char)0;                            for (; next < end; ++next)                          {                              if ((ch = pStr[next]) == '%')                              {                                  if ((unescapeMode & UnescapeMode.Unescape) == 0)                                  {                                      // re-escape' don't check anything else                                      escapeReserved = true;                                  }                                  else if (next + 2 < end)                                  {                                      ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                      // Unescape a good sequence if full unescape is requested                                      if (unescapeMode >= UnescapeMode.UnescapeAll)                                      {                                          if (ch == Uri.c_DummyChar)                                          {                                              if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                              {                                                  // Should be a rare case where the app tries to feed an invalid escaped sequence                                                  throw new UriFormatException(SR.net_uri_BadString);                                              }                                              continue;                                          }                                      }                                      // re-escape % from an invalid sequence                                      else if (ch == Uri.c_DummyChar)                                      {                                          if ((unescapeMode & UnescapeMode.Escape) != 0)                                              escapeReserved = true;                                          else                                              continue;   // we should throw instead but since v1.0 would just print '%'                                      }                                      // Do not unescape '%' itself unless full unescape is requested                                      else if (ch == '%')                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a reserved char unless full unescape is requested                                      else if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a dangerous char unless it's V1ToStringFlags mode                                      else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0 && IsNotSafeForUnescape(ch))                                      {                                          next += 2;                                          continue;                                      }                                      else if (iriParsing && ((ch <= '\x9F' && IsNotSafeForUnescape(ch)) ||                                                              (ch > '\x9F' && !IriHelper.CheckIriUnicodeRange(ch' isQuery))))                                      {                                          // check if unenscaping gives a char outside iri range                                           // if it does then keep it escaped                                          next += 2;                                          continue;                                      }                                      // unescape escaped char or escape %                                      break;                                  }                                  else if (unescapeMode >= UnescapeMode.UnescapeAll)                                  {                                      if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                      {                                          // Should be a rare case where the app tries to feed an invalid escaped sequence                                          throw new UriFormatException(SR.net_uri_BadString);                                      }                                      // keep a '%' as part of a bogus sequence                                       continue;                                  }                                  else                                  {                                      escapeReserved = true;                                  }                                  // escape (escapeReserved==true) or otherwise unescape the sequence                                  break;                              }                              else if ((unescapeMode & (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                                  == (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                              {                                  continue;                              }                              else if ((unescapeMode & UnescapeMode.Escape) != 0)                              {                                  // Could actually escape some of the characters                                  if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                                  else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0                                      && (ch <= '\x1F' || (ch >= '\x7F' && ch <= '\x9F')))                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                              }                          }                            //copy off previous characters from input                          while (start < next)                              pDest[destPosition++] = pStr[start++];                            if (next != end)                          {                              if (escapeReserved)                              {                                  //escape that char                                  // Since this should be _really_ rare case' reallocate with constant size increase of 30 rsvd-type characters.                                  if (escapedReallocations == 0)                                  {                                      escapedReallocations = 30;                                      char[] newDest = new char[dest.Length + escapedReallocations * 3];                                      fixed (char* pNewDest = &newDest[0])                                      {                                          for (int i = 0; i < destPosition; ++i)                                              pNewDest[i] = pDest[i];                                      }                                      dest = newDest;                                      // re-pin new dest[] array                                      goto dest_fixed_loop_break;                                  }                                  else                                  {                                      --escapedReallocations;                                      EscapeAsciiChar(pStr[next]' dest' ref destPosition);                                      escapeReserved = false;                                      start = ++next;                                      continue;                                  }                              }                                // unescaping either one Ascii or possibly multiple Unicode                                if (ch <= '\x7F')                              {                                  //ASCII                                  dest[destPosition++] = ch;                                  next += 3;                                  start = next;                                  continue;                              }                                // Unicode                                int byteCount = 1;                              // lazy initialization of max size' will reuse the array for next sequences                              if ((object)bytes == null)                                  bytes = new byte[end - next];                                bytes[0] = (byte)ch;                              next += 3;                              while (next < end)                              {                                  // Check on exit criterion                                  if ((ch = pStr[next]) != '%' || next + 2 >= end)                                      break;                                    // already made sure we have 3 characters in str                                  ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                    //invalid hex sequence ?                                  if (ch == Uri.c_DummyChar)                                      break;                                  // character is not part of a UTF-8 sequence ?                                  else if (ch < '\x80')                                      break;                                  else                                  {                                      //a UTF-8 sequence                                      bytes[byteCount++] = (byte)ch;                                      next += 3;                                  }                              }                                Encoding noFallbackCharUTF8 = Encoding.GetEncoding(                                                                                  Encoding.UTF8.CodePage'                                                                                  new EncoderReplacementFallback("")'                                                                                  new DecoderReplacementFallback(""));                                char[] unescapedChars = new char[bytes.Length];                              int charCount = noFallbackCharUTF8.GetChars(bytes' 0' byteCount' unescapedChars' 0);                                start = next;                                // match exact bytes                              // Do not unescape chars not allowed by Iri                              // need to check for invalid utf sequences that may not have given any chars                                MatchUTF8Sequence(pDest' dest' ref destPosition' unescapedChars' charCount' bytes'                                  byteCount' isQuery' iriParsing);                          }                            if (next == end)                              goto done;                      }                  dest_fixed_loop_break:;                  }              }
Magic Number,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,UnescapeString,The following statement contains a magic number: while (true)              {                  // we may need to re-pin dest[]                  fixed (char* pDest = dest)                  {                      if ((unescapeMode & UnescapeMode.EscapeUnescape) == UnescapeMode.CopyOnly)                      {                          while (start < end)                              pDest[destPosition++] = pStr[start++];                          return dest;                      }                        while (true)                      {                          char ch = (char)0;                            for (; next < end; ++next)                          {                              if ((ch = pStr[next]) == '%')                              {                                  if ((unescapeMode & UnescapeMode.Unescape) == 0)                                  {                                      // re-escape' don't check anything else                                      escapeReserved = true;                                  }                                  else if (next + 2 < end)                                  {                                      ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                      // Unescape a good sequence if full unescape is requested                                      if (unescapeMode >= UnescapeMode.UnescapeAll)                                      {                                          if (ch == Uri.c_DummyChar)                                          {                                              if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                              {                                                  // Should be a rare case where the app tries to feed an invalid escaped sequence                                                  throw new UriFormatException(SR.net_uri_BadString);                                              }                                              continue;                                          }                                      }                                      // re-escape % from an invalid sequence                                      else if (ch == Uri.c_DummyChar)                                      {                                          if ((unescapeMode & UnescapeMode.Escape) != 0)                                              escapeReserved = true;                                          else                                              continue;   // we should throw instead but since v1.0 would just print '%'                                      }                                      // Do not unescape '%' itself unless full unescape is requested                                      else if (ch == '%')                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a reserved char unless full unescape is requested                                      else if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a dangerous char unless it's V1ToStringFlags mode                                      else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0 && IsNotSafeForUnescape(ch))                                      {                                          next += 2;                                          continue;                                      }                                      else if (iriParsing && ((ch <= '\x9F' && IsNotSafeForUnescape(ch)) ||                                                              (ch > '\x9F' && !IriHelper.CheckIriUnicodeRange(ch' isQuery))))                                      {                                          // check if unenscaping gives a char outside iri range                                           // if it does then keep it escaped                                          next += 2;                                          continue;                                      }                                      // unescape escaped char or escape %                                      break;                                  }                                  else if (unescapeMode >= UnescapeMode.UnescapeAll)                                  {                                      if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                      {                                          // Should be a rare case where the app tries to feed an invalid escaped sequence                                          throw new UriFormatException(SR.net_uri_BadString);                                      }                                      // keep a '%' as part of a bogus sequence                                       continue;                                  }                                  else                                  {                                      escapeReserved = true;                                  }                                  // escape (escapeReserved==true) or otherwise unescape the sequence                                  break;                              }                              else if ((unescapeMode & (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                                  == (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                              {                                  continue;                              }                              else if ((unescapeMode & UnescapeMode.Escape) != 0)                              {                                  // Could actually escape some of the characters                                  if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                                  else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0                                      && (ch <= '\x1F' || (ch >= '\x7F' && ch <= '\x9F')))                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                              }                          }                            //copy off previous characters from input                          while (start < next)                              pDest[destPosition++] = pStr[start++];                            if (next != end)                          {                              if (escapeReserved)                              {                                  //escape that char                                  // Since this should be _really_ rare case' reallocate with constant size increase of 30 rsvd-type characters.                                  if (escapedReallocations == 0)                                  {                                      escapedReallocations = 30;                                      char[] newDest = new char[dest.Length + escapedReallocations * 3];                                      fixed (char* pNewDest = &newDest[0])                                      {                                          for (int i = 0; i < destPosition; ++i)                                              pNewDest[i] = pDest[i];                                      }                                      dest = newDest;                                      // re-pin new dest[] array                                      goto dest_fixed_loop_break;                                  }                                  else                                  {                                      --escapedReallocations;                                      EscapeAsciiChar(pStr[next]' dest' ref destPosition);                                      escapeReserved = false;                                      start = ++next;                                      continue;                                  }                              }                                // unescaping either one Ascii or possibly multiple Unicode                                if (ch <= '\x7F')                              {                                  //ASCII                                  dest[destPosition++] = ch;                                  next += 3;                                  start = next;                                  continue;                              }                                // Unicode                                int byteCount = 1;                              // lazy initialization of max size' will reuse the array for next sequences                              if ((object)bytes == null)                                  bytes = new byte[end - next];                                bytes[0] = (byte)ch;                              next += 3;                              while (next < end)                              {                                  // Check on exit criterion                                  if ((ch = pStr[next]) != '%' || next + 2 >= end)                                      break;                                    // already made sure we have 3 characters in str                                  ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                    //invalid hex sequence ?                                  if (ch == Uri.c_DummyChar)                                      break;                                  // character is not part of a UTF-8 sequence ?                                  else if (ch < '\x80')                                      break;                                  else                                  {                                      //a UTF-8 sequence                                      bytes[byteCount++] = (byte)ch;                                      next += 3;                                  }                              }                                Encoding noFallbackCharUTF8 = Encoding.GetEncoding(                                                                                  Encoding.UTF8.CodePage'                                                                                  new EncoderReplacementFallback("")'                                                                                  new DecoderReplacementFallback(""));                                char[] unescapedChars = new char[bytes.Length];                              int charCount = noFallbackCharUTF8.GetChars(bytes' 0' byteCount' unescapedChars' 0);                                start = next;                                // match exact bytes                              // Do not unescape chars not allowed by Iri                              // need to check for invalid utf sequences that may not have given any chars                                MatchUTF8Sequence(pDest' dest' ref destPosition' unescapedChars' charCount' bytes'                                  byteCount' isQuery' iriParsing);                          }                            if (next == end)                              goto done;                      }                  dest_fixed_loop_break:;                  }              }
Magic Number,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,UnescapeString,The following statement contains a magic number: while (true)              {                  // we may need to re-pin dest[]                  fixed (char* pDest = dest)                  {                      if ((unescapeMode & UnescapeMode.EscapeUnescape) == UnescapeMode.CopyOnly)                      {                          while (start < end)                              pDest[destPosition++] = pStr[start++];                          return dest;                      }                        while (true)                      {                          char ch = (char)0;                            for (; next < end; ++next)                          {                              if ((ch = pStr[next]) == '%')                              {                                  if ((unescapeMode & UnescapeMode.Unescape) == 0)                                  {                                      // re-escape' don't check anything else                                      escapeReserved = true;                                  }                                  else if (next + 2 < end)                                  {                                      ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                      // Unescape a good sequence if full unescape is requested                                      if (unescapeMode >= UnescapeMode.UnescapeAll)                                      {                                          if (ch == Uri.c_DummyChar)                                          {                                              if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                              {                                                  // Should be a rare case where the app tries to feed an invalid escaped sequence                                                  throw new UriFormatException(SR.net_uri_BadString);                                              }                                              continue;                                          }                                      }                                      // re-escape % from an invalid sequence                                      else if (ch == Uri.c_DummyChar)                                      {                                          if ((unescapeMode & UnescapeMode.Escape) != 0)                                              escapeReserved = true;                                          else                                              continue;   // we should throw instead but since v1.0 would just print '%'                                      }                                      // Do not unescape '%' itself unless full unescape is requested                                      else if (ch == '%')                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a reserved char unless full unescape is requested                                      else if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a dangerous char unless it's V1ToStringFlags mode                                      else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0 && IsNotSafeForUnescape(ch))                                      {                                          next += 2;                                          continue;                                      }                                      else if (iriParsing && ((ch <= '\x9F' && IsNotSafeForUnescape(ch)) ||                                                              (ch > '\x9F' && !IriHelper.CheckIriUnicodeRange(ch' isQuery))))                                      {                                          // check if unenscaping gives a char outside iri range                                           // if it does then keep it escaped                                          next += 2;                                          continue;                                      }                                      // unescape escaped char or escape %                                      break;                                  }                                  else if (unescapeMode >= UnescapeMode.UnescapeAll)                                  {                                      if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                      {                                          // Should be a rare case where the app tries to feed an invalid escaped sequence                                          throw new UriFormatException(SR.net_uri_BadString);                                      }                                      // keep a '%' as part of a bogus sequence                                       continue;                                  }                                  else                                  {                                      escapeReserved = true;                                  }                                  // escape (escapeReserved==true) or otherwise unescape the sequence                                  break;                              }                              else if ((unescapeMode & (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                                  == (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                              {                                  continue;                              }                              else if ((unescapeMode & UnescapeMode.Escape) != 0)                              {                                  // Could actually escape some of the characters                                  if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                                  else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0                                      && (ch <= '\x1F' || (ch >= '\x7F' && ch <= '\x9F')))                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                              }                          }                            //copy off previous characters from input                          while (start < next)                              pDest[destPosition++] = pStr[start++];                            if (next != end)                          {                              if (escapeReserved)                              {                                  //escape that char                                  // Since this should be _really_ rare case' reallocate with constant size increase of 30 rsvd-type characters.                                  if (escapedReallocations == 0)                                  {                                      escapedReallocations = 30;                                      char[] newDest = new char[dest.Length + escapedReallocations * 3];                                      fixed (char* pNewDest = &newDest[0])                                      {                                          for (int i = 0; i < destPosition; ++i)                                              pNewDest[i] = pDest[i];                                      }                                      dest = newDest;                                      // re-pin new dest[] array                                      goto dest_fixed_loop_break;                                  }                                  else                                  {                                      --escapedReallocations;                                      EscapeAsciiChar(pStr[next]' dest' ref destPosition);                                      escapeReserved = false;                                      start = ++next;                                      continue;                                  }                              }                                // unescaping either one Ascii or possibly multiple Unicode                                if (ch <= '\x7F')                              {                                  //ASCII                                  dest[destPosition++] = ch;                                  next += 3;                                  start = next;                                  continue;                              }                                // Unicode                                int byteCount = 1;                              // lazy initialization of max size' will reuse the array for next sequences                              if ((object)bytes == null)                                  bytes = new byte[end - next];                                bytes[0] = (byte)ch;                              next += 3;                              while (next < end)                              {                                  // Check on exit criterion                                  if ((ch = pStr[next]) != '%' || next + 2 >= end)                                      break;                                    // already made sure we have 3 characters in str                                  ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                    //invalid hex sequence ?                                  if (ch == Uri.c_DummyChar)                                      break;                                  // character is not part of a UTF-8 sequence ?                                  else if (ch < '\x80')                                      break;                                  else                                  {                                      //a UTF-8 sequence                                      bytes[byteCount++] = (byte)ch;                                      next += 3;                                  }                              }                                Encoding noFallbackCharUTF8 = Encoding.GetEncoding(                                                                                  Encoding.UTF8.CodePage'                                                                                  new EncoderReplacementFallback("")'                                                                                  new DecoderReplacementFallback(""));                                char[] unescapedChars = new char[bytes.Length];                              int charCount = noFallbackCharUTF8.GetChars(bytes' 0' byteCount' unescapedChars' 0);                                start = next;                                // match exact bytes                              // Do not unescape chars not allowed by Iri                              // need to check for invalid utf sequences that may not have given any chars                                MatchUTF8Sequence(pDest' dest' ref destPosition' unescapedChars' charCount' bytes'                                  byteCount' isQuery' iriParsing);                          }                            if (next == end)                              goto done;                      }                  dest_fixed_loop_break:;                  }              }
Magic Number,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,UnescapeString,The following statement contains a magic number: while (true)              {                  // we may need to re-pin dest[]                  fixed (char* pDest = dest)                  {                      if ((unescapeMode & UnescapeMode.EscapeUnescape) == UnescapeMode.CopyOnly)                      {                          while (start < end)                              pDest[destPosition++] = pStr[start++];                          return dest;                      }                        while (true)                      {                          char ch = (char)0;                            for (; next < end; ++next)                          {                              if ((ch = pStr[next]) == '%')                              {                                  if ((unescapeMode & UnescapeMode.Unescape) == 0)                                  {                                      // re-escape' don't check anything else                                      escapeReserved = true;                                  }                                  else if (next + 2 < end)                                  {                                      ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                      // Unescape a good sequence if full unescape is requested                                      if (unescapeMode >= UnescapeMode.UnescapeAll)                                      {                                          if (ch == Uri.c_DummyChar)                                          {                                              if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                              {                                                  // Should be a rare case where the app tries to feed an invalid escaped sequence                                                  throw new UriFormatException(SR.net_uri_BadString);                                              }                                              continue;                                          }                                      }                                      // re-escape % from an invalid sequence                                      else if (ch == Uri.c_DummyChar)                                      {                                          if ((unescapeMode & UnescapeMode.Escape) != 0)                                              escapeReserved = true;                                          else                                              continue;   // we should throw instead but since v1.0 would just print '%'                                      }                                      // Do not unescape '%' itself unless full unescape is requested                                      else if (ch == '%')                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a reserved char unless full unescape is requested                                      else if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a dangerous char unless it's V1ToStringFlags mode                                      else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0 && IsNotSafeForUnescape(ch))                                      {                                          next += 2;                                          continue;                                      }                                      else if (iriParsing && ((ch <= '\x9F' && IsNotSafeForUnescape(ch)) ||                                                              (ch > '\x9F' && !IriHelper.CheckIriUnicodeRange(ch' isQuery))))                                      {                                          // check if unenscaping gives a char outside iri range                                           // if it does then keep it escaped                                          next += 2;                                          continue;                                      }                                      // unescape escaped char or escape %                                      break;                                  }                                  else if (unescapeMode >= UnescapeMode.UnescapeAll)                                  {                                      if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                      {                                          // Should be a rare case where the app tries to feed an invalid escaped sequence                                          throw new UriFormatException(SR.net_uri_BadString);                                      }                                      // keep a '%' as part of a bogus sequence                                       continue;                                  }                                  else                                  {                                      escapeReserved = true;                                  }                                  // escape (escapeReserved==true) or otherwise unescape the sequence                                  break;                              }                              else if ((unescapeMode & (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                                  == (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                              {                                  continue;                              }                              else if ((unescapeMode & UnescapeMode.Escape) != 0)                              {                                  // Could actually escape some of the characters                                  if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                                  else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0                                      && (ch <= '\x1F' || (ch >= '\x7F' && ch <= '\x9F')))                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                              }                          }                            //copy off previous characters from input                          while (start < next)                              pDest[destPosition++] = pStr[start++];                            if (next != end)                          {                              if (escapeReserved)                              {                                  //escape that char                                  // Since this should be _really_ rare case' reallocate with constant size increase of 30 rsvd-type characters.                                  if (escapedReallocations == 0)                                  {                                      escapedReallocations = 30;                                      char[] newDest = new char[dest.Length + escapedReallocations * 3];                                      fixed (char* pNewDest = &newDest[0])                                      {                                          for (int i = 0; i < destPosition; ++i)                                              pNewDest[i] = pDest[i];                                      }                                      dest = newDest;                                      // re-pin new dest[] array                                      goto dest_fixed_loop_break;                                  }                                  else                                  {                                      --escapedReallocations;                                      EscapeAsciiChar(pStr[next]' dest' ref destPosition);                                      escapeReserved = false;                                      start = ++next;                                      continue;                                  }                              }                                // unescaping either one Ascii or possibly multiple Unicode                                if (ch <= '\x7F')                              {                                  //ASCII                                  dest[destPosition++] = ch;                                  next += 3;                                  start = next;                                  continue;                              }                                // Unicode                                int byteCount = 1;                              // lazy initialization of max size' will reuse the array for next sequences                              if ((object)bytes == null)                                  bytes = new byte[end - next];                                bytes[0] = (byte)ch;                              next += 3;                              while (next < end)                              {                                  // Check on exit criterion                                  if ((ch = pStr[next]) != '%' || next + 2 >= end)                                      break;                                    // already made sure we have 3 characters in str                                  ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                    //invalid hex sequence ?                                  if (ch == Uri.c_DummyChar)                                      break;                                  // character is not part of a UTF-8 sequence ?                                  else if (ch < '\x80')                                      break;                                  else                                  {                                      //a UTF-8 sequence                                      bytes[byteCount++] = (byte)ch;                                      next += 3;                                  }                              }                                Encoding noFallbackCharUTF8 = Encoding.GetEncoding(                                                                                  Encoding.UTF8.CodePage'                                                                                  new EncoderReplacementFallback("")'                                                                                  new DecoderReplacementFallback(""));                                char[] unescapedChars = new char[bytes.Length];                              int charCount = noFallbackCharUTF8.GetChars(bytes' 0' byteCount' unescapedChars' 0);                                start = next;                                // match exact bytes                              // Do not unescape chars not allowed by Iri                              // need to check for invalid utf sequences that may not have given any chars                                MatchUTF8Sequence(pDest' dest' ref destPosition' unescapedChars' charCount' bytes'                                  byteCount' isQuery' iriParsing);                          }                            if (next == end)                              goto done;                      }                  dest_fixed_loop_break:;                  }              }
Magic Number,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,UnescapeString,The following statement contains a magic number: while (true)              {                  // we may need to re-pin dest[]                  fixed (char* pDest = dest)                  {                      if ((unescapeMode & UnescapeMode.EscapeUnescape) == UnescapeMode.CopyOnly)                      {                          while (start < end)                              pDest[destPosition++] = pStr[start++];                          return dest;                      }                        while (true)                      {                          char ch = (char)0;                            for (; next < end; ++next)                          {                              if ((ch = pStr[next]) == '%')                              {                                  if ((unescapeMode & UnescapeMode.Unescape) == 0)                                  {                                      // re-escape' don't check anything else                                      escapeReserved = true;                                  }                                  else if (next + 2 < end)                                  {                                      ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                      // Unescape a good sequence if full unescape is requested                                      if (unescapeMode >= UnescapeMode.UnescapeAll)                                      {                                          if (ch == Uri.c_DummyChar)                                          {                                              if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                              {                                                  // Should be a rare case where the app tries to feed an invalid escaped sequence                                                  throw new UriFormatException(SR.net_uri_BadString);                                              }                                              continue;                                          }                                      }                                      // re-escape % from an invalid sequence                                      else if (ch == Uri.c_DummyChar)                                      {                                          if ((unescapeMode & UnescapeMode.Escape) != 0)                                              escapeReserved = true;                                          else                                              continue;   // we should throw instead but since v1.0 would just print '%'                                      }                                      // Do not unescape '%' itself unless full unescape is requested                                      else if (ch == '%')                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a reserved char unless full unescape is requested                                      else if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a dangerous char unless it's V1ToStringFlags mode                                      else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0 && IsNotSafeForUnescape(ch))                                      {                                          next += 2;                                          continue;                                      }                                      else if (iriParsing && ((ch <= '\x9F' && IsNotSafeForUnescape(ch)) ||                                                              (ch > '\x9F' && !IriHelper.CheckIriUnicodeRange(ch' isQuery))))                                      {                                          // check if unenscaping gives a char outside iri range                                           // if it does then keep it escaped                                          next += 2;                                          continue;                                      }                                      // unescape escaped char or escape %                                      break;                                  }                                  else if (unescapeMode >= UnescapeMode.UnescapeAll)                                  {                                      if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                      {                                          // Should be a rare case where the app tries to feed an invalid escaped sequence                                          throw new UriFormatException(SR.net_uri_BadString);                                      }                                      // keep a '%' as part of a bogus sequence                                       continue;                                  }                                  else                                  {                                      escapeReserved = true;                                  }                                  // escape (escapeReserved==true) or otherwise unescape the sequence                                  break;                              }                              else if ((unescapeMode & (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                                  == (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                              {                                  continue;                              }                              else if ((unescapeMode & UnescapeMode.Escape) != 0)                              {                                  // Could actually escape some of the characters                                  if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                                  else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0                                      && (ch <= '\x1F' || (ch >= '\x7F' && ch <= '\x9F')))                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                              }                          }                            //copy off previous characters from input                          while (start < next)                              pDest[destPosition++] = pStr[start++];                            if (next != end)                          {                              if (escapeReserved)                              {                                  //escape that char                                  // Since this should be _really_ rare case' reallocate with constant size increase of 30 rsvd-type characters.                                  if (escapedReallocations == 0)                                  {                                      escapedReallocations = 30;                                      char[] newDest = new char[dest.Length + escapedReallocations * 3];                                      fixed (char* pNewDest = &newDest[0])                                      {                                          for (int i = 0; i < destPosition; ++i)                                              pNewDest[i] = pDest[i];                                      }                                      dest = newDest;                                      // re-pin new dest[] array                                      goto dest_fixed_loop_break;                                  }                                  else                                  {                                      --escapedReallocations;                                      EscapeAsciiChar(pStr[next]' dest' ref destPosition);                                      escapeReserved = false;                                      start = ++next;                                      continue;                                  }                              }                                // unescaping either one Ascii or possibly multiple Unicode                                if (ch <= '\x7F')                              {                                  //ASCII                                  dest[destPosition++] = ch;                                  next += 3;                                  start = next;                                  continue;                              }                                // Unicode                                int byteCount = 1;                              // lazy initialization of max size' will reuse the array for next sequences                              if ((object)bytes == null)                                  bytes = new byte[end - next];                                bytes[0] = (byte)ch;                              next += 3;                              while (next < end)                              {                                  // Check on exit criterion                                  if ((ch = pStr[next]) != '%' || next + 2 >= end)                                      break;                                    // already made sure we have 3 characters in str                                  ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                    //invalid hex sequence ?                                  if (ch == Uri.c_DummyChar)                                      break;                                  // character is not part of a UTF-8 sequence ?                                  else if (ch < '\x80')                                      break;                                  else                                  {                                      //a UTF-8 sequence                                      bytes[byteCount++] = (byte)ch;                                      next += 3;                                  }                              }                                Encoding noFallbackCharUTF8 = Encoding.GetEncoding(                                                                                  Encoding.UTF8.CodePage'                                                                                  new EncoderReplacementFallback("")'                                                                                  new DecoderReplacementFallback(""));                                char[] unescapedChars = new char[bytes.Length];                              int charCount = noFallbackCharUTF8.GetChars(bytes' 0' byteCount' unescapedChars' 0);                                start = next;                                // match exact bytes                              // Do not unescape chars not allowed by Iri                              // need to check for invalid utf sequences that may not have given any chars                                MatchUTF8Sequence(pDest' dest' ref destPosition' unescapedChars' charCount' bytes'                                  byteCount' isQuery' iriParsing);                          }                            if (next == end)                              goto done;                      }                  dest_fixed_loop_break:;                  }              }
Magic Number,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,UnescapeString,The following statement contains a magic number: while (true)              {                  // we may need to re-pin dest[]                  fixed (char* pDest = dest)                  {                      if ((unescapeMode & UnescapeMode.EscapeUnescape) == UnescapeMode.CopyOnly)                      {                          while (start < end)                              pDest[destPosition++] = pStr[start++];                          return dest;                      }                        while (true)                      {                          char ch = (char)0;                            for (; next < end; ++next)                          {                              if ((ch = pStr[next]) == '%')                              {                                  if ((unescapeMode & UnescapeMode.Unescape) == 0)                                  {                                      // re-escape' don't check anything else                                      escapeReserved = true;                                  }                                  else if (next + 2 < end)                                  {                                      ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                      // Unescape a good sequence if full unescape is requested                                      if (unescapeMode >= UnescapeMode.UnescapeAll)                                      {                                          if (ch == Uri.c_DummyChar)                                          {                                              if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                              {                                                  // Should be a rare case where the app tries to feed an invalid escaped sequence                                                  throw new UriFormatException(SR.net_uri_BadString);                                              }                                              continue;                                          }                                      }                                      // re-escape % from an invalid sequence                                      else if (ch == Uri.c_DummyChar)                                      {                                          if ((unescapeMode & UnescapeMode.Escape) != 0)                                              escapeReserved = true;                                          else                                              continue;   // we should throw instead but since v1.0 would just print '%'                                      }                                      // Do not unescape '%' itself unless full unescape is requested                                      else if (ch == '%')                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a reserved char unless full unescape is requested                                      else if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a dangerous char unless it's V1ToStringFlags mode                                      else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0 && IsNotSafeForUnescape(ch))                                      {                                          next += 2;                                          continue;                                      }                                      else if (iriParsing && ((ch <= '\x9F' && IsNotSafeForUnescape(ch)) ||                                                              (ch > '\x9F' && !IriHelper.CheckIriUnicodeRange(ch' isQuery))))                                      {                                          // check if unenscaping gives a char outside iri range                                           // if it does then keep it escaped                                          next += 2;                                          continue;                                      }                                      // unescape escaped char or escape %                                      break;                                  }                                  else if (unescapeMode >= UnescapeMode.UnescapeAll)                                  {                                      if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                      {                                          // Should be a rare case where the app tries to feed an invalid escaped sequence                                          throw new UriFormatException(SR.net_uri_BadString);                                      }                                      // keep a '%' as part of a bogus sequence                                       continue;                                  }                                  else                                  {                                      escapeReserved = true;                                  }                                  // escape (escapeReserved==true) or otherwise unescape the sequence                                  break;                              }                              else if ((unescapeMode & (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                                  == (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                              {                                  continue;                              }                              else if ((unescapeMode & UnescapeMode.Escape) != 0)                              {                                  // Could actually escape some of the characters                                  if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                                  else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0                                      && (ch <= '\x1F' || (ch >= '\x7F' && ch <= '\x9F')))                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                              }                          }                            //copy off previous characters from input                          while (start < next)                              pDest[destPosition++] = pStr[start++];                            if (next != end)                          {                              if (escapeReserved)                              {                                  //escape that char                                  // Since this should be _really_ rare case' reallocate with constant size increase of 30 rsvd-type characters.                                  if (escapedReallocations == 0)                                  {                                      escapedReallocations = 30;                                      char[] newDest = new char[dest.Length + escapedReallocations * 3];                                      fixed (char* pNewDest = &newDest[0])                                      {                                          for (int i = 0; i < destPosition; ++i)                                              pNewDest[i] = pDest[i];                                      }                                      dest = newDest;                                      // re-pin new dest[] array                                      goto dest_fixed_loop_break;                                  }                                  else                                  {                                      --escapedReallocations;                                      EscapeAsciiChar(pStr[next]' dest' ref destPosition);                                      escapeReserved = false;                                      start = ++next;                                      continue;                                  }                              }                                // unescaping either one Ascii or possibly multiple Unicode                                if (ch <= '\x7F')                              {                                  //ASCII                                  dest[destPosition++] = ch;                                  next += 3;                                  start = next;                                  continue;                              }                                // Unicode                                int byteCount = 1;                              // lazy initialization of max size' will reuse the array for next sequences                              if ((object)bytes == null)                                  bytes = new byte[end - next];                                bytes[0] = (byte)ch;                              next += 3;                              while (next < end)                              {                                  // Check on exit criterion                                  if ((ch = pStr[next]) != '%' || next + 2 >= end)                                      break;                                    // already made sure we have 3 characters in str                                  ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                    //invalid hex sequence ?                                  if (ch == Uri.c_DummyChar)                                      break;                                  // character is not part of a UTF-8 sequence ?                                  else if (ch < '\x80')                                      break;                                  else                                  {                                      //a UTF-8 sequence                                      bytes[byteCount++] = (byte)ch;                                      next += 3;                                  }                              }                                Encoding noFallbackCharUTF8 = Encoding.GetEncoding(                                                                                  Encoding.UTF8.CodePage'                                                                                  new EncoderReplacementFallback("")'                                                                                  new DecoderReplacementFallback(""));                                char[] unescapedChars = new char[bytes.Length];                              int charCount = noFallbackCharUTF8.GetChars(bytes' 0' byteCount' unescapedChars' 0);                                start = next;                                // match exact bytes                              // Do not unescape chars not allowed by Iri                              // need to check for invalid utf sequences that may not have given any chars                                MatchUTF8Sequence(pDest' dest' ref destPosition' unescapedChars' charCount' bytes'                                  byteCount' isQuery' iriParsing);                          }                            if (next == end)                              goto done;                      }                  dest_fixed_loop_break:;                  }              }
Magic Number,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,UnescapeString,The following statement contains a magic number: while (true)              {                  // we may need to re-pin dest[]                  fixed (char* pDest = dest)                  {                      if ((unescapeMode & UnescapeMode.EscapeUnescape) == UnescapeMode.CopyOnly)                      {                          while (start < end)                              pDest[destPosition++] = pStr[start++];                          return dest;                      }                        while (true)                      {                          char ch = (char)0;                            for (; next < end; ++next)                          {                              if ((ch = pStr[next]) == '%')                              {                                  if ((unescapeMode & UnescapeMode.Unescape) == 0)                                  {                                      // re-escape' don't check anything else                                      escapeReserved = true;                                  }                                  else if (next + 2 < end)                                  {                                      ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                      // Unescape a good sequence if full unescape is requested                                      if (unescapeMode >= UnescapeMode.UnescapeAll)                                      {                                          if (ch == Uri.c_DummyChar)                                          {                                              if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                              {                                                  // Should be a rare case where the app tries to feed an invalid escaped sequence                                                  throw new UriFormatException(SR.net_uri_BadString);                                              }                                              continue;                                          }                                      }                                      // re-escape % from an invalid sequence                                      else if (ch == Uri.c_DummyChar)                                      {                                          if ((unescapeMode & UnescapeMode.Escape) != 0)                                              escapeReserved = true;                                          else                                              continue;   // we should throw instead but since v1.0 would just print '%'                                      }                                      // Do not unescape '%' itself unless full unescape is requested                                      else if (ch == '%')                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a reserved char unless full unescape is requested                                      else if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a dangerous char unless it's V1ToStringFlags mode                                      else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0 && IsNotSafeForUnescape(ch))                                      {                                          next += 2;                                          continue;                                      }                                      else if (iriParsing && ((ch <= '\x9F' && IsNotSafeForUnescape(ch)) ||                                                              (ch > '\x9F' && !IriHelper.CheckIriUnicodeRange(ch' isQuery))))                                      {                                          // check if unenscaping gives a char outside iri range                                           // if it does then keep it escaped                                          next += 2;                                          continue;                                      }                                      // unescape escaped char or escape %                                      break;                                  }                                  else if (unescapeMode >= UnescapeMode.UnescapeAll)                                  {                                      if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                      {                                          // Should be a rare case where the app tries to feed an invalid escaped sequence                                          throw new UriFormatException(SR.net_uri_BadString);                                      }                                      // keep a '%' as part of a bogus sequence                                       continue;                                  }                                  else                                  {                                      escapeReserved = true;                                  }                                  // escape (escapeReserved==true) or otherwise unescape the sequence                                  break;                              }                              else if ((unescapeMode & (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                                  == (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                              {                                  continue;                              }                              else if ((unescapeMode & UnescapeMode.Escape) != 0)                              {                                  // Could actually escape some of the characters                                  if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                                  else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0                                      && (ch <= '\x1F' || (ch >= '\x7F' && ch <= '\x9F')))                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                              }                          }                            //copy off previous characters from input                          while (start < next)                              pDest[destPosition++] = pStr[start++];                            if (next != end)                          {                              if (escapeReserved)                              {                                  //escape that char                                  // Since this should be _really_ rare case' reallocate with constant size increase of 30 rsvd-type characters.                                  if (escapedReallocations == 0)                                  {                                      escapedReallocations = 30;                                      char[] newDest = new char[dest.Length + escapedReallocations * 3];                                      fixed (char* pNewDest = &newDest[0])                                      {                                          for (int i = 0; i < destPosition; ++i)                                              pNewDest[i] = pDest[i];                                      }                                      dest = newDest;                                      // re-pin new dest[] array                                      goto dest_fixed_loop_break;                                  }                                  else                                  {                                      --escapedReallocations;                                      EscapeAsciiChar(pStr[next]' dest' ref destPosition);                                      escapeReserved = false;                                      start = ++next;                                      continue;                                  }                              }                                // unescaping either one Ascii or possibly multiple Unicode                                if (ch <= '\x7F')                              {                                  //ASCII                                  dest[destPosition++] = ch;                                  next += 3;                                  start = next;                                  continue;                              }                                // Unicode                                int byteCount = 1;                              // lazy initialization of max size' will reuse the array for next sequences                              if ((object)bytes == null)                                  bytes = new byte[end - next];                                bytes[0] = (byte)ch;                              next += 3;                              while (next < end)                              {                                  // Check on exit criterion                                  if ((ch = pStr[next]) != '%' || next + 2 >= end)                                      break;                                    // already made sure we have 3 characters in str                                  ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                    //invalid hex sequence ?                                  if (ch == Uri.c_DummyChar)                                      break;                                  // character is not part of a UTF-8 sequence ?                                  else if (ch < '\x80')                                      break;                                  else                                  {                                      //a UTF-8 sequence                                      bytes[byteCount++] = (byte)ch;                                      next += 3;                                  }                              }                                Encoding noFallbackCharUTF8 = Encoding.GetEncoding(                                                                                  Encoding.UTF8.CodePage'                                                                                  new EncoderReplacementFallback("")'                                                                                  new DecoderReplacementFallback(""));                                char[] unescapedChars = new char[bytes.Length];                              int charCount = noFallbackCharUTF8.GetChars(bytes' 0' byteCount' unescapedChars' 0);                                start = next;                                // match exact bytes                              // Do not unescape chars not allowed by Iri                              // need to check for invalid utf sequences that may not have given any chars                                MatchUTF8Sequence(pDest' dest' ref destPosition' unescapedChars' charCount' bytes'                                  byteCount' isQuery' iriParsing);                          }                            if (next == end)                              goto done;                      }                  dest_fixed_loop_break:;                  }              }
Magic Number,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,UnescapeString,The following statement contains a magic number: while (true)              {                  // we may need to re-pin dest[]                  fixed (char* pDest = dest)                  {                      if ((unescapeMode & UnescapeMode.EscapeUnescape) == UnescapeMode.CopyOnly)                      {                          while (start < end)                              pDest[destPosition++] = pStr[start++];                          return dest;                      }                        while (true)                      {                          char ch = (char)0;                            for (; next < end; ++next)                          {                              if ((ch = pStr[next]) == '%')                              {                                  if ((unescapeMode & UnescapeMode.Unescape) == 0)                                  {                                      // re-escape' don't check anything else                                      escapeReserved = true;                                  }                                  else if (next + 2 < end)                                  {                                      ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                      // Unescape a good sequence if full unescape is requested                                      if (unescapeMode >= UnescapeMode.UnescapeAll)                                      {                                          if (ch == Uri.c_DummyChar)                                          {                                              if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                              {                                                  // Should be a rare case where the app tries to feed an invalid escaped sequence                                                  throw new UriFormatException(SR.net_uri_BadString);                                              }                                              continue;                                          }                                      }                                      // re-escape % from an invalid sequence                                      else if (ch == Uri.c_DummyChar)                                      {                                          if ((unescapeMode & UnescapeMode.Escape) != 0)                                              escapeReserved = true;                                          else                                              continue;   // we should throw instead but since v1.0 would just print '%'                                      }                                      // Do not unescape '%' itself unless full unescape is requested                                      else if (ch == '%')                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a reserved char unless full unescape is requested                                      else if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a dangerous char unless it's V1ToStringFlags mode                                      else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0 && IsNotSafeForUnescape(ch))                                      {                                          next += 2;                                          continue;                                      }                                      else if (iriParsing && ((ch <= '\x9F' && IsNotSafeForUnescape(ch)) ||                                                              (ch > '\x9F' && !IriHelper.CheckIriUnicodeRange(ch' isQuery))))                                      {                                          // check if unenscaping gives a char outside iri range                                           // if it does then keep it escaped                                          next += 2;                                          continue;                                      }                                      // unescape escaped char or escape %                                      break;                                  }                                  else if (unescapeMode >= UnescapeMode.UnescapeAll)                                  {                                      if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                      {                                          // Should be a rare case where the app tries to feed an invalid escaped sequence                                          throw new UriFormatException(SR.net_uri_BadString);                                      }                                      // keep a '%' as part of a bogus sequence                                       continue;                                  }                                  else                                  {                                      escapeReserved = true;                                  }                                  // escape (escapeReserved==true) or otherwise unescape the sequence                                  break;                              }                              else if ((unescapeMode & (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                                  == (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                              {                                  continue;                              }                              else if ((unescapeMode & UnescapeMode.Escape) != 0)                              {                                  // Could actually escape some of the characters                                  if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                                  else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0                                      && (ch <= '\x1F' || (ch >= '\x7F' && ch <= '\x9F')))                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                              }                          }                            //copy off previous characters from input                          while (start < next)                              pDest[destPosition++] = pStr[start++];                            if (next != end)                          {                              if (escapeReserved)                              {                                  //escape that char                                  // Since this should be _really_ rare case' reallocate with constant size increase of 30 rsvd-type characters.                                  if (escapedReallocations == 0)                                  {                                      escapedReallocations = 30;                                      char[] newDest = new char[dest.Length + escapedReallocations * 3];                                      fixed (char* pNewDest = &newDest[0])                                      {                                          for (int i = 0; i < destPosition; ++i)                                              pNewDest[i] = pDest[i];                                      }                                      dest = newDest;                                      // re-pin new dest[] array                                      goto dest_fixed_loop_break;                                  }                                  else                                  {                                      --escapedReallocations;                                      EscapeAsciiChar(pStr[next]' dest' ref destPosition);                                      escapeReserved = false;                                      start = ++next;                                      continue;                                  }                              }                                // unescaping either one Ascii or possibly multiple Unicode                                if (ch <= '\x7F')                              {                                  //ASCII                                  dest[destPosition++] = ch;                                  next += 3;                                  start = next;                                  continue;                              }                                // Unicode                                int byteCount = 1;                              // lazy initialization of max size' will reuse the array for next sequences                              if ((object)bytes == null)                                  bytes = new byte[end - next];                                bytes[0] = (byte)ch;                              next += 3;                              while (next < end)                              {                                  // Check on exit criterion                                  if ((ch = pStr[next]) != '%' || next + 2 >= end)                                      break;                                    // already made sure we have 3 characters in str                                  ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                    //invalid hex sequence ?                                  if (ch == Uri.c_DummyChar)                                      break;                                  // character is not part of a UTF-8 sequence ?                                  else if (ch < '\x80')                                      break;                                  else                                  {                                      //a UTF-8 sequence                                      bytes[byteCount++] = (byte)ch;                                      next += 3;                                  }                              }                                Encoding noFallbackCharUTF8 = Encoding.GetEncoding(                                                                                  Encoding.UTF8.CodePage'                                                                                  new EncoderReplacementFallback("")'                                                                                  new DecoderReplacementFallback(""));                                char[] unescapedChars = new char[bytes.Length];                              int charCount = noFallbackCharUTF8.GetChars(bytes' 0' byteCount' unescapedChars' 0);                                start = next;                                // match exact bytes                              // Do not unescape chars not allowed by Iri                              // need to check for invalid utf sequences that may not have given any chars                                MatchUTF8Sequence(pDest' dest' ref destPosition' unescapedChars' charCount' bytes'                                  byteCount' isQuery' iriParsing);                          }                            if (next == end)                              goto done;                      }                  dest_fixed_loop_break:;                  }              }
Magic Number,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,UnescapeString,The following statement contains a magic number: while (true)              {                  // we may need to re-pin dest[]                  fixed (char* pDest = dest)                  {                      if ((unescapeMode & UnescapeMode.EscapeUnescape) == UnescapeMode.CopyOnly)                      {                          while (start < end)                              pDest[destPosition++] = pStr[start++];                          return dest;                      }                        while (true)                      {                          char ch = (char)0;                            for (; next < end; ++next)                          {                              if ((ch = pStr[next]) == '%')                              {                                  if ((unescapeMode & UnescapeMode.Unescape) == 0)                                  {                                      // re-escape' don't check anything else                                      escapeReserved = true;                                  }                                  else if (next + 2 < end)                                  {                                      ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                      // Unescape a good sequence if full unescape is requested                                      if (unescapeMode >= UnescapeMode.UnescapeAll)                                      {                                          if (ch == Uri.c_DummyChar)                                          {                                              if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                              {                                                  // Should be a rare case where the app tries to feed an invalid escaped sequence                                                  throw new UriFormatException(SR.net_uri_BadString);                                              }                                              continue;                                          }                                      }                                      // re-escape % from an invalid sequence                                      else if (ch == Uri.c_DummyChar)                                      {                                          if ((unescapeMode & UnescapeMode.Escape) != 0)                                              escapeReserved = true;                                          else                                              continue;   // we should throw instead but since v1.0 would just print '%'                                      }                                      // Do not unescape '%' itself unless full unescape is requested                                      else if (ch == '%')                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a reserved char unless full unescape is requested                                      else if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a dangerous char unless it's V1ToStringFlags mode                                      else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0 && IsNotSafeForUnescape(ch))                                      {                                          next += 2;                                          continue;                                      }                                      else if (iriParsing && ((ch <= '\x9F' && IsNotSafeForUnescape(ch)) ||                                                              (ch > '\x9F' && !IriHelper.CheckIriUnicodeRange(ch' isQuery))))                                      {                                          // check if unenscaping gives a char outside iri range                                           // if it does then keep it escaped                                          next += 2;                                          continue;                                      }                                      // unescape escaped char or escape %                                      break;                                  }                                  else if (unescapeMode >= UnescapeMode.UnescapeAll)                                  {                                      if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                      {                                          // Should be a rare case where the app tries to feed an invalid escaped sequence                                          throw new UriFormatException(SR.net_uri_BadString);                                      }                                      // keep a '%' as part of a bogus sequence                                       continue;                                  }                                  else                                  {                                      escapeReserved = true;                                  }                                  // escape (escapeReserved==true) or otherwise unescape the sequence                                  break;                              }                              else if ((unescapeMode & (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                                  == (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                              {                                  continue;                              }                              else if ((unescapeMode & UnescapeMode.Escape) != 0)                              {                                  // Could actually escape some of the characters                                  if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                                  else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0                                      && (ch <= '\x1F' || (ch >= '\x7F' && ch <= '\x9F')))                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                              }                          }                            //copy off previous characters from input                          while (start < next)                              pDest[destPosition++] = pStr[start++];                            if (next != end)                          {                              if (escapeReserved)                              {                                  //escape that char                                  // Since this should be _really_ rare case' reallocate with constant size increase of 30 rsvd-type characters.                                  if (escapedReallocations == 0)                                  {                                      escapedReallocations = 30;                                      char[] newDest = new char[dest.Length + escapedReallocations * 3];                                      fixed (char* pNewDest = &newDest[0])                                      {                                          for (int i = 0; i < destPosition; ++i)                                              pNewDest[i] = pDest[i];                                      }                                      dest = newDest;                                      // re-pin new dest[] array                                      goto dest_fixed_loop_break;                                  }                                  else                                  {                                      --escapedReallocations;                                      EscapeAsciiChar(pStr[next]' dest' ref destPosition);                                      escapeReserved = false;                                      start = ++next;                                      continue;                                  }                              }                                // unescaping either one Ascii or possibly multiple Unicode                                if (ch <= '\x7F')                              {                                  //ASCII                                  dest[destPosition++] = ch;                                  next += 3;                                  start = next;                                  continue;                              }                                // Unicode                                int byteCount = 1;                              // lazy initialization of max size' will reuse the array for next sequences                              if ((object)bytes == null)                                  bytes = new byte[end - next];                                bytes[0] = (byte)ch;                              next += 3;                              while (next < end)                              {                                  // Check on exit criterion                                  if ((ch = pStr[next]) != '%' || next + 2 >= end)                                      break;                                    // already made sure we have 3 characters in str                                  ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                    //invalid hex sequence ?                                  if (ch == Uri.c_DummyChar)                                      break;                                  // character is not part of a UTF-8 sequence ?                                  else if (ch < '\x80')                                      break;                                  else                                  {                                      //a UTF-8 sequence                                      bytes[byteCount++] = (byte)ch;                                      next += 3;                                  }                              }                                Encoding noFallbackCharUTF8 = Encoding.GetEncoding(                                                                                  Encoding.UTF8.CodePage'                                                                                  new EncoderReplacementFallback("")'                                                                                  new DecoderReplacementFallback(""));                                char[] unescapedChars = new char[bytes.Length];                              int charCount = noFallbackCharUTF8.GetChars(bytes' 0' byteCount' unescapedChars' 0);                                start = next;                                // match exact bytes                              // Do not unescape chars not allowed by Iri                              // need to check for invalid utf sequences that may not have given any chars                                MatchUTF8Sequence(pDest' dest' ref destPosition' unescapedChars' charCount' bytes'                                  byteCount' isQuery' iriParsing);                          }                            if (next == end)                              goto done;                      }                  dest_fixed_loop_break:;                  }              }
Magic Number,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,UnescapeString,The following statement contains a magic number: while (true)              {                  // we may need to re-pin dest[]                  fixed (char* pDest = dest)                  {                      if ((unescapeMode & UnescapeMode.EscapeUnescape) == UnescapeMode.CopyOnly)                      {                          while (start < end)                              pDest[destPosition++] = pStr[start++];                          return dest;                      }                        while (true)                      {                          char ch = (char)0;                            for (; next < end; ++next)                          {                              if ((ch = pStr[next]) == '%')                              {                                  if ((unescapeMode & UnescapeMode.Unescape) == 0)                                  {                                      // re-escape' don't check anything else                                      escapeReserved = true;                                  }                                  else if (next + 2 < end)                                  {                                      ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                      // Unescape a good sequence if full unescape is requested                                      if (unescapeMode >= UnescapeMode.UnescapeAll)                                      {                                          if (ch == Uri.c_DummyChar)                                          {                                              if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                              {                                                  // Should be a rare case where the app tries to feed an invalid escaped sequence                                                  throw new UriFormatException(SR.net_uri_BadString);                                              }                                              continue;                                          }                                      }                                      // re-escape % from an invalid sequence                                      else if (ch == Uri.c_DummyChar)                                      {                                          if ((unescapeMode & UnescapeMode.Escape) != 0)                                              escapeReserved = true;                                          else                                              continue;   // we should throw instead but since v1.0 would just print '%'                                      }                                      // Do not unescape '%' itself unless full unescape is requested                                      else if (ch == '%')                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a reserved char unless full unescape is requested                                      else if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a dangerous char unless it's V1ToStringFlags mode                                      else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0 && IsNotSafeForUnescape(ch))                                      {                                          next += 2;                                          continue;                                      }                                      else if (iriParsing && ((ch <= '\x9F' && IsNotSafeForUnescape(ch)) ||                                                              (ch > '\x9F' && !IriHelper.CheckIriUnicodeRange(ch' isQuery))))                                      {                                          // check if unenscaping gives a char outside iri range                                           // if it does then keep it escaped                                          next += 2;                                          continue;                                      }                                      // unescape escaped char or escape %                                      break;                                  }                                  else if (unescapeMode >= UnescapeMode.UnescapeAll)                                  {                                      if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                      {                                          // Should be a rare case where the app tries to feed an invalid escaped sequence                                          throw new UriFormatException(SR.net_uri_BadString);                                      }                                      // keep a '%' as part of a bogus sequence                                       continue;                                  }                                  else                                  {                                      escapeReserved = true;                                  }                                  // escape (escapeReserved==true) or otherwise unescape the sequence                                  break;                              }                              else if ((unescapeMode & (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                                  == (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                              {                                  continue;                              }                              else if ((unescapeMode & UnescapeMode.Escape) != 0)                              {                                  // Could actually escape some of the characters                                  if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                                  else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0                                      && (ch <= '\x1F' || (ch >= '\x7F' && ch <= '\x9F')))                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                              }                          }                            //copy off previous characters from input                          while (start < next)                              pDest[destPosition++] = pStr[start++];                            if (next != end)                          {                              if (escapeReserved)                              {                                  //escape that char                                  // Since this should be _really_ rare case' reallocate with constant size increase of 30 rsvd-type characters.                                  if (escapedReallocations == 0)                                  {                                      escapedReallocations = 30;                                      char[] newDest = new char[dest.Length + escapedReallocations * 3];                                      fixed (char* pNewDest = &newDest[0])                                      {                                          for (int i = 0; i < destPosition; ++i)                                              pNewDest[i] = pDest[i];                                      }                                      dest = newDest;                                      // re-pin new dest[] array                                      goto dest_fixed_loop_break;                                  }                                  else                                  {                                      --escapedReallocations;                                      EscapeAsciiChar(pStr[next]' dest' ref destPosition);                                      escapeReserved = false;                                      start = ++next;                                      continue;                                  }                              }                                // unescaping either one Ascii or possibly multiple Unicode                                if (ch <= '\x7F')                              {                                  //ASCII                                  dest[destPosition++] = ch;                                  next += 3;                                  start = next;                                  continue;                              }                                // Unicode                                int byteCount = 1;                              // lazy initialization of max size' will reuse the array for next sequences                              if ((object)bytes == null)                                  bytes = new byte[end - next];                                bytes[0] = (byte)ch;                              next += 3;                              while (next < end)                              {                                  // Check on exit criterion                                  if ((ch = pStr[next]) != '%' || next + 2 >= end)                                      break;                                    // already made sure we have 3 characters in str                                  ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                    //invalid hex sequence ?                                  if (ch == Uri.c_DummyChar)                                      break;                                  // character is not part of a UTF-8 sequence ?                                  else if (ch < '\x80')                                      break;                                  else                                  {                                      //a UTF-8 sequence                                      bytes[byteCount++] = (byte)ch;                                      next += 3;                                  }                              }                                Encoding noFallbackCharUTF8 = Encoding.GetEncoding(                                                                                  Encoding.UTF8.CodePage'                                                                                  new EncoderReplacementFallback("")'                                                                                  new DecoderReplacementFallback(""));                                char[] unescapedChars = new char[bytes.Length];                              int charCount = noFallbackCharUTF8.GetChars(bytes' 0' byteCount' unescapedChars' 0);                                start = next;                                // match exact bytes                              // Do not unescape chars not allowed by Iri                              // need to check for invalid utf sequences that may not have given any chars                                MatchUTF8Sequence(pDest' dest' ref destPosition' unescapedChars' charCount' bytes'                                  byteCount' isQuery' iriParsing);                          }                            if (next == end)                              goto done;                      }                  dest_fixed_loop_break:;                  }              }
Magic Number,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,UnescapeString,The following statement contains a magic number: while (true)              {                  // we may need to re-pin dest[]                  fixed (char* pDest = dest)                  {                      if ((unescapeMode & UnescapeMode.EscapeUnescape) == UnescapeMode.CopyOnly)                      {                          while (start < end)                              pDest[destPosition++] = pStr[start++];                          return dest;                      }                        while (true)                      {                          char ch = (char)0;                            for (; next < end; ++next)                          {                              if ((ch = pStr[next]) == '%')                              {                                  if ((unescapeMode & UnescapeMode.Unescape) == 0)                                  {                                      // re-escape' don't check anything else                                      escapeReserved = true;                                  }                                  else if (next + 2 < end)                                  {                                      ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                      // Unescape a good sequence if full unescape is requested                                      if (unescapeMode >= UnescapeMode.UnescapeAll)                                      {                                          if (ch == Uri.c_DummyChar)                                          {                                              if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                              {                                                  // Should be a rare case where the app tries to feed an invalid escaped sequence                                                  throw new UriFormatException(SR.net_uri_BadString);                                              }                                              continue;                                          }                                      }                                      // re-escape % from an invalid sequence                                      else if (ch == Uri.c_DummyChar)                                      {                                          if ((unescapeMode & UnescapeMode.Escape) != 0)                                              escapeReserved = true;                                          else                                              continue;   // we should throw instead but since v1.0 would just print '%'                                      }                                      // Do not unescape '%' itself unless full unescape is requested                                      else if (ch == '%')                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a reserved char unless full unescape is requested                                      else if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a dangerous char unless it's V1ToStringFlags mode                                      else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0 && IsNotSafeForUnescape(ch))                                      {                                          next += 2;                                          continue;                                      }                                      else if (iriParsing && ((ch <= '\x9F' && IsNotSafeForUnescape(ch)) ||                                                              (ch > '\x9F' && !IriHelper.CheckIriUnicodeRange(ch' isQuery))))                                      {                                          // check if unenscaping gives a char outside iri range                                           // if it does then keep it escaped                                          next += 2;                                          continue;                                      }                                      // unescape escaped char or escape %                                      break;                                  }                                  else if (unescapeMode >= UnescapeMode.UnescapeAll)                                  {                                      if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                      {                                          // Should be a rare case where the app tries to feed an invalid escaped sequence                                          throw new UriFormatException(SR.net_uri_BadString);                                      }                                      // keep a '%' as part of a bogus sequence                                       continue;                                  }                                  else                                  {                                      escapeReserved = true;                                  }                                  // escape (escapeReserved==true) or otherwise unescape the sequence                                  break;                              }                              else if ((unescapeMode & (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                                  == (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                              {                                  continue;                              }                              else if ((unescapeMode & UnescapeMode.Escape) != 0)                              {                                  // Could actually escape some of the characters                                  if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                                  else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0                                      && (ch <= '\x1F' || (ch >= '\x7F' && ch <= '\x9F')))                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                              }                          }                            //copy off previous characters from input                          while (start < next)                              pDest[destPosition++] = pStr[start++];                            if (next != end)                          {                              if (escapeReserved)                              {                                  //escape that char                                  // Since this should be _really_ rare case' reallocate with constant size increase of 30 rsvd-type characters.                                  if (escapedReallocations == 0)                                  {                                      escapedReallocations = 30;                                      char[] newDest = new char[dest.Length + escapedReallocations * 3];                                      fixed (char* pNewDest = &newDest[0])                                      {                                          for (int i = 0; i < destPosition; ++i)                                              pNewDest[i] = pDest[i];                                      }                                      dest = newDest;                                      // re-pin new dest[] array                                      goto dest_fixed_loop_break;                                  }                                  else                                  {                                      --escapedReallocations;                                      EscapeAsciiChar(pStr[next]' dest' ref destPosition);                                      escapeReserved = false;                                      start = ++next;                                      continue;                                  }                              }                                // unescaping either one Ascii or possibly multiple Unicode                                if (ch <= '\x7F')                              {                                  //ASCII                                  dest[destPosition++] = ch;                                  next += 3;                                  start = next;                                  continue;                              }                                // Unicode                                int byteCount = 1;                              // lazy initialization of max size' will reuse the array for next sequences                              if ((object)bytes == null)                                  bytes = new byte[end - next];                                bytes[0] = (byte)ch;                              next += 3;                              while (next < end)                              {                                  // Check on exit criterion                                  if ((ch = pStr[next]) != '%' || next + 2 >= end)                                      break;                                    // already made sure we have 3 characters in str                                  ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                    //invalid hex sequence ?                                  if (ch == Uri.c_DummyChar)                                      break;                                  // character is not part of a UTF-8 sequence ?                                  else if (ch < '\x80')                                      break;                                  else                                  {                                      //a UTF-8 sequence                                      bytes[byteCount++] = (byte)ch;                                      next += 3;                                  }                              }                                Encoding noFallbackCharUTF8 = Encoding.GetEncoding(                                                                                  Encoding.UTF8.CodePage'                                                                                  new EncoderReplacementFallback("")'                                                                                  new DecoderReplacementFallback(""));                                char[] unescapedChars = new char[bytes.Length];                              int charCount = noFallbackCharUTF8.GetChars(bytes' 0' byteCount' unescapedChars' 0);                                start = next;                                // match exact bytes                              // Do not unescape chars not allowed by Iri                              // need to check for invalid utf sequences that may not have given any chars                                MatchUTF8Sequence(pDest' dest' ref destPosition' unescapedChars' charCount' bytes'                                  byteCount' isQuery' iriParsing);                          }                            if (next == end)                              goto done;                      }                  dest_fixed_loop_break:;                  }              }
Magic Number,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,UnescapeString,The following statement contains a magic number: while (true)              {                  // we may need to re-pin dest[]                  fixed (char* pDest = dest)                  {                      if ((unescapeMode & UnescapeMode.EscapeUnescape) == UnescapeMode.CopyOnly)                      {                          while (start < end)                              pDest[destPosition++] = pStr[start++];                          return dest;                      }                        while (true)                      {                          char ch = (char)0;                            for (; next < end; ++next)                          {                              if ((ch = pStr[next]) == '%')                              {                                  if ((unescapeMode & UnescapeMode.Unescape) == 0)                                  {                                      // re-escape' don't check anything else                                      escapeReserved = true;                                  }                                  else if (next + 2 < end)                                  {                                      ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                      // Unescape a good sequence if full unescape is requested                                      if (unescapeMode >= UnescapeMode.UnescapeAll)                                      {                                          if (ch == Uri.c_DummyChar)                                          {                                              if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                              {                                                  // Should be a rare case where the app tries to feed an invalid escaped sequence                                                  throw new UriFormatException(SR.net_uri_BadString);                                              }                                              continue;                                          }                                      }                                      // re-escape % from an invalid sequence                                      else if (ch == Uri.c_DummyChar)                                      {                                          if ((unescapeMode & UnescapeMode.Escape) != 0)                                              escapeReserved = true;                                          else                                              continue;   // we should throw instead but since v1.0 would just print '%'                                      }                                      // Do not unescape '%' itself unless full unescape is requested                                      else if (ch == '%')                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a reserved char unless full unescape is requested                                      else if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                      {                                          next += 2;                                          continue;                                      }                                      // Do not unescape a dangerous char unless it's V1ToStringFlags mode                                      else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0 && IsNotSafeForUnescape(ch))                                      {                                          next += 2;                                          continue;                                      }                                      else if (iriParsing && ((ch <= '\x9F' && IsNotSafeForUnescape(ch)) ||                                                              (ch > '\x9F' && !IriHelper.CheckIriUnicodeRange(ch' isQuery))))                                      {                                          // check if unenscaping gives a char outside iri range                                           // if it does then keep it escaped                                          next += 2;                                          continue;                                      }                                      // unescape escaped char or escape %                                      break;                                  }                                  else if (unescapeMode >= UnescapeMode.UnescapeAll)                                  {                                      if (unescapeMode >= UnescapeMode.UnescapeAllOrThrow)                                      {                                          // Should be a rare case where the app tries to feed an invalid escaped sequence                                          throw new UriFormatException(SR.net_uri_BadString);                                      }                                      // keep a '%' as part of a bogus sequence                                       continue;                                  }                                  else                                  {                                      escapeReserved = true;                                  }                                  // escape (escapeReserved==true) or otherwise unescape the sequence                                  break;                              }                              else if ((unescapeMode & (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                                  == (UnescapeMode.Unescape | UnescapeMode.UnescapeAll))                              {                                  continue;                              }                              else if ((unescapeMode & UnescapeMode.Escape) != 0)                              {                                  // Could actually escape some of the characters                                  if (ch == rsvd1 || ch == rsvd2 || ch == rsvd3)                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                                  else if ((unescapeMode & UnescapeMode.V1ToStringFlag) == 0                                      && (ch <= '\x1F' || (ch >= '\x7F' && ch <= '\x9F')))                                  {                                      // found an unescaped reserved character -> escape it                                      escapeReserved = true;                                      break;                                  }                              }                          }                            //copy off previous characters from input                          while (start < next)                              pDest[destPosition++] = pStr[start++];                            if (next != end)                          {                              if (escapeReserved)                              {                                  //escape that char                                  // Since this should be _really_ rare case' reallocate with constant size increase of 30 rsvd-type characters.                                  if (escapedReallocations == 0)                                  {                                      escapedReallocations = 30;                                      char[] newDest = new char[dest.Length + escapedReallocations * 3];                                      fixed (char* pNewDest = &newDest[0])                                      {                                          for (int i = 0; i < destPosition; ++i)                                              pNewDest[i] = pDest[i];                                      }                                      dest = newDest;                                      // re-pin new dest[] array                                      goto dest_fixed_loop_break;                                  }                                  else                                  {                                      --escapedReallocations;                                      EscapeAsciiChar(pStr[next]' dest' ref destPosition);                                      escapeReserved = false;                                      start = ++next;                                      continue;                                  }                              }                                // unescaping either one Ascii or possibly multiple Unicode                                if (ch <= '\x7F')                              {                                  //ASCII                                  dest[destPosition++] = ch;                                  next += 3;                                  start = next;                                  continue;                              }                                // Unicode                                int byteCount = 1;                              // lazy initialization of max size' will reuse the array for next sequences                              if ((object)bytes == null)                                  bytes = new byte[end - next];                                bytes[0] = (byte)ch;                              next += 3;                              while (next < end)                              {                                  // Check on exit criterion                                  if ((ch = pStr[next]) != '%' || next + 2 >= end)                                      break;                                    // already made sure we have 3 characters in str                                  ch = EscapedAscii(pStr[next + 1]' pStr[next + 2]);                                    //invalid hex sequence ?                                  if (ch == Uri.c_DummyChar)                                      break;                                  // character is not part of a UTF-8 sequence ?                                  else if (ch < '\x80')                                      break;                                  else                                  {                                      //a UTF-8 sequence                                      bytes[byteCount++] = (byte)ch;                                      next += 3;                                  }                              }                                Encoding noFallbackCharUTF8 = Encoding.GetEncoding(                                                                                  Encoding.UTF8.CodePage'                                                                                  new EncoderReplacementFallback("")'                                                                                  new DecoderReplacementFallback(""));                                char[] unescapedChars = new char[bytes.Length];                              int charCount = noFallbackCharUTF8.GetChars(bytes' 0' byteCount' unescapedChars' 0);                                start = next;                                // match exact bytes                              // Do not unescape chars not allowed by Iri                              // need to check for invalid utf sequences that may not have given any chars                                MatchUTF8Sequence(pDest' dest' ref destPosition' unescapedChars' charCount' bytes'                                  byteCount' isQuery' iriParsing);                          }                            if (next == end)                              goto done;                      }                  dest_fixed_loop_break:;                  }              }
Magic Number,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,MatchUTF8Sequence,The following statement contains a magic number: fixed (char* unescapedCharsPtr = unescapedChars)              {                  for (int j = 0; j < charCount; ++j)                  {                      bool isHighSurr = char.IsHighSurrogate(unescapedCharsPtr[j]);                        byte[] encodedBytes = Encoding.UTF8.GetBytes(unescapedChars' j' isHighSurr ? 2 : 1);                      int encodedBytesLength = encodedBytes.Length;                        // we have to keep unicode chars outside Iri range escaped                      bool inIriRange = false;                      if (iriParsing)                      {                          if (!isHighSurr)                              inIriRange = IriHelper.CheckIriUnicodeRange(unescapedChars[j]' isQuery);                          else                          {                              bool surrPair = false;                              inIriRange = IriHelper.CheckIriUnicodeRange(unescapedChars[j]' unescapedChars[j + 1]'                                                                     ref surrPair' isQuery);                          }                      }                        while (true)                      {                          // Escape any invalid bytes that were before this character                          while (bytes[count] != encodedBytes[0])                          {                              Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                              EscapeAsciiChar((char)bytes[count++]' dest' ref destOffset);                          }                            // check if all bytes match                          bool allBytesMatch = true;                          int k = 0;                          for (; k < encodedBytesLength; ++k)                          {                              if (bytes[count + k] != encodedBytes[k])                              {                                  allBytesMatch = false;                                  break;                              }                          }                            if (allBytesMatch)                          {                              count += encodedBytesLength;                              if (iriParsing)                              {                                  if (!inIriRange)                                  {                                      // need to keep chars not allowed as escaped                                      for (int l = 0; l < encodedBytes.Length; ++l)                                      {                                          Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                          EscapeAsciiChar((char)encodedBytes[l]' dest' ref destOffset);                                      }                                  }                                  else if (!UriHelper.IsBidiControlCharacter(unescapedCharsPtr[j]))                                  {                                      //copy chars                                      Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                      pDest[destOffset++] = unescapedCharsPtr[j];                                      if (isHighSurr)                                      {                                          Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                          pDest[destOffset++] = unescapedCharsPtr[j + 1];                                      }                                  }                              }                              else                              {                                  //copy chars                                  Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                  pDest[destOffset++] = unescapedCharsPtr[j];                                    if (isHighSurr)                                  {                                      Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                      pDest[destOffset++] = unescapedCharsPtr[j + 1];                                  }                              }                                break; // break out of while (true) since we've matched this char bytes                          }                          else                          {                              // copy bytes till place where bytes don't match                              for (int l = 0; l < k; ++l)                              {                                  Debug.Assert(dest.Length > destOffset' "Destination length exceeded destination offset.");                                  EscapeAsciiChar((char)bytes[count++]' dest' ref destOffset);                              }                          }                      }                        if (isHighSurr) j++;                  }              }
Magic Number,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,EscapeAsciiChar,The following statement contains a magic number: to[pos++] = s_hexUpperChars[(ch & 0xf0) >> 4];
Magic Number,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,EscapedAscii,The following statement contains a magic number: int res = (digit <= '9')                  ? ((int)digit - (int)'0')                  : (((digit <= 'F')                  ? ((int)digit - (int)'A')                  : ((int)digit - (int)'a'))                     + 10);
Magic Number,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,EscapedAscii,The following statement contains a magic number: return (char)((res << 4) + ((next <= '9')                      ? ((int)next - (int)'0')                      : (((next <= 'F')                          ? ((int)next - (int)'A')                          : ((int)next - (int)'a'))                         + 10)));
Magic Number,System,UriHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriHelper.cs,EscapedAscii,The following statement contains a magic number: return (char)((res << 4) + ((next <= '9')                      ? ((int)next - (int)'0')                      : (((next <= 'F')                          ? ((int)next - (int)'A')                          : ((int)next - (int)'a'))                         + 10)));
Magic Number,System,UriParser,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriScheme.cs,UriParser,The following statement contains a magic number: HttpUri = new BuiltInUriParser("http"' 80' HttpSyntaxFlags);
Magic Number,System,UriParser,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriScheme.cs,UriParser,The following statement contains a magic number: HttpsUri = new BuiltInUriParser("https"' 443' HttpUri._flags);
Magic Number,System,UriParser,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriScheme.cs,UriParser,The following statement contains a magic number: WsUri = new BuiltInUriParser("ws"' 80' HttpSyntaxFlags);
Magic Number,System,UriParser,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriScheme.cs,UriParser,The following statement contains a magic number: WssUri = new BuiltInUriParser("wss"' 443' HttpSyntaxFlags);
Magic Number,System,UriParser,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriScheme.cs,UriParser,The following statement contains a magic number: FtpUri = new BuiltInUriParser("ftp"' 21' FtpSyntaxFlags);
Magic Number,System,UriParser,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriScheme.cs,UriParser,The following statement contains a magic number: GopherUri = new BuiltInUriParser("gopher"' 70' GopherSyntaxFlags);
Magic Number,System,UriParser,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriScheme.cs,UriParser,The following statement contains a magic number: NntpUri = new BuiltInUriParser("nntp"' 119' NntpSyntaxFlags);
Magic Number,System,UriParser,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriScheme.cs,UriParser,The following statement contains a magic number: MailToUri = new BuiltInUriParser("mailto"' 25' MailtoSyntaxFlags);
Magic Number,System,UriParser,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriScheme.cs,UriParser,The following statement contains a magic number: TelnetUri = new BuiltInUriParser("telnet"' 23' TelnetSyntaxFlags);
Magic Number,System,UriParser,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriScheme.cs,UriParser,The following statement contains a magic number: LdapUri = new BuiltInUriParser("ldap"' 389' LdapSyntaxFlags);
Magic Number,System,UriParser,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\UriScheme.cs,UriParser,The following statement contains a magic number: NetTcpUri = new BuiltInUriParser("net.tcp"' 808' NetTcpSyntaxFlags);
Missing Default,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,GetLeftPart,The following switch statement is missing a default case: switch (part)              {                  case UriPartial.Scheme:                        return GetParts(UriComponents.Scheme | UriComponents.KeepDelimiter' UriFormat.UriEscaped);                    case UriPartial.Authority:                        if (NotAny(Flags.AuthorityFound) || IsDosPath)                      {                          // V1.0 compatibility.                          // It not return an empty string but instead "scheme:" because it is a LEFT part.                          // Also neither it should check for IsDosPath here                            // From V1.0 comments:                            // anything that didn't have "//" after the scheme name                          // (mailto: and news: e.g.) doesn't have an authority                          //                            return string.Empty;                      }                      return GetParts(NonPathPart' UriFormat.UriEscaped);                    case UriPartial.Path:                      return GetParts(NonPathPart | UriComponents.Path' UriFormat.UriEscaped);                    case UriPartial.Query:                      return GetParts(NonPathPart | UriComponents.Path | UriComponents.Query' UriFormat.UriEscaped);              }
Missing Default,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following switch statement is missing a default case: switch (length)              {                  case 2:                      if (ptr[0] == 'w' && ptr[1] == 's')                      {                          syntax = UriParser.WsUri;                          return ParsingError.None;                      }                      break;                  case 3:                      const int ftpMask = 'f' << 16 | 't' << 8 | 'p';                      const int wssMask = 'w' << 16 | 's' << 8 | 's';                      switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }                      break;                  case 4:                      const int httpMask = 'h' << 24 | 't' << 16 | 't' << 8 | 'p';                      const int fileMask = 'f' << 24 | 'i' << 16 | 'l' << 8 | 'e';                      switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }                      break;                  case 5:                      if (ptr[0] == 'h' && ptr[1] == 't' && ptr[2] == 't' && ptr[3] == 'p' && ptr[4] == 's')                      {                          syntax = UriParser.HttpsUri;                          return ParsingError.None;                      }                      break;                  case 6:                      if (ptr[0] == 'm' && ptr[1] == 'a' && ptr[2] == 'i' && ptr[3] == 'l' && ptr[4] == 't' && ptr[5] == 'o')                      {                          syntax = UriParser.MailToUri;                          return ParsingError.None;                      }                      break;              }
Missing Default,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following switch statement is missing a default case: switch (ptr[0] << 16 | ptr[1] << 8 | ptr[2])                      {                          case ftpMask:                              syntax = UriParser.FtpUri;                              return ParsingError.None;                          case wssMask:                              syntax = UriParser.WssUri;                              return ParsingError.None;                      }
Missing Default,System,Uri,C:\selectedRepos\dotnet_corefx\src\System.Private.Uri\src\System\Uri.cs,CheckSchemeSyntax,The following switch statement is missing a default case: switch (ptr[0] << 24 | ptr[1] << 16 | ptr[2] << 8 | ptr[3])                      {                          case httpMask:                              syntax = UriParser.HttpUri;                              return ParsingError.None;                          case fileMask:                              syntax = UriParser.FileUri;                              return ParsingError.None;                      }
