Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.IO,PatternMatcher,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem.Watcher\src\System\IO\PatternMatcher.cs,StrictMatchPattern,The method has 342 lines of code.
Complex Method,System.IO,PatternMatcher,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem.Watcher\src\System\IO\PatternMatcher.cs,StrictMatchPattern,Cyclomatic complexity of the method is 30
Long Statement,System.IO,FileSystemWatcher,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem.Watcher\src\System\IO\FileSystemWatcher.cs,StartRaisingEventsIfNotDisposed,The length of the statement  "            //Cannot allocate the directoryHandle and the readBuffer if the object has been disposed; finalization has been suppressed. " is 123.
Long Statement,System.IO,PathInternal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\IO\PathInternal.cs,GetIsCaseSensitive,The length of the statement  "                using (new FileStream(pathWithUpperCase' FileMode.CreateNew' FileAccess.ReadWrite' FileShare.None' 0x1000' FileOptions.DeleteOnClose)) " is 134.
Complex Conditional,System.IO,PatternMatcher,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem.Watcher\src\System\IO\PatternMatcher.cs,StrictMatchPattern,The conditional expression  "name == null || name.Length == 0 || expression == null || expression.Length == 0"  is complex.
Complex Conditional,System.IO,PathInternal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\IO\PathInternal.cs,EqualStartingCharacterCount,The conditional expression  "l != leftEnd && r != rightEnd                      && (*l == *r || (ignoreCase && char.ToUpperInvariant((*l)) == char.ToUpperInvariant((*r))))"  is complex.
Magic Number,System.IO,PatternMatcher,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem.Watcher\src\System\IO\PatternMatcher.cs,StrictMatchPattern,The following statement contains a magic number: maxState = expression.Length * 2;
Magic Number,System.IO,PatternMatcher,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem.Watcher\src\System\IO\PatternMatcher.cs,StrictMatchPattern,The following statement contains a magic number: while (!nameFinished)              {                  if (nameOffset < name.Length)                  {                      nameChar = name[nameOffset];                      nameOffset++;                  }                  else                  {                      nameFinished = true;                        //                      //  if we have already exhausted the expression' C#.  Don't                      //  continue.                      //                      if (previousMatches[matchesCount - 1] == maxState)                      {                          break;                      }                  }                    //                  //  Now' for each of the previous stored expression matches' see what                  //  we can do with this name character.                  //                  srcCount = 0;                  destCount = 0;                  previousDestCount = 0;                    while (srcCount < matchesCount)                  {                      //                      //  We have to carry on our expression analysis as far as possible                      //  for each character of name' so we loop here until the                      //  expression stops matching.  A clue here is that expression                      //  cases that can match zero or more characters end with a                      //  continue' while those that can accept only a single character                      //  end with a break.                      //                      exprOffset = ((previousMatches[srcCount++] + 1) / 2);                      length = 0;                        while (true)                      {                          if (exprOffset == expression.Length)                          {                              break;                          }                            //                          //  The first time through the loop we don't want                          //  to increment ExprOffset.                          //                            exprOffset += length;                            currentState = exprOffset * 2;                            if (exprOffset == expression.Length)                          {                              currentMatches[destCount++] = maxState;                              break;                          }                            exprChar = expression[exprOffset];                          length = 1;                            //                          //  We may be about to exhaust the local                          //  space for ExpressionMatches[][]' so we have to allocate                          //  some pool if this is the case.                          //                            if (destCount >= MATCHES_ARRAY_SIZE - 2)                          {                              int newSize = currentMatches.Length * 2;                              int[] tmp = new int[newSize];                              Array.Copy(currentMatches' 0' tmp' 0' currentMatches.Length);                              currentMatches = tmp;                                tmp = new int[newSize];                              Array.Copy(previousMatches' 0' tmp' 0' previousMatches.Length);                              previousMatches = tmp;                          }                            //                          //  * matches any character zero or more times.                          //                            if (exprChar == '*')                          {                              currentMatches[destCount++] = currentState;                              currentMatches[destCount++] = (currentState + 1);                              continue;                          }                            //                          //  DOS_STAR matches any character except . zero or more times.                          //                            if (exprChar == ANSI_DOS_STAR)                          {                              bool iCanEatADot = false;                                //                              //  If we are at a period' determine if we are allowed to                              //  consume it' i.e. make sure it is not the last one.                              //                              if (!nameFinished && (nameChar == '.'))                              {                                  char tmpChar;                                  int offset;                                    int nameLength = name.Length;                                  for (offset = nameOffset; offset < nameLength; offset++)                                  {                                      tmpChar = name[offset];                                      length = 1;                                        if (tmpChar == '.')                                      {                                          iCanEatADot = true;                                          break;                                      }                                  }                              }                                if (nameFinished || (nameChar != '.') || iCanEatADot)                              {                                  currentMatches[destCount++] = currentState;                                  currentMatches[destCount++] = (currentState + 1);                                  continue;                              }                              else                              {                                  //                                  //  We are at a period.  We can only match zero                                  //  characters (i.e. the epsilon transition).                                  //                                  currentMatches[destCount++] = (currentState + 1);                                  continue;                              }                          }                            //                          //  The following expression characters all match by consuming                          //  a character' thus force the expression' and thus state                          //  forward.                          //                          currentState += length * 2;                            //                          //  DOS_QM is the most complicated.  If the name is finished'                          //  we can match zero characters.  If this name is a '.'' we                          //  don't match' but look at the next expression.  Otherwise                          //  we match a single character.                          //                          if (exprChar == ANSI_DOS_QM)                          {                              if (nameFinished || (nameChar == '.'))                              {                                  continue;                              }                                currentMatches[destCount++] = currentState;                              break;                          }                            //                          //  A DOS_DOT can match either a period' or zero characters                          //  beyond the end of name.                          //                          if (exprChar == DOS_DOT)                          {                              if (nameFinished)                              {                                  continue;                              }                                if (nameChar == '.')                              {                                  currentMatches[destCount++] = currentState;                                  break;                              }                          }                            //                          //  From this point on a name character is required to even                          //  continue' let alone make a match.                          //                          if (nameFinished)                          {                              break;                          }                            //                          //  If this expression was a '?' we can match it once.                          //                          if (exprChar == '?')                          {                              currentMatches[destCount++] = currentState;                              break;                          }                            //                          //  Finally' check if the expression char matches the name char                          //                                                    if (PathInternal.IsCaseSensitive ?                               (exprChar == nameChar) :                               (char.ToUpperInvariant(exprChar) == char.ToUpperInvariant(nameChar)))                          {                              currentMatches[destCount++] = currentState;                              break;                          }                            //                          //  The expression didn't match so go look at the next                          //  previous match.                          //                            break;                      }                          //                      //  Prevent duplication in the destination array.                      //                      //  Each of the arrays is monotonically increasing and non-                      //  duplicating' thus we skip over any source element in the src                      //  array if we just added the same element to the destination                      //  array.  This guarantees non-duplication in the dest. array.                      //                        if ((srcCount < matchesCount) && (previousDestCount < destCount))                      {                          while (previousDestCount < destCount)                          {                              int previousLength = previousMatches.Length;                              while ((srcCount < previousLength) && (previousMatches[srcCount] < currentMatches[previousDestCount]))                              {                                  srcCount += 1;                              }                              previousDestCount += 1;                          }                      }                  }                    //                  //  If we found no matches in the just finished iteration' it's time                  //  to bail.                  //                    if (destCount == 0)                  {                      return false;                  }                    //                  //  Swap the meaning the two arrays                  //                    {                      int[] tmp;                        tmp = previousMatches;                        previousMatches = currentMatches;                        currentMatches = tmp;                  }                    matchesCount = destCount;              }
Magic Number,System.IO,PatternMatcher,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem.Watcher\src\System\IO\PatternMatcher.cs,StrictMatchPattern,The following statement contains a magic number: while (!nameFinished)              {                  if (nameOffset < name.Length)                  {                      nameChar = name[nameOffset];                      nameOffset++;                  }                  else                  {                      nameFinished = true;                        //                      //  if we have already exhausted the expression' C#.  Don't                      //  continue.                      //                      if (previousMatches[matchesCount - 1] == maxState)                      {                          break;                      }                  }                    //                  //  Now' for each of the previous stored expression matches' see what                  //  we can do with this name character.                  //                  srcCount = 0;                  destCount = 0;                  previousDestCount = 0;                    while (srcCount < matchesCount)                  {                      //                      //  We have to carry on our expression analysis as far as possible                      //  for each character of name' so we loop here until the                      //  expression stops matching.  A clue here is that expression                      //  cases that can match zero or more characters end with a                      //  continue' while those that can accept only a single character                      //  end with a break.                      //                      exprOffset = ((previousMatches[srcCount++] + 1) / 2);                      length = 0;                        while (true)                      {                          if (exprOffset == expression.Length)                          {                              break;                          }                            //                          //  The first time through the loop we don't want                          //  to increment ExprOffset.                          //                            exprOffset += length;                            currentState = exprOffset * 2;                            if (exprOffset == expression.Length)                          {                              currentMatches[destCount++] = maxState;                              break;                          }                            exprChar = expression[exprOffset];                          length = 1;                            //                          //  We may be about to exhaust the local                          //  space for ExpressionMatches[][]' so we have to allocate                          //  some pool if this is the case.                          //                            if (destCount >= MATCHES_ARRAY_SIZE - 2)                          {                              int newSize = currentMatches.Length * 2;                              int[] tmp = new int[newSize];                              Array.Copy(currentMatches' 0' tmp' 0' currentMatches.Length);                              currentMatches = tmp;                                tmp = new int[newSize];                              Array.Copy(previousMatches' 0' tmp' 0' previousMatches.Length);                              previousMatches = tmp;                          }                            //                          //  * matches any character zero or more times.                          //                            if (exprChar == '*')                          {                              currentMatches[destCount++] = currentState;                              currentMatches[destCount++] = (currentState + 1);                              continue;                          }                            //                          //  DOS_STAR matches any character except . zero or more times.                          //                            if (exprChar == ANSI_DOS_STAR)                          {                              bool iCanEatADot = false;                                //                              //  If we are at a period' determine if we are allowed to                              //  consume it' i.e. make sure it is not the last one.                              //                              if (!nameFinished && (nameChar == '.'))                              {                                  char tmpChar;                                  int offset;                                    int nameLength = name.Length;                                  for (offset = nameOffset; offset < nameLength; offset++)                                  {                                      tmpChar = name[offset];                                      length = 1;                                        if (tmpChar == '.')                                      {                                          iCanEatADot = true;                                          break;                                      }                                  }                              }                                if (nameFinished || (nameChar != '.') || iCanEatADot)                              {                                  currentMatches[destCount++] = currentState;                                  currentMatches[destCount++] = (currentState + 1);                                  continue;                              }                              else                              {                                  //                                  //  We are at a period.  We can only match zero                                  //  characters (i.e. the epsilon transition).                                  //                                  currentMatches[destCount++] = (currentState + 1);                                  continue;                              }                          }                            //                          //  The following expression characters all match by consuming                          //  a character' thus force the expression' and thus state                          //  forward.                          //                          currentState += length * 2;                            //                          //  DOS_QM is the most complicated.  If the name is finished'                          //  we can match zero characters.  If this name is a '.'' we                          //  don't match' but look at the next expression.  Otherwise                          //  we match a single character.                          //                          if (exprChar == ANSI_DOS_QM)                          {                              if (nameFinished || (nameChar == '.'))                              {                                  continue;                              }                                currentMatches[destCount++] = currentState;                              break;                          }                            //                          //  A DOS_DOT can match either a period' or zero characters                          //  beyond the end of name.                          //                          if (exprChar == DOS_DOT)                          {                              if (nameFinished)                              {                                  continue;                              }                                if (nameChar == '.')                              {                                  currentMatches[destCount++] = currentState;                                  break;                              }                          }                            //                          //  From this point on a name character is required to even                          //  continue' let alone make a match.                          //                          if (nameFinished)                          {                              break;                          }                            //                          //  If this expression was a '?' we can match it once.                          //                          if (exprChar == '?')                          {                              currentMatches[destCount++] = currentState;                              break;                          }                            //                          //  Finally' check if the expression char matches the name char                          //                                                    if (PathInternal.IsCaseSensitive ?                               (exprChar == nameChar) :                               (char.ToUpperInvariant(exprChar) == char.ToUpperInvariant(nameChar)))                          {                              currentMatches[destCount++] = currentState;                              break;                          }                            //                          //  The expression didn't match so go look at the next                          //  previous match.                          //                            break;                      }                          //                      //  Prevent duplication in the destination array.                      //                      //  Each of the arrays is monotonically increasing and non-                      //  duplicating' thus we skip over any source element in the src                      //  array if we just added the same element to the destination                      //  array.  This guarantees non-duplication in the dest. array.                      //                        if ((srcCount < matchesCount) && (previousDestCount < destCount))                      {                          while (previousDestCount < destCount)                          {                              int previousLength = previousMatches.Length;                              while ((srcCount < previousLength) && (previousMatches[srcCount] < currentMatches[previousDestCount]))                              {                                  srcCount += 1;                              }                              previousDestCount += 1;                          }                      }                  }                    //                  //  If we found no matches in the just finished iteration' it's time                  //  to bail.                  //                    if (destCount == 0)                  {                      return false;                  }                    //                  //  Swap the meaning the two arrays                  //                    {                      int[] tmp;                        tmp = previousMatches;                        previousMatches = currentMatches;                        currentMatches = tmp;                  }                    matchesCount = destCount;              }
Magic Number,System.IO,PatternMatcher,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem.Watcher\src\System\IO\PatternMatcher.cs,StrictMatchPattern,The following statement contains a magic number: while (!nameFinished)              {                  if (nameOffset < name.Length)                  {                      nameChar = name[nameOffset];                      nameOffset++;                  }                  else                  {                      nameFinished = true;                        //                      //  if we have already exhausted the expression' C#.  Don't                      //  continue.                      //                      if (previousMatches[matchesCount - 1] == maxState)                      {                          break;                      }                  }                    //                  //  Now' for each of the previous stored expression matches' see what                  //  we can do with this name character.                  //                  srcCount = 0;                  destCount = 0;                  previousDestCount = 0;                    while (srcCount < matchesCount)                  {                      //                      //  We have to carry on our expression analysis as far as possible                      //  for each character of name' so we loop here until the                      //  expression stops matching.  A clue here is that expression                      //  cases that can match zero or more characters end with a                      //  continue' while those that can accept only a single character                      //  end with a break.                      //                      exprOffset = ((previousMatches[srcCount++] + 1) / 2);                      length = 0;                        while (true)                      {                          if (exprOffset == expression.Length)                          {                              break;                          }                            //                          //  The first time through the loop we don't want                          //  to increment ExprOffset.                          //                            exprOffset += length;                            currentState = exprOffset * 2;                            if (exprOffset == expression.Length)                          {                              currentMatches[destCount++] = maxState;                              break;                          }                            exprChar = expression[exprOffset];                          length = 1;                            //                          //  We may be about to exhaust the local                          //  space for ExpressionMatches[][]' so we have to allocate                          //  some pool if this is the case.                          //                            if (destCount >= MATCHES_ARRAY_SIZE - 2)                          {                              int newSize = currentMatches.Length * 2;                              int[] tmp = new int[newSize];                              Array.Copy(currentMatches' 0' tmp' 0' currentMatches.Length);                              currentMatches = tmp;                                tmp = new int[newSize];                              Array.Copy(previousMatches' 0' tmp' 0' previousMatches.Length);                              previousMatches = tmp;                          }                            //                          //  * matches any character zero or more times.                          //                            if (exprChar == '*')                          {                              currentMatches[destCount++] = currentState;                              currentMatches[destCount++] = (currentState + 1);                              continue;                          }                            //                          //  DOS_STAR matches any character except . zero or more times.                          //                            if (exprChar == ANSI_DOS_STAR)                          {                              bool iCanEatADot = false;                                //                              //  If we are at a period' determine if we are allowed to                              //  consume it' i.e. make sure it is not the last one.                              //                              if (!nameFinished && (nameChar == '.'))                              {                                  char tmpChar;                                  int offset;                                    int nameLength = name.Length;                                  for (offset = nameOffset; offset < nameLength; offset++)                                  {                                      tmpChar = name[offset];                                      length = 1;                                        if (tmpChar == '.')                                      {                                          iCanEatADot = true;                                          break;                                      }                                  }                              }                                if (nameFinished || (nameChar != '.') || iCanEatADot)                              {                                  currentMatches[destCount++] = currentState;                                  currentMatches[destCount++] = (currentState + 1);                                  continue;                              }                              else                              {                                  //                                  //  We are at a period.  We can only match zero                                  //  characters (i.e. the epsilon transition).                                  //                                  currentMatches[destCount++] = (currentState + 1);                                  continue;                              }                          }                            //                          //  The following expression characters all match by consuming                          //  a character' thus force the expression' and thus state                          //  forward.                          //                          currentState += length * 2;                            //                          //  DOS_QM is the most complicated.  If the name is finished'                          //  we can match zero characters.  If this name is a '.'' we                          //  don't match' but look at the next expression.  Otherwise                          //  we match a single character.                          //                          if (exprChar == ANSI_DOS_QM)                          {                              if (nameFinished || (nameChar == '.'))                              {                                  continue;                              }                                currentMatches[destCount++] = currentState;                              break;                          }                            //                          //  A DOS_DOT can match either a period' or zero characters                          //  beyond the end of name.                          //                          if (exprChar == DOS_DOT)                          {                              if (nameFinished)                              {                                  continue;                              }                                if (nameChar == '.')                              {                                  currentMatches[destCount++] = currentState;                                  break;                              }                          }                            //                          //  From this point on a name character is required to even                          //  continue' let alone make a match.                          //                          if (nameFinished)                          {                              break;                          }                            //                          //  If this expression was a '?' we can match it once.                          //                          if (exprChar == '?')                          {                              currentMatches[destCount++] = currentState;                              break;                          }                            //                          //  Finally' check if the expression char matches the name char                          //                                                    if (PathInternal.IsCaseSensitive ?                               (exprChar == nameChar) :                               (char.ToUpperInvariant(exprChar) == char.ToUpperInvariant(nameChar)))                          {                              currentMatches[destCount++] = currentState;                              break;                          }                            //                          //  The expression didn't match so go look at the next                          //  previous match.                          //                            break;                      }                          //                      //  Prevent duplication in the destination array.                      //                      //  Each of the arrays is monotonically increasing and non-                      //  duplicating' thus we skip over any source element in the src                      //  array if we just added the same element to the destination                      //  array.  This guarantees non-duplication in the dest. array.                      //                        if ((srcCount < matchesCount) && (previousDestCount < destCount))                      {                          while (previousDestCount < destCount)                          {                              int previousLength = previousMatches.Length;                              while ((srcCount < previousLength) && (previousMatches[srcCount] < currentMatches[previousDestCount]))                              {                                  srcCount += 1;                              }                              previousDestCount += 1;                          }                      }                  }                    //                  //  If we found no matches in the just finished iteration' it's time                  //  to bail.                  //                    if (destCount == 0)                  {                      return false;                  }                    //                  //  Swap the meaning the two arrays                  //                    {                      int[] tmp;                        tmp = previousMatches;                        previousMatches = currentMatches;                        currentMatches = tmp;                  }                    matchesCount = destCount;              }
Magic Number,System.IO,PatternMatcher,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem.Watcher\src\System\IO\PatternMatcher.cs,StrictMatchPattern,The following statement contains a magic number: while (!nameFinished)              {                  if (nameOffset < name.Length)                  {                      nameChar = name[nameOffset];                      nameOffset++;                  }                  else                  {                      nameFinished = true;                        //                      //  if we have already exhausted the expression' C#.  Don't                      //  continue.                      //                      if (previousMatches[matchesCount - 1] == maxState)                      {                          break;                      }                  }                    //                  //  Now' for each of the previous stored expression matches' see what                  //  we can do with this name character.                  //                  srcCount = 0;                  destCount = 0;                  previousDestCount = 0;                    while (srcCount < matchesCount)                  {                      //                      //  We have to carry on our expression analysis as far as possible                      //  for each character of name' so we loop here until the                      //  expression stops matching.  A clue here is that expression                      //  cases that can match zero or more characters end with a                      //  continue' while those that can accept only a single character                      //  end with a break.                      //                      exprOffset = ((previousMatches[srcCount++] + 1) / 2);                      length = 0;                        while (true)                      {                          if (exprOffset == expression.Length)                          {                              break;                          }                            //                          //  The first time through the loop we don't want                          //  to increment ExprOffset.                          //                            exprOffset += length;                            currentState = exprOffset * 2;                            if (exprOffset == expression.Length)                          {                              currentMatches[destCount++] = maxState;                              break;                          }                            exprChar = expression[exprOffset];                          length = 1;                            //                          //  We may be about to exhaust the local                          //  space for ExpressionMatches[][]' so we have to allocate                          //  some pool if this is the case.                          //                            if (destCount >= MATCHES_ARRAY_SIZE - 2)                          {                              int newSize = currentMatches.Length * 2;                              int[] tmp = new int[newSize];                              Array.Copy(currentMatches' 0' tmp' 0' currentMatches.Length);                              currentMatches = tmp;                                tmp = new int[newSize];                              Array.Copy(previousMatches' 0' tmp' 0' previousMatches.Length);                              previousMatches = tmp;                          }                            //                          //  * matches any character zero or more times.                          //                            if (exprChar == '*')                          {                              currentMatches[destCount++] = currentState;                              currentMatches[destCount++] = (currentState + 1);                              continue;                          }                            //                          //  DOS_STAR matches any character except . zero or more times.                          //                            if (exprChar == ANSI_DOS_STAR)                          {                              bool iCanEatADot = false;                                //                              //  If we are at a period' determine if we are allowed to                              //  consume it' i.e. make sure it is not the last one.                              //                              if (!nameFinished && (nameChar == '.'))                              {                                  char tmpChar;                                  int offset;                                    int nameLength = name.Length;                                  for (offset = nameOffset; offset < nameLength; offset++)                                  {                                      tmpChar = name[offset];                                      length = 1;                                        if (tmpChar == '.')                                      {                                          iCanEatADot = true;                                          break;                                      }                                  }                              }                                if (nameFinished || (nameChar != '.') || iCanEatADot)                              {                                  currentMatches[destCount++] = currentState;                                  currentMatches[destCount++] = (currentState + 1);                                  continue;                              }                              else                              {                                  //                                  //  We are at a period.  We can only match zero                                  //  characters (i.e. the epsilon transition).                                  //                                  currentMatches[destCount++] = (currentState + 1);                                  continue;                              }                          }                            //                          //  The following expression characters all match by consuming                          //  a character' thus force the expression' and thus state                          //  forward.                          //                          currentState += length * 2;                            //                          //  DOS_QM is the most complicated.  If the name is finished'                          //  we can match zero characters.  If this name is a '.'' we                          //  don't match' but look at the next expression.  Otherwise                          //  we match a single character.                          //                          if (exprChar == ANSI_DOS_QM)                          {                              if (nameFinished || (nameChar == '.'))                              {                                  continue;                              }                                currentMatches[destCount++] = currentState;                              break;                          }                            //                          //  A DOS_DOT can match either a period' or zero characters                          //  beyond the end of name.                          //                          if (exprChar == DOS_DOT)                          {                              if (nameFinished)                              {                                  continue;                              }                                if (nameChar == '.')                              {                                  currentMatches[destCount++] = currentState;                                  break;                              }                          }                            //                          //  From this point on a name character is required to even                          //  continue' let alone make a match.                          //                          if (nameFinished)                          {                              break;                          }                            //                          //  If this expression was a '?' we can match it once.                          //                          if (exprChar == '?')                          {                              currentMatches[destCount++] = currentState;                              break;                          }                            //                          //  Finally' check if the expression char matches the name char                          //                                                    if (PathInternal.IsCaseSensitive ?                               (exprChar == nameChar) :                               (char.ToUpperInvariant(exprChar) == char.ToUpperInvariant(nameChar)))                          {                              currentMatches[destCount++] = currentState;                              break;                          }                            //                          //  The expression didn't match so go look at the next                          //  previous match.                          //                            break;                      }                          //                      //  Prevent duplication in the destination array.                      //                      //  Each of the arrays is monotonically increasing and non-                      //  duplicating' thus we skip over any source element in the src                      //  array if we just added the same element to the destination                      //  array.  This guarantees non-duplication in the dest. array.                      //                        if ((srcCount < matchesCount) && (previousDestCount < destCount))                      {                          while (previousDestCount < destCount)                          {                              int previousLength = previousMatches.Length;                              while ((srcCount < previousLength) && (previousMatches[srcCount] < currentMatches[previousDestCount]))                              {                                  srcCount += 1;                              }                              previousDestCount += 1;                          }                      }                  }                    //                  //  If we found no matches in the just finished iteration' it's time                  //  to bail.                  //                    if (destCount == 0)                  {                      return false;                  }                    //                  //  Swap the meaning the two arrays                  //                    {                      int[] tmp;                        tmp = previousMatches;                        previousMatches = currentMatches;                        currentMatches = tmp;                  }                    matchesCount = destCount;              }
Magic Number,System.IO,PatternMatcher,C:\selectedRepos\dotnet_corefx\src\System.IO.FileSystem.Watcher\src\System\IO\PatternMatcher.cs,StrictMatchPattern,The following statement contains a magic number: while (!nameFinished)              {                  if (nameOffset < name.Length)                  {                      nameChar = name[nameOffset];                      nameOffset++;                  }                  else                  {                      nameFinished = true;                        //                      //  if we have already exhausted the expression' C#.  Don't                      //  continue.                      //                      if (previousMatches[matchesCount - 1] == maxState)                      {                          break;                      }                  }                    //                  //  Now' for each of the previous stored expression matches' see what                  //  we can do with this name character.                  //                  srcCount = 0;                  destCount = 0;                  previousDestCount = 0;                    while (srcCount < matchesCount)                  {                      //                      //  We have to carry on our expression analysis as far as possible                      //  for each character of name' so we loop here until the                      //  expression stops matching.  A clue here is that expression                      //  cases that can match zero or more characters end with a                      //  continue' while those that can accept only a single character                      //  end with a break.                      //                      exprOffset = ((previousMatches[srcCount++] + 1) / 2);                      length = 0;                        while (true)                      {                          if (exprOffset == expression.Length)                          {                              break;                          }                            //                          //  The first time through the loop we don't want                          //  to increment ExprOffset.                          //                            exprOffset += length;                            currentState = exprOffset * 2;                            if (exprOffset == expression.Length)                          {                              currentMatches[destCount++] = maxState;                              break;                          }                            exprChar = expression[exprOffset];                          length = 1;                            //                          //  We may be about to exhaust the local                          //  space for ExpressionMatches[][]' so we have to allocate                          //  some pool if this is the case.                          //                            if (destCount >= MATCHES_ARRAY_SIZE - 2)                          {                              int newSize = currentMatches.Length * 2;                              int[] tmp = new int[newSize];                              Array.Copy(currentMatches' 0' tmp' 0' currentMatches.Length);                              currentMatches = tmp;                                tmp = new int[newSize];                              Array.Copy(previousMatches' 0' tmp' 0' previousMatches.Length);                              previousMatches = tmp;                          }                            //                          //  * matches any character zero or more times.                          //                            if (exprChar == '*')                          {                              currentMatches[destCount++] = currentState;                              currentMatches[destCount++] = (currentState + 1);                              continue;                          }                            //                          //  DOS_STAR matches any character except . zero or more times.                          //                            if (exprChar == ANSI_DOS_STAR)                          {                              bool iCanEatADot = false;                                //                              //  If we are at a period' determine if we are allowed to                              //  consume it' i.e. make sure it is not the last one.                              //                              if (!nameFinished && (nameChar == '.'))                              {                                  char tmpChar;                                  int offset;                                    int nameLength = name.Length;                                  for (offset = nameOffset; offset < nameLength; offset++)                                  {                                      tmpChar = name[offset];                                      length = 1;                                        if (tmpChar == '.')                                      {                                          iCanEatADot = true;                                          break;                                      }                                  }                              }                                if (nameFinished || (nameChar != '.') || iCanEatADot)                              {                                  currentMatches[destCount++] = currentState;                                  currentMatches[destCount++] = (currentState + 1);                                  continue;                              }                              else                              {                                  //                                  //  We are at a period.  We can only match zero                                  //  characters (i.e. the epsilon transition).                                  //                                  currentMatches[destCount++] = (currentState + 1);                                  continue;                              }                          }                            //                          //  The following expression characters all match by consuming                          //  a character' thus force the expression' and thus state                          //  forward.                          //                          currentState += length * 2;                            //                          //  DOS_QM is the most complicated.  If the name is finished'                          //  we can match zero characters.  If this name is a '.'' we                          //  don't match' but look at the next expression.  Otherwise                          //  we match a single character.                          //                          if (exprChar == ANSI_DOS_QM)                          {                              if (nameFinished || (nameChar == '.'))                              {                                  continue;                              }                                currentMatches[destCount++] = currentState;                              break;                          }                            //                          //  A DOS_DOT can match either a period' or zero characters                          //  beyond the end of name.                          //                          if (exprChar == DOS_DOT)                          {                              if (nameFinished)                              {                                  continue;                              }                                if (nameChar == '.')                              {                                  currentMatches[destCount++] = currentState;                                  break;                              }                          }                            //                          //  From this point on a name character is required to even                          //  continue' let alone make a match.                          //                          if (nameFinished)                          {                              break;                          }                            //                          //  If this expression was a '?' we can match it once.                          //                          if (exprChar == '?')                          {                              currentMatches[destCount++] = currentState;                              break;                          }                            //                          //  Finally' check if the expression char matches the name char                          //                                                    if (PathInternal.IsCaseSensitive ?                               (exprChar == nameChar) :                               (char.ToUpperInvariant(exprChar) == char.ToUpperInvariant(nameChar)))                          {                              currentMatches[destCount++] = currentState;                              break;                          }                            //                          //  The expression didn't match so go look at the next                          //  previous match.                          //                            break;                      }                          //                      //  Prevent duplication in the destination array.                      //                      //  Each of the arrays is monotonically increasing and non-                      //  duplicating' thus we skip over any source element in the src                      //  array if we just added the same element to the destination                      //  array.  This guarantees non-duplication in the dest. array.                      //                        if ((srcCount < matchesCount) && (previousDestCount < destCount))                      {                          while (previousDestCount < destCount)                          {                              int previousLength = previousMatches.Length;                              while ((srcCount < previousLength) && (previousMatches[srcCount] < currentMatches[previousDestCount]))                              {                                  srcCount += 1;                              }                              previousDestCount += 1;                          }                      }                  }                    //                  //  If we found no matches in the just finished iteration' it's time                  //  to bail.                  //                    if (destCount == 0)                  {                      return false;                  }                    //                  //  Swap the meaning the two arrays                  //                    {                      int[] tmp;                        tmp = previousMatches;                        previousMatches = currentMatches;                        currentMatches = tmp;                  }                    matchesCount = destCount;              }
